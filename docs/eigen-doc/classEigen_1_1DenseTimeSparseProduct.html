<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DenseTimeSparseProduct&lt; Lhs, Rhs &gt; Class Template Reference</title>
<link href="eigendoxy_tabs.css" rel="stylesheet" type="text/css">
<link href="$relpath/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="$relpath/search.js"></script>
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
</head>
<body onload='searchBox.OnSelectItem(0);'>
<a name="top"></a>
<a class="logo" href="http://eigen.tuxfamily.org/">
<img class="logo" src="Eigen_Silly_Professor_64x64.png" width=64 height=64 alt="Eigen's silly professor"/></a>
<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceEigen.html">Eigen</a>      </li>
      <li class="navelem"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">DenseTimeSparseProduct&lt; Lhs, Rhs &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="SparseDenseProduct_8h_source.html">SparseDenseProduct.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for DenseTimeSparseProduct&lt; Lhs, Rhs &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classEigen_1_1DenseTimeSparseProduct__inherit__graph.png" border="0" usemap="#DenseTimeSparseProduct_3_01Lhs_00_01Rhs_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="DenseTimeSparseProduct_3_01Lhs_00_01Rhs_01_4_inherit__map" id="DenseTimeSparseProduct_3_01Lhs_00_01Rhs_01_4_inherit__map">
<area shape="rect" id="node2" href="classEigen_1_1ProductBase.html" title="{ProductBase\&lt; DenseTimeSparseProduct\&lt; Lhs, Rhs \&gt;, Lhs, Rhs \&gt;\n|# m_lhs\l# m_result\l# m_rhs\l|+ addTo()\l+ coeff()\l+ coeff()\l+ coeffRef()\l+ coeffRef()\l+ cols()\l+ diagonal()\l+ diagonal()\l+ diagonal()\l+ evalTo()\land 6 more...}" alt="" coords="5,1117,416,1411"/><area shape="rect" id="node4" href="classEigen_1_1MatrixBase.html" title="{MatrixBase\&lt; DenseTimeSparseProduct\&lt; Lhs, Rhs \&gt; \&gt;\n||+ adjoint()\l+ adjointInPlace()\l+ applyHouseholderOnTheLeft()\l+ applyHouseholderOnTheRight()\l+ applyOnTheLeft()\l+ applyOnTheLeft()\l+ applyOnTheRight()\l+ applyOnTheRight()\l+ array()\l+ array()\land 109 more...+ Identity()\l+ Identity()\l+ Unit()\l+ Unit()\l+ UnitW()\l+ UnitX()\l+ UnitY()\l+ UnitZ()\l# MatrixBase()\l# operator+=()\l# operator&#45;=()\l}" alt="" coords="40,637,381,1069"/><area shape="rect" id="node6" href="classEigen_1_1DenseBase.html" title="{DenseBase\&lt; DenseTimeSparseProduct\&lt; Lhs, Rhs \&gt; \&gt;\n||+ all()\l+ any()\l+ block()\l+ block()\l+ block()\l+ block()\l+ bottomLeftCorner()\l+ bottomLeftCorner()\l+ bottomLeftCorner()\l+ bottomLeftCorner()\land 120 more...+ Constant()\l+ Constant()\l+ Constant()\l+ LinSpaced()\l+ LinSpaced()\l+ LinSpaced()\l+ LinSpaced()\l+ NullaryExpr()\l+ NullaryExpr()\l+ NullaryExpr()\land 8 more...# checkTransposeAliasing()\l# DenseBase()\l}" alt="" coords="39,139,383,589"/><area shape="rect" id="node8" href="classDenseCoeffsBase.html" title="{DenseCoeffsBase\&lt; DenseTimeSparseProduct\&lt; Lhs, Rhs \&gt; \&gt;\n||}" alt="" coords="20,5,401,91"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classEigen_1_1DenseTimeSparseProduct-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a12acb3634428eafc5724df6d836f4e64"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memitem:adab0c4467b3c6f365e87d0316a74bf64"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memitem:a900dca9b26de42491763226e12dcd47b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memitem:a1be3860693af99a6c1da72580097294c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memitem:a94813ca113fdfe695508c04b1088da49"><td class="memItemLeft" align="right" valign="top">typedef internal::remove_all<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1ProductBase.html#aa3e058df4f67cadb1d0d84eec063b1f9">ActualLhsType</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a94813ca113fdfe695508c04b1088da49">_ActualLhsType</a></td></tr>
<tr class="memitem:ac6ef279a246137082b0992b37759a423"><td class="memItemLeft" align="right" valign="top">typedef internal::remove_all<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1ProductBase.html#a373c62e6591f8f00410718418c5da22c">ActualRhsType</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#ac6ef279a246137082b0992b37759a423">_ActualRhsType</a></td></tr>
<tr class="memitem:a45b8b5cbeae8078ecc85e875074d72bd"><td class="memItemLeft" align="right" valign="top">typedef internal::remove_all<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1ProductBase.html#adc2b9e2eab4afab226c7cced7a912840">LhsNested</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a45b8b5cbeae8078ecc85e875074d72bd">_LhsNested</a></td></tr>
<tr class="memitem:a870a8f6be0f8fca7ca4ff85dcd85b04f"><td class="memItemLeft" align="right" valign="top">typedef internal::remove_all<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1ProductBase.html#a89d0de86a5e1a2320541ca26718d0f65">RhsNested</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a870a8f6be0f8fca7ca4ff85dcd85b04f">_RhsNested</a></td></tr>
<tr class="memitem:aa3e058df4f67cadb1d0d84eec063b1f9"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
LhsBlasTraits::DirectLinearAccessType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#aa3e058df4f67cadb1d0d84eec063b1f9">ActualLhsType</a></td></tr>
<tr class="memitem:a373c62e6591f8f00410718418c5da22c"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
RhsBlasTraits::DirectLinearAccessType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a373c62e6591f8f00410718418c5da22c">ActualRhsType</a></td></tr>
<tr class="memitem:a0c21fb1f093f709af41fde1122aa153d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a0c21fb1f093f709af41fde1122aa153d">Base</a></td></tr>
<tr class="memitem:a7ade678155e3ede0ed013e65dd79c905"><td class="memItemLeft" align="right" valign="top">typedef Base::CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a7ade678155e3ede0ed013e65dd79c905">CoeffReturnType</a></td></tr>
<tr class="memitem:a663adf32b8ea1a09257cdace430225c5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, <a class="el" href="group__enums.html#gga8ef30fa9c08e08c8706653571f9f5b81a2434cd8c1a594a4cdaa250f86639c600">Vertical</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a663adf32b8ea1a09257cdace430225c5">ColwiseReturnType</a></td></tr>
<tr class="memitem:ace7755b07e61d0bec634fa4efd0131ad"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a><br class="typebreak"/>
&lt; const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt;, <a class="el" href="group__enums.html#gga8ef30fa9c08e08c8706653571f9f5b81a2434cd8c1a594a4cdaa250f86639c600">Vertical</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ace7755b07e61d0bec634fa4efd0131ad">ConstColwiseReturnType</a></td></tr>
<tr class="memitem:a6b7cc85ada478b0a4c885e1d8646d573"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classEigen_1_1Diagonal.html">Diagonal</a>&lt; const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a6b7cc85ada478b0a4c885e1d8646d573">ConstDiagonalReturnType</a></td></tr>
<tr class="memitem:ae98cbeddf3a9f43697733e6f53ff9f81"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classEigen_1_1Reverse.html">Reverse</a>&lt; const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, <a class="el" href="group__enums.html#gga8ef30fa9c08e08c8706653571f9f5b81a45def18a07325686f25627f90734e202">BothDirections</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae98cbeddf3a9f43697733e6f53ff9f81">ConstReverseReturnType</a></td></tr>
<tr class="memitem:a7b6f43bb643c4b843ee03b1250c4a82b"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a><br class="typebreak"/>
&lt; const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt;, <a class="el" href="group__enums.html#gga8ef30fa9c08e08c8706653571f9f5b81a7d5f78c516bedc0a066182a6fd606b8b">Horizontal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a7b6f43bb643c4b843ee03b1250c4a82b">ConstRowwiseReturnType</a></td></tr>
<tr class="memitem:ad2d40e210cd2f66126149c908270ead7"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classEigen_1_1VectorBlock.html">VectorBlock</a><br class="typebreak"/>
&lt; const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad2d40e210cd2f66126149c908270ead7">ConstSegmentReturnType</a></td></tr>
<tr class="memitem:a53a5f8ba92ce8489455a9094511a5928"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a900dca9b26de42491763226e12dcd47bae943bdba893721a848dfcd03db756b22">ColsAtCompileTime</a>==1?SizeMinusOne:1, <br class="typebreak"/>
internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a900dca9b26de42491763226e12dcd47bae943bdba893721a848dfcd03db756b22">ColsAtCompileTime</a>==1?1:<a class="el" href="classEigen_1_1MatrixBase.html#adab0c4467b3c6f365e87d0316a74bf64a78fe8ecc4113d81ef4f62e5eeefc0681">SizeMinusOne</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a53a5f8ba92ce8489455a9094511a5928">ConstStartMinusOne</a></td></tr>
<tr class="memitem:ac49cc2270a49c9e3453edcd9e9bc405b"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classEigen_1_1Transpose.html">Transpose</a>&lt; const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac49cc2270a49c9e3453edcd9e9bc405b">ConstTransposeReturnType</a></td></tr>
<tr class="memitem:a980bc0441b32195d35237dc095e8e299"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1Diagonal.html">Diagonal</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a980bc0441b32195d35237dc095e8e299">DiagonalReturnType</a></td></tr>
<tr class="memitem:aa142e6aca5decb8755ad04bfabf5bd4b"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
internal::add_const_on_value_type<br class="typebreak"/>
&lt; typename internal::eval<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;::type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa142e6aca5decb8755ad04bfabf5bd4b">EvalReturnType</a></td></tr>
<tr class="memitem:a8611b45083b3349d0f66f65e8f3e003d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1CoeffBasedProduct.html">CoeffBasedProduct</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1ProductBase.html#adc2b9e2eab4afab226c7cced7a912840">LhsNested</a>, <a class="el" href="classEigen_1_1ProductBase.html#a89d0de86a5e1a2320541ca26718d0f65">RhsNested</a>, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a8611b45083b3349d0f66f65e8f3e003d">FullyLazyCoeffBaseProductType</a></td></tr>
<tr class="memitem:a897444a687e838cf9ef294c38b4f2c3a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_quotient1_op<br class="typebreak"/>
&lt; typename internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1MatrixBase.html#a53a5f8ba92ce8489455a9094511a5928">ConstStartMinusOne</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a897444a687e838cf9ef294c38b4f2c3a">HNormalizedReturnType</a></td></tr>
<tr class="memitem:aae465955506095e5f943246eef43ecd1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1Homogeneous.html">Homogeneous</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;<br class="typebreak"/>
, <a class="el" href="classEigen_1_1MatrixBase.html#a12acb3634428eafc5724df6d836f4e64a6afa161e3ca510bbe71bc0a8beeaecef">HomogeneousReturnTypeDirection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aae465955506095e5f943246eef43ecd1">HomogeneousReturnType</a></td></tr>
<tr class="memitem:a4d4873e91be950c079f067fa97fd5c40"><td class="memItemLeft" align="right" valign="top">typedef internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a></td></tr>
<tr class="memdesc:a4d4873e91be950c079f067fa97fd5c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of indices.  <a href="#a4d4873e91be950c079f067fa97fd5c40"></a><br/></td></tr>
<tr class="memitem:aed5dbf6a65324779debbce61f2ad5085"><td class="memItemLeft" align="right" valign="top">typedef internal::blas_traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1ProductBase.html#a45b8b5cbeae8078ecc85e875074d72bd">_LhsNested</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#aed5dbf6a65324779debbce61f2ad5085">LhsBlasTraits</a></td></tr>
<tr class="memitem:adc2b9e2eab4afab226c7cced7a912840"><td class="memItemLeft" align="right" valign="top">typedef Lhs::Nested&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#adc2b9e2eab4afab226c7cced7a912840">LhsNested</a></td></tr>
<tr class="memitem:a095d48f8778996539975b3bc08ccf882"><td class="memItemLeft" align="right" valign="top">typedef internal::traits&lt; Lhs &gt;<br class="typebreak"/>
::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a095d48f8778996539975b3bc08ccf882">LhsScalar</a></td></tr>
<tr class="memitem:a0825f75e4eb100df4d8b09856fcb5139"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
internal::packet_traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a0825f75e4eb100df4d8b09856fcb5139">PacketScalar</a></td></tr>
<tr class="memitem:afd51a600a89b1b1d7db212cb8c80fbeb"><td class="memItemLeft" align="right" valign="top">typedef Base::PlainObject&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#afd51a600a89b1b1d7db212cb8c80fbeb">PlainObject</a></td></tr>
<tr class="memdesc:afd51a600a89b1b1d7db212cb8c80fbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The plain matrix type corresponding to this expression.  <a href="#afd51a600a89b1b1d7db212cb8c80fbeb"></a><br/></td></tr>
<tr class="memitem:acb5c3dc237f99cf17167e8a629f01b43"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a></td></tr>
<tr class="memitem:a8f39c2cb70afabf9d0283c44b8e7bf35"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1Reverse.html">Reverse</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, <a class="el" href="group__enums.html#gga8ef30fa9c08e08c8706653571f9f5b81a45def18a07325686f25627f90734e202">BothDirections</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a8f39c2cb70afabf9d0283c44b8e7bf35">ReverseReturnType</a></td></tr>
<tr class="memitem:a52a85733e0c99ba7e1b6460a8258b9c3"><td class="memItemLeft" align="right" valign="top">typedef internal::blas_traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1ProductBase.html#a870a8f6be0f8fca7ca4ff85dcd85b04f">_RhsNested</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a52a85733e0c99ba7e1b6460a8258b9c3">RhsBlasTraits</a></td></tr>
<tr class="memitem:a89d0de86a5e1a2320541ca26718d0f65"><td class="memItemLeft" align="right" valign="top">typedef Rhs::Nested&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a89d0de86a5e1a2320541ca26718d0f65">RhsNested</a></td></tr>
<tr class="memitem:a654adb5a3b18b111e0e31cdec815fa6a"><td class="memItemLeft" align="right" valign="top">typedef internal::traits&lt; Rhs &gt;<br class="typebreak"/>
::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a654adb5a3b18b111e0e31cdec815fa6a">RhsScalar</a></td></tr>
<tr class="memitem:a0f3a9175a7678aee05b39f4c85f750be"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, <a class="el" href="group__enums.html#gga8ef30fa9c08e08c8706653571f9f5b81a7d5f78c516bedc0a066182a6fd606b8b">Horizontal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a0f3a9175a7678aee05b39f4c85f750be">RowwiseReturnType</a></td></tr>
<tr class="memitem:a844358c46408e878e60c4026c52eb1e9"><td class="memItemLeft" align="right" valign="top">typedef internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a></td></tr>
<tr class="memitem:aa34201718d13b0e688d5b449772b74b7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1VectorBlock.html">VectorBlock</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa34201718d13b0e688d5b449772b74b7">SegmentReturnType</a></td></tr>
<tr class="memitem:a3f2f4e0a0daae11c77e2e4a3fdca1ea4"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
internal::stem_function<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a3f2f4e0a0daae11c77e2e4a3fdca1ea4">StemFunction</a></td></tr>
<tr class="memitem:a8500a4c2291f9efa756357ed83caf9d5"><td class="memItemLeft" align="right" valign="top">typedef internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a8500a4c2291f9efa756357ed83caf9d5">StorageKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a8500a4c2291f9efa756357ed83caf9d5">StorageKind</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae971ba016b817811ee81245fecdb85e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#ae971ba016b817811ee81245fecdb85e3">addTo</a> (Dest &amp;dst) const</td></tr>
<tr class="memitem:ac43d5834cffcedbd27777329a8f5eeca"><td class="memItemLeft" align="right" valign="top">const AdjointReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ac43d5834cffcedbd27777329a8f5eeca">adjoint</a> () const</td></tr>
<tr class="memitem:aa9915f22bf6388c78f860dfe20e8e4e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aa9915f22bf6388c78f860dfe20e8e4e3">adjointInPlace</a> ()</td></tr>
<tr class="memitem:aea914316af61df197f21629e14e7870a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aea914316af61df197f21629e14e7870a">all</a> (void) const</td></tr>
<tr class="memitem:a42571e028736ca9103bac8b50f269824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a42571e028736ca9103bac8b50f269824">any</a> (void) const</td></tr>
<tr class="memitem:a627d53362b0753eb710d8132e84fa490"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a627d53362b0753eb710d8132e84fa490">applyHouseholderOnTheLeft</a> (const EssentialPart &amp;essential, const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;tau, <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> *workspace)</td></tr>
<tr class="memitem:a146f355a8e78e220a49a0344d56b28e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a146f355a8e78e220a49a0344d56b28e9">applyHouseholderOnTheRight</a> (const EssentialPart &amp;essential, const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;tau, <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> *workspace)</td></tr>
<tr class="memitem:a9aaee4fba54baa7d0ca508e094f2d6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a9aaee4fba54baa7d0ca508e094f2d6f9">applyOnTheLeft</a> (const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memitem:a68c6383c506e63a2250be4433c73b519"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a68c6383c506e63a2250be4433c73b519">applyOnTheLeft</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="eigendoxy_8css.html#ac483f6ce851c9ecd9fb835ff7551737c">p</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="Eigen__Silly__Professor__64x64_8png.html#a7c33fee471dffccc71f296543d2f1b49">q</a>, const <a class="el" href="classEigen_1_1JacobiRotation.html">JacobiRotation</a>&lt; OtherScalar &gt; &amp;j)</td></tr>
<tr class="memitem:a6e5b1e71a1916ddd01e7c324831c40dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a6e5b1e71a1916ddd01e7c324831c40dc">applyOnTheRight</a> (const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memitem:ga794a90a8b3f30366546f93c5b9b77b18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Jacobi__Module.html#ga794a90a8b3f30366546f93c5b9b77b18">applyOnTheRight</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="eigendoxy_8css.html#ac483f6ce851c9ecd9fb835ff7551737c">p</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="Eigen__Silly__Professor__64x64_8png.html#a7c33fee471dffccc71f296543d2f1b49">q</a>, const <a class="el" href="classEigen_1_1JacobiRotation.html">JacobiRotation</a>&lt; OtherScalar &gt; &amp;j)</td></tr>
<tr class="memitem:a4545be7a9af33ba337a4ebb0101395fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1ArrayWrapper.html">ArrayWrapper</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a4545be7a9af33ba337a4ebb0101395fd">array</a> ()</td></tr>
<tr class="memitem:ae10a12846e86207146b1cc73207a1d46"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1ArrayWrapper.html">ArrayWrapper</a>&lt; const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae10a12846e86207146b1cc73207a1d46">array</a> () const</td></tr>
<tr class="memitem:adaf22d3a2069ec2c0df912cb87329e9c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1DiagonalWrapper.html">DiagonalWrapper</a>&lt; const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#adaf22d3a2069ec2c0df912cb87329e9c">asDiagonal</a> () const</td></tr>
<tr class="memitem:a39afb9eb8ca7f16fe64a8e601985df5d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PermutationWrapper.html">PermutationWrapper</a><br class="typebreak"/>
&lt; const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a39afb9eb8ca7f16fe64a8e601985df5d">asPermutation</a> () const</td></tr>
<tr class="memitem:ac00eb88e0d7599b8a2881715d3e4b35f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; CustomBinaryOp, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, const OtherDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ac00eb88e0d7599b8a2881715d3e4b35f">binaryExpr</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other, const CustomBinaryOp &amp;func=CustomBinaryOp()) const</td></tr>
<tr class="memitem:a1dbaa2fc7b809720407130f48dfacf8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> blockRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> blockCols)</td></tr>
<tr class="memitem:ace64451d903a49f7627cb3b87257c801"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ace64451d903a49f7627cb3b87257c801">block</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> blockRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> blockCols) const</td></tr>
<tr class="memitem:a3e433315822db2811a65e88c70672743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt;, BlockRows, <br class="typebreak"/>
BlockCols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3e433315822db2811a65e88c70672743">block</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol)</td></tr>
<tr class="memitem:a40f9466c400c6dc5779380124e37bf7f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, BlockRows, BlockCols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a40f9466c400c6dc5779380124e37bf7f">block</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol) const</td></tr>
<tr class="memitem:a6df34b875ae925798a3381a20b8f5ce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a6df34b875ae925798a3381a20b8f5ce8">blueNorm</a> () const</td></tr>
<tr class="memitem:a641cf096441faf5ab490c4973c719c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a641cf096441faf5ab490c4973c719c7a">bottomLeftCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols)</td></tr>
<tr class="memitem:abd00a289a3033ba0802cb55c23910874"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#abd00a289a3033ba0802cb55c23910874">bottomLeftCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols) const</td></tr>
<tr class="memitem:a243a44832e36d2bf5d0d8d17d1505900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt;, CRows, CCols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a243a44832e36d2bf5d0d8d17d1505900">bottomLeftCorner</a> ()</td></tr>
<tr class="memitem:a7fa849b36665dcca6316f05a634e6540"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, CRows, CCols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a7fa849b36665dcca6316f05a634e6540">bottomLeftCorner</a> () const</td></tr>
<tr class="memitem:a2b9618f3c9eb4d4c9813ae8f6a8e70c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a2b9618f3c9eb4d4c9813ae8f6a8e70c5">bottomRightCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols)</td></tr>
<tr class="memitem:a26cfa9c974065fc714cdaf7a5fdbe1ed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a26cfa9c974065fc714cdaf7a5fdbe1ed">bottomRightCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols) const</td></tr>
<tr class="memitem:a6563b16b601d9fd66340ab04d101f9d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt;, CRows, CCols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6563b16b601d9fd66340ab04d101f9d1">bottomRightCorner</a> ()</td></tr>
<tr class="memitem:aa0b8870679a8b100f24a8eecf1ac3477"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, CRows, CCols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa0b8870679a8b100f24a8eecf1ac3477">bottomRightCorner</a> () const</td></tr>
<tr class="memitem:afe61d23353a75d7034f7b44ff02aaea1"><td class="memItemLeft" align="right" valign="top">RowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#afe61d23353a75d7034f7b44ff02aaea1">bottomRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n)</td></tr>
<tr class="memitem:ae5959de43ccb180fbd4ad44002441a52"><td class="memItemLeft" align="right" valign="top">ConstRowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae5959de43ccb180fbd4ad44002441a52">bottomRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n) const</td></tr>
<tr class="memitem:a4809c823f0179782a50409c5444b55a1"><td class="memItemLeft" align="right" valign="top">NRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a4809c823f0179782a50409c5444b55a1">bottomRows</a> ()</td></tr>
<tr class="memitem:a2a0e94a9eca5418753083c42fd30deaf"><td class="memItemLeft" align="right" valign="top">ConstNRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a2a0e94a9eca5418753083c42fd30deaf">bottomRows</a> () const</td></tr>
<tr class="memitem:a660200abaf1fc4b888330a37d6132b76"><td class="memItemLeft" align="right" valign="top">internal::cast_return_type<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_cast_op<br class="typebreak"/>
&lt; typename internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>, NewType &gt;<br class="typebreak"/>
, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt; &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a660200abaf1fc4b888330a37d6132b76">cast</a> () const</td></tr>
<tr class="memitem:a8702b6108ed34ccb8ef15998da3ea4fd"><td class="memItemLeft" align="right" valign="top">Base::CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a8702b6108ed34ccb8ef15998da3ea4fd">coeff</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1DenseBase.html#aa8716d44f51321072ee5c88665c28813">row</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1DenseBase.html#a58c77695de3b33405f01f2fdf3dc389d">col</a>) const</td></tr>
<tr class="memitem:af507a43b31aada97c86331ebd95aff0e"><td class="memItemLeft" align="right" valign="top">Base::CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#af507a43b31aada97c86331ebd95aff0e">coeff</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> i) const</td></tr>
<tr class="memitem:a0df249c2cb09c14b5bdd9735b50831ee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a0df249c2cb09c14b5bdd9735b50831ee">coeffRef</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1DenseBase.html#aa8716d44f51321072ee5c88665c28813">row</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1DenseBase.html#a58c77695de3b33405f01f2fdf3dc389d">col</a>) const</td></tr>
<tr class="memitem:a5f68893d78cccdb143771222d94ad814"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a5f68893d78cccdb143771222d94ad814">coeffRef</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> i) const</td></tr>
<tr class="memitem:a58c77695de3b33405f01f2fdf3dc389d"><td class="memItemLeft" align="right" valign="top">ColXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a58c77695de3b33405f01f2fdf3dc389d">col</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> i)</td></tr>
<tr class="memitem:a390f7c534678354959dd587080b82c2c"><td class="memItemLeft" align="right" valign="top">ConstColXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a390f7c534678354959dd587080b82c2c">col</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> i) const</td></tr>
<tr class="memitem:a05afed751d3a7277951d1918468e0872"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1ColPivHouseholderQR.html">ColPivHouseholderQR</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a05afed751d3a7277951d1918468e0872">colPivHouseholderQr</a> () const</td></tr>
<tr class="memitem:aaca1908a5ec508a25ff0a8bca803e5f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#aaca1908a5ec508a25ff0a8bca803e5f3">cols</a> () const</td></tr>
<tr class="memitem:a49a617f24129ca31a27fe8a67ec20370"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#ace7755b07e61d0bec634fa4efd0131ad">ConstColwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a49a617f24129ca31a27fe8a67ec20370">colwise</a> () const</td></tr>
<tr class="memitem:abe7ae69362c464b6721adbb47c655874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a663adf32b8ea1a09257cdace430225c5">ColwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#abe7ae69362c464b6721adbb47c655874">colwise</a> ()</td></tr>
<tr class="memitem:abcd1eb30af2979b147e1f65477caa209"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#abcd1eb30af2979b147e1f65477caa209">computeInverseAndDetWithCheck</a> (ResultType &amp;<a class="el" href="classEigen_1_1MatrixBase.html#aa2834da4c855fa35fed8c4030f79f9da">inverse</a>, typename ResultType::Scalar &amp;<a class="el" href="classEigen_1_1MatrixBase.html#ad63cea11a4bf220298dce4489a1704c7">determinant</a>, <a class="el" href="classbool.html">bool</a> &amp;invertible, const <a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> &amp;absDeterminantThreshold=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:a687bc5340efb79f83dae171828407535"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a687bc5340efb79f83dae171828407535">computeInverseWithCheck</a> (ResultType &amp;<a class="el" href="classEigen_1_1MatrixBase.html#aa2834da4c855fa35fed8c4030f79f9da">inverse</a>, <a class="el" href="classbool.html">bool</a> &amp;invertible, const <a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> &amp;absDeterminantThreshold=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:aab6c2241712d7faf07019a0d86d3fb79"><td class="memItemLeft" align="right" valign="top">ConjugateReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aab6c2241712d7faf07019a0d86d3fb79">conjugate</a> () const</td></tr>
<tr class="memitem:a77167ec5968810d751e7c7ffee2451f4"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/classEigen_1_1MatrixFunctionReturnValue.html">MatrixFunctionReturnValue</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a77167ec5968810d751e7c7ffee2451f4">cos</a> () const</td></tr>
<tr class="memitem:ae39654c9e3ca67d20e54148c71666e69"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/classEigen_1_1MatrixFunctionReturnValue.html">MatrixFunctionReturnValue</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae39654c9e3ca67d20e54148c71666e69">cosh</a> () const</td></tr>
<tr class="memitem:aa671b5ea336ba21a7644d3fa6577ee00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa671b5ea336ba21a7644d3fa6577ee00">count</a> () const</td></tr>
<tr class="memitem:adb061c0be34af5f5f00ac8b3df0664d6"><td class="memItemLeft" align="right" valign="top">cross_product_return_type<br class="typebreak"/>
&lt; OtherDerived &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#adb061c0be34af5f5f00ac8b3df0664d6">cross</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="memitem:aa5243fb88c6f95f539afdec31cdbdfc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aa5243fb88c6f95f539afdec31cdbdfc2">cross3</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="memitem:ab4d8398a4497e4a888cfc11c51c14a81"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_abs_op<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ab4d8398a4497e4a888cfc11c51c14a81">cwiseAbs</a> () const</td></tr>
<tr class="memitem:abc9cb99dcb93caf0c3c37860aeef30b2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_abs2_op<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#abc9cb99dcb93caf0c3c37860aeef30b2">cwiseAbs2</a> () const</td></tr>
<tr class="memitem:a2373e043b49396e152523e85b0a2ace8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; std::equal_to&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;<br class="typebreak"/>
, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt;, const <br class="typebreak"/>
OtherDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a2373e043b49396e152523e85b0a2ace8">cwiseEqual</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="memitem:ae1f241762b604c2117232c5c994068bb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; std::binder1st<br class="typebreak"/>
&lt; std::equal_to&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;<br class="typebreak"/>
 &gt;, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae1f241762b604c2117232c5c994068bb">cwiseEqual</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;s) const</td></tr>
<tr class="memitem:a433cd5f8e17b2662c4081ec798fa54be"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_inverse_op<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a433cd5f8e17b2662c4081ec798fa54be">cwiseInverse</a> () const</td></tr>
<tr class="memitem:aa1a53029c0ee62fb8875ce3c12151eda"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_max_op<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, const OtherDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aa1a53029c0ee62fb8875ce3c12151eda">cwiseMax</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="memitem:a7e985c7a4f692584865b9ec9e7d5780c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_max_op<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, const <br class="typebreak"/>
ConstantReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a7e985c7a4f692584865b9ec9e7d5780c">cwiseMax</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;other) const</td></tr>
<tr class="memitem:afc17a621f5682e6eba6a1c439174d550"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_min_op<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, const OtherDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#afc17a621f5682e6eba6a1c439174d550">cwiseMin</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="memitem:ac02d0af0ea867d6b1cc0cc4db0e1d480"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_min_op<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, const <br class="typebreak"/>
ConstantReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ac02d0af0ea867d6b1cc0cc4db0e1d480">cwiseMin</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;other) const</td></tr>
<tr class="memitem:ac3f5276480c741953c66498a078ecd30"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; std::not_equal_to&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;<br class="typebreak"/>
, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt;, const <br class="typebreak"/>
OtherDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ac3f5276480c741953c66498a078ecd30">cwiseNotEqual</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="memitem:aa36bff7d4e9186e4fbed250b15ad9e36"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_quotient_op<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, const OtherDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aa36bff7d4e9186e4fbed250b15ad9e36">cwiseQuotient</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="memitem:a88945ad7d126468c10e299e896bf0d1e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_sqrt_op<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a88945ad7d126468c10e299e896bf0d1e">cwiseSqrt</a> () const</td></tr>
<tr class="memitem:a09f86d9dfd11fdb4522c90057a1d2c52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html#a09f86d9dfd11fdb4522c90057a1d2c52">DenseTimeSparseProduct</a> (const Lhs &amp;<a class="el" href="classEigen_1_1ProductBase.html#a1ab2b47535692481285a998525d0c646">lhs</a>, const Rhs &amp;<a class="el" href="classEigen_1_1ProductBase.html#a3483b038d185d8b507d26104094c5996">rhs</a>)</td></tr>
<tr class="memitem:ad63cea11a4bf220298dce4489a1704c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ad63cea11a4bf220298dce4489a1704c7">determinant</a> () const</td></tr>
<tr class="memitem:a67cc84868616ef3bb59afbb88bd5067b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Diagonal.html">Diagonal</a>&lt; const <br class="typebreak"/>
<a class="el" href="classEigen_1_1ProductBase.html#a8611b45083b3349d0f66f65e8f3e003d">FullyLazyCoeffBaseProductType</a>, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a67cc84868616ef3bb59afbb88bd5067b">diagonal</a> () const</td></tr>
<tr class="memitem:a51dbe204be4b592199b76bea60f60d19"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Diagonal.html">Diagonal</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1ProductBase.html#a8611b45083b3349d0f66f65e8f3e003d">FullyLazyCoeffBaseProductType</a>, <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a51dbe204be4b592199b76bea60f60d19">diagonal</a> () const</td></tr>
<tr class="memitem:a04ae0ec27434ac62cd570e9af2887262"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Diagonal.html">Diagonal</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1ProductBase.html#a8611b45083b3349d0f66f65e8f3e003d">FullyLazyCoeffBaseProductType</a>, <br class="typebreak"/>
<a class="el" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a04ae0ec27434ac62cd570e9af2887262">diagonal</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> index) const</td></tr>
<tr class="memitem:a0a45dd0ed5a44ec3f8f43239f2e4ac25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1MatrixBase.html#a980bc0441b32195d35237dc095e8e299">DiagonalReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a0a45dd0ed5a44ec3f8f43239f2e4ac25">diagonal</a> ()</td></tr>
<tr class="memitem:aeb52275c2538565644776d99214111fa"><td class="memItemLeft" align="right" valign="top">DiagonalIndexReturnType<br class="typebreak"/>
&lt; <a class="el" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aeb52275c2538565644776d99214111fa">diagonal</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> index)</td></tr>
<tr class="memitem:a41c29f54b9da54e37fbe1756a0da7013"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a41c29f54b9da54e37fbe1756a0da7013">diagonalSize</a> () const</td></tr>
<tr class="memitem:adb71ddef4955ae7d353df12d05665191"><td class="memItemLeft" align="right" valign="top">internal::scalar_product_traits<br class="typebreak"/>
&lt; typename internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>, typename <br class="typebreak"/>
internal::traits&lt; OtherDerived &gt;<br class="typebreak"/>
::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#adb71ddef4955ae7d353df12d05665191">dot</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="memitem:affb25649d2870c8a977cdbd6d4602a26"><td class="memItemLeft" align="right" valign="top">const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#affb25649d2870c8a977cdbd6d4602a26">EIGEN_CWISE_PRODUCT_RETURN_TYPE</a> (<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt;, OtherDerived) cwiseProduct(const Eigen</td></tr>
<tr class="memitem:a0ffa061371b1bd1b9f14ecef94b4502e"><td class="memItemLeft" align="right" valign="top">EigenvaluesReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a0ffa061371b1bd1b9f14ecef94b4502e">eigenvalues</a> () const</td></tr>
<tr class="memitem:gad118fececd448d7485ffea4858775e5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>, 3, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#gad118fececd448d7485ffea4858775e5a">eulerAngles</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> a0, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> a1, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> a2) const</td></tr>
<tr class="memitem:a6cb26f170dd440dfafe11117cf826334"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#aa142e6aca5decb8755ad04bfabf5bd4b">EvalReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6cb26f170dd440dfafe11117cf826334">eval</a> () const</td></tr>
<tr class="memitem:a4bce1b0cbd668b88d690b6016a529b7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a4bce1b0cbd668b88d690b6016a529b7c">evalTo</a> (Dest &amp;dst) const</td></tr>
<tr class="memitem:add90139a0c8c1e97b57b15efdcacfd5d"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/structEigen_1_1MatrixExponentialReturnValue.html">MatrixExponentialReturnValue</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#add90139a0c8c1e97b57b15efdcacfd5d">exp</a> () const</td></tr>
<tr class="memitem:a98692bec8f3d859f1e7a60eab87ac571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a98692bec8f3d859f1e7a60eab87ac571">fill</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;<a class="el" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a>)</td></tr>
<tr class="memitem:afcbba97b05d9a88657783dfc4f931f3f"><td class="memItemLeft" align="right" valign="top">const Flagged<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, Added, Removed &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#afcbba97b05d9a88657783dfc4f931f3f">flagged</a> () const</td></tr>
<tr class="memitem:a86875fbcf9ef290fdb82f6542687df33"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a86875fbcf9ef290fdb82f6542687df33">forceAlignedAccess</a> () const</td></tr>
<tr class="memitem:a4cb729c32116eedded672e8eed818696"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a4cb729c32116eedded672e8eed818696">forceAlignedAccess</a> ()</td></tr>
<tr class="memitem:aebafa5f282acf909015f679fa3a65b1e"><td class="memItemLeft" align="right" valign="top">internal::add_const_on_value_type<br class="typebreak"/>
&lt; typename <br class="typebreak"/>
internal::conditional&lt; Enable, <br class="typebreak"/>
<a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;<br class="typebreak"/>
 &gt;, <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt; &amp; &gt;::type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aebafa5f282acf909015f679fa3a65b1e">forceAlignedAccessIf</a> () const</td></tr>
<tr class="memitem:ac6a2fc1775837c6cbafa6b1c7d95e9c0"><td class="memItemLeft" align="right" valign="top">internal::conditional&lt; Enable, <br class="typebreak"/>
<a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;<br class="typebreak"/>
 &gt;, <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt; &amp; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ac6a2fc1775837c6cbafa6b1c7d95e9c0">forceAlignedAccessIf</a> ()</td></tr>
<tr class="memitem:aa364b60e6a2a124ea7392e4c0550fb4e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1WithFormat.html">WithFormat</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa364b60e6a2a124ea7392e4c0550fb4e">format</a> (const <a class="el" href="structEigen_1_1IOFormat.html">IOFormat</a> &amp;fmt) const</td></tr>
<tr class="memitem:aae22be8c5d589a13a872d2b43614d3a7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1FullPivHouseholderQR.html">FullPivHouseholderQR</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aae22be8c5d589a13a872d2b43614d3a7">fullPivHouseholderQr</a> () const</td></tr>
<tr class="memitem:a0844e94f8f95ae01a2cd88dbbf5cbf91"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1FullPivLU.html">FullPivLU</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a0844e94f8f95ae01a2cd88dbbf5cbf91">fullPivLu</a> () const</td></tr>
<tr class="memitem:aa1ff6e0f934acd0c0df92df542e3f151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#aa34201718d13b0e688d5b449772b74b7">SegmentReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa1ff6e0f934acd0c0df92df542e3f151">head</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size)</td></tr>
<tr class="memitem:ac79d7aa3f28290a69e27670810b5a171"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#ad2d40e210cd2f66126149c908270ead7">DenseBase::ConstSegmentReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac79d7aa3f28290a69e27670810b5a171">head</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size) const</td></tr>
<tr class="memitem:ad051b1f86e01a2ab8ab517ba100409b8"><td class="memItemLeft" align="right" valign="top">FixedSegmentReturnType&lt; Size &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad051b1f86e01a2ab8ab517ba100409b8">head</a> ()</td></tr>
<tr class="memitem:a753d5c674b39df5ceb6cac5f97c35ea7"><td class="memItemLeft" align="right" valign="top">ConstFixedSegmentReturnType<br class="typebreak"/>
&lt; Size &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a753d5c674b39df5ceb6cac5f97c35ea7">head</a> () const</td></tr>
<tr class="memitem:adcf645f676d798fc19417d3ce43484d0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1MatrixBase.html#a897444a687e838cf9ef294c38b4f2c3a">HNormalizedReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#adcf645f676d798fc19417d3ce43484d0">hnormalized</a> () const</td></tr>
<tr class="memitem:af3513a0abfc3875e6d1912b8bb7b28ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1MatrixBase.html#aae465955506095e5f943246eef43ecd1">HomogeneousReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#af3513a0abfc3875e6d1912b8bb7b28ac">homogeneous</a> () const</td></tr>
<tr class="memitem:abafaafa2e7eb9f485b282041833034bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1HouseholderQR.html">HouseholderQR</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#abafaafa2e7eb9f485b282041833034bf">householderQr</a> () const</td></tr>
<tr class="memitem:aa3aafc59ae3a7c8bb42ea3cee116fb59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aa3aafc59ae3a7c8bb42ea3cee116fb59">hypotNorm</a> () const</td></tr>
<tr class="memitem:a01069a930197aeca3b13b44bdc426c7b"><td class="memItemLeft" align="right" valign="top">const ImagReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a01069a930197aeca3b13b44bdc426c7b">imag</a> () const</td></tr>
<tr class="memitem:a1032121a2fc5fcc5f006f976413378f8"><td class="memItemLeft" align="right" valign="top">NonConstImagReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a1032121a2fc5fcc5f006f976413378f8">imag</a> ()</td></tr>
<tr class="memitem:acd9791e1914ad8761992e16032d49c54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#acd9791e1914ad8761992e16032d49c54">innerSize</a> () const</td></tr>
<tr class="memitem:aa2834da4c855fa35fed8c4030f79f9da"><td class="memItemLeft" align="right" valign="top">const internal::inverse_impl<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aa2834da4c855fa35fed8c4030f79f9da">inverse</a> () const</td></tr>
<tr class="memitem:a710e3763df8518854578a160c1a8902d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a710e3763df8518854578a160c1a8902d">isApprox</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other, <a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:a8340216d15cfd44fffe6c593d1ec65fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a8340216d15cfd44fffe6c593d1ec65fb">isApproxToConstant</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;<a class="el" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a>, <a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:abf87bca134f09f39c96bb205a3bbc6ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#abf87bca134f09f39c96bb205a3bbc6ec">isConstant</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;<a class="el" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a>, <a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:a57bee98bc48b0c01933b811972bf426f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a57bee98bc48b0c01933b811972bf426f">isDiagonal</a> (<a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:ae193aecdf8aaa0100d1768d1f52f7ab1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae193aecdf8aaa0100d1768d1f52f7ab1">isIdentity</a> (<a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:afe8985962ddd0dd6eb8274038bf47a58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#afe8985962ddd0dd6eb8274038bf47a58">isLowerTriangular</a> (<a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:afba6a244696a222955090ef25ddbbf33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#afba6a244696a222955090ef25ddbbf33">isMuchSmallerThan</a> (const <a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> &amp;other, <a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:a1ac5bfdda4730df82128870d3bb7186a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a1ac5bfdda4730df82128870d3bb7186a">isMuchSmallerThan</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other, <a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:a6eff8d451e78fa219272a17d2a31ccc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6eff8d451e78fa219272a17d2a31ccc1">isOnes</a> (<a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:a1c735180582f340aa9d678405c911381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a1c735180582f340aa9d678405c911381">isOrthogonal</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other, <a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:aa13076dcd20cd579534f623ffeb2dbfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aa13076dcd20cd579534f623ffeb2dbfa">isUnitary</a> (<a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:a53a24a38a7f89486a69d9c3b762909e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a53a24a38a7f89486a69d9c3b762909e2">isUpperTriangular</a> (<a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:a94a4633a78961a98a87b674337635ff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a94a4633a78961a98a87b674337635ff2">isZero</a> (<a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:a27a6a2e9d8839662a29cc8294398ff97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1JacobiSVD.html">JacobiSVD</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a27a6a2e9d8839662a29cc8294398ff97">jacobiSvd</a> (unsigned <a class="el" href="classint.html">int</a> computationOptions=0) const</td></tr>
<tr class="memitem:a605309e450951e44eaf5167c59bc3c97"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structEigen_1_1LazyProductReturnType.html">LazyProductReturnType</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, OtherDerived &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a605309e450951e44eaf5167c59bc3c97">lazyProduct</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="memitem:a197a04cda6b4606ec2416fd3f950371f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1LDLT.html">LDLT</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a197a04cda6b4606ec2416fd3f950371f">ldlt</a> () const</td></tr>
<tr class="memitem:ace4288d22b0312944ec93c8c46474ef6"><td class="memItemLeft" align="right" valign="top">ColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ace4288d22b0312944ec93c8c46474ef6">leftCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n)</td></tr>
<tr class="memitem:aa43a2f7ef9b8029727a3e0424fd4e57d"><td class="memItemLeft" align="right" valign="top">ConstColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa43a2f7ef9b8029727a3e0424fd4e57d">leftCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n) const</td></tr>
<tr class="memitem:a01053284fe198875df0ff63aae33eea8"><td class="memItemLeft" align="right" valign="top">NColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a01053284fe198875df0ff63aae33eea8">leftCols</a> ()</td></tr>
<tr class="memitem:ac838d0f0d149ad1e1581fd38a7922b04"><td class="memItemLeft" align="right" valign="top">ConstNColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac838d0f0d149ad1e1581fd38a7922b04">leftCols</a> () const</td></tr>
<tr class="memitem:a1ab2b47535692481285a998525d0c646"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1ProductBase.html#a45b8b5cbeae8078ecc85e875074d72bd">_LhsNested</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a1ab2b47535692481285a998525d0c646">lhs</a> () const</td></tr>
<tr class="memitem:a72ca76a1df449fd21a21d15ac1d1042a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1LLT.html">LLT</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a72ca76a1df449fd21a21d15ac1d1042a">llt</a> () const</td></tr>
<tr class="memitem:aa3626209eb159a56d0b0ed617af0dc39"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/classEigen_1_1MatrixLogarithmReturnValue.html">MatrixLogarithmReturnValue</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aa3626209eb159a56d0b0ed617af0dc39">log</a> () const</td></tr>
<tr class="memitem:a1f78d41c2ab7389e3df08384371188bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a1f78d41c2ab7389e3df08384371188bf">lpNorm</a> () const</td></tr>
<tr class="memitem:a013595649f973f38b3507d7cffe32ff9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialPivLU.html">PartialPivLU</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a013595649f973f38b3507d7cffe32ff9">lu</a> () const</td></tr>
<tr class="memitem:a306f9da1f2385c4a6e33e1d0e09173f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a306f9da1f2385c4a6e33e1d0e09173f2">makeHouseholder</a> (EssentialPart &amp;essential, <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;tau, <a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> &amp;beta) const</td></tr>
<tr class="memitem:ab04e8cc14dd5445607ab15a0d27745a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ab04e8cc14dd5445607ab15a0d27745a5">makeHouseholderInPlace</a> (<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;tau, <a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> &amp;beta)</td></tr>
<tr class="memitem:a7b68e468ddb549f7a051ab896a93288f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a7b68e468ddb549f7a051ab896a93288f">matrix</a> ()</td></tr>
<tr class="memitem:a1656a1d960cf89ba8c4b298a42e40721"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a1656a1d960cf89ba8c4b298a42e40721">matrix</a> () const</td></tr>
<tr class="memitem:a19ae20bfd9a9f7e5b315295825e4e9e1"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/classEigen_1_1MatrixFunctionReturnValue.html">MatrixFunctionReturnValue</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a19ae20bfd9a9f7e5b315295825e4e9e1">matrixFunction</a> (<a class="el" href="classEigen_1_1MatrixBase.html#a3f2f4e0a0daae11c77e2e4a3fdca1ea4">StemFunction</a> f) const</td></tr>
<tr class="memitem:a878f0dae18b28d8158c5f1c232edced2"><td class="memItemLeft" align="right" valign="top">internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a878f0dae18b28d8158c5f1c232edced2">maxCoeff</a> () const</td></tr>
<tr class="memitem:aad851ef369d212dcea81d9cded12dbdd"><td class="memItemLeft" align="right" valign="top">internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aad851ef369d212dcea81d9cded12dbdd">maxCoeff</a> (IndexType *<a class="el" href="classEigen_1_1DenseBase.html#aa8716d44f51321072ee5c88665c28813">row</a>, IndexType *<a class="el" href="classEigen_1_1DenseBase.html#a58c77695de3b33405f01f2fdf3dc389d">col</a>) const</td></tr>
<tr class="memitem:a0b381dbcb0435c3a34a78abad4726cc3"><td class="memItemLeft" align="right" valign="top">internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a0b381dbcb0435c3a34a78abad4726cc3">maxCoeff</a> (IndexType *index) const</td></tr>
<tr class="memitem:a0af2b3991862a079e3efaef3e4d17d96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a0af2b3991862a079e3efaef3e4d17d96">mean</a> () const</td></tr>
<tr class="memitem:a2d4f5da8e2019251ad3ed876d363d5d1"><td class="memItemLeft" align="right" valign="top">ColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a2d4f5da8e2019251ad3ed876d363d5d1">middleCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> numCols)</td></tr>
<tr class="memitem:a428643f7e51813faa8c8ad89b8282235"><td class="memItemLeft" align="right" valign="top">ConstColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a428643f7e51813faa8c8ad89b8282235">middleCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> numCols) const</td></tr>
<tr class="memitem:ab449491fb1077811187a0988a5c83e48"><td class="memItemLeft" align="right" valign="top">NColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ab449491fb1077811187a0988a5c83e48">middleCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol)</td></tr>
<tr class="memitem:a355072c91943dc9bdc4255a6538a5270"><td class="memItemLeft" align="right" valign="top">ConstNColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a355072c91943dc9bdc4255a6538a5270">middleCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol) const</td></tr>
<tr class="memitem:aa87a7527cd042907d180cf0c36c5f48a"><td class="memItemLeft" align="right" valign="top">RowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa87a7527cd042907d180cf0c36c5f48a">middleRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> numRows)</td></tr>
<tr class="memitem:a5dbf41bffa5d27df9ba17f81cdd64983"><td class="memItemLeft" align="right" valign="top">ConstRowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a5dbf41bffa5d27df9ba17f81cdd64983">middleRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> numRows) const</td></tr>
<tr class="memitem:a64475892fb40e70a2b701fd900084cbc"><td class="memItemLeft" align="right" valign="top">NRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a64475892fb40e70a2b701fd900084cbc">middleRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow)</td></tr>
<tr class="memitem:ad1750285d85ea6fbe5ee645eebbd749a"><td class="memItemLeft" align="right" valign="top">ConstNRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad1750285d85ea6fbe5ee645eebbd749a">middleRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow) const</td></tr>
<tr class="memitem:add6cb2d85282829eb9adc9565ce784d6"><td class="memItemLeft" align="right" valign="top">internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#add6cb2d85282829eb9adc9565ce784d6">minCoeff</a> () const</td></tr>
<tr class="memitem:ad927d600371ba16dcb44518530ba906a"><td class="memItemLeft" align="right" valign="top">internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad927d600371ba16dcb44518530ba906a">minCoeff</a> (IndexType *<a class="el" href="classEigen_1_1DenseBase.html#aa8716d44f51321072ee5c88665c28813">row</a>, IndexType *<a class="el" href="classEigen_1_1DenseBase.html#a58c77695de3b33405f01f2fdf3dc389d">col</a>) const</td></tr>
<tr class="memitem:ae959fb7401b9cfdf900ff3b295466526"><td class="memItemLeft" align="right" valign="top">internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae959fb7401b9cfdf900ff3b295466526">minCoeff</a> (IndexType *index) const</td></tr>
<tr class="memitem:a324b9263b40738a260d46ff011b8d31b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1NestByValue.html">NestByValue</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a324b9263b40738a260d46ff011b8d31b">nestByValue</a> () const</td></tr>
<tr class="memitem:ae77f3c3ccfb21694555dafc92c2da340"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1NoAlias.html">NoAlias</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae77f3c3ccfb21694555dafc92c2da340">noalias</a> ()</td></tr>
<tr class="memitem:abe29bfb5f2d88cf2a50ffb577ec6f0a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#abe29bfb5f2d88cf2a50ffb577ec6f0a4">nonZeros</a> () const</td></tr>
<tr class="memitem:a0be1b433c65ce9d92c81a4718daf54e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a0be1b433c65ce9d92c81a4718daf54e5">norm</a> () const</td></tr>
<tr class="memitem:acd0de676568888d848beb97dcc53ae47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#acd0de676568888d848beb97dcc53ae47">normalize</a> ()</td></tr>
<tr class="memitem:a8ed1fb2e792b1079639a74e3581fbc74"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a8ed1fb2e792b1079639a74e3581fbc74">normalized</a> () const</td></tr>
<tr class="memitem:a18a4fad97bfaa6ca788ea3b8464615ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a18a4fad97bfaa6ca788ea3b8464615ad">operator const PlainObject &amp;</a> () const</td></tr>
<tr class="memitem:a5648a35b9610ad47cb01912752db1dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a5648a35b9610ad47cb01912752db1dae">operator!=</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="memitem:ae8ab11fb1ef0822aa61527f7ecd77b9d"><td class="memItemLeft" align="right" valign="top">const ScalarMultipleReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae8ab11fb1ef0822aa61527f7ecd77b9d">operator*</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;scalar) const</td></tr>
<tr class="memitem:a40526ebb0e39712dcdd51ba545cae440"><td class="memItemLeft" align="right" valign="top">const ScalarMultipleReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a40526ebb0e39712dcdd51ba545cae440">operator*</a> (const <a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> &amp;scalar) const</td></tr>
<tr class="memitem:a01a3dfc024abbb42150002facf498357"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_multiple2_op<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>, std::complex&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;<br class="typebreak"/>
 &gt;, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a01a3dfc024abbb42150002facf498357">operator*</a> (const std::complex&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt; &amp;scalar) const</td></tr>
<tr class="memitem:adf2ccabec2f82b36f445e9c7f58c9080"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structEigen_1_1ProductReturnType.html">ProductReturnType</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, OtherDerived &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#adf2ccabec2f82b36f445e9c7f58c9080">operator*</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="memitem:a1f423e078af275d2f90a59af85a43f8d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1DiagonalProduct.html">DiagonalProduct</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, DiagonalDerived, <br class="typebreak"/>
<a class="el" href="group__enums.html#gga07422cff4c3dd5075f91f87bd0e57ee7aeda0d7b1859ec757de18ee3b7c6c541c">OnTheRight</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a1f423e078af275d2f90a59af85a43f8d">operator*</a> (const <a class="el" href="classDiagonalBase.html">DiagonalBase</a>&lt; DiagonalDerived &gt; &amp;<a class="el" href="classEigen_1_1ProductBase.html#a67cc84868616ef3bb59afbb88bd5067b">diagonal</a>) const</td></tr>
<tr class="memitem:ab413f2bd3b22564ab55633f7bca0155f"><td class="memItemLeft" align="right" valign="top">ScalarMultipleReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ab413f2bd3b22564ab55633f7bca0155f">operator*</a> (const <a class="el" href="classEigen_1_1UniformScaling.html">UniformScaling</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt; &amp;s) const</td></tr>
<tr class="memitem:ac9beaa3954c989bbbc59b361d9423e78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ac9beaa3954c989bbbc59b361d9423e78">operator*=</a> (const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memitem:ae339381c643e4ed8eaac81755c35532b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae339381c643e4ed8eaac81755c35532b">operator*=</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;other)</td></tr>
<tr class="memitem:a7aaf408b3bfbdd38749b01979393e814"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a7aaf408b3bfbdd38749b01979393e814">operator+=</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memitem:ad5a2176a93acda3adb5faf883818cbaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad5a2176a93acda3adb5faf883818cbaa">operator+=</a> (const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memitem:a7f53ae2f5586a75f1747d84822ae9581"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_opposite_op<br class="typebreak"/>
&lt; typename internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a7f53ae2f5586a75f1747d84822ae9581">operator-</a> () const</td></tr>
<tr class="memitem:a2da6ae5caa522c1efec3a75428b22143"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a2da6ae5caa522c1efec3a75428b22143">operator-=</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memitem:a34eedf9b323532a37f44e7d5c736c6c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a34eedf9b323532a37f44e7d5c736c6c6">operator-=</a> (const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memitem:ae78e46db7ee3ba78d3cf59968d261f90"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_quotient1_op<br class="typebreak"/>
&lt; typename internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae78e46db7ee3ba78d3cf59968d261f90">operator/</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;scalar) const</td></tr>
<tr class="memitem:a18e0c799d4dbc351465fb2d8964a6913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a18e0c799d4dbc351465fb2d8964a6913">operator/=</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;other)</td></tr>
<tr class="memitem:ade5d2e09de50c2ca145037f295542b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ade5d2e09de50c2ca145037f295542b16">operator&lt;&lt;</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;s)</td></tr>
<tr class="memitem:a3dacded5374fe30f8d4eb4ae18bc87c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3dacded5374fe30f8d4eb4ae18bc87c9">operator&lt;&lt;</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memitem:a78f22189db1a4cc4634bb8427ae64f06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a78f22189db1a4cc4634bb8427ae64f06">operator==</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="memitem:a0650a523c77a498a88b4998809d0bd14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a0650a523c77a498a88b4998809d0bd14">operatorNorm</a> () const</td></tr>
<tr class="memitem:af080d3d3f82e0d4391f19af22a5eedb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af080d3d3f82e0d4391f19af22a5eedb8">outerSize</a> () const</td></tr>
<tr class="memitem:a734707779b0449ea429d4ae42c3350f6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialPivLU.html">PartialPivLU</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a734707779b0449ea429d4ae42c3350f6">partialPivLu</a> () const</td></tr>
<tr class="memitem:a6bdcbfa7e3b07d3246ad80de7170b0f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6bdcbfa7e3b07d3246ad80de7170b0f5">prod</a> () const</td></tr>
<tr class="memitem:a4a1c87f8e48a66edc05859421048f8b0"><td class="memItemLeft" align="right" valign="top">RealReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a4a1c87f8e48a66edc05859421048f8b0">real</a> () const</td></tr>
<tr class="memitem:accfa15407b80807dab914b1844c725e5"><td class="memItemLeft" align="right" valign="top">NonConstRealReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#accfa15407b80807dab914b1844c725e5">real</a> ()</td></tr>
<tr class="memitem:afca0e8ff7921ee0e3ab4422818ecb214"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, RowFactor, ColFactor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#afca0e8ff7921ee0e3ab4422818ecb214">replicate</a> () const</td></tr>
<tr class="memitem:a594bdd8d2d9dd3249d563a33b9ac73bd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, <a class="el" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a>, <a class="el" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a594bdd8d2d9dd3249d563a33b9ac73bd">replicate</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> rowFacor, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> colFactor) const</td></tr>
<tr class="memitem:a0b8db206b78137e95dc0833952ed1ed0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a0b8db206b78137e95dc0833952ed1ed0">resize</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size)</td></tr>
<tr class="memitem:ac20f895ce9b73fa7447196855c0d0758"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac20f895ce9b73fa7447196855c0d0758">resize</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#a5552abd83dbd03c85cea6d61fd8875a5">rows</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#aaca1908a5ec508a25ff0a8bca803e5f3">cols</a>)</td></tr>
<tr class="memitem:a6e354bb81f0c7b6888c6a0ce4b4649e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a8f39c2cb70afabf9d0283c44b8e7bf35">ReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6e354bb81f0c7b6888c6a0ce4b4649e2">reverse</a> ()</td></tr>
<tr class="memitem:ae3a4b984747fa12de0f521b3bff907b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#ae98cbeddf3a9f43697733e6f53ff9f81">ConstReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae3a4b984747fa12de0f521b3bff907b3">reverse</a> () const</td></tr>
<tr class="memitem:af148c4e77e657d04573c4fda43740ed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af148c4e77e657d04573c4fda43740ed5">reverseInPlace</a> ()</td></tr>
<tr class="memitem:a3483b038d185d8b507d26104094c5996"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1ProductBase.html#a870a8f6be0f8fca7ca4ff85dcd85b04f">_RhsNested</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a3483b038d185d8b507d26104094c5996">rhs</a> () const</td></tr>
<tr class="memitem:af80f9e4e3708d7e3b0e1487ca90cf339"><td class="memItemLeft" align="right" valign="top">ColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af80f9e4e3708d7e3b0e1487ca90cf339">rightCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n)</td></tr>
<tr class="memitem:ad16081d19c5482a30aa6be15769e8056"><td class="memItemLeft" align="right" valign="top">ConstColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad16081d19c5482a30aa6be15769e8056">rightCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n) const</td></tr>
<tr class="memitem:af9afaaa2c2c27716dccdc58c50449103"><td class="memItemLeft" align="right" valign="top">NColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af9afaaa2c2c27716dccdc58c50449103">rightCols</a> ()</td></tr>
<tr class="memitem:ab4707ce78c96ddd7ca15c4e6f0a2a207"><td class="memItemLeft" align="right" valign="top">ConstNColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ab4707ce78c96ddd7ca15c4e6f0a2a207">rightCols</a> () const</td></tr>
<tr class="memitem:aa8716d44f51321072ee5c88665c28813"><td class="memItemLeft" align="right" valign="top">RowXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa8716d44f51321072ee5c88665c28813">row</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> i)</td></tr>
<tr class="memitem:ad62dcaf648cca25e9318da34c9840799"><td class="memItemLeft" align="right" valign="top">ConstRowXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad62dcaf648cca25e9318da34c9840799">row</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> i) const</td></tr>
<tr class="memitem:a5552abd83dbd03c85cea6d61fd8875a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a5552abd83dbd03c85cea6d61fd8875a5">rows</a> () const</td></tr>
<tr class="memitem:a3af2f03b1d2affcec24e0748edf892cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a7b6f43bb643c4b843ee03b1250c4a82b">ConstRowwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3af2f03b1d2affcec24e0748edf892cd">rowwise</a> () const</td></tr>
<tr class="memitem:a8a7fd1e8004d4bd93a7ea36957aa8e99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a0f3a9175a7678aee05b39f4c85f750be">RowwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a8a7fd1e8004d4bd93a7ea36957aa8e99">rowwise</a> ()</td></tr>
<tr class="memitem:a2cfd0bb3f7616ba0fc7ee592d795738d"><td class="memTemplParams" colspan="2">template&lt;typename Dest &gt; </td></tr>
<tr class="memitem:a2cfd0bb3f7616ba0fc7ee592d795738d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html#a2cfd0bb3f7616ba0fc7ee592d795738d">scaleAndAddTo</a> (Dest &amp;dest, <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> alpha) const </td></tr>
<tr class="memitem:ab958cfdd0a612fe8482d51e425921acb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#aa34201718d13b0e688d5b449772b74b7">SegmentReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ab958cfdd0a612fe8482d51e425921acb">segment</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> start, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size)</td></tr>
<tr class="memitem:a6bf70e2ce8b6a07a564ce04a01174e1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#ad2d40e210cd2f66126149c908270ead7">DenseBase::ConstSegmentReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6bf70e2ce8b6a07a564ce04a01174e1b">segment</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> start, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size) const</td></tr>
<tr class="memitem:a0bfdea57af5d6adc7a38fcd3c3dadc16"><td class="memItemLeft" align="right" valign="top">FixedSegmentReturnType&lt; Size &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a0bfdea57af5d6adc7a38fcd3c3dadc16">segment</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> start)</td></tr>
<tr class="memitem:ac1a11f3de938f4cfb9d248e55b15c7b0"><td class="memItemLeft" align="right" valign="top">ConstFixedSegmentReturnType<br class="typebreak"/>
&lt; Size &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac1a11f3de938f4cfb9d248e55b15c7b0">segment</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> start) const</td></tr>
<tr class="memitem:aaaed9ab0c7a20c689017542e40d1ef6e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Select.html">Select</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, ThenDerived, <br class="typebreak"/>
ElseDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aaaed9ab0c7a20c689017542e40d1ef6e">select</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;thenMatrix, const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;elseMatrix) const</td></tr>
<tr class="memitem:a0a07265514531d947ff91c2376aa7b29"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Select.html">Select</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, ThenDerived, typename <br class="typebreak"/>
ThenDerived::ConstantReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a0a07265514531d947ff91c2376aa7b29">select</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;thenMatrix, typename ThenDerived::Scalar elseScalar) const</td></tr>
<tr class="memitem:aa8cf1760451f0ba7263c9a0c7030b260"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Select.html">Select</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, typename <br class="typebreak"/>
ElseDerived::ConstantReturnType, <br class="typebreak"/>
ElseDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa8cf1760451f0ba7263c9a0c7030b260">select</a> (typename ElseDerived::Scalar thenScalar, const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;elseMatrix) const</td></tr>
<tr class="memitem:a37814d4937f5c0b0e247d74219875b72"><td class="memItemLeft" align="right" valign="top">SelfAdjointViewReturnType<br class="typebreak"/>
&lt; UpLo &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a37814d4937f5c0b0e247d74219875b72">selfadjointView</a> ()</td></tr>
<tr class="memitem:a18c31876454650792f4227cd1126b5e4"><td class="memItemLeft" align="right" valign="top">ConstSelfAdjointViewReturnType<br class="typebreak"/>
&lt; UpLo &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a18c31876454650792f4227cd1126b5e4">selfadjointView</a> () const</td></tr>
<tr class="memitem:a351ca566980cf96d9cdd61f3ce0cf94f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a351ca566980cf96d9cdd61f3ce0cf94f">setConstant</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;<a class="el" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a>)</td></tr>
<tr class="memitem:af1b15ae4c6f69b7324dd8ef70089dfc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#af1b15ae4c6f69b7324dd8ef70089dfc3">setIdentity</a> ()</td></tr>
<tr class="memitem:ad643c8a00f9d32b98659d9d745c56caf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ad643c8a00f9d32b98659d9d745c56caf">setIdentity</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#a5552abd83dbd03c85cea6d61fd8875a5">rows</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#aaca1908a5ec508a25ff0a8bca803e5f3">cols</a>)</td></tr>
<tr class="memitem:aca96b3050ceeffaa781d3d4ee185bd1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aca96b3050ceeffaa781d3d4ee185bd1d">setLinSpaced</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size, const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;low, const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;high)</td></tr>
<tr class="memitem:a043485fa5a9510639cd8034392371aec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a043485fa5a9510639cd8034392371aec">setLinSpaced</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;low, const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;high)</td></tr>
<tr class="memitem:a196e62ee8a1fc3b4af631e955d650cfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a196e62ee8a1fc3b4af631e955d650cfc">setOnes</a> ()</td></tr>
<tr class="memitem:ab795c242db18862f502dfd9fa625c504"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ab795c242db18862f502dfd9fa625c504">setRandom</a> ()</td></tr>
<tr class="memitem:a9053ca03ac251002768a54742be28fce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a> ()</td></tr>
<tr class="memitem:a4303e65ff533bfc10e9bca9d9347887d"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/classEigen_1_1MatrixFunctionReturnValue.html">MatrixFunctionReturnValue</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a4303e65ff533bfc10e9bca9d9347887d">sin</a> () const</td></tr>
<tr class="memitem:a05bc52605cb45455e831971539050d54"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/classEigen_1_1MatrixFunctionReturnValue.html">MatrixFunctionReturnValue</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a05bc52605cb45455e831971539050d54">sinh</a> () const</td></tr>
<tr class="memitem:a7e1e1ff74803d9ded35ed44bd6dab0d6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1SparseView.html">SparseView</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a7e1e1ff74803d9ded35ed44bd6dab0d6">sparseView</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;m_reference=<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>(0), typename <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::Real m_epsilon=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:aa9d7a22735200792533edc1566c05126"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/classEigen_1_1MatrixSquareRootReturnValue.html">MatrixSquareRootReturnValue</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aa9d7a22735200792533edc1566c05126">sqrt</a> () const</td></tr>
<tr class="memitem:a229bd5cc6237359a1d85401743476ede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a229bd5cc6237359a1d85401743476ede">squaredNorm</a> () const</td></tr>
<tr class="memitem:a8cdb3143143e8df89dfb4c58977ea811"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a8cdb3143143e8df89dfb4c58977ea811">stableNorm</a> () const</td></tr>
<tr class="memitem:a9296f1ee60afdaa657ec14ed2facf993"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a9296f1ee60afdaa657ec14ed2facf993">subTo</a> (Dest &amp;dst) const</td></tr>
<tr class="memitem:a3a3b3fb530d3364ecef0bf9c9daf0983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3a3b3fb530d3364ecef0bf9c9daf0983">sum</a> () const</td></tr>
<tr class="memitem:add3bfb296c2f8e29aac6037b16c2e8a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#add3bfb296c2f8e29aac6037b16c2e8a9">swap</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other, <a class="el" href="classint.html">int</a>=OtherDerived::ThisConstantIsPrivateInPlainObjectBase)</td></tr>
<tr class="memitem:a203951fa04396e45d2c38737943c2c55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a203951fa04396e45d2c38737943c2c55">swap</a> (<a class="el" href="classEigen_1_1PlainObjectBase.html">PlainObjectBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memitem:a65f0bc141c75cb3e83010921851566fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#aa34201718d13b0e688d5b449772b74b7">SegmentReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a65f0bc141c75cb3e83010921851566fb">tail</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size)</td></tr>
<tr class="memitem:a808e1458a0de8ae07abea003af652aca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#ad2d40e210cd2f66126149c908270ead7">DenseBase::ConstSegmentReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a808e1458a0de8ae07abea003af652aca">tail</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size) const</td></tr>
<tr class="memitem:a10ed126a393d99256f80cfc54455c75c"><td class="memItemLeft" align="right" valign="top">FixedSegmentReturnType&lt; Size &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a10ed126a393d99256f80cfc54455c75c">tail</a> ()</td></tr>
<tr class="memitem:ac64cd62d1cd7216b0568154d1562b831"><td class="memItemLeft" align="right" valign="top">ConstFixedSegmentReturnType<br class="typebreak"/>
&lt; Size &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac64cd62d1cd7216b0568154d1562b831">tail</a> () const</td></tr>
<tr class="memitem:a6f5fc5fe9d3fb70e62d4a9b1795704a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6f5fc5fe9d3fb70e62d4a9b1795704a8">topLeftCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols)</td></tr>
<tr class="memitem:af51f8dd1a464c0fe48182f7bab7ffab6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af51f8dd1a464c0fe48182f7bab7ffab6">topLeftCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols) const</td></tr>
<tr class="memitem:ae06d0a5c4008014fb717866aec8d30c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt;, CRows, CCols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae06d0a5c4008014fb717866aec8d30c7">topLeftCorner</a> ()</td></tr>
<tr class="memitem:a29c05f280e61cf18f5865b0065cc769a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, CRows, CCols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a29c05f280e61cf18f5865b0065cc769a">topLeftCorner</a> () const</td></tr>
<tr class="memitem:a318006038c9becc5f9af003b7c77ea18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a318006038c9becc5f9af003b7c77ea18">topRightCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols)</td></tr>
<tr class="memitem:a8cd6c56ce974c092a0aa0f11ca1853cb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a8cd6c56ce974c092a0aa0f11ca1853cb">topRightCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols) const</td></tr>
<tr class="memitem:ad0088b2c1ec4dbd677dd19f589777945"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a><br class="typebreak"/>
&lt; Lhs, Rhs &gt;, CRows, CCols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad0088b2c1ec4dbd677dd19f589777945">topRightCorner</a> ()</td></tr>
<tr class="memitem:abbe4b3135cc0afa4eee8d9db60c637c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt;, CRows, CCols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#abbe4b3135cc0afa4eee8d9db60c637c1">topRightCorner</a> () const</td></tr>
<tr class="memitem:afdfced3e157f74b3bc68892aad178424"><td class="memItemLeft" align="right" valign="top">RowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#afdfced3e157f74b3bc68892aad178424">topRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n)</td></tr>
<tr class="memitem:ac77be6c2cf44abbb6f80496cbe14f2af"><td class="memItemLeft" align="right" valign="top">ConstRowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac77be6c2cf44abbb6f80496cbe14f2af">topRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n) const</td></tr>
<tr class="memitem:a77933058fb3cd3319a86dd0ac4c88d38"><td class="memItemLeft" align="right" valign="top">NRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a77933058fb3cd3319a86dd0ac4c88d38">topRows</a> ()</td></tr>
<tr class="memitem:a4d7327699c5128262f29dc66efac6484"><td class="memItemLeft" align="right" valign="top">ConstNRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a4d7327699c5128262f29dc66efac6484">topRows</a> () const</td></tr>
<tr class="memitem:a71696dd0adbf4731561fd60e55c3a96e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a71696dd0adbf4731561fd60e55c3a96e">trace</a> () const</td></tr>
<tr class="memitem:a3c187c30922fc5e42f208ae3eb0970ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Transpose.html">Eigen::Transpose</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3c187c30922fc5e42f208ae3eb0970ee">transpose</a> ()</td></tr>
<tr class="memitem:a3936cd66f319a377cdb93cad66f46755"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#ac49cc2270a49c9e3453edcd9e9bc405b">ConstTransposeReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3936cd66f319a377cdb93cad66f46755">transpose</a> () const</td></tr>
<tr class="memitem:a3689faf485a5e405a4fc9bf0e05564c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3689faf485a5e405a4fc9bf0e05564c9">transposeInPlace</a> ()</td></tr>
<tr class="memitem:a90150a6deb18826cee5ece716663358a"><td class="memItemLeft" align="right" valign="top">TriangularViewReturnType&lt; Mode &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a90150a6deb18826cee5ece716663358a">triangularView</a> ()</td></tr>
<tr class="memitem:a85796290d88996a8c943c53efdf5988a"><td class="memItemLeft" align="right" valign="top">ConstTriangularViewReturnType<br class="typebreak"/>
&lt; Mode &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a85796290d88996a8c943c53efdf5988a">triangularView</a> () const</td></tr>
<tr class="memitem:a23fc4bf97168dee2516f85edcfd4cfe7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; CustomUnaryOp, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a23fc4bf97168dee2516f85edcfd4cfe7">unaryExpr</a> (const CustomUnaryOp &amp;func=CustomUnaryOp()) const</td></tr>
<tr class="memdesc:a23fc4bf97168dee2516f85edcfd4cfe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a unary operator coefficient-wise.  <a href="#a23fc4bf97168dee2516f85edcfd4cfe7"></a><br/></td></tr>
<tr class="memitem:aba9ae3923f6caa962ef3418d6872c369"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryView.html">CwiseUnaryView</a><br class="typebreak"/>
&lt; CustomViewOp, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aba9ae3923f6caa962ef3418d6872c369">unaryViewExpr</a> (const CustomViewOp &amp;func=CustomViewOp()) const</td></tr>
<tr class="memitem:a42fdca0c5854b85d9482853c8a085dc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a42fdca0c5854b85d9482853c8a085dc1">unitOrthogonal</a> (void) const</td></tr>
<tr class="memitem:adf21a576b8f3a10bb141b8afd173b13d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a7ade678155e3ede0ed013e65dd79c905">CoeffReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a> () const</td></tr>
<tr class="memitem:af33f695c0e0ad5634ca73f19c347f7b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af33f695c0e0ad5634ca73f19c347f7b3">visit</a> (Visitor &amp;func) const</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abb7652b9ae2c6ee26be9db276613c4f6"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#abb7652b9ae2c6ee26be9db276613c4f6">Constant</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#a5552abd83dbd03c85cea6d61fd8875a5">rows</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#aaca1908a5ec508a25ff0a8bca803e5f3">cols</a>, const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;<a class="el" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a>)</td></tr>
<tr class="memitem:aa07edf1aa85b7e84bd6b15158efbca71"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa07edf1aa85b7e84bd6b15158efbca71">Constant</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size, const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;<a class="el" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a>)</td></tr>
<tr class="memitem:aa3647a2091ca73b864aee4126118fd44"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa3647a2091ca73b864aee4126118fd44">Constant</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;<a class="el" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a>)</td></tr>
<tr class="memitem:a0650b65c6ae6c3d19a138b72a6d68568"><td class="memItemLeft" align="right" valign="top">static const IdentityReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a0650b65c6ae6c3d19a138b72a6d68568">Identity</a> ()</td></tr>
<tr class="memitem:ac836fdaa36fbf51080ca710d682ef039"><td class="memItemLeft" align="right" valign="top">static const IdentityReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ac836fdaa36fbf51080ca710d682ef039">Identity</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#a5552abd83dbd03c85cea6d61fd8875a5">rows</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#aaca1908a5ec508a25ff0a8bca803e5f3">cols</a>)</td></tr>
<tr class="memitem:a03a4ddf48fc9f3674a783da9c6ae34d8"><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
SequentialLinSpacedReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a03a4ddf48fc9f3674a783da9c6ae34d8">LinSpaced</a> (<a class="el" href="namespaceEigen.html#a2346b8f38ce1366aa961095738a5f545">Sequential_t</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size, const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;low, const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;high)</td></tr>
<tr class="memitem:add3a25508eab3a05851a3b4208b96eb8"><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
RandomAccessLinSpacedReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#add3a25508eab3a05851a3b4208b96eb8">LinSpaced</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size, const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;low, const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;high)</td></tr>
<tr class="memitem:a30ceb9d76f8ca3ff5bc71f7797b9788d"><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
SequentialLinSpacedReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a30ceb9d76f8ca3ff5bc71f7797b9788d">LinSpaced</a> (<a class="el" href="namespaceEigen.html#a2346b8f38ce1366aa961095738a5f545">Sequential_t</a>, const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;low, const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;high)</td></tr>
<tr class="memitem:ac0e2ccb6cded6a7aa927c3410aee071b"><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
RandomAccessLinSpacedReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac0e2ccb6cded6a7aa927c3410aee071b">LinSpaced</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;low, const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;high)</td></tr>
<tr class="memitem:a138e37f3c338a544afb347aaf80d32da"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; CustomNullaryOp, <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a138e37f3c338a544afb347aaf80d32da">NullaryExpr</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#a5552abd83dbd03c85cea6d61fd8875a5">rows</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#aaca1908a5ec508a25ff0a8bca803e5f3">cols</a>, const CustomNullaryOp &amp;func)</td></tr>
<tr class="memitem:ae50fd894930b4f917cf5c40f23965f67"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; CustomNullaryOp, <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae50fd894930b4f917cf5c40f23965f67">NullaryExpr</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size, const CustomNullaryOp &amp;func)</td></tr>
<tr class="memitem:a24025debf13d8352eb963b814e08b5e8"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; CustomNullaryOp, <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a24025debf13d8352eb963b814e08b5e8">NullaryExpr</a> (const CustomNullaryOp &amp;func)</td></tr>
<tr class="memitem:ad148f93a6a00e32ef00903c5393337ef"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad148f93a6a00e32ef00903c5393337ef">Ones</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#a5552abd83dbd03c85cea6d61fd8875a5">rows</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#aaca1908a5ec508a25ff0a8bca803e5f3">cols</a>)</td></tr>
<tr class="memitem:adec530c086d6b585ebb009fe4fbb77e6"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#adec530c086d6b585ebb009fe4fbb77e6">Ones</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size)</td></tr>
<tr class="memitem:a2278addf9a3c977d40322571a0df8ac9"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a2278addf9a3c977d40322571a0df8ac9">Ones</a> ()</td></tr>
<tr class="memitem:a78061942c4ccb57f5b1dde173fdd8bd0"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; internal::scalar_random_op<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;<br class="typebreak"/>
, <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a78061942c4ccb57f5b1dde173fdd8bd0">Random</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#a5552abd83dbd03c85cea6d61fd8875a5">rows</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#aaca1908a5ec508a25ff0a8bca803e5f3">cols</a>)</td></tr>
<tr class="memitem:a6f42aba8fbe2618deb0e80e4af876e04"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; internal::scalar_random_op<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;<br class="typebreak"/>
, <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6f42aba8fbe2618deb0e80e4af876e04">Random</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size)</td></tr>
<tr class="memitem:a8e759dafdd9ecc446d397b7f5435f60a"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; internal::scalar_random_op<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;<br class="typebreak"/>
, <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Random</a> ()</td></tr>
<tr class="memitem:ae908d6321d43a20ed57d9f6c1c6acbe9"><td class="memItemLeft" align="right" valign="top">static const BasisReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae908d6321d43a20ed57d9f6c1c6acbe9">Unit</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> i)</td></tr>
<tr class="memitem:a3f665c26af64e93899d1899f67dbf11b"><td class="memItemLeft" align="right" valign="top">static const BasisReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a3f665c26af64e93899d1899f67dbf11b">Unit</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> i)</td></tr>
<tr class="memitem:a585b3898eb4f52adce6b7025fb8fb429"><td class="memItemLeft" align="right" valign="top">static const BasisReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a585b3898eb4f52adce6b7025fb8fb429">UnitW</a> ()</td></tr>
<tr class="memitem:a5e0e42c39330e4274d2d0479048ebc37"><td class="memItemLeft" align="right" valign="top">static const BasisReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a5e0e42c39330e4274d2d0479048ebc37">UnitX</a> ()</td></tr>
<tr class="memitem:abc925a22c4f4b48b5b10fa90924f14c1"><td class="memItemLeft" align="right" valign="top">static const BasisReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#abc925a22c4f4b48b5b10fa90924f14c1">UnitY</a> ()</td></tr>
<tr class="memitem:a135f14351a7213bf0b764272c14ca68c"><td class="memItemLeft" align="right" valign="top">static const BasisReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a135f14351a7213bf0b764272c14ca68c">UnitZ</a> ()</td></tr>
<tr class="memitem:a724349af3e253b69a54d503931b52ec3"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a724349af3e253b69a54d503931b52ec3">Zero</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#a5552abd83dbd03c85cea6d61fd8875a5">rows</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#aaca1908a5ec508a25ff0a8bca803e5f3">cols</a>)</td></tr>
<tr class="memitem:a39390955f1297dacb49ac94429f321fd"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a39390955f1297dacb49ac94429f321fd">Zero</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size)</td></tr>
<tr class="memitem:a2e36721b4833498b713e94a7948c6a29"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">Zero</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0f04267e5a2f6070d2568f68032f00b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a0f04267e5a2f6070d2568f68032f00b8">checkTransposeAliasing</a> (const OtherDerived &amp;other) const</td></tr>
<tr class="memitem:a5a5015ed430477ad1cf3c1ddc76652c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a5a5015ed430477ad1cf3c1ddc76652c4">operator+=</a> (const <a class="el" href="classEigen_1_1ArrayBase.html">ArrayBase</a>&lt; OtherDerived &gt; &amp;)</td></tr>
<tr class="memitem:abd22c4c1df0b17aae5dd7ac21dea4bda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#abd22c4c1df0b17aae5dd7ac21dea4bda">operator-=</a> (const <a class="el" href="classEigen_1_1ArrayBase.html">ArrayBase</a>&lt; OtherDerived &gt; &amp;)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a261a63462b154999ed8e894064c70b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1ProductBase.html#adc2b9e2eab4afab226c7cced7a912840">LhsNested</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a261a63462b154999ed8e894064c70b8f">m_lhs</a></td></tr>
<tr class="memitem:a18c00fa3636a862fda426d2a507f65f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a18c00fa3636a862fda426d2a507f65f9">m_result</a></td></tr>
<tr class="memitem:a09b383b77155f5437e24e6de15522270"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1ProductBase.html#a89d0de86a5e1a2320541ca26718d0f65">RhsNested</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductBase.html#a09b383b77155f5437e24e6de15522270">m_rhs</a></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3e057492d9eb3d397593114ddc7d349f"><td class="memItemLeft" align="right" valign="top">const ScalarMultipleReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a3e057492d9eb3d397593114ddc7d349f">operator*</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;scalar, const StorageBaseType &amp;<a class="el" href="classEigen_1_1MatrixBase.html#a7b68e468ddb549f7a051ab896a93288f">matrix</a>)</td></tr>
<tr class="memitem:ac20f49dfb37329c75616c592830973f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_multiple2_op<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>, std::complex&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;<br class="typebreak"/>
 &gt;, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, <br class="typebreak"/>
Rhs &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ac20f49dfb37329c75616c592830973f5">operator*</a> (const std::complex&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt; &amp;scalar, const StorageBaseType &amp;<a class="el" href="classEigen_1_1MatrixBase.html#a7b68e468ddb549f7a051ab896a93288f">matrix</a>)</td></tr>
</table>
<h3>template&lt;typename Lhs, typename Rhs&gt;<br/>
 class Eigen::DenseTimeSparseProduct&lt; Lhs, Rhs &gt;</h3>

<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a94813ca113fdfe695508c04b1088da49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::remove_all&lt;<a class="el" href="classEigen_1_1ProductBase.html#aa3e058df4f67cadb1d0d84eec063b1f9">ActualLhsType</a>&gt;::type <a class="el" href="classEigen_1_1ProductBase.html#a94813ca113fdfe695508c04b1088da49">_ActualLhsType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac6ef279a246137082b0992b37759a423"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::remove_all&lt;<a class="el" href="classEigen_1_1ProductBase.html#a373c62e6591f8f00410718418c5da22c">ActualRhsType</a>&gt;::type <a class="el" href="classEigen_1_1ProductBase.html#ac6ef279a246137082b0992b37759a423">_ActualRhsType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a45b8b5cbeae8078ecc85e875074d72bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::remove_all&lt;<a class="el" href="classEigen_1_1ProductBase.html#adc2b9e2eab4afab226c7cced7a912840">LhsNested</a>&gt;::type <a class="el" href="classEigen_1_1ProductBase.html#a45b8b5cbeae8078ecc85e875074d72bd">_LhsNested</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a870a8f6be0f8fca7ca4ff85dcd85b04f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::remove_all&lt;<a class="el" href="classEigen_1_1ProductBase.html#a89d0de86a5e1a2320541ca26718d0f65">RhsNested</a>&gt;::type <a class="el" href="classEigen_1_1ProductBase.html#a870a8f6be0f8fca7ca4ff85dcd85b04f">_RhsNested</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa3e058df4f67cadb1d0d84eec063b1f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef LhsBlasTraits::DirectLinearAccessType <a class="el" href="classEigen_1_1ProductBase.html#aa3e058df4f67cadb1d0d84eec063b1f9">ActualLhsType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a373c62e6591f8f00410718418c5da22c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RhsBlasTraits::DirectLinearAccessType <a class="el" href="classEigen_1_1ProductBase.html#a373c62e6591f8f00410718418c5da22c">ActualRhsType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0c21fb1f093f709af41fde1122aa153d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#ab629393e03251d41a4a97f88fd76fc72">Base</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classEigen_1_1DenseBase.html#ab629393e03251d41a4a97f88fd76fc72">DenseBase&lt; DenseTimeSparseProduct&lt; Lhs, Rhs &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7ade678155e3ede0ed013e65dd79c905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Base::CoeffReturnType <a class="el" href="classEigen_1_1DenseBase.html#a7ade678155e3ede0ed013e65dd79c905">CoeffReturnType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a663adf32b8ea1a09257cdace430225c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , <a class="el" href="group__enums.html#gga8ef30fa9c08e08c8706653571f9f5b81a2434cd8c1a594a4cdaa250f86639c600">Vertical</a>&gt; <a class="el" href="classEigen_1_1DenseBase.html#a663adf32b8ea1a09257cdace430225c5">ColwiseReturnType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ace7755b07e61d0bec634fa4efd0131ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , <a class="el" href="group__enums.html#gga8ef30fa9c08e08c8706653571f9f5b81a2434cd8c1a594a4cdaa250f86639c600">Vertical</a>&gt; <a class="el" href="classEigen_1_1DenseBase.html#ace7755b07e61d0bec634fa4efd0131ad">ConstColwiseReturnType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6b7cc85ada478b0a4c885e1d8646d573"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classEigen_1_1Diagonal.html">Diagonal</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#a6b7cc85ada478b0a4c885e1d8646d573">ConstDiagonalReturnType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae98cbeddf3a9f43697733e6f53ff9f81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classEigen_1_1Reverse.html">Reverse</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , <a class="el" href="group__enums.html#gga8ef30fa9c08e08c8706653571f9f5b81a45def18a07325686f25627f90734e202">BothDirections</a>&gt; <a class="el" href="classEigen_1_1DenseBase.html#ae98cbeddf3a9f43697733e6f53ff9f81">ConstReverseReturnType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b6f43bb643c4b843ee03b1250c4a82b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , <a class="el" href="group__enums.html#gga8ef30fa9c08e08c8706653571f9f5b81a7d5f78c516bedc0a066182a6fd606b8b">Horizontal</a>&gt; <a class="el" href="classEigen_1_1DenseBase.html#a7b6f43bb643c4b843ee03b1250c4a82b">ConstRowwiseReturnType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad2d40e210cd2f66126149c908270ead7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classEigen_1_1VectorBlock.html">VectorBlock</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#ad2d40e210cd2f66126149c908270ead7">ConstSegmentReturnType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a53a5f8ba92ce8489455a9094511a5928"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , internal::traits&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a900dca9b26de42491763226e12dcd47bae943bdba893721a848dfcd03db756b22">ColsAtCompileTime</a>==1 ? <a class="el" href="classEigen_1_1MatrixBase.html#adab0c4467b3c6f365e87d0316a74bf64a78fe8ecc4113d81ef4f62e5eeefc0681">SizeMinusOne</a> : 1, internal::traits&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a900dca9b26de42491763226e12dcd47bae943bdba893721a848dfcd03db756b22">ColsAtCompileTime</a>==1 ? 1 : <a class="el" href="classEigen_1_1MatrixBase.html#adab0c4467b3c6f365e87d0316a74bf64a78fe8ecc4113d81ef4f62e5eeefc0681">SizeMinusOne</a>&gt; <a class="el" href="classEigen_1_1MatrixBase.html#a53a5f8ba92ce8489455a9094511a5928">ConstStartMinusOne</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac49cc2270a49c9e3453edcd9e9bc405b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classEigen_1_1Transpose.html">Transpose</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#ac49cc2270a49c9e3453edcd9e9bc405b">ConstTransposeReturnType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a980bc0441b32195d35237dc095e8e299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classEigen_1_1Diagonal.html">Diagonal</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#a980bc0441b32195d35237dc095e8e299">DiagonalReturnType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa142e6aca5decb8755ad04bfabf5bd4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::add_const_on_value_type&lt;typename internal::eval&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;::type&gt;::type <a class="el" href="classEigen_1_1DenseBase.html#aa142e6aca5decb8755ad04bfabf5bd4b">EvalReturnType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8611b45083b3349d0f66f65e8f3e003d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classEigen_1_1CoeffBasedProduct.html">CoeffBasedProduct</a>&lt;<a class="el" href="classEigen_1_1ProductBase.html#adc2b9e2eab4afab226c7cced7a912840">LhsNested</a>, <a class="el" href="classEigen_1_1ProductBase.html#a89d0de86a5e1a2320541ca26718d0f65">RhsNested</a>, 0&gt; <a class="el" href="classEigen_1_1ProductBase.html#a8611b45083b3349d0f66f65e8f3e003d">FullyLazyCoeffBaseProductType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a897444a687e838cf9ef294c38b4f2c3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_quotient1_op&lt;typename internal::traits&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;, const <a class="el" href="classEigen_1_1MatrixBase.html#a53a5f8ba92ce8489455a9094511a5928">ConstStartMinusOne</a> &gt; <a class="el" href="classEigen_1_1MatrixBase.html#a897444a687e838cf9ef294c38b4f2c3a">HNormalizedReturnType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aae465955506095e5f943246eef43ecd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classEigen_1_1Homogeneous.html">Homogeneous</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , <a class="el" href="classEigen_1_1MatrixBase.html#a12acb3634428eafc5724df6d836f4e64a6afa161e3ca510bbe71bc0a8beeaecef">HomogeneousReturnTypeDirection</a>&gt; <a class="el" href="classEigen_1_1MatrixBase.html#aae465955506095e5f943246eef43ecd1">HomogeneousReturnType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d4873e91be950c079f067fa97fd5c40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::traits&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The type of indices. </p>
<p>To change this, <code>#define</code> the preprocessor symbol <code>EIGEN_DEFAULT_DENSE_INDEX_TYPE</code>. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="TopicPreprocessorDirectives.html">Preprocessor directives</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aed5dbf6a65324779debbce61f2ad5085"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::blas_traits&lt;<a class="el" href="classEigen_1_1ProductBase.html#a45b8b5cbeae8078ecc85e875074d72bd">_LhsNested</a>&gt; <a class="el" href="classEigen_1_1ProductBase.html#aed5dbf6a65324779debbce61f2ad5085">LhsBlasTraits</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adc2b9e2eab4afab226c7cced7a912840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Lhs::Nested <a class="el" href="classEigen_1_1ProductBase.html#adc2b9e2eab4afab226c7cced7a912840">LhsNested</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a095d48f8778996539975b3bc08ccf882"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::traits&lt;Lhs&gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> <a class="el" href="classEigen_1_1ProductBase.html#a095d48f8778996539975b3bc08ccf882">LhsScalar</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0825f75e4eb100df4d8b09856fcb5139"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::packet_traits&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::type <a class="el" href="classEigen_1_1DenseBase.html#a0825f75e4eb100df4d8b09856fcb5139">PacketScalar</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afd51a600a89b1b1d7db212cb8c80fbeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Base::PlainObject <a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The plain matrix type corresponding to this expression. </p>
<p>This is not necessarily exactly the return type of eval(). In the case of plain matrices, the return type of eval() is a const reference to a matrix, not a matrix! It is however guaranteed that the return type of eval() is either PlainObject or const PlainObject&amp;. </p>

<p>Reimplemented from <a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">MatrixBase&lt; DenseTimeSparseProduct&lt; Lhs, Rhs &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="acb5c3dc237f99cf17167e8a629f01b43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::Real <a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8f39c2cb70afabf9d0283c44b8e7bf35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classEigen_1_1Reverse.html">Reverse</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , <a class="el" href="group__enums.html#gga8ef30fa9c08e08c8706653571f9f5b81a45def18a07325686f25627f90734e202">BothDirections</a>&gt; <a class="el" href="classEigen_1_1DenseBase.html#a8f39c2cb70afabf9d0283c44b8e7bf35">ReverseReturnType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a52a85733e0c99ba7e1b6460a8258b9c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::blas_traits&lt;<a class="el" href="classEigen_1_1ProductBase.html#a870a8f6be0f8fca7ca4ff85dcd85b04f">_RhsNested</a>&gt; <a class="el" href="classEigen_1_1ProductBase.html#a52a85733e0c99ba7e1b6460a8258b9c3">RhsBlasTraits</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a89d0de86a5e1a2320541ca26718d0f65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Rhs::Nested <a class="el" href="classEigen_1_1ProductBase.html#a89d0de86a5e1a2320541ca26718d0f65">RhsNested</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a654adb5a3b18b111e0e31cdec815fa6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::traits&lt;Rhs&gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> <a class="el" href="classEigen_1_1ProductBase.html#a654adb5a3b18b111e0e31cdec815fa6a">RhsScalar</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f3a9175a7678aee05b39f4c85f750be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , <a class="el" href="group__enums.html#gga8ef30fa9c08e08c8706653571f9f5b81a7d5f78c516bedc0a066182a6fd606b8b">Horizontal</a>&gt; <a class="el" href="classEigen_1_1DenseBase.html#a0f3a9175a7678aee05b39f4c85f750be">RowwiseReturnType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a844358c46408e878e60c4026c52eb1e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::traits&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa34201718d13b0e688d5b449772b74b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classEigen_1_1VectorBlock.html">VectorBlock</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#aa34201718d13b0e688d5b449772b74b7">SegmentReturnType</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3f2f4e0a0daae11c77e2e4a3fdca1ea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::stem_function&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::type <a class="el" href="classEigen_1_1MatrixBase.html#a3f2f4e0a0daae11c77e2e4a3fdca1ea4">StemFunction</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8500a4c2291f9efa756357ed83caf9d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::traits&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a8500a4c2291f9efa756357ed83caf9d5">StorageKind</a> <a class="el" href="classEigen_1_1DenseBase.html#a8500a4c2291f9efa756357ed83caf9d5">StorageKind</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a12acb3634428eafc5724df6d836f4e64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adab0c4467b3c6f365e87d0316a74bf64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a900dca9b26de42491763226e12dcd47b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1be3860693af99a6c1da72580097294c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a09f86d9dfd11fdb4522c90057a1d2c52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a> </td>
          <td>(</td>
          <td class="paramtype">const Lhs &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rhs &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae971ba016b817811ee81245fecdb85e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1ProductBase.html#ae971ba016b817811ee81245fecdb85e3">addTo</a> </td>
          <td>(</td>
          <td class="paramtype">Dest &amp;&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac43d5834cffcedbd27777329a8f5eeca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AdjointReturnType <a class="el" href="classEigen_1_1MatrixBase.html#ac43d5834cffcedbd27777329a8f5eeca">adjoint</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the adjoint (i.e. conjugate transpose) of *this.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga57974378374e0683c6b6896298fbf4be">Matrix2cf</a> m = Matrix2cf::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the 2x2 complex matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is the adjoint of m:&quot;</span> &lt;&lt; endl &lt;&lt; m.adjoint() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the 2x2 complex matrix m:
 (-0.211,0.68) (-0.605,0.823)
 (0.597,0.566)  (0.536,-0.33)
Here is the adjoint of m:
(-0.211,-0.68) (0.597,-0.566)
(-0.605,-0.823)   (0.536,0.33)
</pre></div><dl class="section warning"><dt>Warning:</dt><dd>If you want to replace a matrix by its own adjoint, do <b>NOT</b> do this: <div class="fragment"><pre class="fragment"> m = m.adjoint(); <span class="comment">// bug!!! caused by aliasing effect</span>
</pre></div> Instead, use the adjointInPlace() method: <div class="fragment"><pre class="fragment"> m.adjointInPlace();
</pre></div> which gives <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> good opportunities for optimization, or alternatively you can also do: <div class="fragment"><pre class="fragment"> m = m.adjoint().eval();
</pre></div></dd></dl>
<dl class="section see"><dt>See also:</dt><dd>adjointInPlace(), transpose(), <a class="el" href="CommonCwiseUnaryOps_8h.html#aab6c2241712d7faf07019a0d86d3fb79">conjugate()</a>, class Transpose, class internal::scalar_conjugate_op </dd></dl>

</div>
</div>
<a class="anchor" id="aa9915f22bf6388c78f860dfe20e8e4e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html#aa9915f22bf6388c78f860dfe20e8e4e3">adjointInPlace</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the "in place" version of adjoint(): it replaces <code>*this</code> by its own transpose. Thus, doing </p>
<div class="fragment"><pre class="fragment"> m.adjointInPlace();
</pre></div><p> has the same effect on m as doing </p>
<div class="fragment"><pre class="fragment"> m = m.adjoint().eval();
</pre></div><p> and is faster and also safer because in the latter line of code, forgetting the eval() results in a bug caused by aliasing.</p>
<p>Notice however that this method is only useful if you want to replace a matrix by its own adjoint. If you just need the adjoint of a matrix, use adjoint().</p>
<dl class="section note"><dt>Note:</dt><dd>if the matrix is not square, then <code>*this</code> must be a resizable matrix.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>transpose(), adjoint(), transposeInPlace() </dd></dl>

</div>
</div>
<a class="anchor" id="aea914316af61df197f21629e14e7870a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classEigen_1_1DenseBase.html#aea914316af61df197f21629e14e7870a">all</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>true if all coefficients are true</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">Vector3f boxMin(Vector3f::Zero()), boxMax(Vector3f::Ones());
Vector3f p0 = Vector3f::Random(), p1 = Vector3f::Random().cwiseAbs();
<span class="comment">// let&#39;s check if p0 and p1 are inside the axis aligned box defined by the corners boxMin,boxMax:</span>
cout &lt;&lt; <span class="stringliteral">&quot;Is (&quot;</span> &lt;&lt; p0.transpose() &lt;&lt; <span class="stringliteral">&quot;) inside the box: &quot;</span>
     &lt;&lt; ((boxMin.array()&lt;p0.array()).<a class="code" href="classEigen_1_1DenseBase.html#aea914316af61df197f21629e14e7870a">all</a>() &amp;&amp; (boxMax.array()&gt;p0.array()).<a class="code" href="classEigen_1_1DenseBase.html#aea914316af61df197f21629e14e7870a">all</a>()) &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Is (&quot;</span> &lt;&lt; p1.transpose() &lt;&lt; <span class="stringliteral">&quot;) inside the box: &quot;</span>
     &lt;&lt; ((boxMin.array()&lt;p1.array()).<a class="code" href="classEigen_1_1DenseBase.html#aea914316af61df197f21629e14e7870a">all</a>() &amp;&amp; (boxMax.array()&gt;p1.array()).<a class="code" href="classEigen_1_1DenseBase.html#aea914316af61df197f21629e14e7870a">all</a>()) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Is (  0.68 -0.211  0.566) inside the box: 0
Is (0.597 0.823 0.605) inside the box: 1
</pre></div><dl class="section see"><dt>See also:</dt><dd>any(), Cwise::operator&lt;() </dd></dl>

</div>
</div>
<a class="anchor" id="a42571e028736ca9103bac8b50f269824"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classEigen_1_1DenseBase.html#a42571e028736ca9103bac8b50f269824">any</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>true if at least one coefficient is true</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>all() </dd></dl>

</div>
</div>
<a class="anchor" id="a627d53362b0753eb710d8132e84fa490"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html#a627d53362b0753eb710d8132e84fa490">applyHouseholderOnTheLeft</a> </td>
          <td>(</td>
          <td class="paramtype">const EssentialPart &amp;&#160;</td>
          <td class="paramname"><em>essential</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> *&#160;</td>
          <td class="paramname"><em>workspace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the elementary reflector H given by <img class="formulaInl" alt="$ H = I - tau v v^*$" src="form_117.png"/> with <img class="formulaInl" alt="$ v^T = [1 essential^T] $" src="form_118.png"/> from the left to a vector or matrix.</p>
<p>On input: </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">essential</td><td>the essential part of the vector <code>v</code> </td></tr>
    <tr><td class="paramname">tau</td><td>the scaling factor of the Householder transformation </td></tr>
    <tr><td class="paramname">workspace</td><td>a pointer to working space with at least this-&gt;cols() * essential.size() entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd>MatrixBase::makeHouseholder(), MatrixBase::makeHouseholderInPlace(), MatrixBase::applyHouseholderOnTheRight() </dd></dl>

</div>
</div>
<a class="anchor" id="a146f355a8e78e220a49a0344d56b28e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html#a146f355a8e78e220a49a0344d56b28e9">applyHouseholderOnTheRight</a> </td>
          <td>(</td>
          <td class="paramtype">const EssentialPart &amp;&#160;</td>
          <td class="paramname"><em>essential</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> *&#160;</td>
          <td class="paramname"><em>workspace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the elementary reflector H given by <img class="formulaInl" alt="$ H = I - tau v v^*$" src="form_117.png"/> with <img class="formulaInl" alt="$ v^T = [1 essential^T] $" src="form_118.png"/> from the right to a vector or matrix.</p>
<p>On input: </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">essential</td><td>the essential part of the vector <code>v</code> </td></tr>
    <tr><td class="paramname">tau</td><td>the scaling factor of the Householder transformation </td></tr>
    <tr><td class="paramname">workspace</td><td>a pointer to working space with at least this-&gt;cols() * essential.size() entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd>MatrixBase::makeHouseholder(), MatrixBase::makeHouseholderInPlace(), MatrixBase::applyHouseholderOnTheLeft() </dd></dl>

</div>
</div>
<a class="anchor" id="a9aaee4fba54baa7d0ca508e094f2d6f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html#a9aaee4fba54baa7d0ca508e094f2d6f9">applyOnTheLeft</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>replaces <code>*this</code> by <code>*this</code> * <em>other</em>. </p>

</div>
</div>
<a class="anchor" id="a68c6383c506e63a2250be4433c73b519"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html#a9aaee4fba54baa7d0ca508e094f2d6f9">applyOnTheLeft</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1JacobiRotation.html">JacobiRotation</a>&lt; OtherScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is defined in the Jacobi module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="Jacobi.html">Eigen/Jacobi</a>&gt;</span> 
</pre></div><p> Applies the rotation in the plane <em>j</em> to the rows <em>p</em> and <em>q</em> of <code>*this</code>, i.e., it computes B = J * B, with <img class="formulaInl" alt="$ B = \left ( \begin{array}{cc} \text{*this.row}(p) \\ \text{*this.row}(q) \end{array} \right ) $" src="form_140.png"/>.</p>
<dl class="section see"><dt>See also:</dt><dd>class JacobiRotation, MatrixBase::applyOnTheRight(), <a class="el" href="namespaceEigen_1_1internal.html#a82102fb9628b9fe094700930888ceb67">internal::apply_rotation_in_the_plane()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6e5b1e71a1916ddd01e7c324831c40dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html#a6e5b1e71a1916ddd01e7c324831c40dc">applyOnTheRight</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>replaces <code><em>this</code> by <code>*this</code> * <em>other</em>. It is equivalent to MatrixBase::operator&lt;/em&gt;=() </em></p>

</div>
</div>
<a class="anchor" id="ga794a90a8b3f30366546f93c5b9b77b18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html#a6e5b1e71a1916ddd01e7c324831c40dc">applyOnTheRight</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1JacobiRotation.html">JacobiRotation</a>&lt; OtherScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Applies the rotation in the plane <em>j</em> to the columns <em>p</em> and <em>q</em> of <code>*this</code>, i.e., it computes B = B * J with <img class="formulaInl" alt="$ B = \left ( \begin{array}{cc} \text{*this.col}(p) &amp; \text{*this.col}(q) \end{array} \right ) $" src="form_141.png"/>.</p>
<dl class="section see"><dt>See also:</dt><dd>class JacobiRotation, MatrixBase::applyOnTheLeft(), <a class="el" href="namespaceEigen_1_1internal.html#a82102fb9628b9fe094700930888ceb67">internal::apply_rotation_in_the_plane()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4545be7a9af33ba337a4ebb0101395fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1ArrayWrapper.html">ArrayWrapper</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#a4545be7a9af33ba337a4ebb0101395fd">array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an <a class="el" href="">Array </a> expression of this matrix </dd></dl>
<dl class="section see"><dt>See also:</dt><dd>ArrayBase::matrix() </dd></dl>

</div>
</div>
<a class="anchor" id="ae10a12846e86207146b1cc73207a1d46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1ArrayWrapper.html">ArrayWrapper</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#a4545be7a9af33ba337a4ebb0101395fd">array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adaf22d3a2069ec2c0df912cb87329e9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DiagonalWrapper.html">DiagonalWrapper</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#adaf22d3a2069ec2c0df912cb87329e9c">asDiagonal</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a pseudo-expression of a diagonal matrix with *this as vector of diagonal coefficients</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">cout &lt;&lt; <a class="code" href="group__matrixtypedefs.html#ga4b6688615f30a9959be0285115080c3d">Matrix3i</a>(<a class="code" href="group__matrixtypedefs.html#gaa4931fe5bb599038466be823fdfadd04">Vector3i</a>(2,5,6).<a class="code" href="classEigen_1_1MatrixBase.html#adaf22d3a2069ec2c0df912cb87329e9c">asDiagonal</a>()) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">2 0 0
0 5 0
0 0 6
</pre></div><dl class="section see"><dt>See also:</dt><dd>class DiagonalWrapper, class DiagonalMatrix, diagonal(), isDiagonal() </dd></dl>

</div>
</div>
<a class="anchor" id="a39afb9eb8ca7f16fe64a8e601985df5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PermutationWrapper.html">PermutationWrapper</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#a39afb9eb8ca7f16fe64a8e601985df5d">asPermutation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac00eb88e0d7599b8a2881715d3e4b35f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;CustomBinaryOp, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , const OtherDerived&gt; <a class="el" href="classEigen_1_1MatrixBase.html#ac00eb88e0d7599b8a2881715d3e4b35f">binaryExpr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CustomBinaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>CustomBinaryOp()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the difference of <code>*this</code> and <em>other</em> </dd></dl>
<dl class="section note"><dt>Note:</dt><dd>If you want to substract a given scalar from all coefficients, see Cwise::operator-().</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>class CwiseBinaryOp, operator-=() </dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>an expression of the sum of <code>*this</code> and <em>other</em> </dd></dl>
<dl class="section note"><dt>Note:</dt><dd>If you want to add a given scalar to all coefficients, see Cwise::operator+().</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>class CwiseBinaryOp, operator+=() </dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>an expression of a custom coefficient-wise operator <em>func</em> of *this and <em>other</em> </dd></dl>
<p>The template parameter <em>CustomBinaryOp</em> is the type of the functor of the custom operator (see class CwiseBinaryOp for an example)</p>
<p>Here is an example illustrating the use of custom functors: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="Core.html">Eigen/Core</a>&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="keyword">using namespace </span>Eigen;
<span class="keyword">using namespace </span>std;

<span class="comment">// define a custom template binary functor</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt; <span class="keyword">struct </span>MakeComplexOp {
  <a class="code" href="XprHelper_8h.html#a4363bfa78f2780a0714888ec373b2673">EIGEN_EMPTY_STRUCT_CTOR</a>(MakeComplexOp)
  typedef complex&lt;Scalar&gt; result_type;
  complex&lt;Scalar&gt; operator()(const Scalar&amp; a, const Scalar&amp; b)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> complex&lt;Scalar&gt;(a,b); }
};

<span class="keywordtype">int</span> <a class="code" href="tutorial_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)
{
  <a class="code" href="classEigen_1_1Matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix4d</a> m1 = Matrix4d::Random(), m2 = Matrix4d::Random();
  cout &lt;&lt; m1.<a class="code" href="classEigen_1_1MatrixBase.html#ac00eb88e0d7599b8a2881715d3e4b35f">binaryExpr</a>(m2, MakeComplexOp&lt;double&gt;()) &lt;&lt; endl;
  <span class="keywordflow">return</span> 0;
}
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">   (0.68,0.271)  (0.823,-0.967) (-0.444,-0.687)   (-0.27,0.998)
 (-0.211,0.435) (-0.605,-0.514)  (0.108,-0.198) (0.0268,-0.563)
 (0.566,-0.717)  (-0.33,-0.726) (-0.0452,-0.74)  (0.904,0.0259)
  (0.597,0.214)   (0.536,0.608)  (0.258,-0.782)   (0.832,0.678)
</pre></div><dl class="section see"><dt>See also:</dt><dd>class CwiseBinaryOp, <a class="el" href="ArrayCwiseBinaryOps_8h.html#a49b9b40206fe10320613f469b72e35bf">operator+()</a>, <a class="el" href="ArrayCwiseBinaryOps_8h.html#a62cfea0bdbdd10fb977e0eb5cdc4eb7a">operator-()</a>, cwiseProduct() </dd></dl>

</div>
</div>
<a class="anchor" id="a1dbaa2fc7b809720407130f48dfacf8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>blockRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>blockCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a dynamic-size expression of a block in *this.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the first row in the block </td></tr>
    <tr><td class="paramname">startCol</td><td>the first column in the block </td></tr>
    <tr><td class="paramname">blockRows</td><td>the number of rows in the block </td></tr>
    <tr><td class="paramname">blockCols</td><td>the number of columns in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = Matrix4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is m.block(1, 1, 2, 2):&quot;</span> &lt;&lt; endl &lt;&lt; m.block(1, 1, 2, 2) &lt;&lt; endl;
m.block(1, 1, 2, 2).setZero();
cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.block(1, 1, 2, 2):
-6 1
-3 0
Now the matrix m is:
 7  9 -5 -3
-2  0  0  0
 6  0  0  9
 6  6  3  9
</pre></div><dl class="section note"><dt>Note:</dt><dd>Even though the returned expression has dynamic size, in the case when it is applied to a fixed-size matrix, it inherits a fixed maximal size, which means that evaluating it does not cause a dynamic memory allocation.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a5ec25a830c3ba675b3fc095b413ed444">block(Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ace64451d903a49f7627cb3b87257c801"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>blockRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>blockCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a3e433315822db2811a65e88c70672743"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , BlockRows, BlockCols&gt; <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a fixed-size expression of a block in *this.</dd></dl>
<p>The template parameters <em>BlockRows</em> and <em>BlockCols</em> are the number of rows and columns in the block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the first row in the block </td></tr>
    <tr><td class="paramname">startCol</td><td>the first column in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = Matrix4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is m.block&lt;2,2&gt;(1,1):&quot;</span> &lt;&lt; endl &lt;&lt; m.block&lt;2,2&gt;(1,1) &lt;&lt; endl;
m.block&lt;2,2&gt;(1,1).<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();
cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.block&lt;2,2&gt;(1,1):
-6 1
-3 0
Now the matrix m is:
 7  9 -5 -3
-2  0  0  0
 6  0  0  9
 6  6  3  9
</pre></div><dl class="section note"><dt>Note:</dt><dd>since block is a templated member, the keyword template has to be used if the matrix type is also a template parameter: <div class="fragment"><pre class="fragment"> m.template block&lt;3,3&gt;(1,1); 
</pre></div></dd></dl>
<dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a40f9466c400c6dc5779380124e37bf7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , BlockRows, BlockCols&gt; <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#a5ec25a830c3ba675b3fc095b413ed444">block&lt;&gt;(Index, Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a6df34b875ae925798a3381a20b8f5ce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> <a class="el" href="classEigen_1_1MatrixBase.html#a6df34b875ae925798a3381a20b8f5ce8">blueNorm</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the <em>l2</em> norm of <code>*this</code> using the Blue's algorithm. A Portable Fortran Program to Find the Euclidean Norm of a Vector, ACM TOMS, Vol 4, Issue 1, 1978.</dd></dl>
<p>For architecture/scalar types without vectorization, this version is much faster than stableNorm(). Otherwise the stableNorm() is faster.</p>
<dl class="section see"><dt>See also:</dt><dd>norm(), stableNorm(), hypotNorm() </dd></dl>

</div>
</div>
<a class="anchor" id="a641cf096441faf5ab490c4973c719c7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a641cf096441faf5ab490c4973c719c7a">bottomLeftCorner</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a dynamic-size expression of a bottom-left corner of *this.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">cCols</td><td>the number of columns in the corner</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = Matrix4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is m.bottomLeftCorner(2, 2):&quot;</span> &lt;&lt; endl;
cout &lt;&lt; m.bottomLeftCorner(2, 2) &lt;&lt; endl;
m.bottomLeftCorner(2, 2).setZero();
cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.bottomLeftCorner(2, 2):
 6 -3
 6  6
Now the matrix m is:
 7  9 -5 -3
-2 -6  1  0
 0  0  0  9
 0  0  3  9
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abd00a289a3033ba0802cb55c23910874"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a641cf096441faf5ab490c4973c719c7a">bottomLeftCorner</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#a2ff10a17f5de27e277b388d83ad410da">bottomLeftCorner(Index, Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a243a44832e36d2bf5d0d8d17d1505900"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , CRows, CCols&gt; <a class="el" href="classEigen_1_1DenseBase.html#a641cf096441faf5ab490c4973c719c7a">bottomLeftCorner</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a fixed-size bottom-left corner of *this.</dd></dl>
<p>The template parameters CRows and CCols are the number of rows and columns in the corner.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = Matrix4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is m.bottomLeftCorner&lt;2,2&gt;():&quot;</span> &lt;&lt; endl;
cout &lt;&lt; m.bottomLeftCorner&lt;2,2&gt;() &lt;&lt; endl;
m.bottomLeftCorner&lt;2,2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();
cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.bottomLeftCorner&lt;2,2&gt;():
 6 -3
 6  6
Now the matrix m is:
 7  9 -5 -3
-2 -6  1  0
 0  0  0  9
 0  0  3  9
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7fa849b36665dcca6316f05a634e6540"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , CRows, CCols&gt; <a class="el" href="classEigen_1_1DenseBase.html#a641cf096441faf5ab490c4973c719c7a">bottomLeftCorner</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#a2ff10a17f5de27e277b388d83ad410da">bottomLeftCorner&lt;int, int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="a2b9618f3c9eb4d4c9813ae8f6a8e70c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a2b9618f3c9eb4d4c9813ae8f6a8e70c5">bottomRightCorner</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a dynamic-size expression of a bottom-right corner of *this.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">cCols</td><td>the number of columns in the corner</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = Matrix4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is m.bottomRightCorner(2, 2):&quot;</span> &lt;&lt; endl;
cout &lt;&lt; m.bottomRightCorner(2, 2) &lt;&lt; endl;
m.bottomRightCorner(2, 2).setZero();
cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.bottomRightCorner(2, 2):
0 9
3 9
Now the matrix m is:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  0
 6  6  0  0
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a26cfa9c974065fc714cdaf7a5fdbe1ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a2b9618f3c9eb4d4c9813ae8f6a8e70c5">bottomRightCorner</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#a2a866740312991e600cc984131a8a10a">bottomRightCorner(Index, Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a6563b16b601d9fd66340ab04d101f9d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , CRows, CCols&gt; <a class="el" href="classEigen_1_1DenseBase.html#a2b9618f3c9eb4d4c9813ae8f6a8e70c5">bottomRightCorner</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a fixed-size bottom-right corner of *this.</dd></dl>
<p>The template parameters CRows and CCols are the number of rows and columns in the corner.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = Matrix4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is m.bottomRightCorner&lt;2,2&gt;():&quot;</span> &lt;&lt; endl;
cout &lt;&lt; m.bottomRightCorner&lt;2,2&gt;() &lt;&lt; endl;
m.bottomRightCorner&lt;2,2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();
cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.bottomRightCorner&lt;2,2&gt;():
0 9
3 9
Now the matrix m is:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  0
 6  6  0  0
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa0b8870679a8b100f24a8eecf1ac3477"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , CRows, CCols&gt; <a class="el" href="classEigen_1_1DenseBase.html#a2b9618f3c9eb4d4c9813ae8f6a8e70c5">bottomRightCorner</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#a2a866740312991e600cc984131a8a10a">bottomRightCorner&lt;int, int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="afe61d23353a75d7034f7b44ff02aaea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RowsBlockXpr <a class="el" href="classEigen_1_1DenseBase.html#afe61d23353a75d7034f7b44ff02aaea1">bottomRows</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a block consisting of the bottom rows of *this.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of rows in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">Array44i a = Array44i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is a.bottomRows(2):&quot;</span> &lt;&lt; endl;
cout &lt;&lt; a.bottomRows(2) &lt;&lt; endl;
a.bottomRows(2).setZero();
cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.bottomRows(2):
 6 -3  0  9
 6  6  3  9
Now the array a is:
 7  9 -5 -3
-2 -6  1  0
 0  0  0  0
 0  0  0  0
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae5959de43ccb180fbd4ad44002441a52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstRowsBlockXpr <a class="el" href="classEigen_1_1DenseBase.html#afe61d23353a75d7034f7b44ff02aaea1">bottomRows</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#ab8fa56c7fd85a4177895d0acab5b14e9">bottomRows(Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a4809c823f0179782a50409c5444b55a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRowsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#afe61d23353a75d7034f7b44ff02aaea1">bottomRows</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a block consisting of the bottom rows of *this.</dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">N</td><td>the number of rows in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">Array44i a = Array44i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is a.bottomRows&lt;2&gt;():&quot;</span> &lt;&lt; endl;
cout &lt;&lt; a.bottomRows&lt;2&gt;() &lt;&lt; endl;
a.bottomRows&lt;2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();
cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.bottomRows&lt;2&gt;():
 6 -3  0  9
 6  6  3  9
Now the array a is:
 7  9 -5 -3
-2 -6  1  0
 0  0  0  0
 0  0  0  0
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2a0e94a9eca5418753083c42fd30deaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstNRowsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#afe61d23353a75d7034f7b44ff02aaea1">bottomRows</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#ab8fa56c7fd85a4177895d0acab5b14e9">bottomRows&lt;int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="a660200abaf1fc4b888330a37d6132b76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::cast_return_type&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; ,const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_cast_op&lt;typename internal::traits&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>, NewType&gt;, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; &gt;::type <a class="el" href="classEigen_1_1MatrixBase.html#a660200abaf1fc4b888330a37d6132b76">cast</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of *this with the <em>Scalar</em> type casted to <em>NewScalar</em>.</dd></dl>
<p>The template parameter <em>NewScalar</em> is the type we are casting the scalars to.</p>
<dl class="section see"><dt>See also:</dt><dd>class CwiseUnaryOp </dd></dl>

</div>
</div>
<a class="anchor" id="a0f04267e5a2f6070d2568f68032f00b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseBase.html#a0f04267e5a2f6070d2568f68032f00b8">checkTransposeAliasing</a> </td>
          <td>(</td>
          <td class="paramtype">const OtherDerived &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8702b6108ed34ccb8ef15998da3ea4fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Base::CoeffReturnType <a class="el" href="classEigen_1_1ProductBase.html#a8702b6108ed34ccb8ef15998da3ea4fd">coeff</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af507a43b31aada97c86331ebd95aff0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Base::CoeffReturnType <a class="el" href="classEigen_1_1ProductBase.html#a8702b6108ed34ccb8ef15998da3ea4fd">coeff</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0df249c2cb09c14b5bdd9735b50831ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&amp; <a class="el" href="classEigen_1_1ProductBase.html#a0df249c2cb09c14b5bdd9735b50831ee">coeffRef</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f68893d78cccdb143771222d94ad814"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&amp; <a class="el" href="classEigen_1_1ProductBase.html#a0df249c2cb09c14b5bdd9735b50831ee">coeffRef</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a58c77695de3b33405f01f2fdf3dc389d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ColXpr <a class="el" href="classEigen_1_1DenseBase.html#a58c77695de3b33405f01f2fdf3dc389d">col</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the <em>i-th</em> column of *this. Note that the numbering starts at 0.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = Matrix3d::Identity();
m.col(1) = <a class="code" href="group__matrixtypedefs.html#ga2006332f6989f501762673e21f5128f5">Vector3d</a>(4,5,6);
cout &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">1 4 0
0 5 0
0 6 1
</pre></div><dl class="section see"><dt>See also:</dt><dd><a class="el" href="BlockMethods_8h.html#a5890de7c28f383d6a1627f6e40c25399">row()</a>, class Block </dd></dl>

</div>
</div>
<a class="anchor" id="a390f7c534678354959dd587080b82c2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstColXpr <a class="el" href="classEigen_1_1DenseBase.html#a58c77695de3b33405f01f2fdf3dc389d">col</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#a67a3f626cce3b0ed807f76bff7c98cb7">col()</a>. </p>

</div>
</div>
<a class="anchor" id="a05afed751d3a7277951d1918468e0872"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1ColPivHouseholderQR.html">ColPivHouseholderQR</a>&lt;<a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a>&gt; <a class="el" href="classEigen_1_1MatrixBase.html#a05afed751d3a7277951d1918468e0872">colPivHouseholderQr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the column-pivoting Householder QR decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>class ColPivHouseholderQR </dd></dl>

</div>
</div>
<a class="anchor" id="aaca1908a5ec508a25ff0a8bca803e5f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#aaca1908a5ec508a25ff0a8bca803e5f3">cols</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a49a617f24129ca31a27fe8a67ec20370"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#ace7755b07e61d0bec634fa4efd0131ad">ConstColwiseReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html#a49a617f24129ca31a27fe8a67ec20370">colwise</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a VectorwiseOp wrapper of *this providing additional partial reduction operations</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = Matrix3d::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is the sum of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().sum() &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is the maximum absolute value of each column:&quot;</span>
     &lt;&lt; endl &lt;&lt; m.cwiseAbs().colwise().maxCoeff() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the sum of each column:
  1.04  0.815 -0.238
Here is the maximum absolute value of each column:
 0.68 0.823 0.536
</pre></div><dl class="section see"><dt>See also:</dt><dd>rowwise(), class VectorwiseOp, <a class="el" href="TutorialReductionsVisitorsBroadcasting.html">Tutorial page 7 - Reductions, visitors and broadcasting</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abe7ae69362c464b6721adbb47c655874"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a663adf32b8ea1a09257cdace430225c5">ColwiseReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html#a49a617f24129ca31a27fe8a67ec20370">colwise</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a writable VectorwiseOp wrapper of *this providing additional partial reduction operations</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>rowwise(), class VectorwiseOp, <a class="el" href="TutorialReductionsVisitorsBroadcasting.html">Tutorial page 7 - Reductions, visitors and broadcasting</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abcd1eb30af2979b147e1f65477caa209"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html#abcd1eb30af2979b147e1f65477caa209">computeInverseAndDetWithCheck</a> </td>
          <td>(</td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>inverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ResultType::Scalar &amp;&#160;</td>
          <td class="paramname"><em>determinant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>invertible</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> &amp;&#160;</td>
          <td class="paramname"><em>absDeterminantThreshold</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is defined in the LU module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="LU.html">Eigen/LU</a>&gt;</span> 
</pre></div><p>Computation of matrix inverse and determinant, with invertibility check.</p>
<p>This is only for fixed-size square matrices of size up to 4x4.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inverse</td><td>Reference to the matrix in which to store the inverse. </td></tr>
    <tr><td class="paramname">determinant</td><td>Reference to the variable in which to store the inverse. </td></tr>
    <tr><td class="paramname">invertible</td><td>Reference to the bool variable in which to store whether the matrix is invertible. </td></tr>
    <tr><td class="paramname">absDeterminantThreshold</td><td>Optional parameter controlling the invertibility check. The matrix will be declared invertible if the absolute value of its determinant is greater than this threshold.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = Matrix3d::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
<a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> <a class="code" href="ArrayCwiseUnaryOps_8h.html#a49544028ab4b11f85bf112d220ad0e05">inverse</a>;
<span class="keywordtype">bool</span> invertible;
<span class="keywordtype">double</span> determinant;
m.computeInverseAndDetWithCheck(inverse,determinant,invertible);
cout &lt;&lt; <span class="stringliteral">&quot;Its determinant is &quot;</span> &lt;&lt; determinant &lt;&lt; endl;
<span class="keywordflow">if</span>(invertible) {
  cout &lt;&lt; <span class="stringliteral">&quot;It is invertible, and its inverse is:&quot;</span> &lt;&lt; endl &lt;&lt; inverse &lt;&lt; endl;
}
<span class="keywordflow">else</span> {
  cout &lt;&lt; <span class="stringliteral">&quot;It is not invertible.&quot;</span> &lt;&lt; endl;
}
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Its determinant is 0.209
It is invertible, and its inverse is:
-0.199   2.23   2.84
  1.01 -0.555  -1.42
 -1.62   3.59   3.29
</pre></div><dl class="section see"><dt>See also:</dt><dd><a class="el" href="ArrayCwiseUnaryOps_8h.html#a49544028ab4b11f85bf112d220ad0e05">inverse()</a>, computeInverseWithCheck() </dd></dl>

</div>
</div>
<a class="anchor" id="a687bc5340efb79f83dae171828407535"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html#a687bc5340efb79f83dae171828407535">computeInverseWithCheck</a> </td>
          <td>(</td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>inverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>invertible</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> &amp;&#160;</td>
          <td class="paramname"><em>absDeterminantThreshold</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is defined in the LU module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="LU.html">Eigen/LU</a>&gt;</span> 
</pre></div><p>Computation of matrix inverse, with invertibility check.</p>
<p>This is only for fixed-size square matrices of size up to 4x4.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inverse</td><td>Reference to the matrix in which to store the inverse. </td></tr>
    <tr><td class="paramname">invertible</td><td>Reference to the bool variable in which to store whether the matrix is invertible. </td></tr>
    <tr><td class="paramname">absDeterminantThreshold</td><td>Optional parameter controlling the invertibility check. The matrix will be declared invertible if the absolute value of its determinant is greater than this threshold.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = Matrix3d::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
<a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> <a class="code" href="ArrayCwiseUnaryOps_8h.html#a49544028ab4b11f85bf112d220ad0e05">inverse</a>;
<span class="keywordtype">bool</span> invertible;
m.computeInverseWithCheck(inverse,invertible);
<span class="keywordflow">if</span>(invertible) {
  cout &lt;&lt; <span class="stringliteral">&quot;It is invertible, and its inverse is:&quot;</span> &lt;&lt; endl &lt;&lt; inverse &lt;&lt; endl;
}
<span class="keywordflow">else</span> {
  cout &lt;&lt; <span class="stringliteral">&quot;It is not invertible.&quot;</span> &lt;&lt; endl;
}
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
It is invertible, and its inverse is:
-0.199   2.23   2.84
  1.01 -0.555  -1.42
 -1.62   3.59   3.29
</pre></div><dl class="section see"><dt>See also:</dt><dd><a class="el" href="ArrayCwiseUnaryOps_8h.html#a49544028ab4b11f85bf112d220ad0e05">inverse()</a>, computeInverseAndDetWithCheck() </dd></dl>

</div>
</div>
<a class="anchor" id="aab6c2241712d7faf07019a0d86d3fb79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConjugateReturnType <a class="el" href="classEigen_1_1MatrixBase.html#aab6c2241712d7faf07019a0d86d3fb79">conjugate</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the complex conjugate of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>adjoint() </dd></dl>

</div>
</div>
<a class="anchor" id="abb7652b9ae2c6ee26be9db276613c4f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html#abb7652b9ae2c6ee26be9db276613c4f6">Constant</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a constant matrix of value <em>value</em> </dd></dl>
<p>The parameters <em>rows</em> and <em>cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this DenseBase type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>rows</em> and <em>cols</em> as arguments, so Zero() should be used instead.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See also:</dt><dd>class CwiseNullaryOp </dd></dl>

</div>
</div>
<a class="anchor" id="aa07edf1aa85b7e84bd6b15158efbca71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html#abb7652b9ae2c6ee26be9db276613c4f6">Constant</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a constant matrix of value <em>value</em> </dd></dl>
<p>The parameter <em>size</em> is the size of the returned vector. Must be compatible with this DenseBase type.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em>size</em> as argument, so Zero() should be used instead.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See also:</dt><dd>class CwiseNullaryOp </dd></dl>

</div>
</div>
<a class="anchor" id="aa3647a2091ca73b864aee4126118fd44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html#abb7652b9ae2c6ee26be9db276613c4f6">Constant</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a constant matrix of value <em>value</em> </dd></dl>
<p>This variant is only for fixed-size DenseBase types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See also:</dt><dd>class CwiseNullaryOp </dd></dl>

</div>
</div>
<a class="anchor" id="a77167ec5968810d751e7c7ffee2451f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/classEigen_1_1MatrixFunctionReturnValue.html">MatrixFunctionReturnValue</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#a77167ec5968810d751e7c7ffee2451f4">cos</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae39654c9e3ca67d20e54148c71666e69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/classEigen_1_1MatrixFunctionReturnValue.html">MatrixFunctionReturnValue</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#ae39654c9e3ca67d20e54148c71666e69">cosh</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa671b5ea336ba21a7644d3fa6577ee00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1DenseBase.html#aa671b5ea336ba21a7644d3fa6577ee00">count</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the number of coefficients which evaluate to true</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>all(), any() </dd></dl>

</div>
</div>
<a class="anchor" id="adb061c0be34af5f5f00ac8b3df0664d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cross_product_return_type&lt;OtherDerived&gt;::type <a class="el" href="classEigen_1_1MatrixBase.html#adb061c0be34af5f5f00ac8b3df0664d6">cross</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is defined in the Geometry module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="Geometry.html">Eigen/Geometry</a>&gt;</span> 
</pre></div><dl class="section return"><dt>Returns:</dt><dd>the cross product of <code>*this</code> and <em>other</em> </dd></dl>
<p>Here is a very good explanation of cross-product: <a href="http://xkcd.com/199/">http://xkcd.com/199/</a> </p>
<dl class="section see"><dt>See also:</dt><dd>MatrixBase::cross3() </dd></dl>

</div>
</div>
<a class="anchor" id="aa5243fb88c6f95f539afdec31cdbdfc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a> <a class="el" href="classEigen_1_1MatrixBase.html#aa5243fb88c6f95f539afdec31cdbdfc2">cross3</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is defined in the Geometry module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="Geometry.html">Eigen/Geometry</a>&gt;</span> 
</pre></div><dl class="section return"><dt>Returns:</dt><dd>the cross product of <code>*this</code> and <em>other</em> using only the x, y, and z coefficients</dd></dl>
<p>The size of <code>*this</code> and <em>other</em> must be four. This function is especially useful when using 4D vectors instead of 3D ones to get advantage of SSE/AltiVec vectorization.</p>
<dl class="section see"><dt>See also:</dt><dd>MatrixBase::cross() </dd></dl>

</div>
</div>
<a class="anchor" id="ab4d8398a4497e4a888cfc11c51c14a81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_abs_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#ab4d8398a4497e4a888cfc11c51c14a81">cwiseAbs</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the coefficient-wise absolute value of <code>*this</code> </dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">MatrixXd m(2,3);
m &lt;&lt; 2, -4, 6,   
     -5, 1, 0;
cout &lt;&lt; m.cwiseAbs() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">2 4 6
5 1 0
</pre></div><dl class="section see"><dt>See also:</dt><dd><a class="el" href="MatrixCwiseUnaryOps_8h.html#abc9cb99dcb93caf0c3c37860aeef30b2">cwiseAbs2()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abc9cb99dcb93caf0c3c37860aeef30b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_abs2_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#abc9cb99dcb93caf0c3c37860aeef30b2">cwiseAbs2</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the coefficient-wise squared absolute value of <code>*this</code> </dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">MatrixXd m(2,3);
m &lt;&lt; 2, -4, 6,   
     -5, 1, 0;
cout &lt;&lt; m.cwiseAbs2() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment"> 4 16 36
25  1  0
</pre></div><dl class="section see"><dt>See also:</dt><dd><a class="el" href="MatrixCwiseUnaryOps_8h.html#ab4d8398a4497e4a888cfc11c51c14a81">cwiseAbs()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2373e043b49396e152523e85b0a2ace8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;std::equal_to&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , const OtherDerived&gt; <a class="el" href="classEigen_1_1MatrixBase.html#ae1f241762b604c2117232c5c994068bb">cwiseEqual</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the coefficient-wise == operator of *this and <em>other</em> </dd></dl>
<dl class="section warning"><dt>Warning:</dt><dd>this performs an exact comparison, which is generally a bad idea with floating-point types. In order to check for equality between two vectors or matrices with floating-point coefficients, it is generally a far better idea to use a fuzzy comparison as provided by <a class="el" href="namespaceEigen_1_1internal.html#a5f8973f6b62f10c691ccbadc9263c7fc">isApprox()</a> and <a class="el" href="namespaceEigen_1_1internal.html#a065688736535bc0764f59f39781a9052">isMuchSmallerThan()</a>.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga5b9d0d11e78fd355d23221154b7620e4">MatrixXi</a> m(2,2);
m &lt;&lt; 1, 0,
     1, 1;
cout &lt;&lt; <span class="stringliteral">&quot;Comparing m with identity matrix:&quot;</span> &lt;&lt; endl;
cout &lt;&lt; m.cwiseEqual(MatrixXi::Identity(2,2)) &lt;&lt; endl;
<span class="keywordtype">int</span> count = m.cwiseEqual(MatrixXi::Identity(2,2)).count();
cout &lt;&lt; <span class="stringliteral">&quot;Number of coefficients that are equal: &quot;</span> &lt;&lt; count &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Comparing m with identity matrix:
1 1
0 1
Number of coefficients that are equal: 3
</pre></div><dl class="section see"><dt>See also:</dt><dd><a class="el" href="MatrixCwiseBinaryOps_8h.html#a41e185e87c4722d6ca6075afb690536d">cwiseNotEqual()</a>, <a class="el" href="namespaceEigen_1_1internal.html#a5f8973f6b62f10c691ccbadc9263c7fc">isApprox()</a>, <a class="el" href="namespaceEigen_1_1internal.html#a065688736535bc0764f59f39781a9052">isMuchSmallerThan()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae1f241762b604c2117232c5c994068bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;std::binder1st&lt;std::equal_to&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt; &gt;, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#ae1f241762b604c2117232c5c994068bb">cwiseEqual</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the coefficient-wise == operator of <code>*this</code> and a scalar <em>s</em> </dd></dl>
<dl class="section warning"><dt>Warning:</dt><dd>this performs an exact comparison, which is generally a bad idea with floating-point types. In order to check for equality between two vectors or matrices with floating-point coefficients, it is generally a far better idea to use a fuzzy comparison as provided by <a class="el" href="namespaceEigen_1_1internal.html#a5f8973f6b62f10c691ccbadc9263c7fc">isApprox()</a> and <a class="el" href="namespaceEigen_1_1internal.html#a065688736535bc0764f59f39781a9052">isMuchSmallerThan()</a>.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>cwiseEqual(const MatrixBase&lt;OtherDerived&gt; &amp;) const </dd></dl>

</div>
</div>
<a class="anchor" id="a433cd5f8e17b2662c4081ec798fa54be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_inverse_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#a433cd5f8e17b2662c4081ec798fa54be">cwiseInverse</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the coefficient-wise inverse of *this.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">MatrixXd m(2,3);
m &lt;&lt; 2, 0.5, 1,   
     3, 0.25, 1;
cout &lt;&lt; m.cwiseInverse() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">0.5 2 1
0.333 4 1
</pre></div><dl class="section see"><dt>See also:</dt><dd>cwiseProduct() </dd></dl>

</div>
</div>
<a class="anchor" id="aa1a53029c0ee62fb8875ce3c12151eda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_max_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , const OtherDerived&gt; <a class="el" href="classEigen_1_1MatrixBase.html#aa1a53029c0ee62fb8875ce3c12151eda">cwiseMax</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the coefficient-wise max of *this and <em>other</em> </dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga2006332f6989f501762673e21f5128f5">Vector3d</a> v(2,3,4), w(4,2,3);
cout &lt;&lt; v.cwiseMax(w) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">4
3
4
</pre></div><dl class="section see"><dt>See also:</dt><dd>class CwiseBinaryOp, min() </dd></dl>

</div>
</div>
<a class="anchor" id="a7e985c7a4f692584865b9ec9e7d5780c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_max_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , const ConstantReturnType&gt; <a class="el" href="classEigen_1_1MatrixBase.html#aa1a53029c0ee62fb8875ce3c12151eda">cwiseMax</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the coefficient-wise max of *this and scalar <em>other</em> </dd></dl>
<dl class="section see"><dt>See also:</dt><dd>class CwiseBinaryOp, min() </dd></dl>

</div>
</div>
<a class="anchor" id="afc17a621f5682e6eba6a1c439174d550"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_min_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , const OtherDerived&gt; <a class="el" href="classEigen_1_1MatrixBase.html#afc17a621f5682e6eba6a1c439174d550">cwiseMin</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the coefficient-wise min of *this and <em>other</em> </dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga2006332f6989f501762673e21f5128f5">Vector3d</a> v(2,3,4), w(4,2,3);
cout &lt;&lt; v.cwiseMin(w) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">2
2
3
</pre></div><dl class="section see"><dt>See also:</dt><dd>class CwiseBinaryOp, max() </dd></dl>

</div>
</div>
<a class="anchor" id="ac02d0af0ea867d6b1cc0cc4db0e1d480"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_min_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , const ConstantReturnType&gt; <a class="el" href="classEigen_1_1MatrixBase.html#afc17a621f5682e6eba6a1c439174d550">cwiseMin</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the coefficient-wise min of *this and scalar <em>other</em> </dd></dl>
<dl class="section see"><dt>See also:</dt><dd>class CwiseBinaryOp, min() </dd></dl>

</div>
</div>
<a class="anchor" id="ac3f5276480c741953c66498a078ecd30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;std::not_equal_to&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , const OtherDerived&gt; <a class="el" href="classEigen_1_1MatrixBase.html#ac3f5276480c741953c66498a078ecd30">cwiseNotEqual</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the coefficient-wise != operator of *this and <em>other</em> </dd></dl>
<dl class="section warning"><dt>Warning:</dt><dd>this performs an exact comparison, which is generally a bad idea with floating-point types. In order to check for equality between two vectors or matrices with floating-point coefficients, it is generally a far better idea to use a fuzzy comparison as provided by <a class="el" href="namespaceEigen_1_1internal.html#a5f8973f6b62f10c691ccbadc9263c7fc">isApprox()</a> and <a class="el" href="namespaceEigen_1_1internal.html#a065688736535bc0764f59f39781a9052">isMuchSmallerThan()</a>.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga5b9d0d11e78fd355d23221154b7620e4">MatrixXi</a> m(2,2);
m &lt;&lt; 1, 0,
     1, 1;
cout &lt;&lt; <span class="stringliteral">&quot;Comparing m with identity matrix:&quot;</span> &lt;&lt; endl;
cout &lt;&lt; m.cwiseNotEqual(MatrixXi::Identity(2,2)) &lt;&lt; endl;
<span class="keywordtype">int</span> count = m.cwiseNotEqual(MatrixXi::Identity(2,2)).count();
cout &lt;&lt; <span class="stringliteral">&quot;Number of coefficients that are not equal: &quot;</span> &lt;&lt; count &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Comparing m with identity matrix:
0 0
1 0
Number of coefficients that are not equal: 1
</pre></div><dl class="section see"><dt>See also:</dt><dd><a class="el" href="MatrixCwiseBinaryOps_8h.html#a0f804483677fcb40fb13121921473855">cwiseEqual()</a>, <a class="el" href="namespaceEigen_1_1internal.html#a5f8973f6b62f10c691ccbadc9263c7fc">isApprox()</a>, <a class="el" href="namespaceEigen_1_1internal.html#a065688736535bc0764f59f39781a9052">isMuchSmallerThan()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa36bff7d4e9186e4fbed250b15ad9e36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_quotient_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , const OtherDerived&gt; <a class="el" href="classEigen_1_1MatrixBase.html#aa36bff7d4e9186e4fbed250b15ad9e36">cwiseQuotient</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the coefficient-wise quotient of *this and <em>other</em> </dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga2006332f6989f501762673e21f5128f5">Vector3d</a> v(2,3,4), w(4,2,3);
cout &lt;&lt; v.cwiseQuotient(w) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">0.5
1.5
1.33
</pre></div><dl class="section see"><dt>See also:</dt><dd>class CwiseBinaryOp, cwiseProduct(), <a class="el" href="MatrixCwiseUnaryOps_8h.html#a433cd5f8e17b2662c4081ec798fa54be">cwiseInverse()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a88945ad7d126468c10e299e896bf0d1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_sqrt_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#a88945ad7d126468c10e299e896bf0d1e">cwiseSqrt</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the coefficient-wise square root of *this.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga2006332f6989f501762673e21f5128f5">Vector3d</a> v(1,2,4);
cout &lt;&lt; v.cwiseSqrt() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">1
1.41
2
</pre></div><dl class="section see"><dt>See also:</dt><dd>cwisePow(), cwiseSquare() </dd></dl>

</div>
</div>
<a class="anchor" id="ad63cea11a4bf220298dce4489a1704c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> <a class="el" href="classEigen_1_1MatrixBase.html#ad63cea11a4bf220298dce4489a1704c7">determinant</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is defined in the LU module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="LU.html">Eigen/LU</a>&gt;</span> 
</pre></div><dl class="section return"><dt>Returns:</dt><dd>the determinant of this matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a67cc84868616ef3bb59afbb88bd5067b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Diagonal.html">Diagonal</a>&lt;const <a class="el" href="classEigen_1_1ProductBase.html#a8611b45083b3349d0f66f65e8f3e003d">FullyLazyCoeffBaseProductType</a>,0&gt; <a class="el" href="classEigen_1_1ProductBase.html#a67cc84868616ef3bb59afbb88bd5067b">diagonal</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of diagonal().</p>
<p>This is the const version of diagonal&lt;int&gt;(). </p>

<p>Reimplemented from <a class="el" href="classEigen_1_1MatrixBase.html#a2f6e454a7e934fb8212d269c099d0f7a">MatrixBase&lt; DenseTimeSparseProduct&lt; Lhs, Rhs &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a51dbe204be4b592199b76bea60f60d19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Diagonal.html">Diagonal</a>&lt;<a class="el" href="classEigen_1_1ProductBase.html#a8611b45083b3349d0f66f65e8f3e003d">FullyLazyCoeffBaseProductType</a>,<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&gt; <a class="el" href="classEigen_1_1ProductBase.html#a67cc84868616ef3bb59afbb88bd5067b">diagonal</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of diagonal().</p>
<p>This is the const version of diagonal&lt;int&gt;(). </p>

<p>Reimplemented from <a class="el" href="classEigen_1_1MatrixBase.html#a2f6e454a7e934fb8212d269c099d0f7a">MatrixBase&lt; DenseTimeSparseProduct&lt; Lhs, Rhs &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a04ae0ec27434ac62cd570e9af2887262"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Diagonal.html">Diagonal</a>&lt;<a class="el" href="classEigen_1_1ProductBase.html#a8611b45083b3349d0f66f65e8f3e003d">FullyLazyCoeffBaseProductType</a>,<a class="el" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a>&gt; <a class="el" href="classEigen_1_1ProductBase.html#a67cc84868616ef3bb59afbb88bd5067b">diagonal</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of diagonal(Index). </p>

<p>Reimplemented from <a class="el" href="classEigen_1_1MatrixBase.html#ad328d94887b4d7b673447346304cd885">MatrixBase&lt; DenseTimeSparseProduct&lt; Lhs, Rhs &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0a45dd0ed5a44ec3f8f43239f2e4ac25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html#a980bc0441b32195d35237dc095e8e299">DiagonalReturnType</a> <a class="el" href="classEigen_1_1ProductBase.html#a67cc84868616ef3bb59afbb88bd5067b">diagonal</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the main diagonal of the matrix <code>*this</code> </dd></dl>
<p><code>*this</code> is not required to be square.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga4b6688615f30a9959be0285115080c3d">Matrix3i</a> m = Matrix3i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here are the coefficients on the main diagonal of m:&quot;</span> &lt;&lt; endl
     &lt;&lt; m.diagonal() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
 7  6 -3
-2  9  6
 6 -6 -5
Here are the coefficients on the main diagonal of m:
7
9
-5
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Diagonal</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>an expression of the <em>DiagIndex-th</em> sub or super diagonal of the matrix <code>*this</code> </dd></dl>
<p><code>*this</code> is not required to be square.</p>
<p>The template parameter <em>DiagIndex</em> represent a super diagonal if <em>DiagIndex</em> &gt; 0 and a sub diagonal otherwise. <em>DiagIndex</em> == 0 is equivalent to the main diagonal.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = Matrix4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here are the coefficients on the 1st super-diagonal and 2nd sub-diagonal of m:&quot;</span> &lt;&lt; endl
     &lt;&lt; m.diagonal&lt;1&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a3c187c30922fc5e42f208ae3eb0970ee">transpose</a>() &lt;&lt; endl
     &lt;&lt; m.diagonal&lt;-2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a3c187c30922fc5e42f208ae3eb0970ee">transpose</a>() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here are the coefficients on the 1st super-diagonal and 2nd sub-diagonal of m:
9 1 9
6 6
</pre></div><dl class="section see"><dt>See also:</dt><dd>MatrixBase::diagonal(), class Diagonal </dd></dl>

</div>
</div>
<a class="anchor" id="aeb52275c2538565644776d99214111fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DiagonalIndexReturnType&lt;<a class="el" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a>&gt;::Type <a class="el" href="classEigen_1_1ProductBase.html#a67cc84868616ef3bb59afbb88bd5067b">diagonal</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the <em>DiagIndex-th</em> sub or super diagonal of the matrix <code>*this</code> </dd></dl>
<p><code>*this</code> is not required to be square.</p>
<p>The template parameter <em>DiagIndex</em> represent a super diagonal if <em>DiagIndex</em> &gt; 0 and a sub diagonal otherwise. <em>DiagIndex</em> == 0 is equivalent to the main diagonal.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = Matrix4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here are the coefficients on the 1st super-diagonal and 2nd sub-diagonal of m:&quot;</span> &lt;&lt; endl
     &lt;&lt; m.diagonal(1).transpose() &lt;&lt; endl
     &lt;&lt; m.diagonal(-2).transpose() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here are the coefficients on the 1st super-diagonal and 2nd sub-diagonal of m:
9 1 9
6 6
</pre></div><dl class="section see"><dt>See also:</dt><dd>MatrixBase::diagonal(), class Diagonal </dd></dl>

</div>
</div>
<a class="anchor" id="a41c29f54b9da54e37fbe1756a0da7013"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1MatrixBase.html#a41c29f54b9da54e37fbe1756a0da7013">diagonalSize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the size of the main diagonal, which is min(rows(),cols()). </dd></dl>
<dl class="section see"><dt>See also:</dt><dd>rows(), cols(), SizeAtCompileTime. </dd></dl>

</div>
</div>
<a class="anchor" id="adb71ddef4955ae7d353df12d05665191"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::scalar_product_traits&lt;typename internal::traits&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>,typename internal::traits&lt;OtherDerived&gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::ReturnType <a class="el" href="classEigen_1_1MatrixBase.html#adb71ddef4955ae7d353df12d05665191">dot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the dot product of *this with other.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section note"><dt>Note:</dt><dd>If the scalar type is complex numbers, then this function returns the hermitian (sesquilinear) dot product, conjugate-linear in the first variable and linear in the second variable.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>squaredNorm(), norm() </dd></dl>

</div>
</div>
<a class="anchor" id="affb25649d2870c8a977cdbd6d4602a26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1MatrixBase.html#affb25649d2870c8a977cdbd6d4602a26">EIGEN_CWISE_PRODUCT_RETURN_TYPE</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OtherDerived&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the Schur product (coefficient wise product) of *this and <em>other</em> </dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga4b6688615f30a9959be0285115080c3d">Matrix3i</a> a = Matrix3i::Random(), b = Matrix3i::Random();
<a class="code" href="group__matrixtypedefs.html#ga4b6688615f30a9959be0285115080c3d">Matrix3i</a> c = a.cwiseProduct(b);
cout &lt;&lt; <span class="stringliteral">&quot;a:\n&quot;</span> &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot;\nb:\n&quot;</span> &lt;&lt; b &lt;&lt; <span class="stringliteral">&quot;\nc:\n&quot;</span> &lt;&lt; c &lt;&lt; endl;

</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">a:
 7  6 -3
-2  9  6
 6 -6 -5
b:
 1 -3  9
 0  0  3
 3  9  5
c:
  7 -18 -27
  0   0  18
 18 -54 -25
</pre></div><dl class="section see"><dt>See also:</dt><dd>class CwiseBinaryOp, <a class="el" href="MatrixCwiseUnaryOps_8h.html#abc9cb99dcb93caf0c3c37860aeef30b2">cwiseAbs2</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0ffa061371b1bd1b9f14ecef94b4502e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EigenvaluesReturnType <a class="el" href="classEigen_1_1MatrixBase.html#a0ffa061371b1bd1b9f14ecef94b4502e">eigenvalues</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the eigenvalues of a matrix. </p>
<dl class="section return"><dt>Returns:</dt><dd>Column vector containing the eigenvalues.</dd></dl>
<p>This is defined in the Eigenvalues module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="Eigenvalues.html">Eigen/Eigenvalues</a>&gt;</span> 
</pre></div><p> This function computes the eigenvalues with the help of the EigenSolver class (for real matrices) or the ComplexEigenSolver class (for complex matrices).</p>
<p>The eigenvalues are repeated according to their algebraic multiplicity, so there are as many eigenvalues as rows in the matrix.</p>
<p>The SelfAdjointView class provides a better algorithm for selfadjoint matrices.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">MatrixXd ones = MatrixXd::Ones(3,3);
<a class="code" href="group__matrixtypedefs.html#ga3f53566af4e94dd734a669ffcf67560b">VectorXcd</a> eivals = ones.eigenvalues();
cout &lt;&lt; <span class="stringliteral">&quot;The eigenvalues of the 3x3 matrix of ones are:&quot;</span> &lt;&lt; endl &lt;&lt; eivals &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">The eigenvalues of the 3x3 matrix of ones are:
(-5.31e-17,0)
(3,0)
(0,0)
</pre></div><dl class="section see"><dt>See also:</dt><dd>EigenSolver::eigenvalues(), ComplexEigenSolver::eigenvalues(), SelfAdjointView::eigenvalues() </dd></dl>

</div>
</div>
<a class="anchor" id="gad118fececd448d7485ffea4858775e5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>,3,1&gt; <a class="el" href="group__Geometry__Module.html#gad118fececd448d7485ffea4858775e5a">eulerAngles</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is defined in the Geometry module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="Geometry.html">Eigen/Geometry</a>&gt;</span> 
</pre></div><dl class="section return"><dt>Returns:</dt><dd>the Euler-angles of the rotation matrix <code>*this</code> using the convention defined by the triplet (<em>a0</em>,<em>a1</em>,<em>a2</em>)</dd></dl>
<p>Each of the three parameters <em>a0</em>,<em>a1</em>,<em>a2</em> represents the respective rotation axis as an integer in {0,1,2}. For instance, in: </p>
<div class="fragment"><pre class="fragment"> Vector3f ea = mat.<a class="code" href="group__Geometry__Module.html#gad118fececd448d7485ffea4858775e5a">eulerAngles</a>(2, 0, 2); 
</pre></div><p> "2" represents the z axis and "0" the x axis, etc. The returned angles are such that we have the following equality: </p>
<div class="fragment"><pre class="fragment"> mat == <a class="code" href="group__Geometry__Module.html#ga811d6fdab2002723bc7a72f055ce8c1d">AngleAxisf</a>(ea[0], Vector3f::UnitZ())
      * <a class="code" href="group__Geometry__Module.html#ga811d6fdab2002723bc7a72f055ce8c1d">AngleAxisf</a>(ea[1], Vector3f::UnitX())
      * <a class="code" href="group__Geometry__Module.html#ga811d6fdab2002723bc7a72f055ce8c1d">AngleAxisf</a>(ea[2], Vector3f::UnitZ()); 
</pre></div><p> This corresponds to the right-multiply conventions (with right hand side frames). </p>

</div>
</div>
<a class="anchor" id="a6cb26f170dd440dfafe11117cf826334"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#aa142e6aca5decb8755ad04bfabf5bd4b">EvalReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html#a6cb26f170dd440dfafe11117cf826334">eval</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the matrix or vector obtained by evaluating this expression.</dd></dl>
<p>Notice that in the case of a plain matrix or vector (not an expression) this function just returns a const reference, in order to avoid a useless copy. </p>

</div>
</div>
<a class="anchor" id="a4bce1b0cbd668b88d690b6016a529b7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1ProductBase.html#a4bce1b0cbd668b88d690b6016a529b7c">evalTo</a> </td>
          <td>(</td>
          <td class="paramtype">Dest &amp;&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classEigen_1_1DenseBase.html#a81e52545715601e2634416caa0be204e">DenseBase&lt; DenseTimeSparseProduct&lt; Lhs, Rhs &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="add90139a0c8c1e97b57b15efdcacfd5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/structEigen_1_1MatrixExponentialReturnValue.html">MatrixExponentialReturnValue</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#add90139a0c8c1e97b57b15efdcacfd5d">exp</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a98692bec8f3d859f1e7a60eab87ac571"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseBase.html#a98692bec8f3d859f1e7a60eab87ac571">fill</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Alias for setConstant(): sets all coefficients in this expression to <em>value</em>.</p>
<dl class="section see"><dt>See also:</dt><dd>setConstant(), Constant(), class CwiseNullaryOp </dd></dl>

</div>
</div>
<a class="anchor" id="afcbba97b05d9a88657783dfc4f931f3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Flagged&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , Added, Removed&gt; <a class="el" href="classEigen_1_1DenseBase.html#afcbba97b05d9a88657783dfc4f931f3f">flagged</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of *this with added and removed flags</dd></dl>
<p>This is mostly for internal use.</p>
<dl class="section see"><dt>See also:</dt><dd>class Flagged </dd></dl>

</div>
</div>
<a class="anchor" id="a86875fbcf9ef290fdb82f6542687df33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#a86875fbcf9ef290fdb82f6542687df33">forceAlignedAccess</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of *this with forced aligned access </dd></dl>
<dl class="section see"><dt>See also:</dt><dd>forceAlignedAccessIf(),class ForceAlignedAccess </dd></dl>

<p>Reimplemented from <a class="el" href="classEigen_1_1DenseBase.html#a2010aecf12fd2c4b91ec625ed5824d06">DenseBase&lt; DenseTimeSparseProduct&lt; Lhs, Rhs &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4cb729c32116eedded672e8eed818696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#a86875fbcf9ef290fdb82f6542687df33">forceAlignedAccess</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of *this with forced aligned access </dd></dl>
<dl class="section see"><dt>See also:</dt><dd>forceAlignedAccessIf(), class ForceAlignedAccess </dd></dl>

<p>Reimplemented from <a class="el" href="classEigen_1_1DenseBase.html#afe980b43138379d8f42a8d1b47e230a4">DenseBase&lt; DenseTimeSparseProduct&lt; Lhs, Rhs &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aebafa5f282acf909015f679fa3a65b1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::add_const_on_value_type&lt;typename internal::conditional&lt;Enable,<a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;,<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp;&gt;::type&gt;::type <a class="el" href="classEigen_1_1MatrixBase.html#aebafa5f282acf909015f679fa3a65b1e">forceAlignedAccessIf</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of *this with forced aligned access if <em>Enable</em> is true. </dd></dl>
<dl class="section see"><dt>See also:</dt><dd>forceAlignedAccess(), class ForceAlignedAccess </dd></dl>

<p>Reimplemented from <a class="el" href="classEigen_1_1DenseBase.html#a0d33614d29bf40c50cadd9d38d75b359">DenseBase&lt; DenseTimeSparseProduct&lt; Lhs, Rhs &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac6a2fc1775837c6cbafa6b1c7d95e9c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::conditional&lt;Enable,<a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;,<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp;&gt;::type <a class="el" href="classEigen_1_1MatrixBase.html#aebafa5f282acf909015f679fa3a65b1e">forceAlignedAccessIf</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of *this with forced aligned access if <em>Enable</em> is true. </dd></dl>
<dl class="section see"><dt>See also:</dt><dd>forceAlignedAccess(), class ForceAlignedAccess </dd></dl>

<p>Reimplemented from <a class="el" href="classEigen_1_1DenseBase.html#a7770ffc3b5e33b723f3c53cd05052e64">DenseBase&lt; DenseTimeSparseProduct&lt; Lhs, Rhs &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa364b60e6a2a124ea7392e4c0550fb4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1WithFormat.html">WithFormat</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#aa364b60e6a2a124ea7392e4c0550fb4e">format</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEigen_1_1IOFormat.html">IOFormat</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a WithFormat proxy object allowing to print a matrix the with given format <em>fmt</em>.</dd></dl>
<p>See class IOFormat for some examples.</p>
<dl class="section see"><dt>See also:</dt><dd>class IOFormat, class WithFormat </dd></dl>

</div>
</div>
<a class="anchor" id="aae22be8c5d589a13a872d2b43614d3a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1FullPivHouseholderQR.html">FullPivHouseholderQR</a>&lt;<a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a>&gt; <a class="el" href="classEigen_1_1MatrixBase.html#aae22be8c5d589a13a872d2b43614d3a7">fullPivHouseholderQr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the full-pivoting Householder QR decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>class FullPivHouseholderQR </dd></dl>

</div>
</div>
<a class="anchor" id="a0844e94f8f95ae01a2cd88dbbf5cbf91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1FullPivLU.html">FullPivLU</a>&lt;<a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a>&gt; <a class="el" href="classEigen_1_1MatrixBase.html#a0844e94f8f95ae01a2cd88dbbf5cbf91">fullPivLu</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is defined in the LU module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="LU.html">Eigen/LU</a>&gt;</span> 
</pre></div><dl class="section return"><dt>Returns:</dt><dd>the full-pivoting LU decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>class FullPivLU </dd></dl>

</div>
</div>
<a class="anchor" id="aa1ff6e0f934acd0c0df92df542e3f151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#aa34201718d13b0e688d5b449772b74b7">SegmentReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html#aa1ff6e0f934acd0c0df92df542e3f151">head</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a dynamic-size expression of the first coefficients of *this.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of coefficients in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga1b8ec6f0766c4900ed6f84f30c36669a">RowVector4i</a> v = RowVector4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is v.head(2):&quot;</span> &lt;&lt; endl &lt;&lt; v.head(2) &lt;&lt; endl;
v.head(2).setZero();
cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.head(2):
 7 -2
Now the vector v is:
0 0 6 6
</pre></div><dl class="section note"><dt>Note:</dt><dd>Even though the returned expression has dynamic size, in the case when it is applied to a fixed-size vector, it inherits a fixed maximal size, which means that evaluating it does not cause a dynamic memory allocation.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a5ec25a830c3ba675b3fc095b413ed444">block(Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac79d7aa3f28290a69e27670810b5a171"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#ad2d40e210cd2f66126149c908270ead7">DenseBase::ConstSegmentReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html#aa1ff6e0f934acd0c0df92df542e3f151">head</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of head(Index). </p>

</div>
</div>
<a class="anchor" id="ad051b1f86e01a2ab8ab517ba100409b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FixedSegmentReturnType&lt;Size&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#aa1ff6e0f934acd0c0df92df542e3f151">head</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a fixed-size expression of the first coefficients of *this.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>The template parameter <em>Size</em> is the number of coefficients in the block</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga1b8ec6f0766c4900ed6f84f30c36669a">RowVector4i</a> v = RowVector4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is v.head(2):&quot;</span> &lt;&lt; endl &lt;&lt; v.head&lt;2&gt;() &lt;&lt; endl;
v.head&lt;2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();
cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.head(2):
 7 -2
Now the vector v is:
0 0 6 6
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block </dd></dl>

</div>
</div>
<a class="anchor" id="a753d5c674b39df5ceb6cac5f97c35ea7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstFixedSegmentReturnType&lt;Size&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#aa1ff6e0f934acd0c0df92df542e3f151">head</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of head&lt;int&gt;(). </p>

</div>
</div>
<a class="anchor" id="adcf645f676d798fc19417d3ce43484d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1MatrixBase.html#a897444a687e838cf9ef294c38b4f2c3a">HNormalizedReturnType</a> <a class="el" href="classEigen_1_1MatrixBase.html#adcf645f676d798fc19417d3ce43484d0">hnormalized</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is defined in the Geometry module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="Geometry.html">Eigen/Geometry</a>&gt;</span> 
</pre></div><dl class="section return"><dt>Returns:</dt><dd>an expression of the homogeneous normalized vector of <code>*this</code> </dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"></pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment"></pre></div><dl class="section see"><dt>See also:</dt><dd>VectorwiseOp::hnormalized() </dd></dl>

</div>
</div>
<a class="anchor" id="af3513a0abfc3875e6d1912b8bb7b28ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html#aae465955506095e5f943246eef43ecd1">HomogeneousReturnType</a> <a class="el" href="classEigen_1_1MatrixBase.html#af3513a0abfc3875e6d1912b8bb7b28ac">homogeneous</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is defined in the Geometry module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="Geometry.html">Eigen/Geometry</a>&gt;</span> 
</pre></div><dl class="section return"><dt>Returns:</dt><dd>an expression of the equivalent homogeneous vector</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"></pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment"></pre></div><dl class="section see"><dt>See also:</dt><dd>class Homogeneous </dd></dl>

</div>
</div>
<a class="anchor" id="abafaafa2e7eb9f485b282041833034bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1HouseholderQR.html">HouseholderQR</a>&lt;<a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a>&gt; <a class="el" href="classEigen_1_1MatrixBase.html#abafaafa2e7eb9f485b282041833034bf">householderQr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the Householder QR decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>class HouseholderQR </dd></dl>

</div>
</div>
<a class="anchor" id="aa3aafc59ae3a7c8bb42ea3cee116fb59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> <a class="el" href="classEigen_1_1MatrixBase.html#aa3aafc59ae3a7c8bb42ea3cee116fb59">hypotNorm</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the <em>l2</em> norm of <code>*this</code> avoiding undeflow and overflow. This version use a concatenation of hypot() calls, and it is very slow.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>norm(), stableNorm() </dd></dl>

</div>
</div>
<a class="anchor" id="a0650b65c6ae6c3d19a138b72a6d68568"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const IdentityReturnType <a class="el" href="classEigen_1_1MatrixBase.html#a0650b65c6ae6c3d19a138b72a6d68568">Identity</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the identity matrix (not necessarily square).</dd></dl>
<p>This variant is only for fixed-size MatrixBase types. For dynamic-size types, you need to use the variant taking size arguments.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">cout &lt;&lt; Matrix&lt;double, 3, 4&gt;::Identity() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">1 0 0 0
0 1 0 0
0 0 1 0
</pre></div><dl class="section see"><dt>See also:</dt><dd>Identity(Index,Index), setIdentity(), isIdentity() </dd></dl>

</div>
</div>
<a class="anchor" id="ac836fdaa36fbf51080ca710d682ef039"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const IdentityReturnType <a class="el" href="classEigen_1_1MatrixBase.html#a0650b65c6ae6c3d19a138b72a6d68568">Identity</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the identity matrix (not necessarily square).</dd></dl>
<p>The parameters <em>rows</em> and <em>cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this MatrixBase type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>rows</em> and <em>cols</em> as arguments, so Identity() should be used instead.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">cout &lt;&lt; MatrixXd::Identity(4, 3) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">1 0 0
0 1 0
0 0 1
0 0 0
</pre></div><dl class="section see"><dt>See also:</dt><dd>Identity(), setIdentity(), isIdentity() </dd></dl>

</div>
</div>
<a class="anchor" id="a01069a930197aeca3b13b44bdc426c7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ImagReturnType <a class="el" href="classEigen_1_1MatrixBase.html#a01069a930197aeca3b13b44bdc426c7b">imag</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an read-only expression of the imaginary part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/group__AdolcForward__Module.html#ga2be1c373fdf58b02f117b8001d01295d">real()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1032121a2fc5fcc5f006f976413378f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NonConstImagReturnType <a class="el" href="classEigen_1_1MatrixBase.html#a01069a930197aeca3b13b44bdc426c7b">imag</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a non const expression of the imaginary part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/group__AdolcForward__Module.html#ga2be1c373fdf58b02f117b8001d01295d">real()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acd9791e1914ad8761992e16032d49c54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1DenseBase.html#acd9791e1914ad8761992e16032d49c54">innerSize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the inner size.</dd></dl>
<dl class="section note"><dt>Note:</dt><dd>For a vector, this is just the size. For a matrix (non-vector), this is the minor dimension with respect to the <a class="el" href="TopicStorageOrders.html">storage order</a>, i.e., the number of rows for a column-major matrix, and the number of columns for a row-major matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2834da4c855fa35fed8c4030f79f9da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::inverse_impl&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#aa2834da4c855fa35fed8c4030f79f9da">inverse</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is defined in the LU module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="LU.html">Eigen/LU</a>&gt;</span> 
</pre></div><dl class="section return"><dt>Returns:</dt><dd>the matrix inverse of this matrix.</dd></dl>
<p>For small fixed sizes up to 4x4, this method uses cofactors. In the general case, this method uses class PartialPivLU.</p>
<dl class="section note"><dt>Note:</dt><dd>This matrix must be invertible, otherwise the result is undefined. If you need an invertibility check, do the following: <ul>
<li>for fixed sizes up to 4x4, use computeInverseAndDetWithCheck(). </li>
<li>for the general case, use class FullPivLU.</li>
</ul>
Example: <div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = Matrix3d::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Its inverse is:&quot;</span> &lt;&lt; endl &lt;&lt; m.inverse() &lt;&lt; endl;
</pre></div> Output: <div class="fragment"><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Its inverse is:
-0.199   2.23   2.84
  1.01 -0.555  -1.42
 -1.62   3.59   3.29
</pre></div></dd></dl>
<dl class="section see"><dt>See also:</dt><dd>computeInverseAndDetWithCheck() </dd></dl>

</div>
</div>
<a class="anchor" id="a710e3763df8518854578a160c1a8902d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classEigen_1_1DenseBase.html#a710e3763df8518854578a160c1a8902d">isApprox</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd><code>true</code> if <code>*this</code> is approximately equal to <em>other</em>, within the precision determined by <em>prec</em>.</dd></dl>
<dl class="section note"><dt>Note:</dt><dd>The fuzzy compares are done multiplicatively. Two vectors <img class="formulaInl" alt="$ v $" src="form_12.png"/> and <img class="formulaInl" alt="$ w $" src="form_13.png"/> are considered to be approximately equal within precision <img class="formulaInl" alt="$ p $" src="form_14.png"/> if <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Vert v - w \Vert \leqslant p\,\min(\Vert v\Vert, \Vert w\Vert). \]" src="form_15.png"/>
</p>
 For matrices, the comparison is done using the Hilbert-Schmidt norm (aka Frobenius norm L2 norm).</dd>
<dd>
Because of the multiplicativeness of this comparison, one can't use this function to check whether <code>*this</code> is approximately equal to the zero matrix or vector. Indeed, <code>isApprox(zero)</code> returns false unless <code>*this</code> itself is exactly the zero matrix or vector. If you want to test whether <code>*this</code> is zero, use internal::isMuchSmallerThan(const RealScalar&amp;, RealScalar) instead.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>internal::isMuchSmallerThan(const RealScalar&amp;, RealScalar) const </dd></dl>

</div>
</div>
<a class="anchor" id="a8340216d15cfd44fffe6c593d1ec65fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classEigen_1_1DenseBase.html#a8340216d15cfd44fffe6c593d1ec65fb">isApproxToConstant</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>true if all coefficients in this matrix are approximately equal to <em>value</em>, to within precision <em>prec</em> </dd></dl>

</div>
</div>
<a class="anchor" id="abf87bca134f09f39c96bb205a3bbc6ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classEigen_1_1DenseBase.html#abf87bca134f09f39c96bb205a3bbc6ec">isConstant</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is just an alias for isApproxToConstant().</p>
<dl class="section return"><dt>Returns:</dt><dd>true if all coefficients in this matrix are approximately equal to <em>value</em>, to within precision <em>prec</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a57bee98bc48b0c01933b811972bf426f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classEigen_1_1MatrixBase.html#a57bee98bc48b0c01933b811972bf426f">isDiagonal</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::dummy_precision()</code></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>true if *this is approximately equal to a diagonal matrix, within the precision given by <em>prec</em>.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = 10000 * Matrix3d::Identity();
m(0,2) = 1;
cout &lt;&lt; <span class="stringliteral">&quot;Here&#39;s the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;m.isDiagonal() returns: &quot;</span> &lt;&lt; m.isDiagonal() &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;m.isDiagonal(1e-3) returns: &quot;</span> &lt;&lt; m.isDiagonal(1e-3) &lt;&lt; endl;

</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here's the matrix m:
1e+04     0     1
    0 1e+04     0
    0     0 1e+04
m.isDiagonal() returns: 0
m.isDiagonal(1e-3) returns: 1
</pre></div><dl class="section see"><dt>See also:</dt><dd>asDiagonal() </dd></dl>

</div>
</div>
<a class="anchor" id="ae193aecdf8aaa0100d1768d1f52f7ab1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classEigen_1_1MatrixBase.html#ae193aecdf8aaa0100d1768d1f52f7ab1">isIdentity</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::dummy_precision()</code></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>true if *this is approximately equal to the identity matrix (not necessarily square), within the precision given by <em>prec</em>.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = Matrix3d::Identity();
m(0,2) = 1e-4;
cout &lt;&lt; <span class="stringliteral">&quot;Here&#39;s the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;m.isIdentity() returns: &quot;</span> &lt;&lt; m.isIdentity() &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;m.isIdentity(1e-3) returns: &quot;</span> &lt;&lt; m.isIdentity(1e-3) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here's the matrix m:
     1      0 0.0001
     0      1      0
     0      0      1
m.isIdentity() returns: 0
m.isIdentity(1e-3) returns: 1
</pre></div><dl class="section see"><dt>See also:</dt><dd>class CwiseNullaryOp, Identity(), Identity(Index,Index), setIdentity() </dd></dl>

</div>
</div>
<a class="anchor" id="afe8985962ddd0dd6eb8274038bf47a58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classEigen_1_1MatrixBase.html#afe8985962ddd0dd6eb8274038bf47a58">isLowerTriangular</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::dummy_precision()</code></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>true if *this is approximately equal to a lower triangular matrix, within the precision given by <em>prec</em>.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>isUpperTriangular() </dd></dl>

</div>
</div>
<a class="anchor" id="afba6a244696a222955090ef25ddbbf33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classEigen_1_1DenseBase.html#afba6a244696a222955090ef25ddbbf33">isMuchSmallerThan</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1ac5bfdda4730df82128870d3bb7186a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classEigen_1_1DenseBase.html#afba6a244696a222955090ef25ddbbf33">isMuchSmallerThan</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd><code>true</code> if the norm of <code>*this</code> is much smaller than the norm of <em>other</em>, within the precision determined by <em>prec</em>.</dd></dl>
<dl class="section note"><dt>Note:</dt><dd>The fuzzy compares are done multiplicatively. A vector <img class="formulaInl" alt="$ v $" src="form_12.png"/> is considered to be much smaller than a vector <img class="formulaInl" alt="$ w $" src="form_13.png"/> within precision <img class="formulaInl" alt="$ p $" src="form_14.png"/> if <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Vert v \Vert \leqslant p\,\Vert w\Vert. \]" src="form_18.png"/>
</p>
 For matrices, the comparison is done using the Hilbert-Schmidt norm.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="namespaceEigen_1_1internal.html#a5f8973f6b62f10c691ccbadc9263c7fc">isApprox()</a>, isMuchSmallerThan(const RealScalar&amp;, RealScalar) const </dd></dl>

</div>
</div>
<a class="anchor" id="a6eff8d451e78fa219272a17d2a31ccc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classEigen_1_1DenseBase.html#a6eff8d451e78fa219272a17d2a31ccc1">isOnes</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::dummy_precision()</code></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>true if *this is approximately equal to the matrix where all coefficients are equal to 1, within the precision given by <em>prec</em>.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = Matrix3d::Ones();
m(0,2) += 1e-4;
cout &lt;&lt; <span class="stringliteral">&quot;Here&#39;s the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;m.isOnes() returns: &quot;</span> &lt;&lt; m.isOnes() &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;m.isOnes(1e-3) returns: &quot;</span> &lt;&lt; m.isOnes(1e-3) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here's the matrix m:
1 1 1
1 1 1
1 1 1
m.isOnes() returns: 0
m.isOnes(1e-3) returns: 1
</pre></div><dl class="section see"><dt>See also:</dt><dd>class CwiseNullaryOp, Ones() </dd></dl>

</div>
</div>
<a class="anchor" id="a1c735180582f340aa9d678405c911381"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classEigen_1_1MatrixBase.html#a1c735180582f340aa9d678405c911381">isOrthogonal</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>true if *this is approximately orthogonal to <em>other</em>, within the precision given by <em>prec</em>.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga2006332f6989f501762673e21f5128f5">Vector3d</a> v(1,0,0);
<a class="code" href="group__matrixtypedefs.html#ga2006332f6989f501762673e21f5128f5">Vector3d</a> w(1e-4,0,1);
cout &lt;&lt; <span class="stringliteral">&quot;Here&#39;s the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here&#39;s the vector w:&quot;</span> &lt;&lt; endl &lt;&lt; w &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;v.isOrthogonal(w) returns: &quot;</span> &lt;&lt; v.isOrthogonal(w) &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;v.isOrthogonal(w,1e-3) returns: &quot;</span> &lt;&lt; v.isOrthogonal(w,1e-3) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here's the vector v:
1
0
0
Here's the vector w:
0.0001
0
1
v.isOrthogonal(w) returns: 0
v.isOrthogonal(w,1e-3) returns: 1
</pre></div> 
</div>
</div>
<a class="anchor" id="aa13076dcd20cd579534f623ffeb2dbfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classEigen_1_1MatrixBase.html#aa13076dcd20cd579534f623ffeb2dbfa">isUnitary</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::dummy_precision()</code></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>true if *this is approximately an unitary matrix, within the precision given by <em>prec</em>. In the case where the <em>Scalar</em> type is real numbers, a unitary matrix is an orthogonal matrix, whence the name.</dd></dl>
<dl class="section note"><dt>Note:</dt><dd>This can be used to check whether a family of vectors forms an orthonormal basis. Indeed, <code>m.isUnitary()</code> returns true if and only if the columns (equivalently, the rows) of m form an orthonormal basis.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = Matrix3d::Identity();
m(0,2) = 1e-4;
cout &lt;&lt; <span class="stringliteral">&quot;Here&#39;s the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;m.isUnitary() returns: &quot;</span> &lt;&lt; m.isUnitary() &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;m.isUnitary(1e-3) returns: &quot;</span> &lt;&lt; m.isUnitary(1e-3) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here's the matrix m:
     1      0 0.0001
     0      1      0
     0      0      1
m.isUnitary() returns: 0
m.isUnitary(1e-3) returns: 1
</pre></div> 
</div>
</div>
<a class="anchor" id="a53a24a38a7f89486a69d9c3b762909e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classEigen_1_1MatrixBase.html#a53a24a38a7f89486a69d9c3b762909e2">isUpperTriangular</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::dummy_precision()</code></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>true if *this is approximately equal to an upper triangular matrix, within the precision given by <em>prec</em>.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>isLowerTriangular() </dd></dl>

</div>
</div>
<a class="anchor" id="a94a4633a78961a98a87b674337635ff2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classEigen_1_1DenseBase.html#a94a4633a78961a98a87b674337635ff2">isZero</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a>&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::dummy_precision()</code></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>true if *this is approximately equal to the zero matrix, within the precision given by <em>prec</em>.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = Matrix3d::Zero();
m(0,2) = 1e-4;
cout &lt;&lt; <span class="stringliteral">&quot;Here&#39;s the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;m.isZero() returns: &quot;</span> &lt;&lt; m.isZero() &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;m.isZero(1e-3) returns: &quot;</span> &lt;&lt; m.isZero(1e-3) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here's the matrix m:
     0      0 0.0001
     0      0      0
     0      0      0
m.isZero() returns: 0
m.isZero(1e-3) returns: 1
</pre></div><dl class="section see"><dt>See also:</dt><dd>class CwiseNullaryOp, Zero() </dd></dl>

</div>
</div>
<a class="anchor" id="a27a6a2e9d8839662a29cc8294398ff97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1JacobiSVD.html">JacobiSVD</a>&lt;<a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a>&gt; <a class="el" href="classEigen_1_1MatrixBase.html#a27a6a2e9d8839662a29cc8294398ff97">jacobiSvd</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>computationOptions</em> = <code>0</code></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is defined in the SVD module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="SVD.html">Eigen/SVD</a>&gt;</span> 
</pre></div><dl class="section return"><dt>Returns:</dt><dd>the singular value decomposition of <code>*this</code> computed by two-sided Jacobi transformations.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>class JacobiSVD </dd></dl>

</div>
</div>
<a class="anchor" id="a605309e450951e44eaf5167c59bc3c97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structEigen_1_1LazyProductReturnType.html">LazyProductReturnType</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; ,OtherDerived&gt;::Type <a class="el" href="classEigen_1_1MatrixBase.html#a605309e450951e44eaf5167c59bc3c97">lazyProduct</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the matrix product of <code>*this</code> and <em>other</em> without implicit evaluation.</dd></dl>
<p>The returned product will behave like any other expressions: the coefficients of the product will be computed once at a time as requested. This might be useful in some extremely rare cases when only a small and no coherent fraction of the result's coefficients have to be computed.</p>
<dl class="section warning"><dt>Warning:</dt><dd>This version of the matrix product can be much much slower. So use it only if you know what you are doing and that you measured a true speed improvement.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>operator*(const MatrixBase&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a197a04cda6b4606ec2416fd3f950371f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1LDLT.html">LDLT</a>&lt;<a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a>&gt; <a class="el" href="classEigen_1_1MatrixBase.html#a197a04cda6b4606ec2416fd3f950371f">ldlt</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is defined in the Cholesky module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="Cholesky.html">Eigen/Cholesky</a>&gt;</span> 
</pre></div> <dl class="section return"><dt>Returns:</dt><dd>the Cholesky decomposition with full pivoting without square root of <code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ace4288d22b0312944ec93c8c46474ef6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ColsBlockXpr <a class="el" href="classEigen_1_1DenseBase.html#ace4288d22b0312944ec93c8c46474ef6">leftCols</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a block consisting of the left columns of *this.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of columns in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">Array44i a = Array44i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is a.leftCols(2):&quot;</span> &lt;&lt; endl;
cout &lt;&lt; a.leftCols(2) &lt;&lt; endl;
a.leftCols(2).setZero();
cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.leftCols(2):
 7  9
-2 -6
 6 -3
 6  6
Now the array a is:
 0  0 -5 -3
 0  0  1  0
 0  0  0  9
 0  0  3  9
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa43a2f7ef9b8029727a3e0424fd4e57d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstColsBlockXpr <a class="el" href="classEigen_1_1DenseBase.html#ace4288d22b0312944ec93c8c46474ef6">leftCols</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#af6259781564c3c361af85fefb27c5e30">leftCols(Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a01053284fe198875df0ff63aae33eea8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NColsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#ace4288d22b0312944ec93c8c46474ef6">leftCols</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a block consisting of the left columns of *this.</dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">N</td><td>the number of columns in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">Array44i a = Array44i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is a.leftCols&lt;2&gt;():&quot;</span> &lt;&lt; endl;
cout &lt;&lt; a.leftCols&lt;2&gt;() &lt;&lt; endl;
a.leftCols&lt;2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();
cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.leftCols&lt;2&gt;():
 7  9
-2 -6
 6 -3
 6  6
Now the array a is:
 0  0 -5 -3
 0  0  1  0
 0  0  0  9
 0  0  3  9
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac838d0f0d149ad1e1581fd38a7922b04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstNColsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#ace4288d22b0312944ec93c8c46474ef6">leftCols</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#af6259781564c3c361af85fefb27c5e30">leftCols&lt;int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="a1ab2b47535692481285a998525d0c646"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1ProductBase.html#a45b8b5cbeae8078ecc85e875074d72bd">_LhsNested</a>&amp; <a class="el" href="classEigen_1_1ProductBase.html#a1ab2b47535692481285a998525d0c646">lhs</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a03a4ddf48fc9f3674a783da9c6ae34d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const SequentialLinSpacedReturnType <a class="el" href="classEigen_1_1DenseBase.html#a03a4ddf48fc9f3674a783da9c6ae34d8">LinSpaced</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a2346b8f38ce1366aa961095738a5f545">Sequential_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a linearly space vector. </p>
<p>The function generates 'size' equally spaced values in the closed interval [low,high]. This particular version of LinSpaced() uses sequential access, i.e. vector access is assumed to be a(0), a(1), ..., a(size). This assumption allows for better vectorization and yields faster code than the random access version.</p>
<p>When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">cout &lt;&lt; VectorXi::LinSpaced(<a class="code" href="namespaceEigen.html#a2346b8f38ce1366aa961095738a5f545a3e43c0262698131c52c4f95dbd7f6709">Sequential</a>,4,7,10).transpose() &lt;&lt; endl;
cout &lt;&lt; VectorXd::LinSpaced(<a class="code" href="namespaceEigen.html#a2346b8f38ce1366aa961095738a5f545a3e43c0262698131c52c4f95dbd7f6709">Sequential</a>,5,0.0,1.0).transpose() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment"> 7  8  9 10
   0 0.25  0.5 0.75    1
</pre></div><dl class="section see"><dt>See also:</dt><dd>setLinSpaced(Index,const Scalar&amp;,const Scalar&amp;), LinSpaced(Index,Scalar,Scalar), CwiseNullaryOp </dd></dl>

</div>
</div>
<a class="anchor" id="add3a25508eab3a05851a3b4208b96eb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const RandomAccessLinSpacedReturnType <a class="el" href="classEigen_1_1DenseBase.html#a03a4ddf48fc9f3674a783da9c6ae34d8">LinSpaced</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a linearly space vector. </p>
<p>The function generates 'size' equally spaced values in the closed interval [low,high]. When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">cout &lt;&lt; VectorXi::LinSpaced(4,7,10).transpose() &lt;&lt; endl;
cout &lt;&lt; VectorXd::LinSpaced(5,0.0,1.0).transpose() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment"> 7  8  9 10
   0 0.25  0.5 0.75    1
</pre></div><dl class="section see"><dt>See also:</dt><dd>setLinSpaced(Index,const Scalar&amp;,const Scalar&amp;), LinSpaced(Sequential_t,Index,const Scalar&amp;,const Scalar&amp;,Index), CwiseNullaryOp </dd></dl>

</div>
</div>
<a class="anchor" id="a30ceb9d76f8ca3ff5bc71f7797b9788d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const SequentialLinSpacedReturnType <a class="el" href="classEigen_1_1DenseBase.html#a03a4ddf48fc9f3674a783da9c6ae34d8">LinSpaced</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a2346b8f38ce1366aa961095738a5f545">Sequential_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p></p>
<p>Special version for fixed size types which does not require the size parameter. </p>

</div>
</div>
<a class="anchor" id="ac0e2ccb6cded6a7aa927c3410aee071b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const RandomAccessLinSpacedReturnType <a class="el" href="classEigen_1_1DenseBase.html#a03a4ddf48fc9f3674a783da9c6ae34d8">LinSpaced</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p></p>
<p>Special version for fixed size types which does not require the size parameter. </p>

</div>
</div>
<a class="anchor" id="a72ca76a1df449fd21a21d15ac1d1042a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1LLT.html">LLT</a>&lt;<a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a>&gt; <a class="el" href="classEigen_1_1MatrixBase.html#a72ca76a1df449fd21a21d15ac1d1042a">llt</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is defined in the Cholesky module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="Cholesky.html">Eigen/Cholesky</a>&gt;</span> 
</pre></div> <dl class="section return"><dt>Returns:</dt><dd>the LLT decomposition of <code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="aa3626209eb159a56d0b0ed617af0dc39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/classEigen_1_1MatrixLogarithmReturnValue.html">MatrixLogarithmReturnValue</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#aa3626209eb159a56d0b0ed617af0dc39">log</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1f78d41c2ab7389e3df08384371188bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> <a class="el" href="classEigen_1_1MatrixBase.html#a1f78d41c2ab7389e3df08384371188bf">lpNorm</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the <img class="formulaInl" alt="$ \ell^p $" src="form_10.png"/> norm of *this, that is, returns the p-th root of the sum of the p-th powers of the absolute values of the coefficients of *this. If <em>p</em> is the special value <em><a class="el" href="namespaceEigen.html#a6cff718ef6bce746aa5e100036226625">Eigen::Infinity</a></em>, this function returns the <img class="formulaInl" alt="$ \ell^\infty $" src="form_11.png"/> norm, that is the maximum of the absolute values of the coefficients of *this.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>norm() </dd></dl>

<p>Reimplemented from <a class="el" href="classEigen_1_1DenseBase.html#a33339bc6f7ac197a9f83a834c4f9d4a7">DenseBase&lt; DenseTimeSparseProduct&lt; Lhs, Rhs &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a013595649f973f38b3507d7cffe32ff9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialPivLU.html">PartialPivLU</a>&lt;<a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a>&gt; <a class="el" href="classEigen_1_1MatrixBase.html#a013595649f973f38b3507d7cffe32ff9">lu</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is defined in the LU module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="LU.html">Eigen/LU</a>&gt;</span> 
</pre></div><p>Synonym of partialPivLu().</p>
<dl class="section return"><dt>Returns:</dt><dd>the partial-pivoting LU decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>class PartialPivLU </dd></dl>

</div>
</div>
<a class="anchor" id="a306f9da1f2385c4a6e33e1d0e09173f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html#a306f9da1f2385c4a6e33e1d0e09173f2">makeHouseholder</a> </td>
          <td>(</td>
          <td class="paramtype">EssentialPart &amp;&#160;</td>
          <td class="paramname"><em>essential</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the elementary reflector H such that: <img class="formulaInl" alt="$ H *this = [ beta 0 ... 0]^T $" src="form_116.png"/> where the transformation H is: <img class="formulaInl" alt="$ H = I - tau v v^*$" src="form_117.png"/> and the vector v is: <img class="formulaInl" alt="$ v^T = [1 essential^T] $" src="form_118.png"/></p>
<p>On output: </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">essential</td><td>the essential part of the vector <code>v</code> </td></tr>
    <tr><td class="paramname">tau</td><td>the scaling factor of the Householder transformation </td></tr>
    <tr><td class="paramname">beta</td><td>the result of H * <code>*this</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd>MatrixBase::makeHouseholderInPlace(), MatrixBase::applyHouseholderOnTheLeft(), MatrixBase::applyHouseholderOnTheRight() </dd></dl>

</div>
</div>
<a class="anchor" id="ab04e8cc14dd5445607ab15a0d27745a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html#ab04e8cc14dd5445607ab15a0d27745a5">makeHouseholderInPlace</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the elementary reflector H such that: <img class="formulaInl" alt="$ H *this = [ beta 0 ... 0]^T $" src="form_116.png"/> where the transformation H is: <img class="formulaInl" alt="$ H = I - tau v v^*$" src="form_117.png"/> and the vector v is: <img class="formulaInl" alt="$ v^T = [1 essential^T] $" src="form_118.png"/></p>
<p>The essential part of the vector <code>v</code> is stored in *this.</p>
<p>On output: </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tau</td><td>the scaling factor of the Householder transformation </td></tr>
    <tr><td class="paramname">beta</td><td>the result of H * <code>*this</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd>MatrixBase::makeHouseholder(), MatrixBase::applyHouseholderOnTheLeft(), MatrixBase::applyHouseholderOnTheRight() </dd></dl>

</div>
</div>
<a class="anchor" id="a7b68e468ddb549f7a051ab896a93288f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;&amp; <a class="el" href="classEigen_1_1MatrixBase.html#a7b68e468ddb549f7a051ab896a93288f">matrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1656a1d960cf89ba8c4b298a42e40721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;&amp; <a class="el" href="classEigen_1_1MatrixBase.html#a7b68e468ddb549f7a051ab896a93288f">matrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a19ae20bfd9a9f7e5b315295825e4e9e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/classEigen_1_1MatrixFunctionReturnValue.html">MatrixFunctionReturnValue</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#a19ae20bfd9a9f7e5b315295825e4e9e1">matrixFunction</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html#a3f2f4e0a0daae11c77e2e4a3fdca1ea4">StemFunction</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a878f0dae18b28d8158c5f1c232edced2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html#a878f0dae18b28d8158c5f1c232edced2">maxCoeff</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the maximum of all coefficients of *this </dd></dl>

</div>
</div>
<a class="anchor" id="aad851ef369d212dcea81d9cded12dbdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html#a878f0dae18b28d8158c5f1c232edced2">maxCoeff</a> </td>
          <td>(</td>
          <td class="paramtype">IndexType *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType *&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the maximum of all coefficients of *this and puts in *row and *col its location.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>DenseBase::minCoeff(IndexType*,IndexType*), DenseBase::visitor(), DenseBase::maxCoeff() </dd></dl>

</div>
</div>
<a class="anchor" id="a0b381dbcb0435c3a34a78abad4726cc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html#a878f0dae18b28d8158c5f1c232edced2">maxCoeff</a> </td>
          <td>(</td>
          <td class="paramtype">IndexType *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the maximum of all coefficients of *this and puts in *index its location.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>DenseBase::maxCoeff(IndexType*,IndexType*), DenseBase::minCoeff(IndexType*,IndexType*), DenseBase::visitor(), DenseBase::maxCoeff() </dd></dl>

</div>
</div>
<a class="anchor" id="a0af2b3991862a079e3efaef3e4d17d96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html#a0af2b3991862a079e3efaef3e4d17d96">mean</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the mean of all coefficients of *this</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>trace(), prod(), sum() </dd></dl>

</div>
</div>
<a class="anchor" id="a2d4f5da8e2019251ad3ed876d363d5d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ColsBlockXpr <a class="el" href="classEigen_1_1DenseBase.html#a2d4f5da8e2019251ad3ed876d363d5d1">middleCols</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>numCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a block consisting of a range of columns of *this.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startCol</td><td>the index of the first column in the block </td></tr>
    <tr><td class="paramname">numCols</td><td>the number of columns in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="Core.html">Eigen/Core</a>&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">using namespace </span>Eigen;
<span class="keyword">using namespace </span>std;

<span class="keywordtype">int</span> <a class="code" href="tutorial_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">void</span>)
{
    <span class="keywordtype">int</span> <span class="keyword">const</span> N = 5;
    <a class="code" href="classEigen_1_1Matrix.html" title="The matrix class, also used for vectors and row-vectors.">MatrixXi</a> A(N,N);
    A.setRandom();
    cout &lt;&lt; <span class="stringliteral">&quot;A =\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">&quot;A(1..3,:) =\n&quot;</span> &lt;&lt; A.middleCols(1,3) &lt;&lt; endl;
    <span class="keywordflow">return</span> 0;
}
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">A =
  7  -6   0   9 -10
 -2  -3   3   3  -5
  6   6  -3   5  -8
  6  -5   0  -8   6
  9   1   9   2  -7

A(1..3,:) =
-6  0  9
-3  3  3
 6 -3  5
-5  0 -8
 1  9  2
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a428643f7e51813faa8c8ad89b8282235"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstColsBlockXpr <a class="el" href="classEigen_1_1DenseBase.html#a2d4f5da8e2019251ad3ed876d363d5d1">middleCols</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>numCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#a2c659d868dcf6c57f8c18cda3c71e877">middleCols(Index,Index)</a>. </p>

</div>
</div>
<a class="anchor" id="ab449491fb1077811187a0988a5c83e48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NColsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#a2d4f5da8e2019251ad3ed876d363d5d1">middleCols</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a block consisting of a range of columns of *this.</dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">N</td><td>the number of columns in the block </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startCol</td><td>the index of the first column in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="Core.html">Eigen/Core</a>&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">using namespace </span>Eigen;
<span class="keyword">using namespace </span>std;

<span class="keywordtype">int</span> <a class="code" href="tutorial_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">void</span>)
{
    <span class="keywordtype">int</span> <span class="keyword">const</span> N = 5;
    <a class="code" href="classEigen_1_1Matrix.html" title="The matrix class, also used for vectors and row-vectors.">MatrixXi</a> A(N,N);
    A.setRandom();
    cout &lt;&lt; <span class="stringliteral">&quot;A =\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">&quot;A(:,1..3) =\n&quot;</span> &lt;&lt; A.middleCols&lt;3&gt;(1) &lt;&lt; endl;
    <span class="keywordflow">return</span> 0;
}
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">A =
  7  -6   0   9 -10
 -2  -3   3   3  -5
  6   6  -3   5  -8
  6  -5   0  -8   6
  9   1   9   2  -7

A(:,1..3) =
-6  0  9
-3  3  3
 6 -3  5
-5  0 -8
 1  9  2
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a355072c91943dc9bdc4255a6538a5270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstNColsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#a2d4f5da8e2019251ad3ed876d363d5d1">middleCols</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#a2c659d868dcf6c57f8c18cda3c71e877">middleCols&lt;int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="aa87a7527cd042907d180cf0c36c5f48a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RowsBlockXpr <a class="el" href="classEigen_1_1DenseBase.html#aa87a7527cd042907d180cf0c36c5f48a">middleRows</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>numRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a block consisting of a range of rows of *this.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the index of the first row in the block </td></tr>
    <tr><td class="paramname">numRows</td><td>the number of rows in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="Core.html">Eigen/Core</a>&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">using namespace </span>Eigen;
<span class="keyword">using namespace </span>std;

<span class="keywordtype">int</span> <a class="code" href="tutorial_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">void</span>)
{
    <span class="keywordtype">int</span> <span class="keyword">const</span> N = 5;
    <a class="code" href="classEigen_1_1Matrix.html" title="The matrix class, also used for vectors and row-vectors.">MatrixXi</a> A(N,N);
    A.setRandom();
    cout &lt;&lt; <span class="stringliteral">&quot;A =\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">&quot;A(2..3,:) =\n&quot;</span> &lt;&lt; A.middleRows(2,2) &lt;&lt; endl;
    <span class="keywordflow">return</span> 0;
}
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">A =
  7  -6   0   9 -10
 -2  -3   3   3  -5
  6   6  -3   5  -8
  6  -5   0  -8   6
  9   1   9   2  -7

A(2..3,:) =
 6  6 -3  5 -8
 6 -5  0 -8  6
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5dbf41bffa5d27df9ba17f81cdd64983"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstRowsBlockXpr <a class="el" href="classEigen_1_1DenseBase.html#aa87a7527cd042907d180cf0c36c5f48a">middleRows</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>numRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#aa9abeefe5c0c07fc59ab8a7c05683eb7">middleRows(Index,Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a64475892fb40e70a2b701fd900084cbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRowsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#aa87a7527cd042907d180cf0c36c5f48a">middleRows</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a block consisting of a range of rows of *this.</dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">N</td><td>the number of rows in the block </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the index of the first row in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="Core.html">Eigen/Core</a>&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">using namespace </span>Eigen;
<span class="keyword">using namespace </span>std;

<span class="keywordtype">int</span> <a class="code" href="tutorial_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">void</span>)
{
    <span class="keywordtype">int</span> <span class="keyword">const</span> N = 5;
    <a class="code" href="classEigen_1_1Matrix.html" title="The matrix class, also used for vectors and row-vectors.">MatrixXi</a> A(N,N);
    A.setRandom();
    cout &lt;&lt; <span class="stringliteral">&quot;A =\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">&quot;A(1..3,:) =\n&quot;</span> &lt;&lt; A.middleRows&lt;3&gt;(1) &lt;&lt; endl;
    <span class="keywordflow">return</span> 0;
}
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">A =
  7  -6   0   9 -10
 -2  -3   3   3  -5
  6   6  -3   5  -8
  6  -5   0  -8   6
  9   1   9   2  -7

A(1..3,:) =
-2 -3  3  3 -5
 6  6 -3  5 -8
 6 -5  0 -8  6
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad1750285d85ea6fbe5ee645eebbd749a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstNRowsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#aa87a7527cd042907d180cf0c36c5f48a">middleRows</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#aa9abeefe5c0c07fc59ab8a7c05683eb7">middleRows&lt;int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="add6cb2d85282829eb9adc9565ce784d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html#add6cb2d85282829eb9adc9565ce784d6">minCoeff</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the minimum of all coefficients of *this </dd></dl>

</div>
</div>
<a class="anchor" id="ad927d600371ba16dcb44518530ba906a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html#add6cb2d85282829eb9adc9565ce784d6">minCoeff</a> </td>
          <td>(</td>
          <td class="paramtype">IndexType *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType *&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the minimum of all coefficients of *this and puts in *row and *col its location.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>DenseBase::minCoeff(Index*), DenseBase::maxCoeff(Index*,Index*), DenseBase::visitor(), DenseBase::minCoeff() </dd></dl>

</div>
</div>
<a class="anchor" id="ae959fb7401b9cfdf900ff3b295466526"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html#add6cb2d85282829eb9adc9565ce784d6">minCoeff</a> </td>
          <td>(</td>
          <td class="paramtype">IndexType *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the minimum of all coefficients of *this and puts in *index its location.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>DenseBase::minCoeff(IndexType*,IndexType*), DenseBase::maxCoeff(IndexType*,IndexType*), DenseBase::visitor(), DenseBase::minCoeff() </dd></dl>

</div>
</div>
<a class="anchor" id="a324b9263b40738a260d46ff011b8d31b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1NestByValue.html">NestByValue</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a324b9263b40738a260d46ff011b8d31b">nestByValue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the temporary version of *this. </dd></dl>

</div>
</div>
<a class="anchor" id="ae77f3c3ccfb21694555dafc92c2da340"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1NoAlias.html">NoAlias</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; ,<a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a> &gt; <a class="el" href="classEigen_1_1MatrixBase.html#ae77f3c3ccfb21694555dafc92c2da340">noalias</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a pseudo expression of <code>*this</code> with an operator= assuming no aliasing between <code>*this</code> and the source expression.</dd></dl>
<p>More precisely, noalias() allows to bypass the EvalBeforeAssignBit flag. Currently, even though several expressions may alias, only product expressions have this flag. Therefore, noalias() is only usefull when the source expression contains a matrix product.</p>
<p>Here are some examples where noalias is usefull: </p>
<div class="fragment"><pre class="fragment"> D.noalias()  = A * B;
 D.noalias() += A.transpose() * B;
 D.noalias() -= 2 * A * B.adjoint();
</pre></div><p>On the other hand the following example will lead to a <b>wrong</b> result: </p>
<div class="fragment"><pre class="fragment"> A.noalias() = A * B;
</pre></div><p> because the result matrix A is also an operand of the matrix product. Therefore, there is no alternative than evaluating A * B in a temporary, that is the default behavior when you write: </p>
<div class="fragment"><pre class="fragment"> A = A * B;
</pre></div><dl class="section see"><dt>See also:</dt><dd>class NoAlias </dd></dl>

</div>
</div>
<a class="anchor" id="abe29bfb5f2d88cf2a50ffb577ec6f0a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1DenseBase.html#abe29bfb5f2d88cf2a50ffb577ec6f0a4">nonZeros</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the number of nonzero coefficients which is in practice the number of stored coefficients. </dd></dl>

</div>
</div>
<a class="anchor" id="a0be1b433c65ce9d92c81a4718daf54e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> <a class="el" href="classEigen_1_1MatrixBase.html#a0be1b433c65ce9d92c81a4718daf54e5">norm</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>, for vectors, the <em>l2</em> norm of <code>*this</code>, and for matrices the Frobenius norm. In both cases, it consists in the square root of the sum of the square of all the matrix entries. For vectors, this is also equals to the square root of the dot product of <code>*this</code> with itself.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>dot(), squaredNorm() </dd></dl>

</div>
</div>
<a class="anchor" id="acd0de676568888d848beb97dcc53ae47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html#acd0de676568888d848beb97dcc53ae47">normalize</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Normalizes the vector, i.e. divides it by its own norm.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section see"><dt>See also:</dt><dd>norm(), normalized() </dd></dl>

</div>
</div>
<a class="anchor" id="a8ed1fb2e792b1079639a74e3581fbc74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a> <a class="el" href="classEigen_1_1MatrixBase.html#a8ed1fb2e792b1079639a74e3581fbc74">normalized</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the quotient of *this by its own norm.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section see"><dt>See also:</dt><dd>norm(), normalize() </dd></dl>

</div>
</div>
<a class="anchor" id="a138e37f3c338a544afb347aaf80d32da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt;CustomNullaryOp, <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a138e37f3c338a544afb347aaf80d32da">NullaryExpr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CustomNullaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a matrix defined by a custom functor <em>func</em> </dd></dl>
<p>The parameters <em>rows</em> and <em>cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this MatrixBase type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>rows</em> and <em>cols</em> as arguments, so Zero() should be used instead.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See also:</dt><dd>class CwiseNullaryOp </dd></dl>

</div>
</div>
<a class="anchor" id="ae50fd894930b4f917cf5c40f23965f67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt;CustomNullaryOp, <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a138e37f3c338a544afb347aaf80d32da">NullaryExpr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CustomNullaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a matrix defined by a custom functor <em>func</em> </dd></dl>
<p>The parameter <em>size</em> is the size of the returned vector. Must be compatible with this MatrixBase type.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em>size</em> as argument, so Zero() should be used instead.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See also:</dt><dd>class CwiseNullaryOp </dd></dl>

</div>
</div>
<a class="anchor" id="a24025debf13d8352eb963b814e08b5e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt;CustomNullaryOp, <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a138e37f3c338a544afb347aaf80d32da">NullaryExpr</a> </td>
          <td>(</td>
          <td class="paramtype">const CustomNullaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a matrix defined by a custom functor <em>func</em> </dd></dl>
<p>This variant is only for fixed-size DenseBase types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See also:</dt><dd>class CwiseNullaryOp </dd></dl>

</div>
</div>
<a class="anchor" id="ad148f93a6a00e32ef00903c5393337ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html#ad148f93a6a00e32ef00903c5393337ef">Ones</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a matrix where all coefficients equal one.</dd></dl>
<p>The parameters <em>rows</em> and <em>cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this MatrixBase type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>rows</em> and <em>cols</em> as arguments, so Ones() should be used instead.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">cout &lt;&lt; MatrixXi::Ones(2,3) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">1 1 1
1 1 1
</pre></div><dl class="section see"><dt>See also:</dt><dd>Ones(), Ones(Index), isOnes(), class Ones </dd></dl>

</div>
</div>
<a class="anchor" id="adec530c086d6b585ebb009fe4fbb77e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html#ad148f93a6a00e32ef00903c5393337ef">Ones</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a vector where all coefficients equal one.</dd></dl>
<p>The parameter <em>size</em> is the size of the returned vector. Must be compatible with this MatrixBase type.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em>size</em> as argument, so Ones() should be used instead.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">cout &lt;&lt; 6 * RowVectorXi::Ones(4) &lt;&lt; endl;
cout &lt;&lt; VectorXf::Ones(2) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">6 6 6 6
1
1
</pre></div><dl class="section see"><dt>See also:</dt><dd>Ones(), Ones(Index,Index), isOnes(), class Ones </dd></dl>

</div>
</div>
<a class="anchor" id="a2278addf9a3c977d40322571a0df8ac9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html#ad148f93a6a00e32ef00903c5393337ef">Ones</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a fixed-size matrix or vector where all coefficients equal one.</dd></dl>
<p>This variant is only for fixed-size MatrixBase types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">cout &lt;&lt; Matrix2d::Ones() &lt;&lt; endl;
cout &lt;&lt; 6 * RowVector4i::Ones() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">1 1
1 1
6 6 6 6
</pre></div><dl class="section see"><dt>See also:</dt><dd>Ones(Index), Ones(Index,Index), isOnes(), class Ones </dd></dl>

</div>
</div>
<a class="anchor" id="a18a4fad97bfaa6ca788ea3b8464615ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator const <a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a> &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5648a35b9610ad47cb01912752db1dae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>true if at least one pair of coefficients of <code>*this</code> and <em>other</em> are not exactly equal to each other. </dd></dl>
<dl class="section warning"><dt>Warning:</dt><dd>When using floating point scalar values you probably should rather use a fuzzy comparison such as <a class="el" href="namespaceEigen_1_1internal.html#a5f8973f6b62f10c691ccbadc9263c7fc">isApprox()</a> </dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="namespaceEigen_1_1internal.html#a5f8973f6b62f10c691ccbadc9263c7fc">isApprox()</a>, operator== </dd></dl>

</div>
</div>
<a class="anchor" id="ae8ab11fb1ef0822aa61527f7ecd77b9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ScalarMultipleReturnType operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of <code>*this</code> scaled by the scalar factor <em>scalar</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a40526ebb0e39712dcdd51ba545cae440"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ScalarMultipleReturnType operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a01a3dfc024abbb42150002facf498357"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_multiple2_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>,std::complex&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt; &gt;, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloaded for efficient real matrix times complex scalar value </p>

</div>
</div>
<a class="anchor" id="adf2ccabec2f82b36f445e9c7f58c9080"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structEigen_1_1ProductReturnType.html">ProductReturnType</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; ,OtherDerived&gt;::Type operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the matrix product of <code>*this</code> and <em>other</em>.</dd></dl>
<dl class="section note"><dt>Note:</dt><dd>If instead of the matrix product you want the coefficient-wise product, see <a class="el" href="namespaceEigen.html#a81fb70d0dc1c6deb42e9816647607247">Cwise::operator*()</a>.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>lazyProduct(), operator*=(const MatrixBase&amp;), <a class="el" href="namespaceEigen.html#a81fb70d0dc1c6deb42e9816647607247">Cwise::operator*()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1f423e078af275d2f90a59af85a43f8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DiagonalProduct.html">DiagonalProduct</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , DiagonalDerived, <a class="el" href="group__enums.html#gga07422cff4c3dd5075f91f87bd0e57ee7aeda0d7b1859ec757de18ee3b7c6c541c">OnTheRight</a>&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDiagonalBase.html">DiagonalBase</a>&lt; DiagonalDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>diagonal</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the diagonal matrix product of <code>*this</code> by the diagonal matrix <em>diagonal</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab413f2bd3b22564ab55633f7bca0155f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarMultipleReturnType operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1UniformScaling.html">UniformScaling</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Concatenates a linear transformation matrix and a uniform scaling </p>

</div>
</div>
<a class="anchor" id="ac9beaa3954c989bbbc59b361d9423e78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>replaces <code>*this</code> by <code>*this</code> * <em>other</em>.</p>
<dl class="section return"><dt>Returns:</dt><dd>a reference to <code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ae339381c643e4ed8eaac81755c35532b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7aaf408b3bfbdd38749b01979393e814"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>replaces <code>*this</code> by <code>*this</code> + <em>other</em>.</p>
<dl class="section return"><dt>Returns:</dt><dd>a reference to <code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ad5a2176a93acda3adb5faf883818cbaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5a5015ed430477ad1cf3c1ddc76652c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1ArrayBase.html">ArrayBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f53ae2f5586a75f1747d84822ae9581"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_opposite_op&lt;typename internal::traits&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the opposite of <code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a2da6ae5caa522c1efec3a75428b22143"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>replaces <code>*this</code> by <code>*this</code> - <em>other</em>.</p>
<dl class="section return"><dt>Returns:</dt><dd>a reference to <code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a34eedf9b323532a37f44e7d5c736c6c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abd22c4c1df0b17aae5dd7ac21dea4bda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1ArrayBase.html">ArrayBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae78e46db7ee3ba78d3cf59968d261f90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_quotient1_op&lt;typename internal::traits&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of <code>*this</code> divided by the scalar value <em>scalar</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a18e0c799d4dbc351465fb2d8964a6913"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ade5d2e09de50c2ca145037f295542b16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="anchor" id="MatrixBaseCommaInitRef"></a> Convenient operator to set the coefficients of a matrix.</p>
<p>The coefficients must be provided in a row major order and exactly match the size of the matrix. Otherwise an assertion is raised.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga4b6688615f30a9959be0285115080c3d">Matrix3i</a> m1;
m1 &lt;&lt; 1, 2, 3,
      4, 5, 6,
      7, 8, 9;
cout &lt;&lt; m1 &lt;&lt; endl &lt;&lt; endl;
<a class="code" href="group__matrixtypedefs.html#ga4b6688615f30a9959be0285115080c3d">Matrix3i</a> m2 = Matrix3i::Identity();
m2.block(0,0, 2,2) &lt;&lt; 10, 11, 12, 13;
cout &lt;&lt; m2 &lt;&lt; endl &lt;&lt; endl;
<a class="code" href="group__matrixtypedefs.html#gae4b211eebc55d300139b0e6e34a06cba">Vector2i</a> v1;
v1 &lt;&lt; 14, 15;
m2 &lt;&lt; v1.transpose(), 16,
      v1, m1.block(1,1,2,2);
cout &lt;&lt; m2 &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">1 2 3
4 5 6
7 8 9

10 11  0
12 13  0
 0  0  1

14 15 16
14  5  6
15  8  9
</pre></div><dl class="section see"><dt>See also:</dt><dd>CommaInitializer::finished(), class CommaInitializer </dd></dl>

</div>
</div>
<a class="anchor" id="a3dacded5374fe30f8d4eb4ae18bc87c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section see"><dt>See also:</dt><dd>operator&lt;&lt;(const Scalar&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a78f22189db1a4cc4634bb8427ae64f06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>true if each coefficients of <code>*this</code> and <em>other</em> are all exactly equal. </dd></dl>
<dl class="section warning"><dt>Warning:</dt><dd>When using floating point scalar values you probably should rather use a fuzzy comparison such as <a class="el" href="namespaceEigen_1_1internal.html#a5f8973f6b62f10c691ccbadc9263c7fc">isApprox()</a> </dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="namespaceEigen_1_1internal.html#a5f8973f6b62f10c691ccbadc9263c7fc">isApprox()</a>, operator!= </dd></dl>

</div>
</div>
<a class="anchor" id="a0650a523c77a498a88b4998809d0bd14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> <a class="el" href="classEigen_1_1MatrixBase.html#a0650a523c77a498a88b4998809d0bd14">operatorNorm</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the L2 operator norm. </p>
<dl class="section return"><dt>Returns:</dt><dd>Operator norm of the matrix.</dd></dl>
<p>This is defined in the Eigenvalues module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="Eigenvalues.html">Eigen/Eigenvalues</a>&gt;</span> 
</pre></div><p> This function computes the L2 operator norm of a matrix, which is also known as the spectral norm. The norm of a matrix <img class="formulaInl" alt="$ A $" src="form_0.png"/> is defined to be </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \|A\|_2 = \max_x \frac{\|Ax\|_2}{\|x\|_2} \]" src="form_76.png"/>
</p>
<p> where the maximum is over all vectors and the norm on the right is the Euclidean vector norm. The norm equals the largest singular value, which is the square root of the largest eigenvalue of the positive semi-definite matrix <img class="formulaInl" alt="$ A^*A $" src="form_77.png"/>.</p>
<p>The current implementation uses the eigenvalues of <img class="formulaInl" alt="$ A^*A $" src="form_77.png"/>, as computed by SelfAdjointView::eigenvalues(), to compute the operator norm of a matrix. The SelfAdjointView class provides a better algorithm for selfadjoint matrices.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">MatrixXd ones = MatrixXd::Ones(3,3);
cout &lt;&lt; <span class="stringliteral">&quot;The operator norm of the 3x3 matrix of ones is &quot;</span>
     &lt;&lt; ones.operatorNorm() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">The operator norm of the 3x3 matrix of ones is 3
</pre></div><dl class="section see"><dt>See also:</dt><dd>SelfAdjointView::eigenvalues(), SelfAdjointView::operatorNorm() </dd></dl>

</div>
</div>
<a class="anchor" id="af080d3d3f82e0d4391f19af22a5eedb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1DenseBase.html#af080d3d3f82e0d4391f19af22a5eedb8">outerSize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>true if either the number of rows or the number of columns is equal to 1. In other words, this function returns <div class="fragment"><pre class="fragment"> rows()==1 || cols()==1 
</pre></div> </dd></dl>
<dl class="section see"><dt>See also:</dt><dd>rows(), cols(), IsVectorAtCompileTime. </dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>the outer size.</dd></dl>
<dl class="section note"><dt>Note:</dt><dd>For a vector, this returns just 1. For a matrix (non-vector), this is the major dimension with respect to the <a class="el" href="TopicStorageOrders.html">storage order</a>, i.e., the number of columns for a column-major matrix, and the number of rows for a row-major matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a734707779b0449ea429d4ae42c3350f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialPivLU.html">PartialPivLU</a>&lt;<a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a>&gt; <a class="el" href="classEigen_1_1MatrixBase.html#a734707779b0449ea429d4ae42c3350f6">partialPivLu</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is defined in the LU module. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="LU.html">Eigen/LU</a>&gt;</span> 
</pre></div><dl class="section return"><dt>Returns:</dt><dd>the partial-pivoting LU decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>class PartialPivLU </dd></dl>

</div>
</div>
<a class="anchor" id="a6bdcbfa7e3b07d3246ad80de7170b0f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html#a6bdcbfa7e3b07d3246ad80de7170b0f5">prod</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the product of all coefficients of *this</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = Matrix3d::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is the product of all the coefficients:&quot;</span> &lt;&lt; endl &lt;&lt; m.prod() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the product of all the coefficients:
0.0019
</pre></div><dl class="section see"><dt>See also:</dt><dd>sum(), mean(), trace() </dd></dl>

</div>
</div>
<a class="anchor" id="a78061942c4ccb57f5b1dde173fdd8bd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt;internal::scalar_random_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;,<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a78061942c4ccb57f5b1dde173fdd8bd0">Random</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a random matrix expression</dd></dl>
<p>The parameters <em>rows</em> and <em>cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this MatrixBase type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>rows</em> and <em>cols</em> as arguments, so Random() should be used instead.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">cout &lt;&lt; MatrixXi::Random(2,3) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment"> 7  6  9
-2  6 -6
</pre></div><p>This expression has the "evaluate before nesting" flag so that it will be evaluated into a temporary matrix whenever it is nested in a larger expression. This prevents unexpected behavior with expressions involving random matrices.</p>
<dl class="section see"><dt>See also:</dt><dd>MatrixBase::setRandom(), MatrixBase::Random(Index), MatrixBase::Random() </dd></dl>

</div>
</div>
<a class="anchor" id="a6f42aba8fbe2618deb0e80e4af876e04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt;internal::scalar_random_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;,<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a78061942c4ccb57f5b1dde173fdd8bd0">Random</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a random vector expression</dd></dl>
<p>The parameter <em>size</em> is the size of the returned vector. Must be compatible with this MatrixBase type.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em>size</em> as argument, so Random() should be used instead.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">cout &lt;&lt; VectorXi::Random(2) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">7
-2
</pre></div><p>This expression has the "evaluate before nesting" flag so that it will be evaluated into a temporary vector whenever it is nested in a larger expression. This prevents unexpected behavior with expressions involving random matrices.</p>
<dl class="section see"><dt>See also:</dt><dd>MatrixBase::setRandom(), MatrixBase::Random(Index,Index), MatrixBase::Random() </dd></dl>

</div>
</div>
<a class="anchor" id="a8e759dafdd9ecc446d397b7f5435f60a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt;internal::scalar_random_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;,<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a78061942c4ccb57f5b1dde173fdd8bd0">Random</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a fixed-size random matrix or vector expression</dd></dl>
<p>This variant is only for fixed-size MatrixBase types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">cout &lt;&lt; 100 * Matrix2i::Random() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">700 600
-200 600
</pre></div><p>This expression has the "evaluate before nesting" flag so that it will be evaluated into a temporary matrix whenever it is nested in a larger expression. This prevents unexpected behavior with expressions involving random matrices.</p>
<dl class="section see"><dt>See also:</dt><dd>MatrixBase::setRandom(), MatrixBase::Random(Index,Index), MatrixBase::Random(Index) </dd></dl>

</div>
</div>
<a class="anchor" id="a4a1c87f8e48a66edc05859421048f8b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RealReturnType <a class="el" href="classEigen_1_1MatrixBase.html#a4a1c87f8e48a66edc05859421048f8b0">real</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a read-only expression of the real part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/group__AdolcForward__Module.html#gab65c6acd55b5fd93803cec6091bb665b">imag()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="accfa15407b80807dab914b1844c725e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NonConstRealReturnType <a class="el" href="classEigen_1_1MatrixBase.html#a4a1c87f8e48a66edc05859421048f8b0">real</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a non const expression of the real part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/group__AdolcForward__Module.html#gab65c6acd55b5fd93803cec6091bb665b">imag()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afca0e8ff7921ee0e3ab4422818ecb214"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; ,RowFactor,ColFactor&gt; <a class="el" href="classEigen_1_1DenseBase.html#afca0e8ff7921ee0e3ab4422818ecb214">replicate</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the replication of <code>*this</code> </dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga5b9d0d11e78fd355d23221154b7620e4">MatrixXi</a> m = MatrixXi::Random(2,3);
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;m.replicate&lt;3,2&gt;() = ...&quot;</span> &lt;&lt; endl;
cout &lt;&lt; m.replicate&lt;3,2&gt;() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
 7  6  9
-2  6 -6
m.replicate&lt;3,2&gt;() = ...
 7  6  9  7  6  9
-2  6 -6 -2  6 -6
 7  6  9  7  6  9
-2  6 -6 -2  6 -6
 7  6  9  7  6  9
-2  6 -6 -2  6 -6
</pre></div><dl class="section see"><dt>See also:</dt><dd>VectorwiseOp::replicate(), DenseBase::replicate(Index,Index), class Replicate </dd></dl>

</div>
</div>
<a class="anchor" id="a594bdd8d2d9dd3249d563a33b9ac73bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; ,<a class="el" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a>,<a class="el" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a>&gt; <a class="el" href="classEigen_1_1DenseBase.html#afca0e8ff7921ee0e3ab4422818ecb214">replicate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>rowFacor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>colFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the replication of <code>*this</code> </dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#gaa4931fe5bb599038466be823fdfadd04">Vector3i</a> v = Vector3i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;v.replicate(2,5) = ...&quot;</span> &lt;&lt; endl;
cout &lt;&lt; v.replicate(2,5) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the vector v:
7
-2
6
v.replicate(2,5) = ...
 7  7  7  7  7
-2 -2 -2 -2 -2
 6  6  6  6  6
 7  7  7  7  7
-2 -2 -2 -2 -2
 6  6  6  6  6
</pre></div><dl class="section see"><dt>See also:</dt><dd>VectorwiseOp::replicate(), DenseBase::replicate&lt;int,int&gt;(), class Replicate </dd></dl>

</div>
</div>
<a class="anchor" id="a0b8db206b78137e95dc0833952ed1ed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseBase.html#a0b8db206b78137e95dc0833952ed1ed0">resize</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Only plain matrices/arrays, not expressions, may be resized; therefore the only useful resize methods are Matrix::resize() and Array::resize(). The present method only asserts that the new size equals the old size, and does nothing else. </p>

</div>
</div>
<a class="anchor" id="ac20f895ce9b73fa7447196855c0d0758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseBase.html#a0b8db206b78137e95dc0833952ed1ed0">resize</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Only plain matrices/arrays, not expressions, may be resized; therefore the only useful resize methods are Matrix::resize() and Array::resize(). The present method only asserts that the new size equals the old size, and does nothing else. </p>

</div>
</div>
<a class="anchor" id="a6e354bb81f0c7b6888c6a0ce4b4649e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a8f39c2cb70afabf9d0283c44b8e7bf35">ReverseReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html#a6e354bb81f0c7b6888c6a0ce4b4649e2">reverse</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the reverse of *this.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga5b9d0d11e78fd355d23221154b7620e4">MatrixXi</a> m = MatrixXi::Random(3,4);
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is the reverse of m:&quot;</span> &lt;&lt; endl &lt;&lt; m.reverse() &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is the coefficient (1,0) in the reverse of m:&quot;</span> &lt;&lt; endl
     &lt;&lt; m.reverse()(1,0) &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Let us overwrite this coefficient with the value 4.&quot;</span> &lt;&lt; endl;
m.reverse()(1,0) = 4;
cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
 7  6 -3  1
-2  9  6  0
 6 -6 -5  3
Here is the reverse of m:
 3 -5 -6  6
 0  6  9 -2
 1 -3  6  7
Here is the coefficient (1,0) in the reverse of m:
0
Let us overwrite this coefficient with the value 4.
Now the matrix m is:
 7  6 -3  1
-2  9  6  4
 6 -6 -5  3
</pre></div> 
</div>
</div>
<a class="anchor" id="ae3a4b984747fa12de0f521b3bff907b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#ae98cbeddf3a9f43697733e6f53ff9f81">ConstReverseReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html#a6e354bb81f0c7b6888c6a0ce4b4649e2">reverse</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of reverse(). </p>

</div>
</div>
<a class="anchor" id="af148c4e77e657d04573c4fda43740ed5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseBase.html#af148c4e77e657d04573c4fda43740ed5">reverseInPlace</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the "in place" version of reverse: it reverses <code>*this</code>.</p>
<p>In most cases it is probably better to simply use the reversed expression of a matrix. However, when reversing the matrix data itself is really needed, then this "in-place" version is probably the right choice because it provides the following additional features:</p>
<ul>
<li>less error prone: doing the same operation with .reverse() requires special care: <div class="fragment"><pre class="fragment"> m = m.reverse().eval(); 
</pre></div></li>
<li>this API allows to avoid creating a temporary (the current implementation creates a temporary, but that could be avoided using swap)</li>
<li>it allows future optimizations (cache friendliness, etc.)</li>
</ul>
<dl class="section see"><dt>See also:</dt><dd>reverse() </dd></dl>

</div>
</div>
<a class="anchor" id="a3483b038d185d8b507d26104094c5996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1ProductBase.html#a870a8f6be0f8fca7ca4ff85dcd85b04f">_RhsNested</a>&amp; <a class="el" href="classEigen_1_1ProductBase.html#a3483b038d185d8b507d26104094c5996">rhs</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af80f9e4e3708d7e3b0e1487ca90cf339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ColsBlockXpr <a class="el" href="classEigen_1_1DenseBase.html#af80f9e4e3708d7e3b0e1487ca90cf339">rightCols</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a block consisting of the right columns of *this.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of columns in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">Array44i a = Array44i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is a.rightCols(2):&quot;</span> &lt;&lt; endl;
cout &lt;&lt; a.rightCols(2) &lt;&lt; endl;
a.rightCols(2).setZero();
cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.rightCols(2):
-5 -3
 1  0
 0  9
 3  9
Now the array a is:
 7  9  0  0
-2 -6  0  0
 6 -3  0  0
 6  6  0  0
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad16081d19c5482a30aa6be15769e8056"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstColsBlockXpr <a class="el" href="classEigen_1_1DenseBase.html#af80f9e4e3708d7e3b0e1487ca90cf339">rightCols</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#aa878619b8257408236559431bd2ab5ab">rightCols(Index)</a>. </p>

</div>
</div>
<a class="anchor" id="af9afaaa2c2c27716dccdc58c50449103"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NColsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#af80f9e4e3708d7e3b0e1487ca90cf339">rightCols</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a block consisting of the right columns of *this.</dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">N</td><td>the number of columns in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">Array44i a = Array44i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is a.rightCols&lt;2&gt;():&quot;</span> &lt;&lt; endl;
cout &lt;&lt; a.rightCols&lt;2&gt;() &lt;&lt; endl;
a.rightCols&lt;2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();
cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.rightCols&lt;2&gt;():
-5 -3
 1  0
 0  9
 3  9
Now the array a is:
 7  9  0  0
-2 -6  0  0
 6 -3  0  0
 6  6  0  0
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab4707ce78c96ddd7ca15c4e6f0a2a207"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstNColsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#af80f9e4e3708d7e3b0e1487ca90cf339">rightCols</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#aa878619b8257408236559431bd2ab5ab">rightCols&lt;int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="aa8716d44f51321072ee5c88665c28813"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RowXpr <a class="el" href="classEigen_1_1DenseBase.html#aa8716d44f51321072ee5c88665c28813">row</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the <em>i-th</em> row of *this. Note that the numbering starts at 0.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = Matrix3d::Identity();
m.row(1) = <a class="code" href="group__matrixtypedefs.html#ga2006332f6989f501762673e21f5128f5">Vector3d</a>(4,5,6);
cout &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">1 0 0
4 5 6
0 0 1
</pre></div><dl class="section see"><dt>See also:</dt><dd><a class="el" href="BlockMethods_8h.html#a67a3f626cce3b0ed807f76bff7c98cb7">col()</a>, class Block </dd></dl>

</div>
</div>
<a class="anchor" id="ad62dcaf648cca25e9318da34c9840799"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstRowXpr <a class="el" href="classEigen_1_1DenseBase.html#aa8716d44f51321072ee5c88665c28813">row</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#a5890de7c28f383d6a1627f6e40c25399">row()</a>. </p>

</div>
</div>
<a class="anchor" id="a5552abd83dbd03c85cea6d61fd8875a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> <a class="el" href="classEigen_1_1ProductBase.html#a5552abd83dbd03c85cea6d61fd8875a5">rows</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3af2f03b1d2affcec24e0748edf892cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a7b6f43bb643c4b843ee03b1250c4a82b">ConstRowwiseReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html#a3af2f03b1d2affcec24e0748edf892cd">rowwise</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a VectorwiseOp wrapper of *this providing additional partial reduction operations</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = Matrix3d::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is the sum of each row:&quot;</span> &lt;&lt; endl &lt;&lt; m.rowwise().sum() &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is the maximum absolute value of each row:&quot;</span>
     &lt;&lt; endl &lt;&lt; m.cwiseAbs().rowwise().maxCoeff() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the sum of each row:
0.948
1.15
-0.483
Here is the maximum absolute value of each row:
0.68
0.823
0.605
</pre></div><dl class="section see"><dt>See also:</dt><dd>colwise(), class VectorwiseOp, <a class="el" href="TutorialReductionsVisitorsBroadcasting.html">Tutorial page 7 - Reductions, visitors and broadcasting</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8a7fd1e8004d4bd93a7ea36957aa8e99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a0f3a9175a7678aee05b39f4c85f750be">RowwiseReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html#a3af2f03b1d2affcec24e0748edf892cd">rowwise</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a writable VectorwiseOp wrapper of *this providing additional partial reduction operations</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>colwise(), class VectorwiseOp, <a class="el" href="TutorialReductionsVisitorsBroadcasting.html">Tutorial page 7 - Reductions, visitors and broadcasting</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2cfd0bb3f7616ba0fc7ee592d795738d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html#a2cfd0bb3f7616ba0fc7ee592d795738d">scaleAndAddTo</a> </td>
          <td>(</td>
          <td class="paramtype">Dest &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classEigen_1_1ProductBase.html#a8e0cfbd23ae0324f8105cd010213f9c3">ProductBase&lt; DenseTimeSparseProduct&lt; Lhs, Rhs &gt;, Lhs, Rhs &gt;</a>.</p>

<p>References <a class="el" href="classEigen_1_1ProductBase.html#a261a63462b154999ed8e894064c70b8f">ProductBase&lt; DenseTimeSparseProduct&lt; Lhs, Rhs &gt;, Lhs, Rhs &gt;::m_lhs</a>, <a class="el" href="classEigen_1_1ProductBase.html#a09b383b77155f5437e24e6de15522270">ProductBase&lt; DenseTimeSparseProduct&lt; Lhs, Rhs &gt;, Lhs, Rhs &gt;::m_rhs</a>, and <a class="el" href="namespaceEigen_1_1internal.html#acf3ec87c63d7c9de83c0141f968df7ae">Eigen::internal::sparse_time_dense_product()</a>.</p>

</div>
</div>
<a class="anchor" id="ab958cfdd0a612fe8482d51e425921acb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#aa34201718d13b0e688d5b449772b74b7">SegmentReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html#ab958cfdd0a612fe8482d51e425921acb">segment</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a dynamic-size expression of a segment (i.e. a vector block) in *this.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>the first coefficient in the segment </td></tr>
    <tr><td class="paramname">size</td><td>the number of coefficients in the segment</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga1b8ec6f0766c4900ed6f84f30c36669a">RowVector4i</a> v = RowVector4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is v.segment(1, 2):&quot;</span> &lt;&lt; endl &lt;&lt; v.segment(1, 2) &lt;&lt; endl;
v.segment(1, 2).setZero();
cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.segment(1, 2):
-2 6
Now the vector v is:
7 0 0 6
</pre></div><dl class="section note"><dt>Note:</dt><dd>Even though the returned expression has dynamic size, in the case when it is applied to a fixed-size vector, it inherits a fixed maximal size, which means that evaluating it does not cause a dynamic memory allocation.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>class Block, segment(Index) </dd></dl>

</div>
</div>
<a class="anchor" id="a6bf70e2ce8b6a07a564ce04a01174e1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#ad2d40e210cd2f66126149c908270ead7">DenseBase::ConstSegmentReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html#ab958cfdd0a612fe8482d51e425921acb">segment</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of segment(Index,Index). </p>

</div>
</div>
<a class="anchor" id="a0bfdea57af5d6adc7a38fcd3c3dadc16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FixedSegmentReturnType&lt;Size&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#ab958cfdd0a612fe8482d51e425921acb">segment</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a fixed-size expression of a segment (i.e. a vector block) in <code>*this</code> </dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>The template parameter <em>Size</em> is the number of coefficients in the block</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>the index of the first element of the sub-vector</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga1b8ec6f0766c4900ed6f84f30c36669a">RowVector4i</a> v = RowVector4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is v.segment&lt;2&gt;(1):&quot;</span> &lt;&lt; endl &lt;&lt; v.segment&lt;2&gt;(1) &lt;&lt; endl;
v.segment&lt;2&gt;(2).<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();
cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.segment&lt;2&gt;(1):
-2 6
Now the vector v is:
 7 -2  0  0
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block </dd></dl>

</div>
</div>
<a class="anchor" id="ac1a11f3de938f4cfb9d248e55b15c7b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstFixedSegmentReturnType&lt;Size&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#ab958cfdd0a612fe8482d51e425921acb">segment</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of segment&lt;int&gt;(Index). </p>

</div>
</div>
<a class="anchor" id="aaaed9ab0c7a20c689017542e40d1ef6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; ,ThenDerived,ElseDerived&gt; <a class="el" href="classEigen_1_1DenseBase.html#aaaed9ab0c7a20c689017542e40d1ef6e">select</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>thenMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>elseMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a matrix where each coefficient (i,j) is equal to <em>thenMatrix(i,j)</em> if <code>*this</code>(i,j), and <em>elseMatrix(i,j)</em> otherwise.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga5b9d0d11e78fd355d23221154b7620e4">MatrixXi</a> m(3, 3);
m &lt;&lt; 1, 2, 3,
     4, 5, 6,
     7, 8, 9;
m = (m.array() &gt;= 5).<a class="code" href="classEigen_1_1DenseBase.html#aaaed9ab0c7a20c689017542e40d1ef6e">select</a>(-m, m);
cout &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment"> 1  2  3
 4 -5 -6
-7 -8 -9
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Select </dd></dl>

</div>
</div>
<a class="anchor" id="a0a07265514531d947ff91c2376aa7b29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; ,ThenDerived, typename ThenDerived::ConstantReturnType&gt; <a class="el" href="classEigen_1_1DenseBase.html#aaaed9ab0c7a20c689017542e40d1ef6e">select</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>thenMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ThenDerived::Scalar&#160;</td>
          <td class="paramname"><em>elseScalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Version of DenseBase::select(const DenseBase&amp;, const DenseBase&amp;) with the <em>else</em> expression being a scalar value.</p>
<dl class="section see"><dt>See also:</dt><dd>DenseBase::select(const DenseBase&lt;ThenDerived&gt;&amp;, const DenseBase&lt;ElseDerived&gt;&amp;) const, class Select </dd></dl>

</div>
</div>
<a class="anchor" id="aa8cf1760451f0ba7263c9a0c7030b260"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , typename ElseDerived::ConstantReturnType, ElseDerived &gt; <a class="el" href="classEigen_1_1DenseBase.html#aaaed9ab0c7a20c689017542e40d1ef6e">select</a> </td>
          <td>(</td>
          <td class="paramtype">typename ElseDerived::Scalar&#160;</td>
          <td class="paramname"><em>thenScalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>elseMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Version of DenseBase::select(const DenseBase&amp;, const DenseBase&amp;) with the <em>then</em> expression being a scalar value.</p>
<dl class="section see"><dt>See also:</dt><dd>DenseBase::select(const DenseBase&lt;ThenDerived&gt;&amp;, const DenseBase&lt;ElseDerived&gt;&amp;) const, class Select </dd></dl>

</div>
</div>
<a class="anchor" id="a37814d4937f5c0b0e247d74219875b72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SelfAdjointViewReturnType&lt;UpLo&gt;::Type <a class="el" href="classEigen_1_1MatrixBase.html#a37814d4937f5c0b0e247d74219875b72">selfadjointView</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a18c31876454650792f4227cd1126b5e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstSelfAdjointViewReturnType&lt;UpLo&gt;::Type <a class="el" href="classEigen_1_1MatrixBase.html#a37814d4937f5c0b0e247d74219875b72">selfadjointView</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a351ca566980cf96d9cdd61f3ce0cf94f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp; <a class="el" href="classEigen_1_1DenseBase.html#a351ca566980cf96d9cdd61f3ce0cf94f">setConstant</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets all coefficients in this expression to <em>value</em>.</p>
<dl class="section see"><dt>See also:</dt><dd>fill(), setConstant(Index,const Scalar&amp;), setConstant(Index,Index,const Scalar&amp;), setZero(), setOnes(), Constant(), class CwiseNullaryOp, setZero(), setOnes() </dd></dl>

</div>
</div>
<a class="anchor" id="af1b15ae4c6f69b7324dd8ef70089dfc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp; <a class="el" href="classEigen_1_1MatrixBase.html#af1b15ae4c6f69b7324dd8ef70089dfc3">setIdentity</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes the identity expression (not necessarily square) into *this.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = Matrix4i::Zero();
m.block&lt;3,3&gt;(1,0).<a class="code" href="classEigen_1_1MatrixBase.html#af1b15ae4c6f69b7324dd8ef70089dfc3">setIdentity</a>();
cout &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">0 0 0 0
1 0 0 0
0 1 0 0
0 0 1 0
</pre></div><dl class="section see"><dt>See also:</dt><dd>class CwiseNullaryOp, Identity(), Identity(Index,Index), isIdentity() </dd></dl>

</div>
</div>
<a class="anchor" id="ad643c8a00f9d32b98659d9d745c56caf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp; <a class="el" href="classEigen_1_1MatrixBase.html#af1b15ae4c6f69b7324dd8ef70089dfc3">setIdentity</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resizes to the given size, and writes the identity expression (not necessarily square) into *this. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>the new number of rows </td></tr>
    <tr><td class="paramname">cols</td><td>the new number of columns</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#gabab09c32e96cfa9829a88400627af162">MatrixXf</a> m;
m.setIdentity(3, 3);
cout &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">1 0 0
0 1 0
0 0 1
</pre></div><dl class="section see"><dt>See also:</dt><dd>MatrixBase::setIdentity(), class CwiseNullaryOp, MatrixBase::Identity() </dd></dl>

</div>
</div>
<a class="anchor" id="aca96b3050ceeffaa781d3d4ee185bd1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp; <a class="el" href="classEigen_1_1DenseBase.html#aca96b3050ceeffaa781d3d4ee185bd1d">setLinSpaced</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a linearly space vector. </p>
<p>The function generates 'size' equally spaced values in the closed interval [low,high]. When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">VectorXf v;
v.setLinSpaced(5,0.5f,1.5f).transpose();
cout &lt;&lt; v &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">0.5
0.75
1
1.25
1.5
</pre></div><dl class="section see"><dt>See also:</dt><dd>CwiseNullaryOp </dd></dl>

</div>
</div>
<a class="anchor" id="a043485fa5a9510639cd8034392371aec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp; <a class="el" href="classEigen_1_1DenseBase.html#aca96b3050ceeffaa781d3d4ee185bd1d">setLinSpaced</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a linearly space vector. </p>
<p>The function fill *this with equally spaced values in the closed interval [low,high]. When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section see"><dt>See also:</dt><dd>setLinSpaced(Index, const Scalar&amp;, const Scalar&amp;), CwiseNullaryOp </dd></dl>

</div>
</div>
<a class="anchor" id="a196e62ee8a1fc3b4af631e955d650cfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp; <a class="el" href="classEigen_1_1DenseBase.html#a196e62ee8a1fc3b4af631e955d650cfc">setOnes</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets all coefficients in this expression to one.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = Matrix4i::Random();
m.row(1).setOnes();
cout &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment"> 7  9 -5 -3
 1  1  1  1
 6 -3  0  9
 6  6  3  9
</pre></div><dl class="section see"><dt>See also:</dt><dd>class CwiseNullaryOp, Ones() </dd></dl>

</div>
</div>
<a class="anchor" id="ab795c242db18862f502dfd9fa625c504"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp; <a class="el" href="classEigen_1_1DenseBase.html#ab795c242db18862f502dfd9fa625c504">setRandom</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets all coefficients in this expression to random values.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = Matrix4i::Zero();
m.col(1).setRandom();
cout &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment"> 0  7  0  0
 0 -2  0  0
 0  6  0  0
 0  6  0  0
</pre></div><dl class="section see"><dt>See also:</dt><dd>class CwiseNullaryOp, setRandom(Index), setRandom(Index,Index) </dd></dl>

</div>
</div>
<a class="anchor" id="a9053ca03ac251002768a54742be28fce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &amp; <a class="el" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets all coefficients in this expression to zero.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = Matrix4i::Random();
m.row(1).setZero();
cout &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment"> 7  9 -5 -3
 0  0  0  0
 6 -3  0  9
 6  6  3  9
</pre></div><dl class="section see"><dt>See also:</dt><dd>class CwiseNullaryOp, Zero() </dd></dl>

</div>
</div>
<a class="anchor" id="a4303e65ff533bfc10e9bca9d9347887d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/classEigen_1_1MatrixFunctionReturnValue.html">MatrixFunctionReturnValue</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#a4303e65ff533bfc10e9bca9d9347887d">sin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a05bc52605cb45455e831971539050d54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/classEigen_1_1MatrixFunctionReturnValue.html">MatrixFunctionReturnValue</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#a05bc52605cb45455e831971539050d54">sinh</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7e1e1ff74803d9ded35ed44bd6dab0d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1SparseView.html">SparseView</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#a7e1e1ff74803d9ded35ed44bd6dab0d6">sparseView</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>m_reference</em> = <code><a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt;::Real&#160;</td>
          <td class="paramname"><em>m_epsilon</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa9d7a22735200792533edc1566c05126"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" doxygen="eigen-unsupported.doxytags:unsupported/" href="unsupported/classEigen_1_1MatrixSquareRootReturnValue.html">MatrixSquareRootReturnValue</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#aa9d7a22735200792533edc1566c05126">sqrt</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a229bd5cc6237359a1d85401743476ede"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> <a class="el" href="classEigen_1_1MatrixBase.html#a229bd5cc6237359a1d85401743476ede">squaredNorm</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>, for vectors, the squared <em>l2</em> norm of <code>*this</code>, and for matrices the Frobenius norm. In both cases, it consists in the sum of the square of all the matrix entries. For vectors, this is also equals to the dot product of <code>*this</code> with itself.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>dot(), norm() </dd></dl>

</div>
</div>
<a class="anchor" id="a8cdb3143143e8df89dfb4c58977ea811"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#acb5c3dc237f99cf17167e8a629f01b43">RealScalar</a> <a class="el" href="classEigen_1_1MatrixBase.html#a8cdb3143143e8df89dfb4c58977ea811">stableNorm</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the <em>l2</em> norm of <code>*this</code> avoiding underflow and overflow. This version use a blockwise two passes algorithm: 1 - find the absolute largest coefficient <code>s</code> 2 - compute <img class="formulaInl" alt="$ s \Vert \frac{*this}{s} \Vert $" src="form_29.png"/> in a standard way</dd></dl>
<p>For architecture/scalar types supporting vectorization, this version is faster than blueNorm(). Otherwise the blueNorm() is much faster.</p>
<dl class="section see"><dt>See also:</dt><dd>norm(), blueNorm(), hypotNorm() </dd></dl>

</div>
</div>
<a class="anchor" id="a9296f1ee60afdaa657ec14ed2facf993"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1ProductBase.html#a9296f1ee60afdaa657ec14ed2facf993">subTo</a> </td>
          <td>(</td>
          <td class="paramtype">Dest &amp;&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3a3b3fb530d3364ecef0bf9c9daf0983"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html#a3a3b3fb530d3364ecef0bf9c9daf0983">sum</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the sum of all coefficients of *this</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>trace(), prod(), mean() </dd></dl>

</div>
</div>
<a class="anchor" id="add3bfb296c2f8e29aac6037b16c2e8a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseBase.html#add3bfb296c2f8e29aac6037b16c2e8a9">swap</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"> = <code>OtherDerived::ThisConstantIsPrivateInPlainObjectBase</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>swaps *this with the expression <em>other</em>. </p>

</div>
</div>
<a class="anchor" id="a203951fa04396e45d2c38737943c2c55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseBase.html#add3bfb296c2f8e29aac6037b16c2e8a9">swap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1PlainObjectBase.html">PlainObjectBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>swaps *this with the matrix or array <em>other</em>. </p>

</div>
</div>
<a class="anchor" id="a65f0bc141c75cb3e83010921851566fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#aa34201718d13b0e688d5b449772b74b7">SegmentReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html#a65f0bc141c75cb3e83010921851566fb">tail</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a dynamic-size expression of the last coefficients of *this.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of coefficients in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga1b8ec6f0766c4900ed6f84f30c36669a">RowVector4i</a> v = RowVector4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is v.tail(2):&quot;</span> &lt;&lt; endl &lt;&lt; v.tail(2) &lt;&lt; endl;
v.tail(2).setZero();
cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.tail(2):
6 6
Now the vector v is:
 7 -2  0  0
</pre></div><dl class="section note"><dt>Note:</dt><dd>Even though the returned expression has dynamic size, in the case when it is applied to a fixed-size vector, it inherits a fixed maximal size, which means that evaluating it does not cause a dynamic memory allocation.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a5ec25a830c3ba675b3fc095b413ed444">block(Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a808e1458a0de8ae07abea003af652aca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#ad2d40e210cd2f66126149c908270ead7">DenseBase::ConstSegmentReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html#a65f0bc141c75cb3e83010921851566fb">tail</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of tail(Index). </p>

</div>
</div>
<a class="anchor" id="a10ed126a393d99256f80cfc54455c75c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FixedSegmentReturnType&lt;Size&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#a65f0bc141c75cb3e83010921851566fb">tail</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a fixed-size expression of the last coefficients of *this.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>The template parameter <em>Size</em> is the number of coefficients in the block</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga1b8ec6f0766c4900ed6f84f30c36669a">RowVector4i</a> v = RowVector4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is v.tail(2):&quot;</span> &lt;&lt; endl &lt;&lt; v.tail&lt;2&gt;() &lt;&lt; endl;
v.tail&lt;2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();
cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.tail(2):
6 6
Now the vector v is:
 7 -2  0  0
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block </dd></dl>

</div>
</div>
<a class="anchor" id="ac64cd62d1cd7216b0568154d1562b831"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstFixedSegmentReturnType&lt;Size&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#a65f0bc141c75cb3e83010921851566fb">tail</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of tail&lt;int&gt;. </p>

</div>
</div>
<a class="anchor" id="a6f5fc5fe9d3fb70e62d4a9b1795704a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a6f5fc5fe9d3fb70e62d4a9b1795704a8">topLeftCorner</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a dynamic-size expression of a top-left corner of *this.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">cCols</td><td>the number of columns in the corner</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = Matrix4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is m.topLeftCorner(2, 2):&quot;</span> &lt;&lt; endl;
cout &lt;&lt; m.topLeftCorner(2, 2) &lt;&lt; endl;
m.topLeftCorner(2, 2).setZero();
cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.topLeftCorner(2, 2):
 7  9
-2 -6
Now the matrix m is:
 0  0 -5 -3
 0  0  1  0
 6 -3  0  9
 6  6  3  9
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af51f8dd1a464c0fe48182f7bab7ffab6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a6f5fc5fe9d3fb70e62d4a9b1795704a8">topLeftCorner</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#a14f0eaeb262b3d854978bd941b467436">topLeftCorner(Index, Index)</a>. </p>

</div>
</div>
<a class="anchor" id="ae06d0a5c4008014fb717866aec8d30c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , CRows, CCols&gt; <a class="el" href="classEigen_1_1DenseBase.html#a6f5fc5fe9d3fb70e62d4a9b1795704a8">topLeftCorner</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a fixed-size top-left corner of *this.</dd></dl>
<p>The template parameters CRows and CCols are the number of rows and columns in the corner.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = Matrix4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is m.topLeftCorner&lt;2,2&gt;():&quot;</span> &lt;&lt; endl;
cout &lt;&lt; m.topLeftCorner&lt;2,2&gt;() &lt;&lt; endl;
m.topLeftCorner&lt;2,2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();
cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.topLeftCorner&lt;2,2&gt;():
 7  9
-2 -6
Now the matrix m is:
 0  0 -5 -3
 0  0  1  0
 6 -3  0  9
 6  6  3  9
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a29c05f280e61cf18f5865b0065cc769a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , CRows, CCols&gt; <a class="el" href="classEigen_1_1DenseBase.html#a6f5fc5fe9d3fb70e62d4a9b1795704a8">topLeftCorner</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#a14f0eaeb262b3d854978bd941b467436">topLeftCorner&lt;int, int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="a318006038c9becc5f9af003b7c77ea18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a318006038c9becc5f9af003b7c77ea18">topRightCorner</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a dynamic-size expression of a top-right corner of *this.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">cCols</td><td>the number of columns in the corner</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = Matrix4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is m.topRightCorner(2, 2):&quot;</span> &lt;&lt; endl;
cout &lt;&lt; m.topRightCorner(2, 2) &lt;&lt; endl;
m.topRightCorner(2, 2).setZero();
cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.topRightCorner(2, 2):
-5 -3
 1  0
Now the matrix m is:
 7  9  0  0
-2 -6  0  0
 6 -3  0  9
 6  6  3  9
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8cd6c56ce974c092a0aa0f11ca1853cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a318006038c9becc5f9af003b7c77ea18">topRightCorner</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#a424a4657b422521695f73ecd94719bdd">topRightCorner(Index, Index)</a>. </p>

</div>
</div>
<a class="anchor" id="ad0088b2c1ec4dbd677dd19f589777945"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , CRows, CCols&gt; <a class="el" href="classEigen_1_1DenseBase.html#a318006038c9becc5f9af003b7c77ea18">topRightCorner</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a fixed-size top-right corner of *this.</dd></dl>
<p>The template parameters CRows and CCols are the number of rows and columns in the corner.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = Matrix4i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is m.topRightCorner&lt;2,2&gt;():&quot;</span> &lt;&lt; endl;
cout &lt;&lt; m.topRightCorner&lt;2,2&gt;() &lt;&lt; endl;
m.topRightCorner&lt;2,2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();
cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.topRightCorner&lt;2,2&gt;():
-5 -3
 1  0
Now the matrix m is:
 7  9  0  0
-2 -6  0  0
 6 -3  0  9
 6  6  3  9
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abbe4b3135cc0afa4eee8d9db60c637c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; , CRows, CCols&gt; <a class="el" href="classEigen_1_1DenseBase.html#a318006038c9becc5f9af003b7c77ea18">topRightCorner</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#a424a4657b422521695f73ecd94719bdd">topRightCorner&lt;int, int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="afdfced3e157f74b3bc68892aad178424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RowsBlockXpr <a class="el" href="classEigen_1_1DenseBase.html#afdfced3e157f74b3bc68892aad178424">topRows</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a block consisting of the top rows of *this.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of rows in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">Array44i a = Array44i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is a.topRows(2):&quot;</span> &lt;&lt; endl;
cout &lt;&lt; a.topRows(2) &lt;&lt; endl;
a.topRows(2).setZero();
cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.topRows(2):
 7  9 -5 -3
-2 -6  1  0
Now the array a is:
 0  0  0  0
 0  0  0  0
 6 -3  0  9
 6  6  3  9
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac77be6c2cf44abbb6f80496cbe14f2af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstRowsBlockXpr <a class="el" href="classEigen_1_1DenseBase.html#afdfced3e157f74b3bc68892aad178424">topRows</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#a16add63ff3a3fa3d036269341bf0a871">topRows(Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a77933058fb3cd3319a86dd0ac4c88d38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRowsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#afdfced3e157f74b3bc68892aad178424">topRows</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a block consisting of the top rows of *this.</dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">N</td><td>the number of rows in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">Array44i a = Array44i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is a.topRows&lt;2&gt;():&quot;</span> &lt;&lt; endl;
cout &lt;&lt; a.topRows&lt;2&gt;() &lt;&lt; endl;
a.topRows&lt;2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();
cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.topRows&lt;2&gt;():
 7  9 -5 -3
-2 -6  1  0
Now the array a is:
 0  0  0  0
 0  0  0  0
 6 -3  0  9
 6  6  3  9
</pre></div><dl class="section see"><dt>See also:</dt><dd>class Block, <a class="el" href="BlockMethods_8h.html#a93e6684bb07c46a5020a99ef03deca57">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4d7327699c5128262f29dc66efac6484"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstNRowsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1DenseBase.html#afdfced3e157f74b3bc68892aad178424">topRows</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of <a class="el" href="BlockMethods_8h.html#a16add63ff3a3fa3d036269341bf0a871">topRows&lt;int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="a71696dd0adbf4731561fd60e55c3a96e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> <a class="el" href="classEigen_1_1MatrixBase.html#a71696dd0adbf4731561fd60e55c3a96e">trace</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the trace of <code>*this</code>, i.e. the sum of the coefficients on the main diagonal.</dd></dl>
<p><code>*this</code> can be any matrix, not necessarily square.</p>
<dl class="section see"><dt>See also:</dt><dd>diagonal(), sum() </dd></dl>

<p>Reimplemented from <a class="el" href="classEigen_1_1DenseBase.html#a8961f313797b1671456863a1935a12bf">DenseBase&lt; DenseTimeSparseProduct&lt; Lhs, Rhs &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3c187c30922fc5e42f208ae3eb0970ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Transpose.html">Eigen::Transpose</a>&lt;<a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1DenseBase.html#a3c187c30922fc5e42f208ae3eb0970ee">transpose</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the transpose of *this.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__matrixtypedefs.html#gab837976997f1fdef130c5f47f712b9b0">Matrix2i</a> m = Matrix2i::Random();
cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is the transpose of m:&quot;</span> &lt;&lt; endl &lt;&lt; m.transpose() &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Here is the coefficient (1,0) in the transpose of m:&quot;</span> &lt;&lt; endl
     &lt;&lt; m.transpose()(1,0) &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Let us overwrite this coefficient with the value 0.&quot;</span> &lt;&lt; endl;
m.transpose()(1,0) = 0;
cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Here is the matrix m:
7 6
-2 6
Here is the transpose of m:
 7 -2
 6  6
Here is the coefficient (1,0) in the transpose of m:
6
Let us overwrite this coefficient with the value 0.
Now the matrix m is:
7 0
-2 6
</pre></div><dl class="section warning"><dt>Warning:</dt><dd>If you want to replace a matrix by its own transpose, do <b>NOT</b> do this: <div class="fragment"><pre class="fragment"> m = m.transpose(); <span class="comment">// bug!!! caused by aliasing effect</span>
</pre></div> Instead, use the transposeInPlace() method: <div class="fragment"><pre class="fragment"> m.transposeInPlace();
</pre></div> which gives <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> good opportunities for optimization, or alternatively you can also do: <div class="fragment"><pre class="fragment"> m = m.transpose().eval();
</pre></div></dd></dl>
<dl class="section see"><dt>See also:</dt><dd>transposeInPlace(), adjoint() </dd></dl>

</div>
</div>
<a class="anchor" id="a3936cd66f319a377cdb93cad66f46755"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#ac49cc2270a49c9e3453edcd9e9bc405b">ConstTransposeReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html#a3c187c30922fc5e42f208ae3eb0970ee">transpose</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of transpose().</p>
<p>Make sure you read the warning for transpose() !</p>
<dl class="section see"><dt>See also:</dt><dd>transposeInPlace(), adjoint() </dd></dl>

</div>
</div>
<a class="anchor" id="a3689faf485a5e405a4fc9bf0e05564c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseBase.html#a3689faf485a5e405a4fc9bf0e05564c9">transposeInPlace</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the "in place" version of transpose(): it replaces <code>*this</code> by its own transpose. Thus, doing </p>
<div class="fragment"><pre class="fragment"> m.transposeInPlace();
</pre></div><p> has the same effect on m as doing </p>
<div class="fragment"><pre class="fragment"> m = m.transpose().eval();
</pre></div><p> and is faster and also safer because in the latter line of code, forgetting the eval() results in a bug caused by aliasing.</p>
<p>Notice however that this method is only useful if you want to replace a matrix by its own transpose. If you just need the transpose of a matrix, use transpose().</p>
<dl class="section note"><dt>Note:</dt><dd>if the matrix is not square, then <code>*this</code> must be a resizable matrix.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>transpose(), adjoint(), adjointInPlace() </dd></dl>

</div>
</div>
<a class="anchor" id="a90150a6deb18826cee5ece716663358a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TriangularViewReturnType&lt;Mode&gt;::Type <a class="el" href="classEigen_1_1MatrixBase.html#a90150a6deb18826cee5ece716663358a">triangularView</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a triangular view extracted from the current matrix</dd></dl>
<p>The parameter <em>Mode</em> can have the following values: <code>#Upper</code>, <code>#StrictlyUpper</code>, <code>#UnitUpper</code>, <code>#Lower</code>, <code>#StrictlyLower</code>, <code>#UnitLower</code>.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#ifndef _MSC_VER</span>
<span class="preprocessor"></span><span class="preprocessor">  #warning deprecated</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="comment">/* deprecated</span>
<span class="comment">Matrix3i m = Matrix3i::Random();</span>
<span class="comment">cout &lt;&lt; &quot;Here is the matrix m:&quot; &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</span>
<span class="comment">cout &lt;&lt; &quot;Here is the upper-triangular matrix extracted from m:&quot; &lt;&lt; endl</span>
<span class="comment">     &lt;&lt; m.part&lt;Eigen::UpperTriangular&gt;() &lt;&lt; endl;</span>
<span class="comment">cout &lt;&lt; &quot;Here is the strictly-upper-triangular matrix extracted from m:&quot; &lt;&lt; endl</span>
<span class="comment">     &lt;&lt; m.part&lt;Eigen::StrictlyUpperTriangular&gt;() &lt;&lt; endl;</span>
<span class="comment">cout &lt;&lt; &quot;Here is the unit-lower-triangular matrix extracted from m:&quot; &lt;&lt; endl</span>
<span class="comment">     &lt;&lt; m.part&lt;Eigen::UnitLowerTriangular&gt;() &lt;&lt; endl;</span>
<span class="comment">*/</span>
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment"></pre></div><dl class="section see"><dt>See also:</dt><dd>class TriangularView </dd></dl>

</div>
</div>
<a class="anchor" id="a85796290d88996a8c943c53efdf5988a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstTriangularViewReturnType&lt;Mode&gt;::Type <a class="el" href="classEigen_1_1MatrixBase.html#a90150a6deb18826cee5ece716663358a">triangularView</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the const version of MatrixBase::triangularView() </p>

</div>
</div>
<a class="anchor" id="a23fc4bf97168dee2516f85edcfd4cfe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;CustomUnaryOp, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#a23fc4bf97168dee2516f85edcfd4cfe7">unaryExpr</a> </td>
          <td>(</td>
          <td class="paramtype">const CustomUnaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>CustomUnaryOp()</code></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a unary operator coefficient-wise. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Functor implementing the unary operator </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">CustomUnaryOp</td><td>Type of <em>func</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>An expression of a custom coefficient-wise unary operator <em>func</em> of *this</dd></dl>
<p>The function <code>ptr_fun()</code> from the C++ standard library can be used to make functors out of normal functions.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="Core.html">Eigen/Core</a>&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="keyword">using namespace </span>Eigen;
<span class="keyword">using namespace </span>std;

<span class="comment">// define function to be applied coefficient-wise</span>
<span class="keywordtype">double</span> ramp(<span class="keywordtype">double</span> x)
{
  <span class="keywordflow">if</span> (x &gt; 0)
    <span class="keywordflow">return</span> x;
  <span class="keywordflow">else</span> 
    <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">int</span> <a class="code" href="tutorial_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)
{
  <a class="code" href="classEigen_1_1Matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix4d</a> m1 = Matrix4d::Random();
  cout &lt;&lt; m1 &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;becomes: &quot;</span> &lt;&lt; endl &lt;&lt; m1.<a class="code" href="classEigen_1_1MatrixBase.html#a23fc4bf97168dee2516f85edcfd4cfe7" title="Apply a unary operator coefficient-wise.">unaryExpr</a>(ptr_fun(ramp)) &lt;&lt; endl;
  <span class="keywordflow">return</span> 0;
}
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">   0.68   0.823  -0.444   -0.27
 -0.211  -0.605   0.108  0.0268
  0.566   -0.33 -0.0452   0.904
  0.597   0.536   0.258   0.832
becomes: 
  0.68  0.823      0      0
     0      0  0.108 0.0268
 0.566      0      0  0.904
 0.597  0.536  0.258  0.832
</pre></div><p>Genuine functors allow for more possibilities, for instance it may contain a state.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="Core.html">Eigen/Core</a>&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="keyword">using namespace </span>Eigen;
<span class="keyword">using namespace </span>std;

<span class="comment">// define a custom template unary functor</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt;
<span class="keyword">struct </span>CwiseClampOp {
  CwiseClampOp(<span class="keyword">const</span> Scalar&amp; inf, <span class="keyword">const</span> Scalar&amp; sup) : m_inf(inf), m_sup(sup) {}
  <span class="keyword">const</span> Scalar operator()(<span class="keyword">const</span> Scalar&amp; x)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> x&lt;m_inf ? m_inf : (x&gt;m_sup ? m_sup : x); }
  Scalar m_inf, m_sup;
};

<span class="keywordtype">int</span> <a class="code" href="tutorial_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)
{
  <a class="code" href="classEigen_1_1Matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix4d</a> m1 = Matrix4d::Random();
  cout &lt;&lt; m1 &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;becomes: &quot;</span> &lt;&lt; endl &lt;&lt; m1.<a class="code" href="classEigen_1_1MatrixBase.html#a23fc4bf97168dee2516f85edcfd4cfe7" title="Apply a unary operator coefficient-wise.">unaryExpr</a>(CwiseClampOp&lt;double&gt;(-0.5,0.5)) &lt;&lt; endl;
  <span class="keywordflow">return</span> 0;
}
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">   0.68   0.823  -0.444   -0.27
 -0.211  -0.605   0.108  0.0268
  0.566   -0.33 -0.0452   0.904
  0.597   0.536   0.258   0.832
becomes: 
    0.5     0.5  -0.444   -0.27
 -0.211    -0.5   0.108  0.0268
    0.5   -0.33 -0.0452     0.5
    0.5     0.5   0.258     0.5
</pre></div><dl class="section see"><dt>See also:</dt><dd>class CwiseUnaryOp, class CwiseBinaryOp </dd></dl>

</div>
</div>
<a class="anchor" id="aba9ae3923f6caa962ef3418d6872c369"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryView.html">CwiseUnaryView</a>&lt;CustomViewOp, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html#aba9ae3923f6caa962ef3418d6872c369">unaryViewExpr</a> </td>
          <td>(</td>
          <td class="paramtype">const CustomViewOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>CustomViewOp()</code></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a custom coefficient-wise unary operator <em>func</em> of *this</dd></dl>
<p>The template parameter <em>CustomUnaryOp</em> is the type of the functor of the custom unary operator.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="Core.html">Eigen/Core</a>&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="keyword">using namespace </span>Eigen;
<span class="keyword">using namespace </span>std;

<span class="comment">// define a custom template unary functor</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt;
<span class="keyword">struct </span>CwiseClampOp {
  CwiseClampOp(<span class="keyword">const</span> Scalar&amp; inf, <span class="keyword">const</span> Scalar&amp; sup) : m_inf(inf), m_sup(sup) {}
  <span class="keyword">const</span> Scalar operator()(<span class="keyword">const</span> Scalar&amp; x)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> x&lt;m_inf ? m_inf : (x&gt;m_sup ? m_sup : x); }
  Scalar m_inf, m_sup;
};

<span class="keywordtype">int</span> <a class="code" href="tutorial_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)
{
  <a class="code" href="classEigen_1_1Matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix4d</a> m1 = Matrix4d::Random();
  cout &lt;&lt; m1 &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;becomes: &quot;</span> &lt;&lt; endl &lt;&lt; m1.<a class="code" href="classEigen_1_1MatrixBase.html#a23fc4bf97168dee2516f85edcfd4cfe7" title="Apply a unary operator coefficient-wise.">unaryExpr</a>(CwiseClampOp&lt;double&gt;(-0.5,0.5)) &lt;&lt; endl;
  <span class="keywordflow">return</span> 0;
}
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">   0.68   0.823  -0.444   -0.27
 -0.211  -0.605   0.108  0.0268
  0.566   -0.33 -0.0452   0.904
  0.597   0.536   0.258   0.832
becomes: 
    0.5     0.5  -0.444   -0.27
 -0.211    -0.5   0.108  0.0268
    0.5   -0.33 -0.0452     0.5
    0.5     0.5   0.258     0.5
</pre></div><dl class="section see"><dt>See also:</dt><dd>class CwiseUnaryOp, class CwiseBinaryOp </dd></dl>

</div>
</div>
<a class="anchor" id="ae908d6321d43a20ed57d9f6c1c6acbe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const BasisReturnType <a class="el" href="classEigen_1_1MatrixBase.html#ae908d6321d43a20ed57d9f6c1c6acbe9">Unit</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the i-th unit (basis) vector.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section see"><dt>See also:</dt><dd>MatrixBase::Unit(Index), MatrixBase::UnitX(), MatrixBase::UnitY(), MatrixBase::UnitZ(), MatrixBase::UnitW() </dd></dl>

</div>
</div>
<a class="anchor" id="a3f665c26af64e93899d1899f67dbf11b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const BasisReturnType <a class="el" href="classEigen_1_1MatrixBase.html#ae908d6321d43a20ed57d9f6c1c6acbe9">Unit</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the i-th unit (basis) vector.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This variant is for fixed-size vector only.</p>
<dl class="section see"><dt>See also:</dt><dd>MatrixBase::Unit(Index,Index), MatrixBase::UnitX(), MatrixBase::UnitY(), MatrixBase::UnitZ(), MatrixBase::UnitW() </dd></dl>

</div>
</div>
<a class="anchor" id="a42fdca0c5854b85d9482853c8a085dc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a> <a class="el" href="classEigen_1_1MatrixBase.html#a42fdca0c5854b85d9482853c8a085dc1">unitOrthogonal</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a unit vector which is orthogonal to <code>*this</code> </dd></dl>
<p>The size of <code>*this</code> must be at least 2. If the size is exactly 2, then the returned vector is a counter clock wise rotation of <code>*this</code>, i.e., (-y,x).normalized().</p>
<dl class="section see"><dt>See also:</dt><dd>cross() </dd></dl>

</div>
</div>
<a class="anchor" id="a585b3898eb4f52adce6b7025fb8fb429"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const BasisReturnType <a class="el" href="classEigen_1_1MatrixBase.html#a585b3898eb4f52adce6b7025fb8fb429">UnitW</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the W axis unit vector (0,0,0,1)</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section see"><dt>See also:</dt><dd>MatrixBase::Unit(Index,Index), MatrixBase::Unit(Index), MatrixBase::UnitY(), MatrixBase::UnitZ(), MatrixBase::UnitW() </dd></dl>

</div>
</div>
<a class="anchor" id="a5e0e42c39330e4274d2d0479048ebc37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const BasisReturnType <a class="el" href="classEigen_1_1MatrixBase.html#a5e0e42c39330e4274d2d0479048ebc37">UnitX</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the X axis unit vector (1{,0}^*)</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section see"><dt>See also:</dt><dd>MatrixBase::Unit(Index,Index), MatrixBase::Unit(Index), MatrixBase::UnitY(), MatrixBase::UnitZ(), MatrixBase::UnitW() </dd></dl>

</div>
</div>
<a class="anchor" id="abc925a22c4f4b48b5b10fa90924f14c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const BasisReturnType <a class="el" href="classEigen_1_1MatrixBase.html#abc925a22c4f4b48b5b10fa90924f14c1">UnitY</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the Y axis unit vector (0,1{,0}^*)</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section see"><dt>See also:</dt><dd>MatrixBase::Unit(Index,Index), MatrixBase::Unit(Index), MatrixBase::UnitY(), MatrixBase::UnitZ(), MatrixBase::UnitW() </dd></dl>

</div>
</div>
<a class="anchor" id="a135f14351a7213bf0b764272c14ca68c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const BasisReturnType <a class="el" href="classEigen_1_1MatrixBase.html#a135f14351a7213bf0b764272c14ca68c">UnitZ</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of the Z axis unit vector (0,0,1{,0}^*)</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section see"><dt>See also:</dt><dd>MatrixBase::Unit(Index,Index), MatrixBase::Unit(Index), MatrixBase::UnitY(), MatrixBase::UnitZ(), MatrixBase::UnitW() </dd></dl>

</div>
</div>
<a class="anchor" id="adf21a576b8f3a10bb141b8afd173b13d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a7ade678155e3ede0ed013e65dd79c905">CoeffReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>the unique coefficient of a 1x1 expression </dd></dl>

</div>
</div>
<a class="anchor" id="af33f695c0e0ad5634ca73f19c347f7b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1DenseBase.html#af33f695c0e0ad5634ca73f19c347f7b3">visit</a> </td>
          <td>(</td>
          <td class="paramtype">Visitor &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Applies the visitor <em>visitor</em> to the whole coefficients of the matrix or vector.</p>
<p>The template parameter <em>Visitor</em> is the type of the visitor and provides the following interface: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>MyVisitor {
   <span class="comment">// called for the first coefficient</span>
   <span class="keywordtype">void</span> init(<span class="keyword">const</span> Scalar&amp; value, Index i, Index j);
   <span class="comment">// called for all other coefficients</span>
   <span class="keywordtype">void</span> operator() (<span class="keyword">const</span> Scalar&amp; value, Index i, Index j);
 };
</pre></div><dl class="section note"><dt>Note:</dt><dd>compared to one or two <em>for</em> <em>loops</em>, visitors offer automatic unrolling for small fixed size matrix.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>minCoeff(Index*,Index*), maxCoeff(Index*,Index*), DenseBase::redux() </dd></dl>

</div>
</div>
<a class="anchor" id="a724349af3e253b69a54d503931b52ec3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html#a724349af3e253b69a54d503931b52ec3">Zero</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a zero matrix.</dd></dl>
<p>The parameters <em>rows</em> and <em>cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this MatrixBase type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>rows</em> and <em>cols</em> as arguments, so Zero() should be used instead.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">cout &lt;&lt; MatrixXi::Zero(2,3) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">0 0 0
0 0 0
</pre></div><dl class="section see"><dt>See also:</dt><dd>Zero(), Zero(Index) </dd></dl>

</div>
</div>
<a class="anchor" id="a39390955f1297dacb49ac94429f321fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html#a724349af3e253b69a54d503931b52ec3">Zero</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a zero vector.</dd></dl>
<p>The parameter <em>size</em> is the size of the returned vector. Must be compatible with this MatrixBase type.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em>size</em> as argument, so Zero() should be used instead.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">cout &lt;&lt; RowVectorXi::Zero(4) &lt;&lt; endl;
cout &lt;&lt; VectorXf::Zero(2) &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">0 0 0 0
0
0
</pre></div><dl class="section see"><dt>See also:</dt><dd>Zero(), Zero(Index,Index) </dd></dl>

</div>
</div>
<a class="anchor" id="a2e36721b4833498b713e94a7948c6a29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html#a724349af3e253b69a54d503931b52ec3">Zero</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>an expression of a fixed-size zero matrix or vector.</dd></dl>
<p>This variant is only for fixed-size MatrixBase types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">cout &lt;&lt; Matrix2d::Zero() &lt;&lt; endl;
cout &lt;&lt; RowVector4i::Zero() &lt;&lt; endl;
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">0 0
0 0
0 0 0 0
</pre></div><dl class="section see"><dt>See also:</dt><dd>Zero(Index), Zero(Index,Index) </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a3e057492d9eb3d397593114ddc7d349f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ScalarMultipleReturnType operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StorageBaseType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac20f49dfb37329c75616c592830973f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_multiple2_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>,std::complex&lt;<a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a>&gt; &gt;, const <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html">DenseTimeSparseProduct</a>&lt; Lhs, Rhs &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; <a class="el" href="classEigen_1_1DenseBase.html#a844358c46408e878e60c4026c52eb1e9">Scalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StorageBaseType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a261a63462b154999ed8e894064c70b8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1ProductBase.html#adc2b9e2eab4afab226c7cced7a912840">LhsNested</a> <a class="el" href="classEigen_1_1ProductBase.html#a261a63462b154999ed8e894064c70b8f">m_lhs</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html#a2cfd0bb3f7616ba0fc7ee592d795738d">DenseTimeSparseProduct&lt; Lhs, Rhs &gt;::scaleAndAddTo()</a>.</p>

</div>
</div>
<a class="anchor" id="a18c00fa3636a862fda426d2a507f65f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html#ac33495a0e3788e5951670c392b44d9ad">PlainObject</a> <a class="el" href="classEigen_1_1ProductBase.html#a18c00fa3636a862fda426d2a507f65f9">m_result</a><code> [mutable, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a09b383b77155f5437e24e6de15522270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1ProductBase.html#a89d0de86a5e1a2320541ca26718d0f65">RhsNested</a> <a class="el" href="classEigen_1_1ProductBase.html#a09b383b77155f5437e24e6de15522270">m_rhs</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="classEigen_1_1DenseTimeSparseProduct.html#a2cfd0bb3f7616ba0fc7ee592d795738d">DenseTimeSparseProduct&lt; Lhs, Rhs &gt;::scaleAndAddTo()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SparseDenseProduct_8h_source.html">SparseDenseProduct.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/>

<!-- Piwik --> 
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ? "https://stats.sylphide-consulting.com/piwik/" : "http://stats.sylphide-consulting.com/piwik/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 20);
piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
</script><noscript><p><img src="http://stats.sylphide-consulting.com/piwik/piwik.php?idsite=20" style="border:0" alt="" /></p></noscript>
<!-- End Piwik Tracking Code -->

</body>
</html>
