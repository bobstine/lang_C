<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Matrix functions module</title>
<link href="eigendoxy_tabs.css" rel="stylesheet" type="text/css">
<link href="$relpath/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="$relpath/search.js"></script>
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
</head>
<body onload='searchBox.OnSelectItem(0);'>
<a name="top"></a>
<a class="logo" href="http://eigen.tuxfamily.org/">
<img class="logo" src="Eigen_Silly_Professor_64x64.png" width=64 height=64 alt="Eigen's silly professor"/></a>
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Matrix functions module<div class="ingroups"><a class="el" href="group__Unsupported__modules.html">Unsupported modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This module aims to provide various methods for the computation of matrix functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixExponential.html">MatrixExponential&lt; MatrixType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing the matrix exponential.  <a href="classEigen_1_1MatrixExponential.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1MatrixExponentialReturnValue.html">MatrixExponentialReturnValue&lt; Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix exponential of some matrix (expression).  <a href="structEigen_1_1MatrixExponentialReturnValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixFunction.html">MatrixFunction&lt; MatrixType, AtomicType, IsComplex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix functions.  <a href="classEigen_1_1MatrixFunction.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixFunctionAtomic.html">MatrixFunctionAtomic&lt; MatrixType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for computing matrix functions of atomic matrices.  <a href="classEigen_1_1MatrixFunctionAtomic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixFunctionReturnValue.html">MatrixFunctionReturnValue&lt; Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix function of some matrix (expression).  <a href="classEigen_1_1MatrixFunctionReturnValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixLogarithmAtomic.html">MatrixLogarithmAtomic&lt; MatrixType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for computing matrix logarithm of atomic matrices.  <a href="classEigen_1_1MatrixLogarithmAtomic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixLogarithmReturnValue.html">MatrixLogarithmReturnValue&lt; Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix logarithm of some matrix (expression).  <a href="classEigen_1_1MatrixLogarithmReturnValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixSquareRoot.html">MatrixSquareRoot&lt; MatrixType, IsComplex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix square roots of general matrices.  <a href="classEigen_1_1MatrixSquareRoot.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixSquareRootQuasiTriangular.html">MatrixSquareRootQuasiTriangular&lt; MatrixType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix square roots of upper quasi-triangular matrices.  <a href="classEigen_1_1MatrixSquareRootQuasiTriangular.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixSquareRootReturnValue.html">MatrixSquareRootReturnValue&lt; Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix square root of some matrix (expression).  <a href="classEigen_1_1MatrixSquareRootReturnValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixSquareRootTriangular.html">MatrixSquareRootTriangular&lt; MatrixType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix square roots of upper triangular matrices.  <a href="classEigen_1_1MatrixSquareRootTriangular.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1StdStemFunctions.html">StdStemFunctions&lt; Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stem functions corresponding to standard mathematical functions.  <a href="classEigen_1_1StdStemFunctions.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module aims to provide various methods for the computation of matrix functions. </p>
<p>To use this module, add </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span></div>
</div><!-- fragment --><p> at the start of your source file.</p>
<p>This module defines the following MatrixBase methods.</p>
<ul>
<li><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_cos">MatrixBase::cos()</a>, for computing the matrix cosine</li>
<li><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_cosh">MatrixBase::cosh()</a>, for computing the matrix hyperbolic cosine</li>
<li><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_exp">MatrixBase::exp()</a>, for computing the matrix exponential</li>
<li><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_log">MatrixBase::log()</a>, for computing the matrix logarithm</li>
<li><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_matrixfunction">MatrixBase::matrixFunction()</a>, for computing general matrix functions</li>
<li><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_sin">MatrixBase::sin()</a>, for computing the matrix sine</li>
<li><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_sinh">MatrixBase::sinh()</a>, for computing the matrix hyperbolic sine</li>
<li><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_sqrt">MatrixBase::sqrt()</a>, for computing the matrix square root</li>
</ul>
<p>These methods are the main entry points to this module.</p>
<p>Matrix functions are defined as follows. Suppose that <img class="formulaInl" alt="$ f $" src="form_3.png"/> is an entire function (that is, a function on the complex plane that is everywhere complex differentiable). Then its Taylor series </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(0) + f'(0) x + \frac{f''(0)}{2} x^2 + \frac{f'''(0)}{3!} x^3 + \cdots \]" src="form_4.png"/>
</p>
<p> converges to <img class="formulaInl" alt="$ f(x) $" src="form_5.png"/>. In this case, we can define the matrix function by the same series: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(M) = f(0) + f'(0) M + \frac{f''(0)}{2} M^2 + \frac{f'''(0)}{3!} M^3 + \cdots \]" src="form_6.png"/>
</p>
 

<h3><a class="anchor" id="matrixbaseextra"></a>MatrixBase methods defined in the MatrixFunctions module</h3><div class="textblock">The remainder of the page documents the following MatrixBase methods which are defined in the MatrixFunctions module.<h1><a class="anchor" id="matrixbase_cos"></a>
MatrixBase::cos()</h1>
<p>Compute the matrix cosine.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MatrixFunctionReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::cos() const</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>a square matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression representing <img class="formulaInl" alt="$ \cos(M) $" src="form_7.png"/>.</dd></dl>
<p>This function calls <a class="el" href="group__MatrixFunctions__Module.html#matrixbase_matrixfunction">matrixFunction()</a> with StdStemFunctions::cos().</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_sin">sin()</a> for an example.</dd></dl>
<h1><a class="anchor" id="matrixbase_cosh"></a>
MatrixBase::cosh()</h1>
<p>Compute the matrix hyberbolic cosine.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MatrixFunctionReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::cosh() const</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>a square matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression representing <img class="formulaInl" alt="$ \cosh(M) $" src="form_8.png"/></dd></dl>
<p>This function calls <a class="el" href="group__MatrixFunctions__Module.html#matrixbase_matrixfunction">matrixFunction()</a> with StdStemFunctions::cosh().</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_sinh">sinh()</a> for an example.</dd></dl>
<h1><a class="anchor" id="matrixbase_exp"></a>
MatrixBase::exp()</h1>
<p>Compute the matrix exponential.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MatrixExponentialReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::exp() const</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>matrix whose exponential is to be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression representing the matrix exponential of <code>M</code>.</dd></dl>
<p>The matrix exponential of <img class="formulaInl" alt="$ M $" src="form_9.png"/> is defined by </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \exp(M) = \sum_{k=0}^\infty \frac{M^k}{k!}. \]" src="form_10.png"/>
</p>
<p> The matrix exponential can be used to solve linear ordinary differential equations: the solution of <img class="formulaInl" alt="$ y' = My $" src="form_11.png"/> with the initial condition <img class="formulaInl" alt="$ y(0) = y_0 $" src="form_12.png"/> is given by <img class="formulaInl" alt="$ y(t) = \exp(M) y_0 $" src="form_13.png"/>.</p>
<p>The cost of the computation is approximately <img class="formulaInl" alt="$ 20 n^3 $" src="form_14.png"/> for matrices of size <img class="formulaInl" alt="$ n $" src="form_15.png"/>. The number 20 depends weakly on the norm of the matrix.</p>
<p>The matrix exponential is computed using the scaling-and-squaring method combined with Pad&eacute; approximation. The matrix is first rescaled, then the exponential of the reduced matrix is computed approximant, and then the rescaling is undone by repeated squaring. The degree of the Pad&eacute; approximant is chosen such that the approximation error is less than the round-off error. However, errors may accumulate during the squaring phase.</p>
<p>Details of the algorithm can be found in: Nicholas J. Higham, "The
scaling and squaring method for the matrix exponential revisited," <em>SIAM J. Matrix Anal. Applic.</em>, <b>26</b>:1179&ndash;1193, 2005.</p>
<p>Example: The following program checks that </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \exp \left[ \begin{array}{ccc} 0 &amp; \frac14\pi &amp; 0 \\ -\frac14\pi &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \end{array} \right] = \left[ \begin{array}{ccc} \frac12\sqrt2 &amp; -\frac12\sqrt2 &amp; 0 \\ \frac12\sqrt2 &amp; \frac12\sqrt2 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{array} \right]. \]" src="form_16.png"/>
</p>
<p> This corresponds to a rotation of <img class="formulaInl" alt="$ \frac14\pi $" src="form_17.png"/> radians around the z-axis.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>Eigen;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> pi = std::acos(-1.0);</div>
<div class="line"></div>
<div class="line">  <a class="codeRef" doxygen="eigen.doxytags:..//" href="../classEigen_1_1Matrix.html">MatrixXd</a> A(3,3);</div>
<div class="line">  A &lt;&lt; 0,    -pi/4, 0,</div>
<div class="line">       pi/4, 0,     0,</div>
<div class="line">       0,    0,     0;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix A is:\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix exponential of A is:\n&quot;</span> &lt;&lt; A.exp() &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output:</p>
<pre class="fragment">The matrix A is:
        0 -0.785398         0
 0.785398         0         0
        0         0         0

The matrix exponential of A is:
 0.707107 -0.707107         0
 0.707107  0.707107         0
        0         0         1

</pre><dl class="section note"><dt>Note</dt><dd><code>M</code> has to be a matrix of <code>float</code>, <code>double</code>, <code>long</code> double <code>complex&lt;float&gt;</code>, <code>complex&lt;double&gt;</code>, or <code>complex&lt;long double&gt;</code> .</dd></dl>
<h1><a class="anchor" id="matrixbase_log"></a>
MatrixBase::log()</h1>
<p>Compute the matrix logarithm.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MatrixLogarithmReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::log() const</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>invertible matrix whose logarithm is to be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression representing the matrix logarithm root of <code>M</code>.</dd></dl>
<p>The matrix logarithm of <img class="formulaInl" alt="$ M $" src="form_9.png"/> is a matrix <img class="formulaInl" alt="$ X $" src="form_18.png"/> such that <img class="formulaInl" alt="$ \exp(X) = M $" src="form_19.png"/> where exp denotes the matrix exponential. As for the scalar logarithm, the equation <img class="formulaInl" alt="$ \exp(X) = M $" src="form_19.png"/> may have multiple solutions; this function returns a matrix whose eigenvalues have imaginary part in the interval <img class="formulaInl" alt="$ (-\pi,\pi] $" src="form_20.png"/>.</p>
<p>In the real case, the matrix <img class="formulaInl" alt="$ M $" src="form_9.png"/> should be invertible and it should have no eigenvalues which are real and negative (pairs of complex conjugate eigenvalues are allowed). In the complex case, it only needs to be invertible.</p>
<p>This function computes the matrix logarithm using the Schur-Parlett algorithm as implemented by MatrixBase::matrixFunction(). The logarithm of an atomic block is computed by MatrixLogarithmAtomic, which uses direct computation for 1-by-1 and 2-by-2 blocks and an inverse scaling-and-squaring algorithm for bigger blocks, with the square roots computed by MatrixBase::sqrt().</p>
<p>Details of the algorithm can be found in Section 11.6.2 of: Nicholas J. Higham, <em>Functions of Matrices: Theory and Computation</em>, SIAM 2008. ISBN 978-0-898716-46-7.</p>
<p>Example: The following program checks that </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \log \left[ \begin{array}{ccc} \frac12\sqrt2 &amp; -\frac12\sqrt2 &amp; 0 \\ \frac12\sqrt2 &amp; \frac12\sqrt2 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{array} \right] = \left[ \begin{array}{ccc} 0 &amp; \frac14\pi &amp; 0 \\ -\frac14\pi &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \end{array} \right]. \]" src="form_21.png"/>
</p>
<p> This corresponds to a rotation of <img class="formulaInl" alt="$ \frac14\pi $" src="form_17.png"/> radians around the z-axis. This is the inverse of the example used in the documentation of <a class="el" href="group__MatrixFunctions__Module.html#matrixbase_exp">exp()</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>Eigen;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using</span> std::sqrt;</div>
<div class="line">  <a class="codeRef" doxygen="eigen.doxytags:..//" href="../classEigen_1_1Matrix.html">MatrixXd</a> A(3,3);</div>
<div class="line">  A &lt;&lt; 0.5*sqrt(2), -0.5*sqrt(2), 0,</div>
<div class="line">       0.5*sqrt(2),  0.5*sqrt(2), 0,</div>
<div class="line">       0,            0,           1;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix A is:\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix logarithm of A is:\n&quot;</span> &lt;&lt; A.log() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output:</p>
<pre class="fragment">The matrix A is:
 0.707107 -0.707107         0
 0.707107  0.707107         0
        0         0         1

The matrix logarithm of A is:
-1.11022e-16    -0.785398            0
    0.785398 -1.11022e-16            0
           0            0            0
</pre><dl class="section note"><dt>Note</dt><dd><code>M</code> has to be a matrix of <code>float</code>, <code>double</code>, <code>long</code> double <code>complex&lt;float&gt;</code>, <code>complex&lt;double&gt;</code>, or <code>complex&lt;long double&gt;</code> .</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>MatrixBase::exp(), MatrixBase::matrixFunction(), class MatrixLogarithmAtomic, MatrixBase::sqrt().</dd></dl>
<h1><a class="anchor" id="matrixbase_matrixfunction"></a>
MatrixBase::matrixFunction()</h1>
<p>Compute a matrix function.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MatrixFunctionReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::matrixFunction(<span class="keyword">typename</span> internal::stem_function&lt;<span class="keyword">typename</span> internal::traits&lt;Derived&gt;::Scalar&gt;::type f) <span class="keyword">const</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>argument of matrix function, should be a square matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>an entire function; <code>f(x,n)</code> should compute the n-th derivative of f at x. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression representing <code>f</code> applied to <code>M</code>.</dd></dl>
<p>Suppose that <code>M</code> is a matrix whose entries have type <code>Scalar</code>. Then, the second argument, <code>f</code>, should be a function with prototype </p>
<div class="fragment"><div class="line">ComplexScalar f(ComplexScalar, <span class="keywordtype">int</span>) </div>
</div><!-- fragment --><p> where <code>ComplexScalar</code> = <code>std::complex&lt;Scalar&gt;</code> if <code>Scalar</code> is real (e.g., <code>float</code> or <code>double</code>) and <code>ComplexScalar</code> = <code>Scalar</code> if <code>Scalar</code> is complex. The return value of <code>f(x,n)</code> should be <img class="formulaInl" alt="$ f^{(n)}(x) $" src="form_22.png"/>, the n-th derivative of f at x.</p>
<p>This routine uses the algorithm described in: Philip Davies and Nicholas J. Higham, "A Schur-Parlett algorithm for computing matrix functions", <em>SIAM J. Matrix Anal. Applic.</em>, <b>25</b>:464&ndash;485, 2003.</p>
<p>The actual work is done by the MatrixFunction class.</p>
<p>Example: The following program checks that </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \exp \left[ \begin{array}{ccc} 0 &amp; \frac14\pi &amp; 0 \\ -\frac14\pi &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \end{array} \right] = \left[ \begin{array}{ccc} \frac12\sqrt2 &amp; -\frac12\sqrt2 &amp; 0 \\ \frac12\sqrt2 &amp; \frac12\sqrt2 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{array} \right]. \]" src="form_16.png"/>
</p>
<p> This corresponds to a rotation of <img class="formulaInl" alt="$ \frac14\pi $" src="form_17.png"/> radians around the z-axis. This is the same example as used in the documentation of <a class="el" href="group__MatrixFunctions__Module.html#matrixbase_exp">exp()</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>Eigen;</div>
<div class="line"></div>
<div class="line">std::complex&lt;double&gt; expfn(std::complex&lt;double&gt; x, <span class="keywordtype">int</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> std::exp(x);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> pi = std::acos(-1.0);</div>
<div class="line"></div>
<div class="line">  <a class="codeRef" doxygen="eigen.doxytags:..//" href="../classEigen_1_1Matrix.html">MatrixXd</a> A(3,3);</div>
<div class="line">  A &lt;&lt; 0,    -pi/4, 0,</div>
<div class="line">       pi/4, 0,     0,</div>
<div class="line">       0,    0,     0;</div>
<div class="line"></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix A is:\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix exponential of A is:\n&quot;</span> </div>
<div class="line">            &lt;&lt; A.matrixFunction(expfn) &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output:</p>
<pre class="fragment">The matrix A is:
        0 -0.785398         0
 0.785398         0         0
        0         0         0

The matrix exponential of A is:
 0.707107 -0.707107         0
 0.707107  0.707107         0
        0         0         1

</pre><p>Note that the function <code>expfn</code> is defined for complex numbers <code>x</code>, even though the matrix <code>A</code> is over the reals. Instead of <code>expfn</code>, we could also have used StdStemFunctions::exp: </p>
<div class="fragment"><div class="line">A.matrixFunction(StdStemFunctions&lt;std::complex&lt;double&gt; &gt;::exp, &amp;B);</div>
</div><!-- fragment --><h1><a class="anchor" id="matrixbase_sin"></a>
MatrixBase::sin()</h1>
<p>Compute the matrix sine.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MatrixFunctionReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::sin() const</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>a square matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression representing <img class="formulaInl" alt="$ \sin(M) $" src="form_23.png"/>.</dd></dl>
<p>This function calls <a class="el" href="group__MatrixFunctions__Module.html#matrixbase_matrixfunction">matrixFunction()</a> with StdStemFunctions::sin().</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>Eigen;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <a class="codeRef" doxygen="eigen.doxytags:..//" href="../classEigen_1_1Matrix.html">MatrixXd</a> A = MatrixXd::Random(3,3);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;A = \n&quot;</span> &lt;&lt; A &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">  <a class="codeRef" doxygen="eigen.doxytags:..//" href="../classEigen_1_1Matrix.html">MatrixXd</a> sinA = A.sin();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;sin(A) = \n&quot;</span> &lt;&lt; sinA &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">  <a class="codeRef" doxygen="eigen.doxytags:..//" href="../classEigen_1_1Matrix.html">MatrixXd</a> cosA = A.cos();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;cos(A) = \n&quot;</span> &lt;&lt; cosA &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// The matrix functions satisfy sin^2(A) + cos^2(A) = I, </span></div>
<div class="line">  <span class="comment">// like the scalar functions.</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;sin^2(A) + cos^2(A) = \n&quot;</span> &lt;&lt; sinA*sinA + cosA*cosA &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output:</p>
<pre class="fragment">A = 
 0.680375   0.59688 -0.329554
-0.211234  0.823295  0.536459
 0.566198 -0.604897 -0.444451

sin(A) = 
 0.679919    0.4579 -0.400612
-0.227278  0.821913    0.5358
 0.570141 -0.676728 -0.462398

cos(A) = 
 0.927728 -0.530361 -0.110482
0.00969246  0.889022 -0.137604
-0.132574  -0.04289   1.16475

sin^2(A) + cos^2(A) = 
           1  5.55112e-16  6.38378e-16
 7.63278e-16            1  3.33067e-16
-1.66533e-16 -5.89806e-16            1

</pre><h1><a class="anchor" id="matrixbase_sinh"></a>
MatrixBase::sinh()</h1>
<p>Compute the matrix hyperbolic sine.</p>
<div class="fragment"><div class="line">MatrixFunctionReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::sinh() const</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>a square matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression representing <img class="formulaInl" alt="$ \sinh(M) $" src="form_24.png"/></dd></dl>
<p>This function calls <a class="el" href="group__MatrixFunctions__Module.html#matrixbase_matrixfunction">matrixFunction()</a> with StdStemFunctions::sinh().</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>Eigen;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <a class="codeRef" doxygen="eigen.doxytags:..//" href="../classEigen_1_1Matrix.html">MatrixXf</a> A = MatrixXf::Random(3,3);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;A = \n&quot;</span> &lt;&lt; A &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">  <a class="codeRef" doxygen="eigen.doxytags:..//" href="../classEigen_1_1Matrix.html">MatrixXf</a> sinhA = A.sinh();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;sinh(A) = \n&quot;</span> &lt;&lt; sinhA &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">  <a class="codeRef" doxygen="eigen.doxytags:..//" href="../classEigen_1_1Matrix.html">MatrixXf</a> coshA = A.cosh();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;cosh(A) = \n&quot;</span> &lt;&lt; coshA &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// The matrix functions satisfy cosh^2(A) - sinh^2(A) = I, </span></div>
<div class="line">  <span class="comment">// like the scalar functions.</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;cosh^2(A) - sinh^2(A) = \n&quot;</span> &lt;&lt; coshA*coshA - sinhA*sinhA &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output:</p>
<pre class="fragment">A = 
 0.680375   0.59688 -0.329554
-0.211234  0.823295  0.536459
 0.566198 -0.604897 -0.444451

sinh(A) = 
 0.682534  0.739989 -0.256871
-0.194928  0.826512  0.537546
 0.562584  -0.53163 -0.425199

cosh(A) = 
  1.07817  0.567068  0.132125
-0.0041862   1.11649  0.135361
 0.128891 0.0659989  0.851201

cosh^2(A) - sinh^2(A) = 
           1 -5.96046e-07 -2.98023e-08
-6.79865e-08            1 -2.98023e-08
 1.49012e-08 -3.42727e-07            1

</pre><h1><a class="anchor" id="matrixbase_sqrt"></a>
MatrixBase::sqrt()</h1>
<p>Compute the matrix square root.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MatrixSquareRootReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::sqrt() const</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>invertible matrix whose square root is to be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression representing the matrix square root of <code>M</code>.</dd></dl>
<p>The matrix square root of <img class="formulaInl" alt="$ M $" src="form_9.png"/> is the matrix <img class="formulaInl" alt="$ M^{1/2} $" src="form_25.png"/> whose square is the original matrix; so if <img class="formulaInl" alt="$ S = M^{1/2} $" src="form_26.png"/> then <img class="formulaInl" alt="$ S^2 = M $" src="form_27.png"/>.</p>
<p>In the <b>real case</b>, the matrix <img class="formulaInl" alt="$ M $" src="form_9.png"/> should be invertible and it should have no eigenvalues which are real and negative (pairs of complex conjugate eigenvalues are allowed). In that case, the matrix has a square root which is also real, and this is the square root computed by this function.</p>
<p>The matrix square root is computed by first reducing the matrix to quasi-triangular form with the real Schur decomposition. The square root of the quasi-triangular matrix can then be computed directly. The cost is approximately <img class="formulaInl" alt="$ 25 n^3 $" src="form_28.png"/> real flops for the real Schur decomposition and <img class="formulaInl" alt="$ 3\frac13 n^3 $" src="form_29.png"/> real flops for the remainder (though the computation time in practice is likely more than this indicates).</p>
<p>Details of the algorithm can be found in: Nicholas J. Highan, "Computing real square roots of a real matrix", <em>Linear Algebra Appl.</em>, 88/89:405&ndash;430, 1987.</p>
<p>If the matrix is <b>positive-definite symmetric</b>, then the square root is also positive-definite symmetric. In this case, it is best to use SelfAdjointEigenSolver::operatorSqrt() to compute it.</p>
<p>In the <b>complex case</b>, the matrix <img class="formulaInl" alt="$ M $" src="form_9.png"/> should be invertible; this is a restriction of the algorithm. The square root computed by this algorithm is the one whose eigenvalues have an argument in the interval <img class="formulaInl" alt="$ (-\frac12\pi, \frac12\pi] $" src="form_30.png"/>. This is the usual branch cut.</p>
<p>The computation is the same as in the real case, except that the complex Schur decomposition is used to reduce the matrix to a triangular matrix. The theoretical cost is the same. Details are in: &Aring;ke Bj&ouml;rck and Sven Hammarling, "A Schur method for the
square root of a matrix", <em>Linear Algebra Appl.</em>, 52/53:127&ndash;140, 1983.</p>
<p>Example: The following program checks that the square root of </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left[ \begin{array}{cc} \cos(\frac13\pi) &amp; -\sin(\frac13\pi) \\ \sin(\frac13\pi) &amp; \cos(\frac13\pi) \end{array} \right], \]" src="form_31.png"/>
</p>
<p> corresponding to a rotation over 60 degrees, is a rotation over 30 degrees: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left[ \begin{array}{cc} \cos(\frac16\pi) &amp; -\sin(\frac16\pi) \\ \sin(\frac16\pi) &amp; \cos(\frac16\pi) \end{array} \right]. \]" src="form_32.png"/>
</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>Eigen;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> pi = std::acos(-1.0);</div>
<div class="line"></div>
<div class="line">  <a class="codeRef" doxygen="eigen.doxytags:..//" href="../classEigen_1_1Matrix.html">MatrixXd</a> A(2,2);</div>
<div class="line">  A &lt;&lt; cos(pi/3), -sin(pi/3), </div>
<div class="line">       sin(pi/3),  cos(pi/3);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix A is:\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix square root of A is:\n&quot;</span> &lt;&lt; A.sqrt() &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The square of the last matrix is:\n&quot;</span> &lt;&lt; A.sqrt() * A.sqrt() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output:</p>
<pre class="fragment">The matrix A is:
      0.5 -0.866025
 0.866025       0.5

The matrix square root of A is:
0.866025     -0.5
     0.5 0.866025

The square of the last matrix is:
      0.5 -0.866025
 0.866025       0.5
</pre><dl class="section see"><dt>See Also</dt><dd>class RealSchur, class ComplexSchur, class MatrixSquareRoot, SelfAdjointEigenSolver::operatorSqrt(). </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 15 2013 06:38:00 for Eigen-unsupportedmodules by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
