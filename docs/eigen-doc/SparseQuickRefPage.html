<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Quick reference guide for sparse matrices</title>
<link href="eigendoxy_tabs.css" rel="stylesheet" type="text/css">
<link href="$relpath/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="$relpath/search.js"></script>
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
</head>
<body onload='searchBox.OnSelectItem(0);'>
<a name="top"></a>
<a class="logo" href="http://eigen.tuxfamily.org/">
<img class="logo" src="Eigen_Silly_Professor_64x64.png" width=64 height=64 alt="Eigen's silly professor"/></a>
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Quick reference guide for sparse matrices </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Table</b> <b>of</b> <b>contents</b> </p>
<ul>
<li><a class="el" href="SparseQuickRefPage.html#Constructors">Constructors and assignments</a></li>
<li><a class="el" href="SparseQuickRefPage.html#SparseMatrixInsertion">Allocating and inserting values</a></li>
<li><a class="el" href="SparseQuickRefPage.html#SparseBasicInfos">Matrix properties</a></li>
<li><a class="el" href="SparseQuickRefPage.html#SparseBasicOps">Arithmetic operations</a></li>
<li><a class="el" href="SparseQuickRefPage.html#SparseInterops">Low-level storage</a></li>
<li><a class="el" href="SparseQuickRefPage.html#sparsepermutation">Permutations, submatrices and Selfadjoint Views</a></li>
<li><a class="el" href="SparseQuickRefPage.html#sparsesubmatrices">Sub-matrices</a></li>
<li><a class="el" href="SparseQuickRefPage.html#sparseselfadjointview">Sparse triangular and selfadjoint Views</a> <br/>
</li>
</ul>
<hr/>
<p>In this page, we give a quick summary of the main operations available for sparse matrices in the class <a class="el" href="classEigen_1_1SparseMatrix.html" title="A versatible sparse matrix representation.">SparseMatrix</a>. First, it is recommended to read first the introductory tutorial at <a class="el" href="TutorialSparse.html">Tutorial page 9 - Sparse Matrix</a>. The important point to have in mind when working on sparse matrices is how they are stored : i.e either row major or column major. The default is column major. Most arithmetic operations on sparse matrices will assert that they have the same storage order. Moreover, when interacting with external libraries that are not yet supported by <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>, it is important to know how to send the required matrix pointers.</p>
<h1><a class="anchor" id="Constructors"></a>
Constructors and assignments</h1>
<p><a class="el" href="classEigen_1_1SparseMatrix.html" title="A versatible sparse matrix representation.">SparseMatrix</a> is the core class to build and manipulate sparse matrices in <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>. It takes as template parameters the Scalar type and the storage order, either RowMajor or ColumnMajor. The default is ColumnMajor.</p>
<div class="fragment"><div class="line">SparseMatrix&lt;double&gt; sm1(1000,1000);              <span class="comment">// 1000x1000 compressed sparse matrix of double. </span></div>
<div class="line">SparseMatrix&lt;std::complex&lt;double&gt;,<a class="code" href="group__enums.html#ggab59c1bec446b10af208f977a871d910ba1e16fa1b92ed7a058cd4ce7a9a0db044">RowMajor</a>&gt; sm2; <span class="comment">// Compressed row major matrix of complex double.</span></div>
</div><!-- fragment --><p> The copy constructor and assignment can be used to convert matrices from a storage order to another </p>
<div class="fragment"><div class="line">SparseMatrix&lt;double,Colmajor&gt; sm1;</div>
<div class="line"><span class="comment">// Eventually fill the matrix sm1 ...</span></div>
<div class="line">SparseMatrix&lt;double,Rowmajor&gt; sm2(sm1), sm3;         <span class="comment">// Initialize sm2 with sm1.</span></div>
<div class="line">sm3 = sm1; <span class="comment">// Assignment and evaluations modify the storage order.</span></div>
</div><!-- fragment --><h1><a class="anchor" id="SparseMatrixInsertion"></a>
Allocating and inserting values</h1>
<p>resize() and reserve() are used to set the size and allocate space for nonzero elements </p>
<div class="fragment"><div class="line">sm1.resize(m,n);      <span class="comment">//Change sm to a mxn matrix. </span></div>
<div class="line">sm1.reserve(nnz);     <span class="comment">// Allocate  room for nnz nonzeros elements.   </span></div>
</div><!-- fragment --><p> Note that when calling reserve(), it is not required that nnz is the exact number of nonzero elements in the final matrix. However, an exact estimation will avoid multiple reallocations during the insertion phase.</p>
<p>Insertions of values in the sparse matrix can be done directly by looping over nonzero elements and use the insert() function </p>
<div class="fragment"><div class="line"><span class="comment">// Direct insertion of the value v_ij; </span></div>
<div class="line">  sm1.insert(i, j) = v_ij;   <span class="comment">// It is assumed that v_ij does not already exist in the matrix. </span></div>
</div><!-- fragment --><p>After insertion, a value at (i,j) can be modified using coeffRef() </p>
<div class="fragment"><div class="line"><span class="comment">// Update the value v_ij</span></div>
<div class="line">sm1.coeffRef(i,j) = v_ij;</div>
<div class="line">sm1.coeffRef(i,j) += v_ij;</div>
<div class="line">sm1.coeffRef(i,j) -= v_ij;</div>
<div class="line">...</div>
</div><!-- fragment --><p>The recommended way to insert values is to build a list of triplets (row, col, val) and then call setFromTriplets(). </p>
<div class="fragment"><div class="line">sm1.setFromTriplets(TripletList.begin(), TripletList.end());</div>
</div><!-- fragment --><p> A complete example is available at <a class="el" href="TutorialSparse.html#TutorialSparseFilling">Filling a sparse matrix</a>.</p>
<p>The following functions can be used to set constant or random values in the matrix. </p>
<div class="fragment"><div class="line">sm1.setZero(); <span class="comment">// Reset the matrix with zero elements</span></div>
<div class="line">...</div>
</div><!-- fragment --><h1><a class="anchor" id="SparseBasicInfos"></a>
Matrix properties</h1>
<p>Beyond the functions rows() and cols() that are used to get the number of rows and columns, there are some useful functions that are available to easily get some informations from the matrix. </p>
<table  class="manual">
<tr>
<td><div class="fragment"><div class="line">sm1.rows();         <span class="comment">// Number of rows</span></div>
<div class="line">sm1.cols();         <span class="comment">// Number of columns </span></div>
<div class="line">sm1.nonZeros();     <span class="comment">// Number of non zero values   </span></div>
<div class="line">sm1.outerSize();    <span class="comment">// Number of columns (resp. rows) for a column major (resp. row major )</span></div>
<div class="line">sm1.innerSize();    <span class="comment">// Number of rows (resp. columns) for a row major (resp. column major)</span></div>
<div class="line">sm1.norm();         <span class="comment">// (Euclidian ??) norm of the matrix</span></div>
<div class="line">sm1.squaredNorm();  <span class="comment">// </span></div>
<div class="line">sm1.isVector();     <span class="comment">// Check if sm1 is a sparse vector or a sparse matrix</span></div>
<div class="line">...</div>
</div><!-- fragment -->   </td></tr>
</table>
<h1><a class="anchor" id="SparseBasicOps"></a>
Arithmetic operations</h1>
<p>It is easy to perform arithmetic operations on sparse matrices provided that the dimensions are adequate and that the matrices have the same storage order. Note that the evaluation can always be done in a matrix with a different storage order. </p>
<table  class="manual">
<tr>
<th>Operations  </th><th>Code  </th><th><p class="starttd">Notes </p>
<p class="endtd"></p>
</th></tr>
<tr>
<td>add subtract  </td><td><div class="fragment"><div class="line">sm3 = sm1 + sm2; </div>
<div class="line">sm3 = sm1 - sm2;</div>
<div class="line">sm2 += sm1; </div>
<div class="line">sm2 -= sm1; </div>
</div><!-- fragment -->  </td><td><p class="starttd">sm1 and sm2 should have the same storage order  </p>
<p class="endtd"></p>
</td></tr>
<tr class="alt">
<td>scalar product</td><td><div class="fragment"><div class="line">sm3 = sm1 * s1;   sm3 *= s1; </div>
<div class="line">sm3 = s1 * sm1 + s2 * sm2; sm3 /= s1;</div>
</div><!-- fragment -->  </td><td><p class="starttd">Many combinations are possible if the dimensions and the storage order agree. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><a class="el" href="classProduct.html" title="Expression of the product of two arbitrary matrices or vectors.">Product</a>  </td><td><div class="fragment"><div class="line">sm3 = sm1 * sm2;</div>
<div class="line">dm2 = sm1 * dm1;</div>
<div class="line">dv2 = sm1 * dv1;</div>
</div><!-- fragment -->  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr class="alt">
<td>transposition, adjoint </td><td><div class="fragment"><div class="line">sm2 = sm1.transpose();</div>
<div class="line">sm2 = sm1.adjoint();</div>
</div><!-- fragment -->  </td><td><p class="starttd">Note that the transposition change the storage order. There is no support for transposeInPlace().  </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Component-wise ops  </td><td><div class="fragment"><div class="line">sm1.cwiseProduct(sm2);</div>
<div class="line">sm1.cwiseQuotient(sm2);</div>
<div class="line">sm1.cwiseMin(sm2);</div>
<div class="line">sm1.cwiseMax(sm2);</div>
<div class="line">sm1.cwiseAbs();</div>
<div class="line">sm1.cwiseSqrt();</div>
</div><!-- fragment --> </td><td>sm1 and sm2 should have the same storage order   </td></tr>
</table>
<h1><a class="anchor" id="SparseInterops"></a>
Low-level storage</h1>
<p>There are a set of low-levels functions to get the standard compressed storage pointers. The matrix should be in compressed mode which can be checked by calling isCompressed(); makeCompressed() should do the job otherwise. </p>
<div class="fragment"><div class="line"><span class="comment">// Scalar pointer to the values of the matrix, size nnz</span></div>
<div class="line">sm1.valuePtr();  </div>
<div class="line"><span class="comment">// Index pointer to get the row indices (resp. column indices) for column major (resp. row major) matrix, size nnz</span></div>
<div class="line">sm1.innerIndexPtr();</div>
<div class="line"><span class="comment">// Index pointer to the beginning of each row (resp. column) in valuePtr() and innerIndexPtr() for column major (row major). The size is outersize()+1; </span></div>
<div class="line">sm1.outerIndexPtr();  </div>
</div><!-- fragment --><p> These pointers can therefore be easily used to send the matrix to some external libraries/solvers that are not yet supported by <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>.</p>
<h1><a class="anchor" id="sparsepermutation"></a>
Permutations, submatrices and Selfadjoint Views</h1>
<p>In many cases, it is necessary to reorder the rows and/or the columns of the sparse matrix for several purposes : fill-in reducing during matrix decomposition, better data locality for sparse matrix-vector products... The class <a class="el" href="classEigen_1_1PermutationMatrix.html" title="Permutation matrix.">PermutationMatrix</a> is available to this end. </p>
<div class="fragment"><div class="line">PermutationMatrix&lt;Dynamic, Dynamic, int&gt; perm;</div>
<div class="line"><span class="comment">// Reserve and fill the values of perm; </span></div>
<div class="line">perm.inverse(n); <span class="comment">// Compute eventually the inverse permutation</span></div>
<div class="line">sm1.twistedBy(perm) <span class="comment">//Apply the permutation on rows and columns </span></div>
<div class="line">sm2 = sm1 * perm; <span class="comment">// ??? Apply the permutation on columns ???; </span></div>
<div class="line">sm2 = perm * sm1; <span class="comment">// ??? Apply the permutation on rows ???; </span></div>
</div><!-- fragment --><h1><a class="anchor" id="sparsesubmatrices"></a>
Sub-matrices</h1>
<p>The following functions are useful to extract a block of rows (resp. columns) from a row-major (resp. column major) sparse matrix. Note that because of the particular storage, it is not ?? efficient ?? to extract a submatrix comprising a certain number of subrows and subcolumns. </p>
<div class="fragment"><div class="line">sm1.innerVector(outer); <span class="comment">// Returns the outer -th column (resp. row) of the matrix if sm is col-major (resp. row-major)</span></div>
<div class="line">sm1.innerVectors(outer); <span class="comment">// Returns the outer -th column (resp. row) of the matrix if mat is col-major (resp. row-major)</span></div>
<div class="line">sm1.middleRows(start, numRows); <span class="comment">// For row major matrices, get a range of numRows rows</span></div>
<div class="line">sm1.middleCols(start, numCols); <span class="comment">// For column major matrices, get a range of numCols cols</span></div>
</div><!-- fragment --><p> Examples :</p>
<h1><a class="anchor" id="sparseselfadjointview"></a>
Sparse triangular and selfadjoint Views</h1>
<div class="fragment"><div class="line">sm2 = sm1.triangularview&lt;<a class="code" href="group__enums.html#ggaa3dfb65ce3006aaab287357097352604af886b397626076218462d53d50eb96bc">Lower</a>&gt;(); <span class="comment">// Get the lower triangular part of the matrix. </span></div>
<div class="line">dv2 = sm1.triangularView&lt;<a class="code" href="group__enums.html#ggaa3dfb65ce3006aaab287357097352604ae70afef0d3ff7aca74e17e85ff6c9f2e">Upper</a>&gt;().solve(dv1); <span class="comment">// Solve the linear system with the uppper triangular part. </span></div>
<div class="line">sm2 = sm1.selfadjointview&lt;<a class="code" href="group__enums.html#ggaa3dfb65ce3006aaab287357097352604af886b397626076218462d53d50eb96bc">Lower</a>&gt;(); <span class="comment">// Build a selfadjoint matrix from the lower part of sm1. </span></div>
</div><!-- fragment --> </div></div><!-- contents -->
<hr class="footer"/>
<!-- Piwik --> 
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ? "https://stats.sylphide-consulting.com/piwik/" : "http://stats.sylphide-consulting.com/piwik/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 20);
piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
</script><noscript><p><img src="http://stats.sylphide-consulting.com/piwik/piwik.php?idsite=20" style="border:0" alt="" /></p></noscript>
<!-- End Piwik Tracking Code -->
</body>
</html>
