<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.54+ (gsl)
     from /home/bjg/gsl.redhat/doc/gsl-ref.texi -->

<TITLE>GNU Scientific Library -- Reference Manual</TITLE>
<!-- <LINK rel="stylesheet" title="Default Style Sheet" href="/css/texinfo.css" type="text/css"> -->

</HEAD>
<BODY>
<H1>GNU Scientific Library</H1>
<H2>Reference Manual</H2>
<H2>Edition 1.7, for GSL Version 1.7</H2>
<H2>13 September 2005</H2>
<ADDRESS>Mark Galassi </ADDRESS>
<ADDRESS>Jim Davies </ADDRESS>
<ADDRESS>James Theiler </ADDRESS>
<ADDRESS>Brian Gough </ADDRESS>
<ADDRESS>Gerard Jungman </ADDRESS>
<ADDRESS>Michael Booth</ADDRESS>
<ADDRESS>Fabrice Rossi</ADDRESS>
<P>
<P><HR><P>
<H1>Table of Contents</H1>
<UL>
<LI><A NAME="TOC1" HREF="gsl_manual.html#SEC1">Introduction</A>
<UL>
<LI><A NAME="TOC2" HREF="gsl_manual.html#SEC2">Routines available in GSL</A>
<LI><A NAME="TOC3" HREF="gsl_manual.html#SEC3">GSL is Free Software</A>
<LI><A NAME="TOC4" HREF="gsl_manual.html#SEC4">Obtaining GSL</A>
<LI><A NAME="TOC5" HREF="gsl_manual.html#SEC5">No Warranty</A>
<LI><A NAME="TOC6" HREF="gsl_manual.html#SEC6">Reporting Bugs</A>
<LI><A NAME="TOC7" HREF="gsl_manual.html#SEC7">Further Information</A>
<LI><A NAME="TOC8" HREF="gsl_manual.html#SEC8">Conventions used in this manual</A>
</UL>
<LI><A NAME="TOC9" HREF="gsl_manual.html#SEC9">Using the library</A>
<UL>
<LI><A NAME="TOC10" HREF="gsl_manual.html#SEC10">An Example Program</A>
<LI><A NAME="TOC11" HREF="gsl_manual.html#SEC11">Compiling and Linking</A>
<UL>
<LI><A NAME="TOC12" HREF="gsl_manual.html#SEC12">Linking programs with the library</A>
<LI><A NAME="TOC13" HREF="gsl_manual.html#SEC13">Linking with an alternative BLAS library</A>
</UL>
<LI><A NAME="TOC14" HREF="gsl_manual.html#SEC14">Shared Libraries</A>
<LI><A NAME="TOC15" HREF="gsl_manual.html#SEC15">ANSI C Compliance</A>
<LI><A NAME="TOC16" HREF="gsl_manual.html#SEC16">Inline functions</A>
<LI><A NAME="TOC17" HREF="gsl_manual.html#SEC17">Long double</A>
<LI><A NAME="TOC18" HREF="gsl_manual.html#SEC18">Portability functions</A>
<LI><A NAME="TOC19" HREF="gsl_manual.html#SEC19">Alternative optimized functions</A>
<LI><A NAME="TOC20" HREF="gsl_manual.html#SEC20">Support for different numeric types</A>
<LI><A NAME="TOC21" HREF="gsl_manual.html#SEC21">Compatibility with C++</A>
<LI><A NAME="TOC22" HREF="gsl_manual.html#SEC22">Aliasing of arrays</A>
<LI><A NAME="TOC23" HREF="gsl_manual.html#SEC23">Thread-safety</A>
<LI><A NAME="TOC24" HREF="gsl_manual.html#SEC24">Deprecated Functions</A>
<LI><A NAME="TOC25" HREF="gsl_manual.html#SEC25">Code Reuse</A>
</UL>
<LI><A NAME="TOC26" HREF="gsl_manual.html#SEC26">Error Handling</A>
<UL>
<LI><A NAME="TOC27" HREF="gsl_manual.html#SEC27">Error Reporting</A>
<LI><A NAME="TOC28" HREF="gsl_manual.html#SEC28">Error Codes</A>
<LI><A NAME="TOC29" HREF="gsl_manual.html#SEC29">Error Handlers</A>
<LI><A NAME="TOC30" HREF="gsl_manual.html#SEC30">Using GSL error reporting in your own functions</A>
<LI><A NAME="TOC31" HREF="gsl_manual.html#SEC31">Examples</A>
</UL>
<LI><A NAME="TOC32" HREF="gsl_manual.html#SEC32">Mathematical Functions</A>
<UL>
<LI><A NAME="TOC33" HREF="gsl_manual.html#SEC33">Mathematical Constants</A>
<LI><A NAME="TOC34" HREF="gsl_manual.html#SEC34">Infinities and Not-a-number</A>
<LI><A NAME="TOC35" HREF="gsl_manual.html#SEC35">Elementary Functions</A>
<LI><A NAME="TOC36" HREF="gsl_manual.html#SEC36">Small integer powers</A>
<LI><A NAME="TOC37" HREF="gsl_manual.html#SEC37">Testing the Sign of Numbers</A>
<LI><A NAME="TOC38" HREF="gsl_manual.html#SEC38">Testing for Odd and Even Numbers</A>
<LI><A NAME="TOC39" HREF="gsl_manual.html#SEC39">Maximum and Minimum functions</A>
<LI><A NAME="TOC40" HREF="gsl_manual.html#SEC40">Approximate Comparison of Floating Point Numbers</A>
</UL>
<LI><A NAME="TOC41" HREF="gsl_manual.html#SEC41">Complex Numbers</A>
<UL>
<LI><A NAME="TOC42" HREF="gsl_manual.html#SEC42">Complex numbers</A>
<LI><A NAME="TOC43" HREF="gsl_manual.html#SEC43">Properties of complex numbers</A>
<LI><A NAME="TOC44" HREF="gsl_manual.html#SEC44">Complex arithmetic operators</A>
<LI><A NAME="TOC45" HREF="gsl_manual.html#SEC45">Elementary Complex Functions</A>
<LI><A NAME="TOC46" HREF="gsl_manual.html#SEC46">Complex Trigonometric Functions</A>
<LI><A NAME="TOC47" HREF="gsl_manual.html#SEC47">Inverse Complex Trigonometric Functions</A>
<LI><A NAME="TOC48" HREF="gsl_manual.html#SEC48">Complex Hyperbolic Functions</A>
<LI><A NAME="TOC49" HREF="gsl_manual.html#SEC49">Inverse Complex Hyperbolic Functions</A>
<LI><A NAME="TOC50" HREF="gsl_manual.html#SEC50">References and Further Reading</A>
</UL>
<LI><A NAME="TOC51" HREF="gsl_manual.html#SEC51">Polynomials</A>
<UL>
<LI><A NAME="TOC52" HREF="gsl_manual.html#SEC52">Polynomial Evaluation</A>
<LI><A NAME="TOC53" HREF="gsl_manual.html#SEC53">Divided Difference Representation of Polynomials</A>
<LI><A NAME="TOC54" HREF="gsl_manual.html#SEC54">Quadratic Equations</A>
<LI><A NAME="TOC55" HREF="gsl_manual.html#SEC55">Cubic Equations</A>
<LI><A NAME="TOC56" HREF="gsl_manual.html#SEC56">General Polynomial Equations</A>
<LI><A NAME="TOC57" HREF="gsl_manual.html#SEC57">Examples</A>
<LI><A NAME="TOC58" HREF="gsl_manual.html#SEC58">References and Further Reading</A>
</UL>
<LI><A NAME="TOC59" HREF="gsl_manual.html#SEC59">Special Functions</A>
<UL>
<LI><A NAME="TOC60" HREF="gsl_manual.html#SEC60">Usage</A>
<LI><A NAME="TOC61" HREF="gsl_manual.html#SEC61">The gsl_sf_result struct</A>
<LI><A NAME="TOC62" HREF="gsl_manual.html#SEC62">Modes</A>
<LI><A NAME="TOC63" HREF="gsl_manual.html#SEC63">Airy Functions and Derivatives</A>
<UL>
<LI><A NAME="TOC64" HREF="gsl_manual.html#SEC64">Airy Functions</A>
<LI><A NAME="TOC65" HREF="gsl_manual.html#SEC65">Derivatives of Airy Functions</A>
<LI><A NAME="TOC66" HREF="gsl_manual.html#SEC66">Zeros of Airy Functions</A>
<LI><A NAME="TOC67" HREF="gsl_manual.html#SEC67">Zeros of Derivatives of Airy Functions</A>
</UL>
<LI><A NAME="TOC68" HREF="gsl_manual.html#SEC68">Bessel Functions</A>
<UL>
<LI><A NAME="TOC69" HREF="gsl_manual.html#SEC69">Regular Cylindrical Bessel Functions</A>
<LI><A NAME="TOC70" HREF="gsl_manual.html#SEC70">Irregular Cylindrical Bessel Functions</A>
<LI><A NAME="TOC71" HREF="gsl_manual.html#SEC71">Regular Modified Cylindrical Bessel Functions</A>
<LI><A NAME="TOC72" HREF="gsl_manual.html#SEC72">Irregular Modified Cylindrical Bessel Functions</A>
<LI><A NAME="TOC73" HREF="gsl_manual.html#SEC73">Regular Spherical Bessel Functions</A>
<LI><A NAME="TOC74" HREF="gsl_manual.html#SEC74">Irregular Spherical Bessel Functions</A>
<LI><A NAME="TOC75" HREF="gsl_manual.html#SEC75">Regular Modified Spherical Bessel Functions</A>
<LI><A NAME="TOC76" HREF="gsl_manual.html#SEC76">Irregular Modified Spherical Bessel Functions</A>
<LI><A NAME="TOC77" HREF="gsl_manual.html#SEC77">Regular Bessel Function--Fractional Order</A>
<LI><A NAME="TOC78" HREF="gsl_manual.html#SEC78">Irregular Bessel Functions--Fractional Order</A>
<LI><A NAME="TOC79" HREF="gsl_manual.html#SEC79">Regular Modified Bessel Functions--Fractional Order</A>
<LI><A NAME="TOC80" HREF="gsl_manual.html#SEC80">Irregular Modified Bessel Functions--Fractional Order</A>
<LI><A NAME="TOC81" HREF="gsl_manual.html#SEC81">Zeros of Regular Bessel Functions</A>
</UL>
<LI><A NAME="TOC82" HREF="gsl_manual.html#SEC82">Clausen Functions</A>
<LI><A NAME="TOC83" HREF="gsl_manual.html#SEC83">Coulomb Functions</A>
<UL>
<LI><A NAME="TOC84" HREF="gsl_manual.html#SEC84">Normalized Hydrogenic Bound States</A>
<LI><A NAME="TOC85" HREF="gsl_manual.html#SEC85">Coulomb Wave Functions</A>
<LI><A NAME="TOC86" HREF="gsl_manual.html#SEC86">Coulomb Wave Function Normalization Constant</A>
</UL>
<LI><A NAME="TOC87" HREF="gsl_manual.html#SEC87">Coupling Coefficients</A>
<UL>
<LI><A NAME="TOC88" HREF="gsl_manual.html#SEC88">3-j Symbols</A>
<LI><A NAME="TOC89" HREF="gsl_manual.html#SEC89">6-j Symbols</A>
<LI><A NAME="TOC90" HREF="gsl_manual.html#SEC90">9-j Symbols</A>
</UL>
<LI><A NAME="TOC91" HREF="gsl_manual.html#SEC91">Dawson Function</A>
<LI><A NAME="TOC92" HREF="gsl_manual.html#SEC92">Debye Functions</A>
<LI><A NAME="TOC93" HREF="gsl_manual.html#SEC93">Dilogarithm</A>
<UL>
<LI><A NAME="TOC94" HREF="gsl_manual.html#SEC94">Real Argument</A>
<LI><A NAME="TOC95" HREF="gsl_manual.html#SEC95">Complex Argument</A>
</UL>
<LI><A NAME="TOC96" HREF="gsl_manual.html#SEC96">Elementary Operations</A>
<LI><A NAME="TOC97" HREF="gsl_manual.html#SEC97">Elliptic Integrals</A>
<UL>
<LI><A NAME="TOC98" HREF="gsl_manual.html#SEC98">Definition of Legendre Forms</A>
<LI><A NAME="TOC99" HREF="gsl_manual.html#SEC99">Definition of Carlson Forms</A>
<LI><A NAME="TOC100" HREF="gsl_manual.html#SEC100">Legendre Form of Complete Elliptic Integrals</A>
<LI><A NAME="TOC101" HREF="gsl_manual.html#SEC101">Legendre Form of Incomplete Elliptic Integrals</A>
<LI><A NAME="TOC102" HREF="gsl_manual.html#SEC102">Carlson Forms</A>
</UL>
<LI><A NAME="TOC103" HREF="gsl_manual.html#SEC103">Elliptic Functions (Jacobi)</A>
<LI><A NAME="TOC104" HREF="gsl_manual.html#SEC104">Error Functions</A>
<UL>
<LI><A NAME="TOC105" HREF="gsl_manual.html#SEC105">Error Function</A>
<LI><A NAME="TOC106" HREF="gsl_manual.html#SEC106">Complementary Error Function</A>
<LI><A NAME="TOC107" HREF="gsl_manual.html#SEC107">Log Complementary Error Function</A>
<LI><A NAME="TOC108" HREF="gsl_manual.html#SEC108">Probability functions</A>
</UL>
<LI><A NAME="TOC109" HREF="gsl_manual.html#SEC109">Exponential Functions</A>
<UL>
<LI><A NAME="TOC110" HREF="gsl_manual.html#SEC110">Exponential Function</A>
<LI><A NAME="TOC111" HREF="gsl_manual.html#SEC111">Relative Exponential Functions</A>
<LI><A NAME="TOC112" HREF="gsl_manual.html#SEC112">Exponentiation With Error Estimate</A>
</UL>
<LI><A NAME="TOC113" HREF="gsl_manual.html#SEC113">Exponential Integrals</A>
<UL>
<LI><A NAME="TOC114" HREF="gsl_manual.html#SEC114">Exponential Integral</A>
<LI><A NAME="TOC115" HREF="gsl_manual.html#SEC115">Ei(x)</A>
<LI><A NAME="TOC116" HREF="gsl_manual.html#SEC116">Hyperbolic Integrals</A>
<LI><A NAME="TOC117" HREF="gsl_manual.html#SEC117">Ei_3(x)</A>
<LI><A NAME="TOC118" HREF="gsl_manual.html#SEC118">Trigonometric Integrals</A>
<LI><A NAME="TOC119" HREF="gsl_manual.html#SEC119">Arctangent Integral</A>
</UL>
<LI><A NAME="TOC120" HREF="gsl_manual.html#SEC120">Fermi-Dirac Function</A>
<UL>
<LI><A NAME="TOC121" HREF="gsl_manual.html#SEC121">Complete Fermi-Dirac Integrals</A>
<LI><A NAME="TOC122" HREF="gsl_manual.html#SEC122">Incomplete Fermi-Dirac Integrals</A>
</UL>
<LI><A NAME="TOC123" HREF="gsl_manual.html#SEC123">Gamma and Beta Functions</A>
<LI><A NAME="TOC124" HREF="gsl_manual.html#SEC124">Gegenbauer Functions</A>
<LI><A NAME="TOC125" HREF="gsl_manual.html#SEC125">Hypergeometric Functions</A>
<LI><A NAME="TOC126" HREF="gsl_manual.html#SEC126">Laguerre Functions</A>
<LI><A NAME="TOC127" HREF="gsl_manual.html#SEC127">Lambert W Functions</A>
<LI><A NAME="TOC128" HREF="gsl_manual.html#SEC128">Legendre Functions and Spherical Harmonics</A>
<UL>
<LI><A NAME="TOC129" HREF="gsl_manual.html#SEC129">Legendre Polynomials</A>
<LI><A NAME="TOC130" HREF="gsl_manual.html#SEC130">Associated Legendre Polynomials and Spherical Harmonics</A>
<LI><A NAME="TOC131" HREF="gsl_manual.html#SEC131">Conical Functions</A>
<LI><A NAME="TOC132" HREF="gsl_manual.html#SEC132">Radial Functions for Hyperbolic Space</A>
</UL>
<LI><A NAME="TOC133" HREF="gsl_manual.html#SEC133">Logarithm and Related Functions</A>
<LI><A NAME="TOC134" HREF="gsl_manual.html#SEC134">Power Function</A>
<LI><A NAME="TOC135" HREF="gsl_manual.html#SEC135">Psi (Digamma) Function</A>
<UL>
<LI><A NAME="TOC136" HREF="gsl_manual.html#SEC136">Digamma Function</A>
<LI><A NAME="TOC137" HREF="gsl_manual.html#SEC137">Trigamma Function</A>
<LI><A NAME="TOC138" HREF="gsl_manual.html#SEC138">Polygamma Function</A>
</UL>
<LI><A NAME="TOC139" HREF="gsl_manual.html#SEC139">Synchrotron Functions</A>
<LI><A NAME="TOC140" HREF="gsl_manual.html#SEC140">Transport Functions</A>
<LI><A NAME="TOC141" HREF="gsl_manual.html#SEC141">Trigonometric Functions</A>
<UL>
<LI><A NAME="TOC142" HREF="gsl_manual.html#SEC142">Circular Trigonometric Functions</A>
<LI><A NAME="TOC143" HREF="gsl_manual.html#SEC143">Trigonometric Functions for Complex Arguments</A>
<LI><A NAME="TOC144" HREF="gsl_manual.html#SEC144">Hyperbolic Trigonometric Functions</A>
<LI><A NAME="TOC145" HREF="gsl_manual.html#SEC145">Conversion Functions</A>
<LI><A NAME="TOC146" HREF="gsl_manual.html#SEC146">Restriction Functions</A>
<LI><A NAME="TOC147" HREF="gsl_manual.html#SEC147">Trigonometric Functions With Error Estimates</A>
</UL>
<LI><A NAME="TOC148" HREF="gsl_manual.html#SEC148">Zeta Functions</A>
<UL>
<LI><A NAME="TOC149" HREF="gsl_manual.html#SEC149">Riemann Zeta Function</A>
<LI><A NAME="TOC150" HREF="gsl_manual.html#SEC150">Riemann Zeta Function Minus One</A>
<LI><A NAME="TOC151" HREF="gsl_manual.html#SEC151">Hurwitz Zeta Function</A>
<LI><A NAME="TOC152" HREF="gsl_manual.html#SEC152">Eta Function</A>
</UL>
<LI><A NAME="TOC153" HREF="gsl_manual.html#SEC153">Examples</A>
<LI><A NAME="TOC154" HREF="gsl_manual.html#SEC154">References and Further Reading</A>
</UL>
<LI><A NAME="TOC155" HREF="gsl_manual.html#SEC155">Vectors and Matrices</A>
<UL>
<LI><A NAME="TOC156" HREF="gsl_manual.html#SEC156">Data types</A>
<LI><A NAME="TOC157" HREF="gsl_manual.html#SEC157">Blocks</A>
<UL>
<LI><A NAME="TOC158" HREF="gsl_manual.html#SEC158">Block allocation</A>
<LI><A NAME="TOC159" HREF="gsl_manual.html#SEC159">Reading and writing blocks</A>
<LI><A NAME="TOC160" HREF="gsl_manual.html#SEC160">Example programs for blocks</A>
</UL>
<LI><A NAME="TOC161" HREF="gsl_manual.html#SEC161">Vectors</A>
<UL>
<LI><A NAME="TOC162" HREF="gsl_manual.html#SEC162">Vector allocation</A>
<LI><A NAME="TOC163" HREF="gsl_manual.html#SEC163">Accessing vector elements</A>
<LI><A NAME="TOC164" HREF="gsl_manual.html#SEC164">Initializing vector elements</A>
<LI><A NAME="TOC165" HREF="gsl_manual.html#SEC165">Reading and writing vectors</A>
<LI><A NAME="TOC166" HREF="gsl_manual.html#SEC166">Vector views</A>
<LI><A NAME="TOC167" HREF="gsl_manual.html#SEC167">Copying vectors</A>
<LI><A NAME="TOC168" HREF="gsl_manual.html#SEC168">Exchanging elements</A>
<LI><A NAME="TOC169" HREF="gsl_manual.html#SEC169">Vector operations</A>
<LI><A NAME="TOC170" HREF="gsl_manual.html#SEC170">Finding maximum and minimum elements of vectors</A>
<LI><A NAME="TOC171" HREF="gsl_manual.html#SEC171">Vector properties</A>
<LI><A NAME="TOC172" HREF="gsl_manual.html#SEC172">Example programs for vectors</A>
</UL>
<LI><A NAME="TOC173" HREF="gsl_manual.html#SEC173">Matrices</A>
<UL>
<LI><A NAME="TOC174" HREF="gsl_manual.html#SEC174">Matrix allocation</A>
<LI><A NAME="TOC175" HREF="gsl_manual.html#SEC175">Accessing matrix elements</A>
<LI><A NAME="TOC176" HREF="gsl_manual.html#SEC176">Initializing matrix elements</A>
<LI><A NAME="TOC177" HREF="gsl_manual.html#SEC177">Reading and writing matrices</A>
<LI><A NAME="TOC178" HREF="gsl_manual.html#SEC178">Matrix views</A>
<LI><A NAME="TOC179" HREF="gsl_manual.html#SEC179">Creating row and column views</A>
<LI><A NAME="TOC180" HREF="gsl_manual.html#SEC180">Copying matrices</A>
<LI><A NAME="TOC181" HREF="gsl_manual.html#SEC181">Copying rows and columns</A>
<LI><A NAME="TOC182" HREF="gsl_manual.html#SEC182">Exchanging rows and columns</A>
<LI><A NAME="TOC183" HREF="gsl_manual.html#SEC183">Matrix operations</A>
<LI><A NAME="TOC184" HREF="gsl_manual.html#SEC184">Finding maximum and minimum elements of matrices</A>
<LI><A NAME="TOC185" HREF="gsl_manual.html#SEC185">Matrix properties</A>
<LI><A NAME="TOC186" HREF="gsl_manual.html#SEC186">Example programs for matrices</A>
</UL>
<LI><A NAME="TOC187" HREF="gsl_manual.html#SEC187">References and Further Reading</A>
</UL>
<LI><A NAME="TOC188" HREF="gsl_manual.html#SEC188">Permutations</A>
<UL>
<LI><A NAME="TOC189" HREF="gsl_manual.html#SEC189">The Permutation struct</A>
<LI><A NAME="TOC190" HREF="gsl_manual.html#SEC190">Permutation allocation</A>
<LI><A NAME="TOC191" HREF="gsl_manual.html#SEC191">Accessing permutation elements</A>
<LI><A NAME="TOC192" HREF="gsl_manual.html#SEC192">Permutation properties</A>
<LI><A NAME="TOC193" HREF="gsl_manual.html#SEC193">Permutation functions</A>
<LI><A NAME="TOC194" HREF="gsl_manual.html#SEC194">Applying Permutations</A>
<LI><A NAME="TOC195" HREF="gsl_manual.html#SEC195">Reading and writing permutations</A>
<LI><A NAME="TOC196" HREF="gsl_manual.html#SEC196">Permutations in cyclic form</A>
<LI><A NAME="TOC197" HREF="gsl_manual.html#SEC197">Examples</A>
<LI><A NAME="TOC198" HREF="gsl_manual.html#SEC198">References and Further Reading</A>
</UL>
<LI><A NAME="TOC199" HREF="gsl_manual.html#SEC199">Combinations</A>
<UL>
<LI><A NAME="TOC200" HREF="gsl_manual.html#SEC200">The Combination struct</A>
<LI><A NAME="TOC201" HREF="gsl_manual.html#SEC201">Combination allocation</A>
<LI><A NAME="TOC202" HREF="gsl_manual.html#SEC202">Accessing combination elements</A>
<LI><A NAME="TOC203" HREF="gsl_manual.html#SEC203">Combination properties</A>
<LI><A NAME="TOC204" HREF="gsl_manual.html#SEC204">Combination functions</A>
<LI><A NAME="TOC205" HREF="gsl_manual.html#SEC205">Reading and writing combinations</A>
<LI><A NAME="TOC206" HREF="gsl_manual.html#SEC206">Examples</A>
<LI><A NAME="TOC207" HREF="gsl_manual.html#SEC207">References and Further Reading</A>
</UL>
<LI><A NAME="TOC208" HREF="gsl_manual.html#SEC208">Sorting</A>
<UL>
<LI><A NAME="TOC209" HREF="gsl_manual.html#SEC209">Sorting objects</A>
<LI><A NAME="TOC210" HREF="gsl_manual.html#SEC210">Sorting vectors</A>
<LI><A NAME="TOC211" HREF="gsl_manual.html#SEC211">Selecting the k smallest or largest elements</A>
<LI><A NAME="TOC212" HREF="gsl_manual.html#SEC212">Computing the rank</A>
<LI><A NAME="TOC213" HREF="gsl_manual.html#SEC213">Examples</A>
<LI><A NAME="TOC214" HREF="gsl_manual.html#SEC214">References and Further Reading</A>
</UL>
<LI><A NAME="TOC215" HREF="gsl_manual.html#SEC215">BLAS Support</A>
<UL>
<LI><A NAME="TOC216" HREF="gsl_manual.html#SEC216">GSL BLAS Interface</A>
<UL>
<LI><A NAME="TOC217" HREF="gsl_manual.html#SEC217">Level 1</A>
<LI><A NAME="TOC218" HREF="gsl_manual.html#SEC218">Level 2</A>
<LI><A NAME="TOC219" HREF="gsl_manual.html#SEC219">Level 3</A>
</UL>
<LI><A NAME="TOC220" HREF="gsl_manual.html#SEC220">Examples</A>
<LI><A NAME="TOC221" HREF="gsl_manual.html#SEC221">References and Further Reading</A>
</UL>
<LI><A NAME="TOC222" HREF="gsl_manual.html#SEC222">Linear Algebra</A>
<UL>
<LI><A NAME="TOC223" HREF="gsl_manual.html#SEC223">LU Decomposition</A>
<LI><A NAME="TOC224" HREF="gsl_manual.html#SEC224">QR Decomposition</A>
<LI><A NAME="TOC225" HREF="gsl_manual.html#SEC225">QR Decomposition with Column Pivoting</A>
<LI><A NAME="TOC226" HREF="gsl_manual.html#SEC226">Singular Value Decomposition</A>
<LI><A NAME="TOC227" HREF="gsl_manual.html#SEC227">Cholesky Decomposition</A>
<LI><A NAME="TOC228" HREF="gsl_manual.html#SEC228">Tridiagonal Decomposition of Real Symmetric Matrices</A>
<LI><A NAME="TOC229" HREF="gsl_manual.html#SEC229">Tridiagonal Decomposition of Hermitian Matrices</A>
<LI><A NAME="TOC230" HREF="gsl_manual.html#SEC230">Bidiagonalization</A>
<LI><A NAME="TOC231" HREF="gsl_manual.html#SEC231">Householder Transformations</A>
<LI><A NAME="TOC232" HREF="gsl_manual.html#SEC232">Householder solver for linear systems</A>
<LI><A NAME="TOC233" HREF="gsl_manual.html#SEC233">Tridiagonal Systems</A>
<LI><A NAME="TOC234" HREF="gsl_manual.html#SEC234">Examples</A>
<LI><A NAME="TOC235" HREF="gsl_manual.html#SEC235">References and Further Reading</A>
</UL>
<LI><A NAME="TOC236" HREF="gsl_manual.html#SEC236">Eigensystems</A>
<UL>
<LI><A NAME="TOC237" HREF="gsl_manual.html#SEC237">Real Symmetric Matrices</A>
<LI><A NAME="TOC238" HREF="gsl_manual.html#SEC238">Complex Hermitian Matrices</A>
<LI><A NAME="TOC239" HREF="gsl_manual.html#SEC239">Sorting Eigenvalues and Eigenvectors</A>
<LI><A NAME="TOC240" HREF="gsl_manual.html#SEC240">Examples</A>
<LI><A NAME="TOC241" HREF="gsl_manual.html#SEC241">References and Further Reading</A>
</UL>
<LI><A NAME="TOC242" HREF="gsl_manual.html#SEC242">Fast Fourier Transforms (FFTs)</A>
<UL>
<LI><A NAME="TOC243" HREF="gsl_manual.html#SEC243">Mathematical Definitions</A>
<LI><A NAME="TOC244" HREF="gsl_manual.html#SEC244">Overview of complex data FFTs</A>
<LI><A NAME="TOC245" HREF="gsl_manual.html#SEC245">Radix-2 FFT routines for complex data</A>
<LI><A NAME="TOC246" HREF="gsl_manual.html#SEC246">Mixed-radix FFT routines for complex data</A>
<LI><A NAME="TOC247" HREF="gsl_manual.html#SEC247">Overview of real data FFTs</A>
<LI><A NAME="TOC248" HREF="gsl_manual.html#SEC248">Radix-2 FFT routines for real data</A>
<LI><A NAME="TOC249" HREF="gsl_manual.html#SEC249">Mixed-radix FFT routines for real data</A>
<LI><A NAME="TOC250" HREF="gsl_manual.html#SEC250">References and Further Reading</A>
</UL>
<LI><A NAME="TOC251" HREF="gsl_manual.html#SEC251">Numerical Integration</A>
<UL>
<LI><A NAME="TOC252" HREF="gsl_manual.html#SEC252">Introduction</A>
<UL>
<LI><A NAME="TOC253" HREF="gsl_manual.html#SEC253">Integrands without weight functions</A>
<LI><A NAME="TOC254" HREF="gsl_manual.html#SEC254">Integrands with weight functions</A>
<LI><A NAME="TOC255" HREF="gsl_manual.html#SEC255">Integrands with singular weight functions</A>
</UL>
<LI><A NAME="TOC256" HREF="gsl_manual.html#SEC256">QNG non-adaptive Gauss-Kronrod integration</A>
<LI><A NAME="TOC257" HREF="gsl_manual.html#SEC257">QAG adaptive integration</A>
<LI><A NAME="TOC258" HREF="gsl_manual.html#SEC258">QAGS adaptive integration with singularities</A>
<LI><A NAME="TOC259" HREF="gsl_manual.html#SEC259">QAGP adaptive integration with known singular points</A>
<LI><A NAME="TOC260" HREF="gsl_manual.html#SEC260">QAGI adaptive integration on infinite intervals</A>
<LI><A NAME="TOC261" HREF="gsl_manual.html#SEC261">QAWC adaptive integration for Cauchy principal values</A>
<LI><A NAME="TOC262" HREF="gsl_manual.html#SEC262">QAWS adaptive integration for singular functions</A>
<LI><A NAME="TOC263" HREF="gsl_manual.html#SEC263">QAWO adaptive integration for oscillatory functions</A>
<LI><A NAME="TOC264" HREF="gsl_manual.html#SEC264">QAWF adaptive integration for Fourier integrals</A>
<LI><A NAME="TOC265" HREF="gsl_manual.html#SEC265">Error codes</A>
<LI><A NAME="TOC266" HREF="gsl_manual.html#SEC266">Examples</A>
<LI><A NAME="TOC267" HREF="gsl_manual.html#SEC267">References and Further Reading</A>
</UL>
<LI><A NAME="TOC268" HREF="gsl_manual.html#SEC268">Random Number Generation</A>
<UL>
<LI><A NAME="TOC269" HREF="gsl_manual.html#SEC269">General comments on random numbers</A>
<LI><A NAME="TOC270" HREF="gsl_manual.html#SEC270">The Random Number Generator Interface</A>
<LI><A NAME="TOC271" HREF="gsl_manual.html#SEC271">Random number generator initialization</A>
<LI><A NAME="TOC272" HREF="gsl_manual.html#SEC272">Sampling from a random number generator</A>
<LI><A NAME="TOC273" HREF="gsl_manual.html#SEC273">Auxiliary random number generator functions</A>
<LI><A NAME="TOC274" HREF="gsl_manual.html#SEC274">Random number environment variables</A>
<LI><A NAME="TOC275" HREF="gsl_manual.html#SEC275">Copying random number generator state</A>
<LI><A NAME="TOC276" HREF="gsl_manual.html#SEC276">Reading and writing random number generator state</A>
<LI><A NAME="TOC277" HREF="gsl_manual.html#SEC277">Random number generator algorithms</A>
<LI><A NAME="TOC278" HREF="gsl_manual.html#SEC278">Unix random number generators</A>
<LI><A NAME="TOC279" HREF="gsl_manual.html#SEC279">Other random number generators</A>
<LI><A NAME="TOC280" HREF="gsl_manual.html#SEC280">Performance</A>
<LI><A NAME="TOC281" HREF="gsl_manual.html#SEC281">Examples</A>
<LI><A NAME="TOC282" HREF="gsl_manual.html#SEC282">References and Further Reading</A>
<LI><A NAME="TOC283" HREF="gsl_manual.html#SEC283">Acknowledgements</A>
</UL>
<LI><A NAME="TOC284" HREF="gsl_manual.html#SEC284">Quasi-Random Sequences</A>
<UL>
<LI><A NAME="TOC285" HREF="gsl_manual.html#SEC285">Quasi-random number generator initialization</A>
<LI><A NAME="TOC286" HREF="gsl_manual.html#SEC286">Sampling from a quasi-random number generator</A>
<LI><A NAME="TOC287" HREF="gsl_manual.html#SEC287">Auxiliary quasi-random number generator functions</A>
<LI><A NAME="TOC288" HREF="gsl_manual.html#SEC288">Saving and resorting quasi-random number generator state</A>
<LI><A NAME="TOC289" HREF="gsl_manual.html#SEC289">Quasi-random number generator algorithms</A>
<LI><A NAME="TOC290" HREF="gsl_manual.html#SEC290">Examples</A>
<LI><A NAME="TOC291" HREF="gsl_manual.html#SEC291">References</A>
</UL>
<LI><A NAME="TOC292" HREF="gsl_manual.html#SEC292">Random Number Distributions</A>
<UL>
<LI><A NAME="TOC293" HREF="gsl_manual.html#SEC293">Introduction</A>
<LI><A NAME="TOC294" HREF="gsl_manual.html#SEC294">The Gaussian Distribution</A>
<LI><A NAME="TOC295" HREF="gsl_manual.html#SEC295">The Gaussian Tail Distribution</A>
<LI><A NAME="TOC296" HREF="gsl_manual.html#SEC296">The Bivariate Gaussian Distribution</A>
<LI><A NAME="TOC297" HREF="gsl_manual.html#SEC297">The Exponential Distribution</A>
<LI><A NAME="TOC298" HREF="gsl_manual.html#SEC298">The Laplace Distribution</A>
<LI><A NAME="TOC299" HREF="gsl_manual.html#SEC299">The Exponential Power Distribution</A>
<LI><A NAME="TOC300" HREF="gsl_manual.html#SEC300">The Cauchy Distribution</A>
<LI><A NAME="TOC301" HREF="gsl_manual.html#SEC301">The Rayleigh Distribution</A>
<LI><A NAME="TOC302" HREF="gsl_manual.html#SEC302">The Rayleigh Tail Distribution</A>
<LI><A NAME="TOC303" HREF="gsl_manual.html#SEC303">The Landau Distribution</A>
<LI><A NAME="TOC304" HREF="gsl_manual.html#SEC304">The Levy alpha-Stable Distributions</A>
<LI><A NAME="TOC305" HREF="gsl_manual.html#SEC305">The Levy skew alpha-Stable Distribution</A>
<LI><A NAME="TOC306" HREF="gsl_manual.html#SEC306">The Gamma Distribution</A>
<LI><A NAME="TOC307" HREF="gsl_manual.html#SEC307">The Flat (Uniform) Distribution</A>
<LI><A NAME="TOC308" HREF="gsl_manual.html#SEC308">The Lognormal Distribution</A>
<LI><A NAME="TOC309" HREF="gsl_manual.html#SEC309">The Chi-squared Distribution</A>
<LI><A NAME="TOC310" HREF="gsl_manual.html#SEC310">The F-distribution</A>
<LI><A NAME="TOC311" HREF="gsl_manual.html#SEC311">The t-distribution</A>
<LI><A NAME="TOC312" HREF="gsl_manual.html#SEC312">The Beta Distribution</A>
<LI><A NAME="TOC313" HREF="gsl_manual.html#SEC313">The Logistic Distribution</A>
<LI><A NAME="TOC314" HREF="gsl_manual.html#SEC314">The Pareto Distribution</A>
<LI><A NAME="TOC315" HREF="gsl_manual.html#SEC315">Spherical Vector Distributions</A>
<LI><A NAME="TOC316" HREF="gsl_manual.html#SEC316">The Weibull Distribution</A>
<LI><A NAME="TOC317" HREF="gsl_manual.html#SEC317">The Type-1 Gumbel Distribution</A>
<LI><A NAME="TOC318" HREF="gsl_manual.html#SEC318">The Type-2 Gumbel Distribution</A>
<LI><A NAME="TOC319" HREF="gsl_manual.html#SEC319">The Dirichlet Distribution</A>
<LI><A NAME="TOC320" HREF="gsl_manual.html#SEC320">General Discrete Distributions</A>
<LI><A NAME="TOC321" HREF="gsl_manual.html#SEC321">The Poisson Distribution</A>
<LI><A NAME="TOC322" HREF="gsl_manual.html#SEC322">The Bernoulli Distribution</A>
<LI><A NAME="TOC323" HREF="gsl_manual.html#SEC323">The Binomial Distribution</A>
<LI><A NAME="TOC324" HREF="gsl_manual.html#SEC324">The Multinomial Distribution</A>
<LI><A NAME="TOC325" HREF="gsl_manual.html#SEC325">The Negative Binomial Distribution</A>
<LI><A NAME="TOC326" HREF="gsl_manual.html#SEC326">The Pascal Distribution</A>
<LI><A NAME="TOC327" HREF="gsl_manual.html#SEC327">The Geometric Distribution</A>
<LI><A NAME="TOC328" HREF="gsl_manual.html#SEC328">The Hypergeometric Distribution</A>
<LI><A NAME="TOC329" HREF="gsl_manual.html#SEC329">The Logarithmic Distribution</A>
<LI><A NAME="TOC330" HREF="gsl_manual.html#SEC330">Shuffling and Sampling</A>
<LI><A NAME="TOC331" HREF="gsl_manual.html#SEC331">Examples</A>
<LI><A NAME="TOC332" HREF="gsl_manual.html#SEC332">References and Further Reading</A>
</UL>
<LI><A NAME="TOC333" HREF="gsl_manual.html#SEC333">Statistics</A>
<UL>
<LI><A NAME="TOC334" HREF="gsl_manual.html#SEC334">Mean, Standard Deviation and Variance</A>
<LI><A NAME="TOC335" HREF="gsl_manual.html#SEC335">Absolute deviation</A>
<LI><A NAME="TOC336" HREF="gsl_manual.html#SEC336">Higher moments (skewness and kurtosis)</A>
<LI><A NAME="TOC337" HREF="gsl_manual.html#SEC337">Autocorrelation</A>
<LI><A NAME="TOC338" HREF="gsl_manual.html#SEC338">Covariance</A>
<LI><A NAME="TOC339" HREF="gsl_manual.html#SEC339">Weighted Samples</A>
<LI><A NAME="TOC340" HREF="gsl_manual.html#SEC340">Maximum and Minimum values</A>
<LI><A NAME="TOC341" HREF="gsl_manual.html#SEC341">Median and Percentiles</A>
<LI><A NAME="TOC342" HREF="gsl_manual.html#SEC342">Examples</A>
<LI><A NAME="TOC343" HREF="gsl_manual.html#SEC343">References and Further Reading</A>
</UL>
<LI><A NAME="TOC344" HREF="gsl_manual.html#SEC344">Histograms</A>
<UL>
<LI><A NAME="TOC345" HREF="gsl_manual.html#SEC345">The histogram struct</A>
<LI><A NAME="TOC346" HREF="gsl_manual.html#SEC346">Histogram allocation</A>
<LI><A NAME="TOC347" HREF="gsl_manual.html#SEC347">Copying Histograms</A>
<LI><A NAME="TOC348" HREF="gsl_manual.html#SEC348">Updating and accessing histogram elements</A>
<LI><A NAME="TOC349" HREF="gsl_manual.html#SEC349">Searching histogram ranges</A>
<LI><A NAME="TOC350" HREF="gsl_manual.html#SEC350">Histogram Statistics</A>
<LI><A NAME="TOC351" HREF="gsl_manual.html#SEC351">Histogram Operations</A>
<LI><A NAME="TOC352" HREF="gsl_manual.html#SEC352">Reading and writing histograms</A>
<LI><A NAME="TOC353" HREF="gsl_manual.html#SEC353">Resampling from histograms</A>
<LI><A NAME="TOC354" HREF="gsl_manual.html#SEC354">The histogram probability distribution struct</A>
<LI><A NAME="TOC355" HREF="gsl_manual.html#SEC355">Example programs for histograms</A>
<LI><A NAME="TOC356" HREF="gsl_manual.html#SEC356">Two dimensional histograms</A>
<LI><A NAME="TOC357" HREF="gsl_manual.html#SEC357">The 2D histogram struct</A>
<LI><A NAME="TOC358" HREF="gsl_manual.html#SEC358">2D Histogram allocation</A>
<LI><A NAME="TOC359" HREF="gsl_manual.html#SEC359">Copying 2D Histograms</A>
<LI><A NAME="TOC360" HREF="gsl_manual.html#SEC360">Updating and accessing 2D histogram elements</A>
<LI><A NAME="TOC361" HREF="gsl_manual.html#SEC361">Searching 2D histogram ranges</A>
<LI><A NAME="TOC362" HREF="gsl_manual.html#SEC362">2D Histogram Statistics</A>
<LI><A NAME="TOC363" HREF="gsl_manual.html#SEC363">2D Histogram Operations</A>
<LI><A NAME="TOC364" HREF="gsl_manual.html#SEC364">Reading and writing 2D histograms</A>
<LI><A NAME="TOC365" HREF="gsl_manual.html#SEC365">Resampling from 2D histograms</A>
<LI><A NAME="TOC366" HREF="gsl_manual.html#SEC366">Example programs for 2D histograms</A>
</UL>
<LI><A NAME="TOC367" HREF="gsl_manual.html#SEC367">N-tuples</A>
<UL>
<LI><A NAME="TOC368" HREF="gsl_manual.html#SEC368">The ntuple struct</A>
<LI><A NAME="TOC369" HREF="gsl_manual.html#SEC369">Creating ntuples</A>
<LI><A NAME="TOC370" HREF="gsl_manual.html#SEC370">Opening an existing ntuple file</A>
<LI><A NAME="TOC371" HREF="gsl_manual.html#SEC371">Writing ntuples</A>
<LI><A NAME="TOC372" HREF="gsl_manual.html#SEC372">Reading ntuples</A>
<LI><A NAME="TOC373" HREF="gsl_manual.html#SEC373">Closing an ntuple file</A>
<LI><A NAME="TOC374" HREF="gsl_manual.html#SEC374">Histogramming ntuple values</A>
<LI><A NAME="TOC375" HREF="gsl_manual.html#SEC375">Examples</A>
<LI><A NAME="TOC376" HREF="gsl_manual.html#SEC376">References and Further Reading</A>
</UL>
<LI><A NAME="TOC377" HREF="gsl_manual.html#SEC377">Monte Carlo Integration</A>
<UL>
<LI><A NAME="TOC378" HREF="gsl_manual.html#SEC378">Interface</A>
<LI><A NAME="TOC379" HREF="gsl_manual.html#SEC379">PLAIN Monte Carlo</A>
<LI><A NAME="TOC380" HREF="gsl_manual.html#SEC380">MISER</A>
<LI><A NAME="TOC381" HREF="gsl_manual.html#SEC381">VEGAS</A>
<LI><A NAME="TOC382" HREF="gsl_manual.html#SEC382">Examples</A>
<LI><A NAME="TOC383" HREF="gsl_manual.html#SEC383">References and Further Reading</A>
</UL>
<LI><A NAME="TOC384" HREF="gsl_manual.html#SEC384">Simulated Annealing</A>
<UL>
<LI><A NAME="TOC385" HREF="gsl_manual.html#SEC385">Simulated Annealing algorithm</A>
<LI><A NAME="TOC386" HREF="gsl_manual.html#SEC386">Simulated Annealing functions</A>
<LI><A NAME="TOC387" HREF="gsl_manual.html#SEC387">Examples</A>
<UL>
<LI><A NAME="TOC388" HREF="gsl_manual.html#SEC388">Trivial example</A>
<LI><A NAME="TOC389" HREF="gsl_manual.html#SEC389">Traveling Salesman Problem</A>
</UL>
<LI><A NAME="TOC390" HREF="gsl_manual.html#SEC390">References and Further Reading</A>
</UL>
<LI><A NAME="TOC391" HREF="gsl_manual.html#SEC391">Ordinary Differential Equations</A>
<UL>
<LI><A NAME="TOC392" HREF="gsl_manual.html#SEC392">Defining the ODE System</A>
<LI><A NAME="TOC393" HREF="gsl_manual.html#SEC393">Stepping Functions</A>
<LI><A NAME="TOC394" HREF="gsl_manual.html#SEC394">Adaptive Step-size Control</A>
<LI><A NAME="TOC395" HREF="gsl_manual.html#SEC395">Evolution</A>
<LI><A NAME="TOC396" HREF="gsl_manual.html#SEC396">Examples</A>
<LI><A NAME="TOC397" HREF="gsl_manual.html#SEC397">References and Further Reading</A>
</UL>
<LI><A NAME="TOC398" HREF="gsl_manual.html#SEC398">Interpolation</A>
<UL>
<LI><A NAME="TOC399" HREF="gsl_manual.html#SEC399">Introduction</A>
<LI><A NAME="TOC400" HREF="gsl_manual.html#SEC400">Interpolation Functions</A>
<LI><A NAME="TOC401" HREF="gsl_manual.html#SEC401">Interpolation Types</A>
<LI><A NAME="TOC402" HREF="gsl_manual.html#SEC402">Index Look-up and Acceleration</A>
<LI><A NAME="TOC403" HREF="gsl_manual.html#SEC403">Evaluation of Interpolating Functions</A>
<LI><A NAME="TOC404" HREF="gsl_manual.html#SEC404">Higher-level Interface</A>
<LI><A NAME="TOC405" HREF="gsl_manual.html#SEC405">Examples</A>
<LI><A NAME="TOC406" HREF="gsl_manual.html#SEC406">References and Further Reading</A>
</UL>
<LI><A NAME="TOC407" HREF="gsl_manual.html#SEC407">Numerical Differentiation</A>
<UL>
<LI><A NAME="TOC408" HREF="gsl_manual.html#SEC408">Functions</A>
<LI><A NAME="TOC409" HREF="gsl_manual.html#SEC409">Examples</A>
<LI><A NAME="TOC410" HREF="gsl_manual.html#SEC410">References and Further Reading</A>
</UL>
<LI><A NAME="TOC411" HREF="gsl_manual.html#SEC411">Chebyshev Approximations</A>
<UL>
<LI><A NAME="TOC412" HREF="gsl_manual.html#SEC412">Definitions</A>
<LI><A NAME="TOC413" HREF="gsl_manual.html#SEC413">Creation and Calculation of Chebyshev Series</A>
<LI><A NAME="TOC414" HREF="gsl_manual.html#SEC414">Chebyshev Series Evaluation</A>
<LI><A NAME="TOC415" HREF="gsl_manual.html#SEC415">Derivatives and Integrals</A>
<LI><A NAME="TOC416" HREF="gsl_manual.html#SEC416">Examples</A>
<LI><A NAME="TOC417" HREF="gsl_manual.html#SEC417">References and Further Reading</A>
</UL>
<LI><A NAME="TOC418" HREF="gsl_manual.html#SEC418">Series Acceleration</A>
<UL>
<LI><A NAME="TOC419" HREF="gsl_manual.html#SEC419">Acceleration functions</A>
<LI><A NAME="TOC420" HREF="gsl_manual.html#SEC420">Acceleration functions without error estimation</A>
<LI><A NAME="TOC421" HREF="gsl_manual.html#SEC421">Examples</A>
<LI><A NAME="TOC422" HREF="gsl_manual.html#SEC422">References and Further Reading</A>
</UL>
<LI><A NAME="TOC423" HREF="gsl_manual.html#SEC423">Wavelet Transforms</A>
<UL>
<LI><A NAME="TOC424" HREF="gsl_manual.html#SEC424">Definitions</A>
<LI><A NAME="TOC425" HREF="gsl_manual.html#SEC425">Initialization</A>
<LI><A NAME="TOC426" HREF="gsl_manual.html#SEC426">Transform Functions</A>
<UL>
<LI><A NAME="TOC427" HREF="gsl_manual.html#SEC427">Wavelet transforms in one dimension</A>
<LI><A NAME="TOC428" HREF="gsl_manual.html#SEC428">Wavelet transforms in two dimension</A>
</UL>
<LI><A NAME="TOC429" HREF="gsl_manual.html#SEC429">Examples</A>
<LI><A NAME="TOC430" HREF="gsl_manual.html#SEC430">References and Further Reading</A>
</UL>
<LI><A NAME="TOC431" HREF="gsl_manual.html#SEC431">Discrete Hankel Transforms</A>
<UL>
<LI><A NAME="TOC432" HREF="gsl_manual.html#SEC432">Definitions</A>
<LI><A NAME="TOC433" HREF="gsl_manual.html#SEC433">Functions</A>
<LI><A NAME="TOC434" HREF="gsl_manual.html#SEC434">References and Further Reading</A>
</UL>
<LI><A NAME="TOC435" HREF="gsl_manual.html#SEC435">One dimensional Root-Finding</A>
<UL>
<LI><A NAME="TOC436" HREF="gsl_manual.html#SEC436">Overview</A>
<LI><A NAME="TOC437" HREF="gsl_manual.html#SEC437">Caveats</A>
<LI><A NAME="TOC438" HREF="gsl_manual.html#SEC438">Initializing the Solver</A>
<LI><A NAME="TOC439" HREF="gsl_manual.html#SEC439">Providing the function to solve</A>
<LI><A NAME="TOC440" HREF="gsl_manual.html#SEC440">Search Bounds and Guesses</A>
<LI><A NAME="TOC441" HREF="gsl_manual.html#SEC441">Iteration</A>
<LI><A NAME="TOC442" HREF="gsl_manual.html#SEC442">Search Stopping Parameters</A>
<LI><A NAME="TOC443" HREF="gsl_manual.html#SEC443">Root Bracketing Algorithms</A>
<LI><A NAME="TOC444" HREF="gsl_manual.html#SEC444">Root Finding Algorithms using Derivatives</A>
<LI><A NAME="TOC445" HREF="gsl_manual.html#SEC445">Examples</A>
<LI><A NAME="TOC446" HREF="gsl_manual.html#SEC446">References and Further Reading</A>
</UL>
<LI><A NAME="TOC447" HREF="gsl_manual.html#SEC447">One dimensional Minimization</A>
<UL>
<LI><A NAME="TOC448" HREF="gsl_manual.html#SEC448">Overview</A>
<LI><A NAME="TOC449" HREF="gsl_manual.html#SEC449">Caveats</A>
<LI><A NAME="TOC450" HREF="gsl_manual.html#SEC450">Initializing the Minimizer</A>
<LI><A NAME="TOC451" HREF="gsl_manual.html#SEC451">Providing the function to minimize</A>
<LI><A NAME="TOC452" HREF="gsl_manual.html#SEC452">Iteration</A>
<LI><A NAME="TOC453" HREF="gsl_manual.html#SEC453">Stopping Parameters</A>
<LI><A NAME="TOC454" HREF="gsl_manual.html#SEC454">Minimization Algorithms</A>
<LI><A NAME="TOC455" HREF="gsl_manual.html#SEC455">Examples</A>
<LI><A NAME="TOC456" HREF="gsl_manual.html#SEC456">References and Further Reading</A>
</UL>
<LI><A NAME="TOC457" HREF="gsl_manual.html#SEC457">Multidimensional Root-Finding</A>
<UL>
<LI><A NAME="TOC458" HREF="gsl_manual.html#SEC458">Overview</A>
<LI><A NAME="TOC459" HREF="gsl_manual.html#SEC459">Initializing the Solver</A>
<LI><A NAME="TOC460" HREF="gsl_manual.html#SEC460">Providing the function to solve</A>
<LI><A NAME="TOC461" HREF="gsl_manual.html#SEC461">Iteration</A>
<LI><A NAME="TOC462" HREF="gsl_manual.html#SEC462">Search Stopping Parameters</A>
<LI><A NAME="TOC463" HREF="gsl_manual.html#SEC463">Algorithms using Derivatives</A>
<LI><A NAME="TOC464" HREF="gsl_manual.html#SEC464">Algorithms without Derivatives</A>
<LI><A NAME="TOC465" HREF="gsl_manual.html#SEC465">Examples</A>
<LI><A NAME="TOC466" HREF="gsl_manual.html#SEC466">References and Further Reading</A>
</UL>
<LI><A NAME="TOC467" HREF="gsl_manual.html#SEC467">Multidimensional Minimization</A>
<UL>
<LI><A NAME="TOC468" HREF="gsl_manual.html#SEC468">Overview</A>
<LI><A NAME="TOC469" HREF="gsl_manual.html#SEC469">Caveats</A>
<LI><A NAME="TOC470" HREF="gsl_manual.html#SEC470">Initializing the Multidimensional Minimizer</A>
<LI><A NAME="TOC471" HREF="gsl_manual.html#SEC471">Providing a function to minimize</A>
<LI><A NAME="TOC472" HREF="gsl_manual.html#SEC472">Iteration</A>
<LI><A NAME="TOC473" HREF="gsl_manual.html#SEC473">Stopping Criteria</A>
<LI><A NAME="TOC474" HREF="gsl_manual.html#SEC474">Algorithms</A>
<LI><A NAME="TOC475" HREF="gsl_manual.html#SEC475">Examples</A>
<LI><A NAME="TOC476" HREF="gsl_manual.html#SEC476">References and Further Reading</A>
</UL>
<LI><A NAME="TOC477" HREF="gsl_manual.html#SEC477">Least-Squares Fitting</A>
<UL>
<LI><A NAME="TOC478" HREF="gsl_manual.html#SEC478">Linear regression</A>
<LI><A NAME="TOC479" HREF="gsl_manual.html#SEC479">Linear fitting without a constant term</A>
<LI><A NAME="TOC480" HREF="gsl_manual.html#SEC480">Multi-parameter fitting</A>
<LI><A NAME="TOC481" HREF="gsl_manual.html#SEC481">Examples</A>
<LI><A NAME="TOC482" HREF="gsl_manual.html#SEC482">References and Further Reading</A>
</UL>
<LI><A NAME="TOC483" HREF="gsl_manual.html#SEC483">Nonlinear Least-Squares Fitting</A>
<UL>
<LI><A NAME="TOC484" HREF="gsl_manual.html#SEC484">Overview</A>
<LI><A NAME="TOC485" HREF="gsl_manual.html#SEC485">Initializing the Solver</A>
<LI><A NAME="TOC486" HREF="gsl_manual.html#SEC486">Providing the Function to be Minimized</A>
<LI><A NAME="TOC487" HREF="gsl_manual.html#SEC487">Iteration</A>
<LI><A NAME="TOC488" HREF="gsl_manual.html#SEC488">Search Stopping Parameters</A>
<LI><A NAME="TOC489" HREF="gsl_manual.html#SEC489">Minimization Algorithms using Derivatives</A>
<LI><A NAME="TOC490" HREF="gsl_manual.html#SEC490">Minimization Algorithms without Derivatives</A>
<LI><A NAME="TOC491" HREF="gsl_manual.html#SEC491">Computing the covariance matrix of best fit parameters</A>
<LI><A NAME="TOC492" HREF="gsl_manual.html#SEC492">Examples</A>
<LI><A NAME="TOC493" HREF="gsl_manual.html#SEC493">References and Further Reading</A>
</UL>
<LI><A NAME="TOC494" HREF="gsl_manual.html#SEC494">Physical Constants</A>
<UL>
<LI><A NAME="TOC495" HREF="gsl_manual.html#SEC495">Fundamental Constants</A>
<LI><A NAME="TOC496" HREF="gsl_manual.html#SEC496">Astronomy and Astrophysics</A>
<LI><A NAME="TOC497" HREF="gsl_manual.html#SEC497">Atomic and Nuclear Physics</A>
<LI><A NAME="TOC498" HREF="gsl_manual.html#SEC498">Measurement of Time</A>
<LI><A NAME="TOC499" HREF="gsl_manual.html#SEC499">Imperial Units</A>
<LI><A NAME="TOC500" HREF="gsl_manual.html#SEC500">Speed and Nautical Units</A>
<LI><A NAME="TOC501" HREF="gsl_manual.html#SEC501">Printers Units</A>
<LI><A NAME="TOC502" HREF="gsl_manual.html#SEC502">Volume, Area and Length</A>
<LI><A NAME="TOC503" HREF="gsl_manual.html#SEC503">Mass and Weight</A>
<LI><A NAME="TOC504" HREF="gsl_manual.html#SEC504">Thermal Energy and Power</A>
<LI><A NAME="TOC505" HREF="gsl_manual.html#SEC505">Pressure</A>
<LI><A NAME="TOC506" HREF="gsl_manual.html#SEC506">Viscosity</A>
<LI><A NAME="TOC507" HREF="gsl_manual.html#SEC507">Light and Illumination</A>
<LI><A NAME="TOC508" HREF="gsl_manual.html#SEC508">Radioactivity</A>
<LI><A NAME="TOC509" HREF="gsl_manual.html#SEC509">Force and Energy</A>
<LI><A NAME="TOC510" HREF="gsl_manual.html#SEC510">Prefixes</A>
<LI><A NAME="TOC511" HREF="gsl_manual.html#SEC511">Examples</A>
<LI><A NAME="TOC512" HREF="gsl_manual.html#SEC512">References and Further Reading</A>
</UL>
<LI><A NAME="TOC513" HREF="gsl_manual.html#SEC513">IEEE floating-point arithmetic</A>
<UL>
<LI><A NAME="TOC514" HREF="gsl_manual.html#SEC514">Representation of floating point numbers</A>
<LI><A NAME="TOC515" HREF="gsl_manual.html#SEC515">Setting up your IEEE environment</A>
<LI><A NAME="TOC516" HREF="gsl_manual.html#SEC516">References and Further Reading</A>
</UL>
<LI><A NAME="TOC517" HREF="gsl_manual.html#SEC517">Debugging Numerical Programs</A>
<UL>
<LI><A NAME="TOC518" HREF="gsl_manual.html#SEC518">Using gdb</A>
<LI><A NAME="TOC519" HREF="gsl_manual.html#SEC519">Examining floating point registers</A>
<LI><A NAME="TOC520" HREF="gsl_manual.html#SEC520">Handling floating point exceptions</A>
<LI><A NAME="TOC521" HREF="gsl_manual.html#SEC521">GCC warning options for numerical programs</A>
<LI><A NAME="TOC522" HREF="gsl_manual.html#SEC522">References and Further Reading</A>
</UL>
<LI><A NAME="TOC523" HREF="gsl_manual.html#SEC523">Contributors to GSL</A>
<LI><A NAME="TOC524" HREF="gsl_manual.html#SEC524">Autoconf Macros</A>
<LI><A NAME="TOC525" HREF="gsl_manual.html#SEC525">GSL CBLAS Library</A>
<UL>
<LI><A NAME="TOC526" HREF="gsl_manual.html#SEC526">Level 1</A>
<LI><A NAME="TOC527" HREF="gsl_manual.html#SEC527">Level 2</A>
<LI><A NAME="TOC528" HREF="gsl_manual.html#SEC528">Level 3</A>
<LI><A NAME="TOC529" HREF="gsl_manual.html#SEC529">Examples</A>
</UL>
<LI><A NAME="TOC530" HREF="gsl_manual.html#SEC530">Free Software Needs Free Documentation</A>
<LI><A NAME="TOC531" HREF="gsl_manual.html#SEC531">GNU General Public License</A>
<LI><A NAME="TOC532" HREF="gsl_manual.html#SEC532">GNU Free Documentation License</A>
<LI><A NAME="TOC533" HREF="gsl_manual.html#SEC533">Function Index</A>
<LI><A NAME="TOC534" HREF="gsl_manual.html#SEC534">Variable Index</A>
<LI><A NAME="TOC535" HREF="gsl_manual.html#SEC535">Type Index</A>
<LI><A NAME="TOC536" HREF="gsl_manual.html#SEC536">Concept Index</A>
</UL>
<P><HR><P>


<H1><A NAME="SEC1" HREF="gsl_manual.html#TOC1">Introduction</A></H1>
<P>
<A NAME="IDX1"></A>
<A NAME="IDX2"></A>
The GNU Scientific Library (GSL) is a collection of routines for
numerical computing.  The routines have been written from scratch in C,
and present a modern Applications Programming Interface
(API) for C programmers, allowing wrappers to be written for very
high level languages.  The source code is distributed under the GNU
General Public License.

</P>



<H2><A NAME="SEC2" HREF="gsl_manual.html#TOC2">Routines available in GSL</A></H2>

<P>
The library covers a wide range of topics in numerical computing.
Routines are available for the following areas,

</P>
<P>
<TABLE>

<TR><TD><TD> Complex Numbers            <TD> Roots of Polynomials
<BR>
<TR><TD><TD> Special Functions          <TD> Vectors and Matrices
<BR>
<TR><TD><TD> Permutations               <TD> Combinations
<BR>
<TR><TD><TD> Sorting                    <TD> BLAS Support
<BR>
<TR><TD><TD> Linear Algebra             <TD> CBLAS Library
<BR>
<TR><TD><TD> Fast Fourier Transforms    <TD> Eigensystems
<BR>
<TR><TD><TD> Random Numbers             <TD> Quadrature
<BR>
<TR><TD><TD> Random Distributions       <TD> Quasi-Random Sequences
<BR>
<TR><TD><TD> Histograms                 <TD> Statistics
<BR>
<TR><TD><TD> Monte Carlo Integration    <TD> N-Tuples
<BR>
<TR><TD><TD> Differential Equations     <TD> Simulated Annealing
<BR>
<TR><TD><TD> Numerical Differentiation  <TD> Interpolation
<BR>
<TR><TD><TD> Series Acceleration        <TD> Chebyshev Approximations
<BR>
<TR><TD><TD> Root-Finding               <TD> Discrete Hankel Transforms
<BR>
<TR><TD><TD> Least-Squares Fitting      <TD> Minimization
<BR>
<TR><TD><TD> IEEE Floating-Point        <TD> Physical Constants
<BR>
<TR><TD><TD> Wavelets
</TABLE>
<P>
The use of these routines is described in this manual.  Each chapter
provides detailed definitions of the functions, followed by example
programs and references to the articles on which the algorithms are
based.



<H2><A NAME="SEC3" HREF="gsl_manual.html#TOC3">GSL is Free Software</A></H2>
<P>
<A NAME="IDX3"></A>
The subroutines in the GNU Scientific Library are "free software";
this means that everyone is free to use them, and to redistribute them
in other free programs.  The library is not in the public domain; it is
copyrighted and there are conditions on its distribution.  These
conditions are designed to permit everything that a good cooperating
citizen would want to do.  What is not allowed is to try to prevent
others from further sharing any version of the software that they might
get from you.

</P>
<P>
Specifically, we want to make sure that you have the right to share
copies of programs that you are given which use the GNU Scientific
Library, that you receive their source code or else can get it if you
want it, that you can change these programs or use pieces of them in new
free programs, and that you know you can do these things.

</P>
<P>
To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of any code which uses the GNU Scientific Library, you must give
the recipients all the rights that you have received.  You must make
sure that they, too, receive or can get the source code, both to the
library and the code which uses it.  And you must tell them their
rights.  This means that the library should not be redistributed in
proprietary programs.

</P>
<P>
Also, for our own protection, we must make certain that everyone finds
out that there is no warranty for the GNU Scientific Library.  If these
programs are modified by someone else and passed on, we want their
recipients to know that what they have is not what we distributed, so
that any problems introduced by others will not reflect on our
reputation.

</P>
<P>
The precise conditions for the distribution of software related to the
GNU Scientific Library are found in the GNU General Public License
(see section <A HREF="gsl_manual.html#SEC531">GNU General Public License</A>).  Further information about this
license is available from the GNU Project webpage <CITE>Frequently Asked
Questions about the GNU GPL</CITE>,

</P>

<UL class="itemize">
<LI>

<A HREF="http://www.gnu.org/copyleft/gpl-faq.html">http://www.gnu.org/copyleft/gpl-faq.html</A>
</UL>

<P>
The Free Software Foundation also operates a license consulting service
for commercial users.

</P>


<H2><A NAME="SEC4" HREF="gsl_manual.html#TOC4">Obtaining GSL</A></H2>
<P>
<A NAME="IDX4"></A>
<A NAME="IDX5"></A>
<A NAME="IDX6"></A>
<A NAME="IDX7"></A>
The source code for the library can be obtained in different ways, by
copying it from a friend, purchasing it on CDROM or downloading it
from the internet. A list of public ftp servers which carry the source
code can be found on the GNU website,

</P>

<UL class="itemize">
<LI>

<A HREF="http://www.gnu.org/software/gsl/">http://www.gnu.org/software/gsl/</A>
</UL>

<P>
The preferred platform for the library is a GNU system, which allows it
to take advantage of additional features in the GNU C compiler and GNU C
library.  However, the library is fully portable and should compile on
most systems.  Precompiled versions of the library can be purchased from
commercial redistributors listed on the website above.

</P>
<P>
Announcements of new releases, updates and other relevant events are
made on the <CODE>info-gsl@gnu.org</CODE> mailing list.  To subscribe to this
low-volume list, send an email of the following form:

</P>

<PRE class="example">
To: info-gsl-request@gnu.org 
Subject: subscribe
</PRE>

<P>
You will receive a response asking you to reply in order to confirm
your subscription.

</P>


<H2><A NAME="SEC5" HREF="gsl_manual.html#TOC5">No Warranty</A></H2>
<P>
<A NAME="IDX8"></A>
The software described in this manual has no warranty, it is provided
"as is".  It is your responsibility to validate the behavior of the
routines and their accuracy using the source code provided, or to
purchase support and warranties from commercial redistributors.  Consult
the GNU General Public license for further details (see section <A HREF="gsl_manual.html#SEC531">GNU General Public License</A>).

</P>


<H2><A NAME="SEC6" HREF="gsl_manual.html#TOC6">Reporting Bugs</A></H2>
<P>
<A NAME="IDX9"></A>
<A NAME="IDX10"></A>
<A NAME="IDX11"></A>
<A NAME="IDX12"></A>
A list of known bugs can be found in the <TT>'BUGS'</TT> file included in
the GSL distribution.  Details of compilation problems can be found in
the <TT>'INSTALL'</TT> file.

</P>
<P>
If you find a bug which is not listed in these files, please report it to
<TT>bug-gsl at gnu.org</TT>.

</P>
<P>
All bug reports should include:

</P>

<UL class="itemize">
<LI>

The version number of GSL
<LI>

The hardware and operating system
<LI>

The compiler used, including version number and compilation options
<LI>

A description of the bug behavior
<LI>

A short program which exercises the bug
</UL>

<P>
It is useful if you can check whether the same problem occurs when the
library is compiled without optimization.  Thank you.

</P>
<P>
Any errors or omissions in this manual can also be reported to the
same address.

</P>


<H2><A NAME="SEC7" HREF="gsl_manual.html#TOC7">Further Information</A></H2>
<P>
<A NAME="IDX13"></A>
<A NAME="IDX14"></A>
<A NAME="IDX15"></A>
Additional information, including online copies of this manual, links to
related projects, and mailing list archives are available from the
website mentioned above.  

</P>
<P>
Any questions about the use and installation of the library can be asked
on the mailing list <CODE>help-gsl@gnu.org</CODE>.  To subscribe to this
list, send an email of the following form:

</P>

<PRE class="example">
To: help-gsl-request@gnu.org
Subject: subscribe
</PRE>

<P>
This mailing list can be used to ask questions not covered by this
manual, and to contact the developers of the library.

</P>


<H2><A NAME="SEC8" HREF="gsl_manual.html#TOC8">Conventions used in this manual</A></H2>
<P>
<A NAME="IDX16"></A>
<A NAME="IDX17"></A>
<A NAME="IDX18"></A>
<A NAME="IDX19"></A>
This manual contains many examples which can be typed at the keyboard.
A command entered at the terminal is shown like this,

</P>

<PRE class="example">
$ <I>command</I>
</PRE>

<P>
<A NAME="IDX20"></A>
The first character on the line is the terminal prompt, and should not
be typed.  The dollar sign <SAMP>'$'</SAMP> is used as the standard prompt in
this manual, although some systems may use a different character.

</P>
<P>
The examples assume the use of the GNU operating system.  There may be
minor differences in the output on other systems.  The commands for
setting environment variables use the Bourne shell syntax of the
standard GNU shell (<CODE>bash</CODE>).

</P>



<H1><A NAME="SEC9" HREF="gsl_manual.html#TOC9">Using the library</A></H1>
<P>
<A NAME="IDX21"></A>
<A NAME="IDX22"></A>
<A NAME="IDX23"></A>
<A NAME="IDX24"></A>
<A NAME="IDX25"></A>
This chapter describes how to compile programs that use GSL, and
introduces its conventions.  

</P>



<H2><A NAME="SEC10" HREF="gsl_manual.html#TOC10">An Example Program</A></H2>

<P>
The following short program demonstrates the use of the library by
computing the value of the Bessel function J_0(x) for x=5,

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_sf_bessel.h&#62;

int
main (void)
{
  double x = 5.0;
  double y = gsl_sf_bessel_J0 (x);
  printf ("J0(%g) = %.18e\n", x, y);
  return 0;
}
</PRE>

<P>
The output is shown below, and should be correct to double-precision
accuracy,

</P>

<PRE class="example">
J0(5) = -1.775967713143382920e-01
</PRE>

<P>
The steps needed to compile this program are described in the following
sections.

</P>


<H2><A NAME="SEC11" HREF="gsl_manual.html#TOC11">Compiling and Linking</A></H2>
<P>
<A NAME="IDX26"></A>
<A NAME="IDX27"></A>
<A NAME="IDX28"></A>
The library header files are installed in their own <TT>'gsl'</TT>
directory.  You should write any preprocessor include statements with a
<TT>'gsl/'</TT> directory prefix thus,

</P>

<PRE class="example">
#include &#60;gsl/gsl_math.h&#62;
</PRE>

<P>
If the directory is not installed on the standard search path of your
compiler you will also need to provide its location to the preprocessor
as a command line flag.  The default location of the <TT>'gsl'</TT>
directory is <TT>'/usr/local/include/gsl'</TT>.  A typical compilation
command for a source file <TT>'example.c'</TT> with the GNU C compiler
<CODE>gcc</CODE> is,

</P>

<PRE class="example">
$ gcc -Wall -I/usr/local/include -c example.c
</PRE>

<P>
This results in an object file <TT>'example.o'</TT>.   The default
include path for <CODE>gcc</CODE> searches <TT>'/usr/local/include'</TT> automatically so
the <CODE>-I</CODE> option can actually be omitted when GSL is installed 
in its default location.

</P>


<H3><A NAME="SEC12" HREF="gsl_manual.html#TOC12">Linking programs with the library</A></H3>
<P>
<A NAME="IDX29"></A>
<A NAME="IDX30"></A>
<A NAME="IDX31"></A>
The library is installed as a single file, <TT>'libgsl.a'</TT>.  A shared
version of the library <TT>'libgsl.so'</TT> is also installed on systems
that support shared libraries.  The default location of these files is
<TT>'/usr/local/lib'</TT>.  If this directory is not on the standard search
path of your linker you will also need to provide its location as a
command line flag.

</P>
<P>
To link against the library you need to specify
both the main library and a supporting CBLAS library, which
provides standard basic linear algebra subroutines.  A suitable
CBLAS implementation is provided in the library
<TT>'libgslcblas.a'</TT> if your system does not provide one.  The following
example shows how to link an application with the library,

</P>

<PRE class="example">
$ gcc -L/usr/local/lib example.o -lgsl -lgslcblas -lm
</PRE>

<P>
The default library path for <CODE>gcc</CODE> searches <TT>'/usr/local/lib'</TT>
automatically so the <CODE>-L</CODE> option can be omitted when GSL is
installed in its default location.

</P>


<H3><A NAME="SEC13" HREF="gsl_manual.html#TOC13">Linking with an alternative BLAS library</A></H3>

<P>
The following command line shows how you would link the same application
with an alternative CBLAS library called <TT>'libcblas'</TT>,

</P>

<PRE class="example">
$ gcc example.o -lgsl -lcblas -lm
</PRE>

<P>
For the best performance an optimized platform-specific CBLAS
library should be used for <CODE>-lcblas</CODE>.  The library must conform to
the CBLAS standard.  The ATLAS package provides a portable
high-performance BLAS library with a CBLAS interface.  It is
free software and should be installed for any work requiring fast vector
and matrix operations.  The following command line will link with the
ATLAS library and its CBLAS interface,

</P>

<PRE class="example">
$ gcc example.o -lgsl -lcblas -latlas -lm
</PRE>

<P>
For more information see section <A HREF="gsl_manual.html#SEC215">BLAS Support</A>.

</P>



<H2><A NAME="SEC14" HREF="gsl_manual.html#TOC14">Shared Libraries</A></H2>
<P>
<A NAME="IDX32"></A>
<A NAME="IDX33"></A>
<A NAME="IDX34"></A>
To run a program linked with the shared version of the library the
operating system must be able to locate the corresponding <TT>'.so'</TT>
file at runtime.  If the library cannot be found, the following error
will occur:

</P>

<PRE class="example">
$ ./a.out 
./a.out: error while loading shared libraries: 
libgsl.so.0: cannot open shared object file: No such 
file or directory
</PRE>

<P>
To avoid this error, define the shell variable <CODE>LD_LIBRARY_PATH</CODE> to
include the directory where the library is installed.

</P>
<P>
For example, in the Bourne shell (<CODE>/bin/sh</CODE> or <CODE>/bin/bash</CODE>),
the library search path can be set with the following commands:

</P>

<PRE class="example">
$ LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH 
$ export LD_LIBRARY_PATH
$ ./example
</PRE>

<P>
In the C-shell (<CODE>/bin/csh</CODE> or <CODE>/bin/tcsh</CODE>) the equivalent
command is,

</P>

<PRE class="example">
% setenv LD_LIBRARY_PATH /usr/local/lib:$LD_LIBRARY_PATH
</PRE>

<P>
The standard prompt for the C-shell in the example above is the percent
character <SAMP>'%'</SAMP>, and should not be typed as part of the command.

</P>
<P>
To save retyping these commands each session they should be placed in an
individual or system-wide login file.

</P>
<P>
To compile a statically linked version of the program, use the
<CODE>-static</CODE> flag in <CODE>gcc</CODE>,

</P>

<PRE class="example">
$ gcc -static example.o -lgsl -lgslcblas -lm
</PRE>



<H2><A NAME="SEC15" HREF="gsl_manual.html#TOC15">ANSI C Compliance</A></H2>

<P>
The library is written in ANSI C and is intended to conform to the ANSI
C standard (C89).  It should be portable to any system with a working
ANSI C compiler.

</P>
<P>
The library does not rely on any non-ANSI extensions in the interface it
exports to the user.  Programs you write using GSL can be ANSI
compliant.  Extensions which can be used in a way compatible with pure
ANSI C are supported, however, via conditional compilation.  This allows
the library to take advantage of compiler extensions on those platforms
which support them.

</P>
<P>
When an ANSI C feature is known to be broken on a particular system the
library will exclude any related functions at compile-time.  This should
make it impossible to link a program that would use these functions and
give incorrect results.

</P>
<P>
To avoid namespace conflicts all exported function names and variables
have the prefix <CODE>gsl_</CODE>, while exported macros have the prefix
<CODE>GSL_</CODE>.

</P>


<H2><A NAME="SEC16" HREF="gsl_manual.html#TOC16">Inline functions</A></H2>

<P>
<A NAME="IDX35"></A>
<A NAME="IDX36"></A>
The <CODE>inline</CODE> keyword is not part of the original ANSI C standard
(C89) and the library does not export any inline function definitions by
default. However, the library provides optional inline versions of
performance-critical functions by conditional compilation.  The inline
versions of these functions can be included by defining the macro
<CODE>HAVE_INLINE</CODE> when compiling an application,

</P>

<PRE class="example">
$ gcc -Wall -c -DHAVE_INLINE example.c
</PRE>

<P>
If you use <CODE>autoconf</CODE> this macro can be defined automatically.  If
you do not define the macro <CODE>HAVE_INLINE</CODE> then the slower
non-inlined versions of the functions will be used instead.

</P>
<P>
Note that the actual usage of the inline keyword is <CODE>extern
inline</CODE>, which eliminates unnecessary function definitions in GCC.
If the form <CODE>extern inline</CODE> causes problems with other compilers a
stricter autoconf test can be used, see section <A HREF="gsl_manual.html#SEC524">Autoconf Macros</A>.

</P>


<H2><A NAME="SEC17" HREF="gsl_manual.html#TOC17">Long double</A></H2>
<P>
<A NAME="IDX37"></A>
The extended numerical type <CODE>long double</CODE> is part of the ANSI C
standard and should be available in every modern compiler.  However, the
precision of <CODE>long double</CODE> is platform dependent, and this should
be considered when using it.  The IEEE standard only specifies the
minimum precision of extended precision numbers, while the precision of
<CODE>double</CODE> is the same on all platforms.

</P>
<P>
In some system libraries the <CODE>stdio.h</CODE> formatted input/output
functions <CODE>printf</CODE> and <CODE>scanf</CODE> are not implemented correctly
for <CODE>long double</CODE>.  Undefined or incorrect results are avoided by
testing these functions during the <CODE>configure</CODE> stage of library
compilation and eliminating certain GSL functions which depend on them
if necessary.  The corresponding line in the <CODE>configure</CODE> output
looks like this,

</P>

<PRE class="example">
checking whether printf works with long double... no
</PRE>

<P>
Consequently when <CODE>long double</CODE> formatted input/output does not
work on a given system it should be impossible to link a program which
uses GSL functions dependent on this.

</P>
<P>
If it is necessary to work on a system which does not support formatted
<CODE>long double</CODE> input/output then the options are to use binary
formats or to convert <CODE>long double</CODE> results into <CODE>double</CODE> for
reading and writing.

</P>


<H2><A NAME="SEC18" HREF="gsl_manual.html#TOC18">Portability functions</A></H2>

<P>
To help in writing portable applications GSL provides some
implementations of functions that are found in other libraries, such as
the BSD math library.  You can write your application to use the native
versions of these functions, and substitute the GSL versions via a
preprocessor macro if they are unavailable on another platform. 

</P>
<P>
For example, after determining whether the BSD function <CODE>hypot</CODE> is
available you can include the following macro definitions in a file
<TT>'config.h'</TT> with your application,

</P>

<PRE class="example">
/* Substitute gsl_hypot for missing system hypot */

#ifndef HAVE_HYPOT
#define hypot gsl_hypot
#endif
</PRE>

<P>
The application source files can then use the include command
<CODE>#include &#60;config.h&#62;</CODE> to replace each occurrence of <CODE>hypot</CODE> by
<CODE>gsl_hypot</CODE> when <CODE>hypot</CODE> is not available.  This substitution
can be made automatically if you use <CODE>autoconf</CODE>, see section <A HREF="gsl_manual.html#SEC524">Autoconf Macros</A>.

</P>
<P>
In most circumstances the best strategy is to use the native versions of
these functions when available, and fall back to GSL versions otherwise,
since this allows your application to take advantage of any
platform-specific optimizations in the system library.  This is the
strategy used within GSL itself.

</P>


<H2><A NAME="SEC19" HREF="gsl_manual.html#TOC19">Alternative optimized functions</A></H2>

<P>
<A NAME="IDX38"></A>
<A NAME="IDX39"></A>
The main implementation of some functions in the library will not be
optimal on all architectures.  For example, there are several ways to
compute a Gaussian random variate and their relative speeds are
platform-dependent.  In cases like this the library provides alternative
implementations of these functions with the same interface.  If you
write your application using calls to the standard implementation you
can select an alternative version later via a preprocessor definition.
It is also possible to introduce your own optimized functions this way
while retaining portability.  The following lines demonstrate the use of
a platform-dependent choice of methods for sampling from the Gaussian
distribution,

</P>

<PRE class="example">
#ifdef SPARC
#define gsl_ran_gaussian gsl_ran_gaussian_ratio_method
#endif
#ifdef INTEL
#define gsl_ran_gaussian my_gaussian
#endif
</PRE>

<P>
These lines would be placed in the configuration header file
<TT>'config.h'</TT> of the application, which should then be included by all
the source files.  Note that the alternative implementations will not
produce bit-for-bit identical results, and in the case of random number
distributions will produce an entirely different stream of random
variates.

</P>


<H2><A NAME="SEC20" HREF="gsl_manual.html#TOC20">Support for different numeric types</A></H2>

<P>
Many functions in the library are defined for different numeric types.
This feature is implemented by varying the name of the function with a
type-related modifier--a primitive form of C++ templates.  The
modifier is inserted into the function name after the initial module
prefix.  The following table shows the function names defined for all
the numeric types of an imaginary module <CODE>gsl_foo</CODE> with function
<CODE>fn</CODE>,

</P>

<PRE class="example">
gsl_foo_fn               double        
gsl_foo_long_double_fn   long double   
gsl_foo_float_fn         float         
gsl_foo_long_fn          long          
gsl_foo_ulong_fn         unsigned long 
gsl_foo_int_fn           int           
gsl_foo_uint_fn          unsigned int  
gsl_foo_short_fn         short         
gsl_foo_ushort_fn        unsigned short
gsl_foo_char_fn          char          
gsl_foo_uchar_fn         unsigned char 
</PRE>

<P>
The normal numeric precision <CODE>double</CODE> is considered the default and
does not require a suffix.  For example, the function
<CODE>gsl_stats_mean</CODE> computes the mean of double precision numbers,
while the function <CODE>gsl_stats_int_mean</CODE> computes the mean of
integers.

</P>
<P>
A corresponding scheme is used for library defined types, such as
<CODE>gsl_vector</CODE> and <CODE>gsl_matrix</CODE>.  In this case the modifier is
appended to the type name.  For example, if a module defines a new
type-dependent struct or typedef <CODE>gsl_foo</CODE> it is modified for other
types in the following way,

</P>

<PRE class="example">
gsl_foo                  double        
gsl_foo_long_double      long double   
gsl_foo_float            float         
gsl_foo_long             long          
gsl_foo_ulong            unsigned long 
gsl_foo_int              int           
gsl_foo_uint             unsigned int  
gsl_foo_short            short         
gsl_foo_ushort           unsigned short
gsl_foo_char             char          
gsl_foo_uchar            unsigned char 
</PRE>

<P>
When a module contains type-dependent definitions the library provides
individual header files for each type.  The filenames are modified as
shown in the below.  For convenience the default header includes the
definitions for all the types.  To include only the double precision
header file, or any other specific type, use its individual filename.

</P>

<PRE class="example">
#include &#60;gsl/gsl_foo.h&#62;               All types
#include &#60;gsl/gsl_foo_double.h&#62;        double        
#include &#60;gsl/gsl_foo_long_double.h&#62;   long double   
#include &#60;gsl/gsl_foo_float.h&#62;         float         
#include &#60;gsl/gsl_foo_long.h&#62;          long          
#include &#60;gsl/gsl_foo_ulong.h&#62;         unsigned long 
#include &#60;gsl/gsl_foo_int.h&#62;           int           
#include &#60;gsl/gsl_foo_uint.h&#62;          unsigned int  
#include &#60;gsl/gsl_foo_short.h&#62;         short         
#include &#60;gsl/gsl_foo_ushort.h&#62;        unsigned short
#include &#60;gsl/gsl_foo_char.h&#62;          char          
#include &#60;gsl/gsl_foo_uchar.h&#62;         unsigned char 
</PRE>



<H2><A NAME="SEC21" HREF="gsl_manual.html#TOC21">Compatibility with C++</A></H2>
<P>
<A NAME="IDX40"></A>
The library header files automatically define functions to have
<CODE>extern "C"</CODE> linkage when included in C++ programs.  This allows
the functions to be called directly from C++.

</P>
<P>
To use C++ exception handling within user-defined functions passed to
the library as parameters, the library must be built with the
additional <CODE>CFLAGS</CODE> compilation option <CODE>-fexceptions</CODE>.

</P>


<H2><A NAME="SEC22" HREF="gsl_manual.html#TOC22">Aliasing of arrays</A></H2>
<P>
<A NAME="IDX41"></A>
The library assumes that arrays, vectors and matrices passed as
modifiable arguments are not aliased and do not overlap with each other.
This removes the need for the library to handle overlapping memory
regions as a special case, and allows additional optimizations to be
used.  If overlapping memory regions are passed as modifiable arguments
then the results of such functions will be undefined.  If the arguments
will not be modified (for example, if a function prototype declares them
as <CODE>const</CODE> arguments) then overlapping or aliased memory regions
can be safely used.

</P>


<H2><A NAME="SEC23" HREF="gsl_manual.html#TOC23">Thread-safety</A></H2>

<P>
The library can be used in multi-threaded programs.  All the functions
are thread-safe, in the sense that they do not use static variables.
Memory is always associated with objects and not with functions.  For
functions which use <I>workspace</I> objects as temporary storage the
workspaces should be allocated on a per-thread basis.  For functions
which use <I>table</I> objects as read-only memory the tables can be used
by multiple threads simultaneously.  Table arguments are always declared
<CODE>const</CODE> in function prototypes, to indicate that they may be
safely accessed by different threads.

</P>
<P>
There are a small number of static global variables which are used to
control the overall behavior of the library (e.g. whether to use
range-checking, the function to call on fatal error, etc).  These
variables are set directly by the user, so they should be initialized
once at program startup and not modified by different threads.

</P>


<H2><A NAME="SEC24" HREF="gsl_manual.html#TOC24">Deprecated Functions</A></H2>
<P>
<A NAME="IDX42"></A>

</P>
<P>
From time to time, it may be necessary for the definitions of some
functions to be altered or removed from the library.  In these
circumstances the functions will first be declared <I>deprecated</I> and
then removed from subsequent versions of the library.  Functions that
are deprecated can be disabled in the current release by setting the
preprocessor definition <CODE>GSL_DISABLE_DEPRECATED</CODE>.  This allows
existing code to be tested for forwards compatibility.

</P>


<H2><A NAME="SEC25" HREF="gsl_manual.html#TOC25">Code Reuse</A></H2>
<P>
<A NAME="IDX43"></A>
<A NAME="IDX44"></A>
Where possible the routines in the library have been written to avoid
dependencies between modules and files.  This should make it possible to
extract individual functions for use in your own applications, without
needing to have the whole library installed.  You may need to define
certain macros such as <CODE>GSL_ERROR</CODE> and remove some <CODE>#include</CODE>
statements in order to compile the files as standalone units. Reuse of
the library code in this way is encouraged, subject to the terms of the
GNU General Public License.

</P>


<H1><A NAME="SEC26" HREF="gsl_manual.html#TOC26">Error Handling</A></H1>
<P>
<A NAME="IDX45"></A>
<A NAME="IDX46"></A>
This chapter describes the way that GSL functions report and handle
errors.  By examining the status information returned by every function
you can determine whether it succeeded or failed, and if it failed you
can find out what the precise cause of failure was.  You can also define
your own error handling functions to modify the default behavior of the
library.

</P>
<P>
The functions described in this section are declared in the header file
<TT>'gsl_errno.h'</TT>.

</P>



<H2><A NAME="SEC27" HREF="gsl_manual.html#TOC27">Error Reporting</A></H2>

<P>
The library follows the thread-safe error reporting conventions of the
POSIX Threads library.  Functions return a non-zero error code to
indicate an error and <CODE>0</CODE> to indicate success.

</P>

<PRE class="example">
int status = gsl_function (...)

if (status) { /* an error occurred */
  .....       
  /* status value specifies the type of error */
}
</PRE>

<P>
The routines report an error whenever they cannot perform the task
requested of them.  For example, a root-finding function would return a
non-zero error code if could not converge to the requested accuracy, or
exceeded a limit on the number of iterations.  Situations like this are
a normal occurrence when using any mathematical library and you should
check the return status of the functions that you call.

</P>
<P>
Whenever a routine reports an error the return value specifies the type
of error.  The return value is analogous to the value of the variable
<CODE>errno</CODE> in the C library.  The caller can examine the return code
and decide what action to take, including ignoring the error if it is
not considered serious.

</P>
<P>
In addition to reporting errors by return codes the library also has an
error handler function <CODE>gsl_error</CODE>.  This function is called by
other library functions when they report an error, just before they
return to the caller.  The default behavior of the error handler is to
print a message and abort the program,

</P>

<PRE class="example">
gsl: file.c:67: ERROR: invalid argument supplied by user
Default GSL error handler invoked.
Aborted
</PRE>

<P>
The purpose of the <CODE>gsl_error</CODE> handler is to provide a function
where a breakpoint can be set that will catch library errors when
running under the debugger.  It is not intended for use in production
programs, which should handle any errors using the return codes.

</P>


<H2><A NAME="SEC28" HREF="gsl_manual.html#TOC28">Error Codes</A></H2>

<P>
The error code numbers returned by library functions are defined in the
file <TT>'gsl_errno.h'</TT>.  They all have the prefix <CODE>GSL_</CODE> and
expand to non-zero constant integer values.  Many of the error codes use
the same base name as the corresponding error code in the C library.  Here are
some of the most common error codes,

</P>
<P>
<A NAME="IDX47"></A>
<DL>
<DT><U>Macro:</U> int <B>GSL_EDOM</B>
<DD><A NAME="IDX48"></A>
Domain error; used by mathematical functions when an argument value does
not fall into the domain over which the function is defined (like
EDOM in the C library)
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>GSL_ERANGE</B>
<DD><A NAME="IDX49"></A>
Range error; used by mathematical functions when the result value is not
representable because of overflow or underflow (like ERANGE in the C
library)
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>GSL_ENOMEM</B>
<DD><A NAME="IDX50"></A>
No memory available.  The system cannot allocate more virtual memory
because its capacity is full (like ENOMEM in the C library).  This error
is reported when a GSL routine encounters problems when trying to
allocate memory with <CODE>malloc</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>GSL_EINVAL</B>
<DD><A NAME="IDX51"></A>
Invalid argument.  This is used to indicate various kinds of problems
with passing the wrong argument to a library function (like EINVAL in the C
library). 
</DL>

</P>
<P>
The error codes can be converted into an error message using the
function <CODE>gsl_strerror</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> const char * <B>gsl_strerror</B> <I>(const int <VAR>gsl_errno</VAR>)</I>
<DD><A NAME="IDX52"></A>
This function returns a pointer to a string describing the error code
<VAR>gsl_errno</VAR>. For example,

</P>

<PRE class="example">
printf ("error: %s\n", gsl_strerror (status));
</PRE>

<P>
would print an error message like <CODE>error: output range error</CODE> for a
status value of <CODE>GSL_ERANGE</CODE>.
</DL>

</P>


<H2><A NAME="SEC29" HREF="gsl_manual.html#TOC29">Error Handlers</A></H2>
<P>
<A NAME="IDX53"></A>

</P>
<P>
The default behavior of the GSL error handler is to print a short
message and call <CODE>abort()</CODE>.  When this default is in use programs
will stop with a core-dump whenever a library routine reports an error.
This is intended as a fail-safe default for programs which do not check
the return status of library routines (we don't encourage you to write
programs this way).

</P>
<P>
If you turn off the default error handler it is your responsibility to
check the return values of routines and handle them yourself.  You can
also customize the error behavior by providing a new error handler. For
example, an alternative error handler could log all errors to a file,
ignore certain error conditions (such as underflows), or start the
debugger and attach it to the current process when an error occurs.

</P>
<P>
All GSL error handlers have the type <CODE>gsl_error_handler_t</CODE>, which is
defined in <TT>'gsl_errno.h'</TT>,

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_error_handler_t</B>
<DD><A NAME="IDX54"></A>

</P>
<P>
This is the type of GSL error handler functions.  An error handler will
be passed four arguments which specify the reason for the error (a
string), the name of the source file in which it occurred (also a
string), the line number in that file (an integer) and the error number
(an integer).  The source file and line number are set at compile time
using the <CODE>__FILE__</CODE> and <CODE>__LINE__</CODE> directives in the
preprocessor.  An error handler function returns type <CODE>void</CODE>.
Error handler functions should be defined like this,

</P>

<PRE class="example">
void handler (const char * reason, 
              const char * file, 
              int line, 
              int gsl_errno)
</PRE>

</DL>
<P>
To request the use of your own error handler you need to call the
function <CODE>gsl_set_error_handler</CODE> which is also declared in
<TT>'gsl_errno.h'</TT>,

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_error_handler_t * <B>gsl_set_error_handler</B> <I>(gsl_error_handler_t <VAR>new_handler</VAR>)</I>
<DD><A NAME="IDX55"></A>

</P>
<P>
This function sets a new error handler, <VAR>new_handler</VAR>, for the GSL
library routines.  The previous handler is returned (so that you can
restore it later).  Note that the pointer to a user defined error
handler function is stored in a static variable, so there can be only
one error handler per program.  This function should be not be used in
multi-threaded programs except to set up a program-wide error handler
from a master thread.  The following example shows how to set and
restore a new error handler,

</P>

<PRE class="example">
/* save original handler, install new handler */
old_handler = gsl_set_error_handler (&#38;my_handler); 

/* code uses new handler */
.....     

/* restore original handler */
gsl_set_error_handler (old_handler); 
</PRE>

<P>
To use the default behavior (<CODE>abort</CODE> on error) set the error
handler to <CODE>NULL</CODE>,

</P>

<PRE class="example">
old_handler = gsl_set_error_handler (NULL); 
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> gsl_error_handler_t * <B>gsl_set_error_handler_off</B> <I>()</I>
<DD><A NAME="IDX56"></A>
This function turns off the error handler by defining an error handler
which does nothing. This will cause the program to continue after any
error, so the return values from any library routines must be checked.
This is the recommended behavior for production programs.  The previous
handler is returned (so that you can restore it later).
</DL>

</P>
<P>
The error behavior can be changed for specific applications by
recompiling the library with a customized definition of the
<CODE>GSL_ERROR</CODE> macro in the file <TT>'gsl_errno.h'</TT>.

</P>


<H2><A NAME="SEC30" HREF="gsl_manual.html#TOC30">Using GSL error reporting in your own functions</A></H2>
<P>
<A NAME="IDX57"></A>
If you are writing numerical functions in a program which also uses GSL
code you may find it convenient to adopt the same error reporting
conventions as in the library.

</P>
<P>
To report an error you need to call the function <CODE>gsl_error</CODE> with a
string describing the error and then return an appropriate error code
from <CODE>gsl_errno.h</CODE>, or a special value, such as <CODE>NaN</CODE>.  For
convenience the file <TT>'gsl_errno.h'</TT> defines two macros which carry
out these steps:

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>GSL_ERROR</B> <I>(<VAR>reason</VAR>, <VAR>gsl_errno</VAR>)</I>
<DD><A NAME="IDX58"></A>

</P>
<P>
This macro reports an error using the GSL conventions and returns a
status value of <CODE>gsl_errno</CODE>.  It expands to the following code fragment,

</P>

<PRE class="example">
gsl_error (reason, __FILE__, __LINE__, gsl_errno);
return gsl_errno;
</PRE>

<P>
The macro definition in <TT>'gsl_errno.h'</TT> actually wraps the code
in a <CODE>do { ... } while (0)</CODE> block to prevent possible
parsing problems.
</DL>

</P>
<P>
Here is an example of how the macro could be used to report that a
routine did not achieve a requested tolerance.  To report the error the
routine needs to return the error code <CODE>GSL_ETOL</CODE>.

</P>

<PRE class="example">
if (residual &#62; tolerance) 
  {
    GSL_ERROR("residual exceeds tolerance", GSL_ETOL);
  }
</PRE>

<P>
<DL>
<DT><U>Macro:</U> <B>GSL_ERROR_VAL</B> <I>(<VAR>reason</VAR>, <VAR>gsl_errno</VAR>, <VAR>value</VAR>)</I>
<DD><A NAME="IDX59"></A>

</P>
<P>
This macro is the same as <CODE>GSL_ERROR</CODE> but returns a user-defined
value of <VAR>value</VAR> instead of an error code.  It can be used for
mathematical functions that return a floating point value.
</DL>

</P>
<P>
The following example shows how to return a <CODE>NaN</CODE> at a mathematical
singularity using the <CODE>GSL_ERROR_VAL</CODE> macro,

</P>

<PRE class="example">
if (x == 0) 
  {
    GSL_ERROR_VAL("argument lies on singularity", 
                  GSL_ERANGE, GSL_NAN);
  }
</PRE>



<H2><A NAME="SEC31" HREF="gsl_manual.html#TOC31">Examples</A></H2>

<P>
Here is an example of some code which checks the return value of a
function where an error might be reported,

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_errno.h&#62;
#include &#60;gsl/gsl_fft_complex.h&#62;

...
  int status;
  size_t n = 37;

  gsl_set_error_handler_off();

  status = gsl_fft_complex_radix2_forward (data, n);

  if (status) {
    if (status == GSL_EINVAL) {
       fprintf (stderr, "invalid argument, n=%d\n", n);
    } else {
       fprintf (stderr, "failed, gsl_errno=%d\n", 
                        status);
    }
    exit (-1);
  }
...
</PRE>

<P>
The function <CODE>gsl_fft_complex_radix2</CODE> only accepts integer lengths
which are a power of two.  If the variable <CODE>n</CODE> is not a power of
two then the call to the library function will return <CODE>GSL_EINVAL</CODE>,
indicating that the length argument is invalid.  The function call to
<CODE>gsl_set_error_handler_off()</CODE> stops the default error handler from
aborting the program.  The <CODE>else</CODE> clause catches any other possible
errors.

</P>



<H1><A NAME="SEC32" HREF="gsl_manual.html#TOC32">Mathematical Functions</A></H1>
<P>
<A NAME="IDX60"></A>
<A NAME="IDX61"></A>

</P>
<P>
This chapter describes basic mathematical functions.  Some of these
functions are present in system libraries, but the alternative versions
given here can be used as a substitute when the system functions are not
available.

</P>
<P>
The functions and macros described in this chapter are defined in the
header file <TT>'gsl_math.h'</TT>.

</P>



<H2><A NAME="SEC33" HREF="gsl_manual.html#TOC33">Mathematical Constants</A></H2>
<P>
<A NAME="IDX62"></A>
<A NAME="IDX63"></A>
<A NAME="IDX64"></A>
<A NAME="IDX65"></A>
The library ensures that the standard BSD mathematical constants
are defined. For reference, here is a list of the constants:

</P>
<DL COMPACT>

<DT><CODE>M_E</CODE>
<DD>
<A NAME="IDX66"></A>
The base of exponentials, e

<DT><CODE>M_LOG2E</CODE>
<DD>
The base-2 logarithm of e, \log_2 (e)

<DT><CODE>M_LOG10E</CODE>
<DD>
The base-10 logarithm of e, 
\log_10 (e)

<DT><CODE>M_SQRT2</CODE>
<DD>
The square root of two, \sqrt 2

<DT><CODE>M_SQRT1_2</CODE>
<DD>
The square root of one-half, 
\sqrt{1/2}

<DT><CODE>M_SQRT3</CODE>
<DD>
The square root of three, \sqrt 3

<DT><CODE>M_PI</CODE>
<DD>
<A NAME="IDX67"></A>
The constant pi, \pi

<DT><CODE>M_PI_2</CODE>
<DD>
Pi divided by two, \pi/2

<DT><CODE>M_PI_4</CODE>
<DD>
Pi divided by four, \pi/4

<DT><CODE>M_SQRTPI</CODE>
<DD>
The square root of pi, \sqrt\pi

<DT><CODE>M_2_SQRTPI</CODE>
<DD>
Two divided by the square root of pi, 2/\sqrt\pi

<DT><CODE>M_1_PI</CODE>
<DD>
The reciprocal of pi, 1/\pi

<DT><CODE>M_2_PI</CODE>
<DD>
Twice the reciprocal of pi, 2/\pi

<DT><CODE>M_LN10</CODE>
<DD>
The natural logarithm of ten, \ln(10)

<DT><CODE>M_LN2</CODE>
<DD>
The natural logarithm of two, \ln(2)

<DT><CODE>M_LNPI</CODE>
<DD>
The natural logarithm of pi, \ln(\pi)

<DT><CODE>M_EULER</CODE>
<DD>
<A NAME="IDX68"></A>
Euler's constant, \gamma

</DL>



<H2><A NAME="SEC34" HREF="gsl_manual.html#TOC34">Infinities and Not-a-number</A></H2>

<P>
<A NAME="IDX69"></A>
<A NAME="IDX70"></A>
<A NAME="IDX71"></A>
<A NAME="IDX72"></A>
<A NAME="IDX73"></A>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>GSL_POSINF</B>
<DD><A NAME="IDX74"></A>
This macro contains the IEEE representation of positive infinity,
+\infty. It is computed from the expression <CODE>+1.0/0.0</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>GSL_NEGINF</B>
<DD><A NAME="IDX75"></A>
This macro contains the IEEE representation of negative infinity,
-\infty. It is computed from the expression <CODE>-1.0/0.0</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>GSL_NAN</B>
<DD><A NAME="IDX76"></A>
This macro contains the IEEE representation of the Not-a-Number symbol,
<CODE>NaN</CODE>. It is computed from the ratio <CODE>0.0/0.0</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_isnan</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX77"></A>
This function returns 1 if <VAR>x</VAR> is not-a-number.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_isinf</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX78"></A>
This function returns +1 if <VAR>x</VAR> is positive infinity,
-1 if <VAR>x</VAR> is negative infinity and 0 otherwise.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_finite</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX79"></A>
This function returns 1 if <VAR>x</VAR> is a real number, and 0 if it is
infinite or not-a-number.
</DL>

</P>



<H2><A NAME="SEC35" HREF="gsl_manual.html#TOC35">Elementary Functions</A></H2>

<P>
The following routines provide portable implementations of functions
found in the BSD math library.  When native versions are not available
the functions described here can be used instead.  The substitution can
be made automatically if you use <CODE>autoconf</CODE> to compile your
application (see section <A HREF="gsl_manual.html#SEC18">Portability functions</A>).

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_log1p</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX80"></A>
<A NAME="IDX81"></A>
<A NAME="IDX82"></A>
This function computes the value of \log(1+x) in a way that is
accurate for small <VAR>x</VAR>. It provides an alternative to the BSD math
function <CODE>log1p(x)</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_expm1</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX83"></A>
<A NAME="IDX84"></A>
<A NAME="IDX85"></A>
This function computes the value of \exp(x)-1 in a way that is
accurate for small <VAR>x</VAR>. It provides an alternative to the BSD math
function <CODE>expm1(x)</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_hypot</B> <I>(const double <VAR>x</VAR>, const double <VAR>y</VAR>)</I>
<DD><A NAME="IDX86"></A>
<A NAME="IDX87"></A>
<A NAME="IDX88"></A>
<A NAME="IDX89"></A>
This function computes the value of
\sqrt{x^2 + y^2} in a way that avoids overflow. It provides an
alternative to the BSD math function <CODE>hypot(x,y)</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_acosh</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX90"></A>
<A NAME="IDX91"></A>
<A NAME="IDX92"></A>
<A NAME="IDX93"></A>
This function computes the value of \arccosh(x). It provides an
alternative to the standard math function <CODE>acosh(x)</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_asinh</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX94"></A>
<A NAME="IDX95"></A>
<A NAME="IDX96"></A>
<A NAME="IDX97"></A>
This function computes the value of \arcsinh(x). It provides an
alternative to the standard math function <CODE>asinh(x)</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_atanh</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX98"></A>
<A NAME="IDX99"></A>
<A NAME="IDX100"></A>
<A NAME="IDX101"></A>
This function computes the value of \arctanh(x). It provides an
alternative to the standard math function <CODE>atanh(x)</CODE>.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ldexp</B> <I>(double <VAR>x</VAR>, int <VAR>e</VAR>)</I>
<DD><A NAME="IDX102"></A>
<A NAME="IDX103"></A>
This function computes the value of x * 2^e. It provides an
alternative to the standard math function <CODE>ldexp(x,e)</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_frexp</B> <I>(double <VAR>x</VAR>, int * <VAR>e</VAR>)</I>
<DD><A NAME="IDX104"></A>
<A NAME="IDX105"></A>
This function splits the number x into its normalized fraction
f and exponent e, such that x = f * 2^e and
0.5 &#60;= f &#60; 1. The function returns f and stores the
exponent in e. If x is zero, both f and e
are set to zero. This function provides an alternative to the standard
math function <CODE>frexp(x, e)</CODE>.
</DL>

</P>


<H2><A NAME="SEC36" HREF="gsl_manual.html#TOC36">Small integer powers</A></H2>

<P>
A common complaint about the standard C library is its lack of a
function for calculating (small) integer powers.  GSL provides a simple
functions to fill this gap.  For reasons of efficiency, these functions
do not check for overflow or underflow conditions. 

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_pow_int</B> <I>(double <VAR>x</VAR>, int <VAR>n</VAR>)</I>
<DD><A NAME="IDX106"></A>
This routine computes the power x^n for integer <VAR>n</VAR>.  The
power is computed efficiently--for example, x^8 is computed as
((x^2)^2)^2, requiring only 3 multiplications.  A version of this
function which also computes the numerical error in the result is
available as <CODE>gsl_sf_pow_int_e</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_pow_2</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX107"></A>
<DT><U>Function:</U> double <B>gsl_pow_3</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX108"></A>
<DT><U>Function:</U> double <B>gsl_pow_4</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX109"></A>
<DT><U>Function:</U> double <B>gsl_pow_5</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX110"></A>
<DT><U>Function:</U> double <B>gsl_pow_6</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX111"></A>
<DT><U>Function:</U> double <B>gsl_pow_7</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX112"></A>
<DT><U>Function:</U> double <B>gsl_pow_8</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX113"></A>
<DT><U>Function:</U> double <B>gsl_pow_9</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX114"></A>
These functions can be used to compute small integer powers x^2,
x^3, etc. efficiently. The functions will be inlined when
possible so that use of these functions should be as efficient as
explicitly writing the corresponding product expression.
</DL>

</P>

<PRE class="example">
#include &#60;gsl/gsl_math.h&#62;
double y = gsl_pow_4 (3.141)  /* compute 3.141**4 */
</PRE>



<H2><A NAME="SEC37" HREF="gsl_manual.html#TOC37">Testing the Sign of Numbers</A></H2>

<P>
<DL>
<DT><U>Macro:</U> <B>GSL_SIGN</B> <I>(x)</I>
<DD><A NAME="IDX115"></A>
This macro returns the sign of <VAR>x</VAR>. It is defined as <CODE>((x) &#62;= 0
? 1 : -1)</CODE>. Note that with this definition the sign of zero is positive
(regardless of its IEEE sign bit).
</DL>

</P>


<H2><A NAME="SEC38" HREF="gsl_manual.html#TOC38">Testing for Odd and Even Numbers</A></H2>

<P>
<DL>
<DT><U>Macro:</U> <B>GSL_IS_ODD</B> <I>(n)</I>
<DD><A NAME="IDX116"></A>
This macro evaluates to 1 if <VAR>n</VAR> is odd and 0 if <VAR>n</VAR> is
even. The argument <VAR>n</VAR> must be of integer type.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>GSL_IS_EVEN</B> <I>(n)</I>
<DD><A NAME="IDX117"></A>
This macro is the opposite of <CODE>GSL_IS_ODD(n)</CODE>. It evaluates to 1 if
<VAR>n</VAR> is even and 0 if <VAR>n</VAR> is odd. The argument <VAR>n</VAR> must be of
integer type.
</DL>

</P>


<H2><A NAME="SEC39" HREF="gsl_manual.html#TOC39">Maximum and Minimum functions</A></H2>

<P>
<DL>
<DT><U>Macro:</U> <B>GSL_MAX</B> <I>(a, b)</I>
<DD><A NAME="IDX118"></A>
<A NAME="IDX119"></A>
This macro returns the maximum of <VAR>a</VAR> and <VAR>b</VAR>. It is defined as 
<CODE>((a) &#62; (b) ? (a):(b))</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>GSL_MIN</B> <I>(a, b)</I>
<DD><A NAME="IDX120"></A>
<A NAME="IDX121"></A>
This macro returns the minimum of <VAR>a</VAR> and <VAR>b</VAR>. It is defined as 
<CODE>((a) &#60; (b) ? (a):(b))</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> extern inline double <B>GSL_MAX_DBL</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX122"></A>
This function returns the maximum of the double precision numbers
<VAR>a</VAR> and <VAR>b</VAR> using an inline function. The use of a function
allows for type checking of the arguments as an extra safety feature. On
platforms where inline functions are not available the macro
<CODE>GSL_MAX</CODE> will be automatically substituted.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> extern inline double <B>GSL_MIN_DBL</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX123"></A>
This function returns the minimum of the double precision numbers
<VAR>a</VAR> and <VAR>b</VAR> using an inline function. The use of a function
allows for type checking of the arguments as an extra safety feature. On
platforms where inline functions are not available the macro
<CODE>GSL_MIN</CODE> will be automatically substituted.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> extern inline int <B>GSL_MAX_INT</B> <I>(int <VAR>a</VAR>, int <VAR>b</VAR>)</I>
<DD><A NAME="IDX124"></A>
<DT><U>Function:</U> extern inline int <B>GSL_MIN_INT</B> <I>(int <VAR>a</VAR>, int <VAR>b</VAR>)</I>
<DD><A NAME="IDX125"></A>
These functions return the maximum or minimum of the integers <VAR>a</VAR>
and <VAR>b</VAR> using an inline function.  On platforms where inline
functions are not available the macros <CODE>GSL_MAX</CODE> or <CODE>GSL_MIN</CODE>
will be automatically substituted.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> extern inline long double <B>GSL_MAX_LDBL</B> <I>(long double <VAR>a</VAR>, long double <VAR>b</VAR>)</I>
<DD><A NAME="IDX126"></A>
<DT><U>Function:</U> extern inline long double <B>GSL_MIN_LDBL</B> <I>(long double <VAR>a</VAR>, long double <VAR>b</VAR>)</I>
<DD><A NAME="IDX127"></A>
These functions return the maximum or minimum of the long doubles <VAR>a</VAR>
and <VAR>b</VAR> using an inline function.  On platforms where inline
functions are not available the macros <CODE>GSL_MAX</CODE> or <CODE>GSL_MIN</CODE>
will be automatically substituted.
</DL>

</P>


<H2><A NAME="SEC40" HREF="gsl_manual.html#TOC40">Approximate Comparison of Floating Point Numbers</A></H2>

<P>
It is sometimes useful to be able to compare two floating point numbers
approximately, to allow for rounding and truncation errors.  The following
function implements the approximate floating-point comparison algorithm
proposed by D.E. Knuth in Section 4.2.2 of <CITE>Seminumerical
Algorithms</CITE> (3rd edition).

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_fcmp</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>, double <VAR>epsilon</VAR>)</I>
<DD><A NAME="IDX128"></A>
<A NAME="IDX129"></A>
<A NAME="IDX130"></A>
<A NAME="IDX131"></A>
This function determines whether x and y are approximately
equal to a relative accuracy <VAR>epsilon</VAR>.

</P>
<P>
The relative accuracy is measured using an interval of size 2
\delta, where \delta = 2^k \epsilon and k is the
maximum base-2 exponent of x and y as computed by the
function <CODE>frexp()</CODE>.  

</P>
<P>
If x and y lie within this interval, they are considered
approximately equal and the function returns 0. Otherwise if x &#60;
y, the function returns -1, or if x &#62; y, the function returns
+1.

</P>
<P>
The implementation is based on the package <CODE>fcmp</CODE> by T.C. Belding.
</DL>

</P>


<H1><A NAME="SEC41" HREF="gsl_manual.html#TOC41">Complex Numbers</A></H1>
<P>
<A NAME="IDX132"></A>

</P>
<P>
The functions described in this chapter provide support for complex
numbers.  The algorithms take care to avoid unnecessary intermediate
underflows and overflows, allowing the functions to be evaluated over 
as much of the complex plane as possible. 

</P>

<P>
For multiple-valued functions the branch cuts have been chosen to follow
the conventions of Abramowitz and Stegun in the <CITE>Handbook of
Mathematical Functions</CITE>. The functions return principal values which are
the same as those in GNU Calc, which in turn are the same as those in
<CITE>Common Lisp, The Language (Second Edition)</CITE><SUP>(<A NAME="DOCF1" HREF="gsl_manual.html#FOOT1">1</A>)</SUP> and the HP-28/48 series of
calculators.

</P>
<P>
The complex types are defined in the header file <TT>'gsl_complex.h'</TT>,
while the corresponding complex functions and arithmetic operations are
defined in <TT>'gsl_complex_math.h'</TT>.

</P>



<H2><A NAME="SEC42" HREF="gsl_manual.html#TOC42">Complex numbers</A></H2>
<P>
<A NAME="IDX133"></A>
<A NAME="IDX134"></A>

</P>
<P>
Complex numbers are represented using the type <CODE>gsl_complex</CODE>. The
internal representation of this type may vary across platforms and
should not be accessed directly. The functions and macros described
below allow complex numbers to be manipulated in a portable way.

</P>
<P>
For reference, the default form of the <CODE>gsl_complex</CODE> type is
given by the following struct,

</P>

<PRE class="example">
typedef struct
{
  double dat[2];
} gsl_complex;
</PRE>

<P>
The real and imaginary part are stored in contiguous elements of a two
element array. This eliminates any padding between the real and
imaginary parts, <CODE>dat[0]</CODE> and <CODE>dat[1]</CODE>, allowing the struct to
be mapped correctly onto packed complex arrays.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_rect</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>)</I>
<DD><A NAME="IDX135"></A>
This function uses the rectangular cartesian components
(<VAR>x</VAR>,<VAR>y</VAR>) to return the complex number z = x + i y.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_polar</B> <I>(double <VAR>r</VAR>, double <VAR>theta</VAR>)</I>
<DD><A NAME="IDX136"></A>
This function returns the complex number z = r \exp(i \theta) = r
(\cos(\theta) + i \sin(\theta)) from the polar representation
(<VAR>r</VAR>,<VAR>theta</VAR>).
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>GSL_REAL</B> <I>(<VAR>z</VAR>)</I>
<DD><A NAME="IDX137"></A>
<DT><U>Macro:</U> <B>GSL_IMAG</B> <I>(<VAR>z</VAR>)</I>
<DD><A NAME="IDX138"></A>
These macros return the real and imaginary parts of the complex number
<VAR>z</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>GSL_SET_COMPLEX</B> <I>(<VAR>zp</VAR>, <VAR>x</VAR>, <VAR>y</VAR>)</I>
<DD><A NAME="IDX139"></A>
This macro uses the cartesian components (<VAR>x</VAR>,<VAR>y</VAR>) to set the
real and imaginary parts of the complex number pointed to by <VAR>zp</VAR>.
For example,

</P>

<PRE class="example">
GSL_SET_COMPLEX(&#38;z, 3, 4)
</PRE>

<P>
sets <VAR>z</VAR> to be 3 + 4i.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>GSL_SET_REAL</B> <I>(<VAR>zp</VAR>,<VAR>x</VAR>)</I>
<DD><A NAME="IDX140"></A>
<DT><U>Macro:</U> <B>GSL_SET_IMAG</B> <I>(<VAR>zp</VAR>,<VAR>y</VAR>)</I>
<DD><A NAME="IDX141"></A>
These macros allow the real and imaginary parts of the complex number
pointed to by <VAR>zp</VAR> to be set independently.
</DL>

</P>


<H2><A NAME="SEC43" HREF="gsl_manual.html#TOC43">Properties of complex numbers</A></H2>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_complex_arg</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX142"></A>
<A NAME="IDX143"></A>
This function returns the argument of the complex number <VAR>z</VAR>,
\arg(z), where 
-\pi &#60; \arg(z) &#60;= \pi.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_complex_abs</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX144"></A>
<A NAME="IDX145"></A>
This function returns the magnitude of the complex number <VAR>z</VAR>, |z|.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_complex_abs2</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX146"></A>
This function returns the squared magnitude of the complex number
<VAR>z</VAR>, |z|^2.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_complex_logabs</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX147"></A>
This function returns the natural logarithm of the magnitude of the
complex number <VAR>z</VAR>, \log|z|.  It allows an accurate
evaluation of \log|z| when |z| is close to one. The direct
evaluation of <CODE>log(gsl_complex_abs(z))</CODE> would lead to a loss of
precision in this case.
</DL>

</P>



<H2><A NAME="SEC44" HREF="gsl_manual.html#TOC44">Complex arithmetic operators</A></H2>
<P>
<A NAME="IDX148"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_add</B> <I>(gsl_complex <VAR>a</VAR>, gsl_complex <VAR>b</VAR>)</I>
<DD><A NAME="IDX149"></A>
This function returns the sum of the complex numbers <VAR>a</VAR> and
<VAR>b</VAR>, z=a+b.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_sub</B> <I>(gsl_complex <VAR>a</VAR>, gsl_complex <VAR>b</VAR>)</I>
<DD><A NAME="IDX150"></A>
This function returns the difference of the complex numbers <VAR>a</VAR> and
<VAR>b</VAR>, z=a-b.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_mul</B> <I>(gsl_complex <VAR>a</VAR>, gsl_complex <VAR>b</VAR>)</I>
<DD><A NAME="IDX151"></A>
This function returns the product of the complex numbers <VAR>a</VAR> and
<VAR>b</VAR>, z=ab.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_div</B> <I>(gsl_complex <VAR>a</VAR>, gsl_complex <VAR>b</VAR>)</I>
<DD><A NAME="IDX152"></A>
This function returns the quotient of the complex numbers <VAR>a</VAR> and
<VAR>b</VAR>, z=a/b.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_add_real</B> <I>(gsl_complex <VAR>a</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX153"></A>
This function returns the sum of the complex number <VAR>a</VAR> and the
real number <VAR>x</VAR>, z=a+x.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_sub_real</B> <I>(gsl_complex <VAR>a</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX154"></A>
This function returns the difference of the complex number <VAR>a</VAR> and the
real number <VAR>x</VAR>, z=a-x.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_mul_real</B> <I>(gsl_complex <VAR>a</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX155"></A>
This function returns the product of the complex number <VAR>a</VAR> and the
real number <VAR>x</VAR>, z=ax.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_div_real</B> <I>(gsl_complex <VAR>a</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX156"></A>
This function returns the quotient of the complex number <VAR>a</VAR> and the
real number <VAR>x</VAR>, z=a/x.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_add_imag</B> <I>(gsl_complex <VAR>a</VAR>, double <VAR>y</VAR>)</I>
<DD><A NAME="IDX157"></A>
This function returns the sum of the complex number <VAR>a</VAR> and the
imaginary number i<VAR>y</VAR>, z=a+iy.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_sub_imag</B> <I>(gsl_complex <VAR>a</VAR>, double <VAR>y</VAR>)</I>
<DD><A NAME="IDX158"></A>
This function returns the difference of the complex number <VAR>a</VAR> and the
imaginary number i<VAR>y</VAR>, z=a-iy.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_mul_imag</B> <I>(gsl_complex <VAR>a</VAR>, double <VAR>y</VAR>)</I>
<DD><A NAME="IDX159"></A>
This function returns the product of the complex number <VAR>a</VAR> and the
imaginary number i<VAR>y</VAR>, z=a*(iy).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_div_imag</B> <I>(gsl_complex <VAR>a</VAR>, double <VAR>y</VAR>)</I>
<DD><A NAME="IDX160"></A>
This function returns the quotient of the complex number <VAR>a</VAR> and the
imaginary number i<VAR>y</VAR>, z=a/(iy).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_conjugate</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX161"></A>
<A NAME="IDX162"></A>
This function returns the complex conjugate of the complex number
<VAR>z</VAR>, z^* = x - i y.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_inverse</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX163"></A>
This function returns the inverse, or reciprocal, of the complex number
<VAR>z</VAR>, 1/z = (x - i y)/(x^2 + y^2).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_negative</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX164"></A>
This function returns the negative of the complex number
<VAR>z</VAR>, -z = (-x) + i(-y).
</DL>

</P>



<H2><A NAME="SEC45" HREF="gsl_manual.html#TOC45">Elementary Complex Functions</A></H2>

<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_sqrt</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX165"></A>
<A NAME="IDX166"></A>
This function returns the square root of the complex number <VAR>z</VAR>,
\sqrt z. The branch cut is the negative real axis. The result
always lies in the right half of the complex plane.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_sqrt_real</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX167"></A>
This function returns the complex square root of the real number
<VAR>x</VAR>, where <VAR>x</VAR> may be negative.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_pow</B> <I>(gsl_complex <VAR>z</VAR>, gsl_complex <VAR>a</VAR>)</I>
<DD><A NAME="IDX168"></A>
<A NAME="IDX169"></A>
<A NAME="IDX170"></A>
The function returns the complex number <VAR>z</VAR> raised to the complex
power <VAR>a</VAR>, z^a. This is computed as \exp(\log(z)*a)
using complex logarithms and complex exponentials.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_pow_real</B> <I>(gsl_complex <VAR>z</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX171"></A>
This function returns the complex number <VAR>z</VAR> raised to the real
power <VAR>x</VAR>, z^x.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_exp</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX172"></A>
This function returns the complex exponential of the complex number
<VAR>z</VAR>, \exp(z).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_log</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX173"></A>
<A NAME="IDX174"></A>
This function returns the complex natural logarithm (base e) of
the complex number <VAR>z</VAR>, \log(z).  The branch cut is the
negative real axis. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_log10</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX175"></A>
This function returns the complex base-10 logarithm of
the complex number <VAR>z</VAR>, 
\log_10 (z).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_log_b</B> <I>(gsl_complex <VAR>z</VAR>, gsl_complex <VAR>b</VAR>)</I>
<DD><A NAME="IDX176"></A>
This function returns the complex base-<VAR>b</VAR> logarithm of the complex
number <VAR>z</VAR>, \log_b(z). This quantity is computed as the ratio
\log(z)/\log(b).
</DL>

</P>



<H2><A NAME="SEC46" HREF="gsl_manual.html#TOC46">Complex Trigonometric Functions</A></H2>
<P>
<A NAME="IDX177"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_sin</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX178"></A>
<A NAME="IDX179"></A>
This function returns the complex sine of the complex number <VAR>z</VAR>,
\sin(z) = (\exp(iz) - \exp(-iz))/(2i).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_cos</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX180"></A>
<A NAME="IDX181"></A>
This function returns the complex cosine of the complex number <VAR>z</VAR>,
\cos(z) = (\exp(iz) + \exp(-iz))/2.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_tan</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX182"></A>
<A NAME="IDX183"></A>
This function returns the complex tangent of the complex number <VAR>z</VAR>,
\tan(z) = \sin(z)/\cos(z).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_sec</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX184"></A>
This function returns the complex secant of the complex number <VAR>z</VAR>,
\sec(z) = 1/\cos(z).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_csc</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX185"></A>
This function returns the complex cosecant of the complex number <VAR>z</VAR>,
\csc(z) = 1/\sin(z).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_cot</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX186"></A>
This function returns the complex cotangent of the complex number <VAR>z</VAR>,
\cot(z) = 1/\tan(z).
</DL>

</P>



<H2><A NAME="SEC47" HREF="gsl_manual.html#TOC47">Inverse Complex Trigonometric Functions</A></H2>
<P>
<A NAME="IDX187"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arcsin</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX188"></A>
This function returns the complex arcsine of the complex number <VAR>z</VAR>,
\arcsin(z). The branch cuts are on the real axis, less than -1
and greater than 1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arcsin_real</B> <I>(double <VAR>z</VAR>)</I>
<DD><A NAME="IDX189"></A>
This function returns the complex arcsine of the real number <VAR>z</VAR>,
\arcsin(z). For z between -1 and 1, the
function returns a real value in the range [-\pi/2,\pi/2]. For
z less than -1 the result has a real part of -\pi/2
and a positive imaginary part.  For z greater than 1 the
result has a real part of \pi/2 and a negative imaginary part.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arccos</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX190"></A>
This function returns the complex arccosine of the complex number <VAR>z</VAR>,
\arccos(z). The branch cuts are on the real axis, less than -1
and greater than 1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arccos_real</B> <I>(double <VAR>z</VAR>)</I>
<DD><A NAME="IDX191"></A>
This function returns the complex arccosine of the real number <VAR>z</VAR>,
\arccos(z). For z between -1 and 1, the
function returns a real value in the range [0,\pi]. For z
less than -1 the result has a real part of \pi and a
negative imaginary part.  For z greater than 1 the result
is purely imaginary and positive.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arctan</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX192"></A>
This function returns the complex arctangent of the complex number
<VAR>z</VAR>, \arctan(z). The branch cuts are on the imaginary axis,
below -i and above i.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arcsec</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX193"></A>
This function returns the complex arcsecant of the complex number <VAR>z</VAR>,
\arcsec(z) = \arccos(1/z). 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arcsec_real</B> <I>(double <VAR>z</VAR>)</I>
<DD><A NAME="IDX194"></A>
This function returns the complex arcsecant of the real number <VAR>z</VAR>,
\arcsec(z) = \arccos(1/z). 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arccsc</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX195"></A>
This function returns the complex arccosecant of the complex number <VAR>z</VAR>,
\arccsc(z) = \arcsin(1/z). 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arccsc_real</B> <I>(double <VAR>z</VAR>)</I>
<DD><A NAME="IDX196"></A>
This function returns the complex arccosecant of the real number <VAR>z</VAR>,
\arccsc(z) = \arcsin(1/z). 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arccot</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX197"></A>
This function returns the complex arccotangent of the complex number <VAR>z</VAR>,
\arccot(z) = \arctan(1/z). 
</DL>

</P>



<H2><A NAME="SEC48" HREF="gsl_manual.html#TOC48">Complex Hyperbolic Functions</A></H2>
<P>
<A NAME="IDX198"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_sinh</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX199"></A>
This function returns the complex hyperbolic sine of the complex number
<VAR>z</VAR>, \sinh(z) = (\exp(z) - \exp(-z))/2.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_cosh</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX200"></A>
This function returns the complex hyperbolic cosine of the complex number
<VAR>z</VAR>, \cosh(z) = (\exp(z) + \exp(-z))/2.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_tanh</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX201"></A>
This function returns the complex hyperbolic tangent of the complex number
<VAR>z</VAR>, \tanh(z) = \sinh(z)/\cosh(z).
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_sech</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX202"></A>
This function returns the complex hyperbolic secant of the complex
number <VAR>z</VAR>, \sech(z) = 1/\cosh(z).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_csch</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX203"></A>
This function returns the complex hyperbolic cosecant of the complex
number <VAR>z</VAR>, \csch(z) = 1/\sinh(z).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_coth</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX204"></A>
This function returns the complex hyperbolic cotangent of the complex
number <VAR>z</VAR>, \coth(z) = 1/\tanh(z).
</DL>

</P>



<H2><A NAME="SEC49" HREF="gsl_manual.html#TOC49">Inverse Complex Hyperbolic Functions</A></H2>
<P>
<A NAME="IDX205"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arcsinh</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX206"></A>
This function returns the complex hyperbolic arcsine of the
complex number <VAR>z</VAR>, \arcsinh(z).  The branch cuts are on the
imaginary axis, below -i and above i.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arccosh</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX207"></A>
This function returns the complex hyperbolic arccosine of the complex
number <VAR>z</VAR>, \arccosh(z).  The branch cut is on the real axis,
less than 1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arccosh_real</B> <I>(double <VAR>z</VAR>)</I>
<DD><A NAME="IDX208"></A>
This function returns the complex hyperbolic arccosine of
the real number <VAR>z</VAR>, \arccosh(z).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arctanh</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX209"></A>
This function returns the complex hyperbolic arctangent of the complex
number <VAR>z</VAR>, \arctanh(z).  The branch cuts are on the real
axis, less than -1 and greater than 1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arctanh_real</B> <I>(double <VAR>z</VAR>)</I>
<DD><A NAME="IDX210"></A>
This function returns the complex hyperbolic arctangent of the real
number <VAR>z</VAR>, \arctanh(z).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arcsech</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX211"></A>
This function returns the complex hyperbolic arcsecant of the complex
number <VAR>z</VAR>, \arcsech(z) = \arccosh(1/z).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arccsch</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX212"></A>
This function returns the complex hyperbolic arccosecant of the complex
number <VAR>z</VAR>, \arccsch(z) = \arcsin(1/z).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_complex <B>gsl_complex_arccoth</B> <I>(gsl_complex <VAR>z</VAR>)</I>
<DD><A NAME="IDX213"></A>
This function returns the complex hyperbolic arccotangent of the complex
number <VAR>z</VAR>, \arccoth(z) = \arctanh(1/z).
</DL>

</P>


<H2><A NAME="SEC50" HREF="gsl_manual.html#TOC50">References and Further Reading</A></H2>

<P>
The implementations of the elementary and trigonometric functions are
based on the following papers,

</P>

<UL class="itemize">
<LI>

T. E. Hull, Thomas F. Fairgrieve, Ping Tak Peter Tang,
"Implementing Complex Elementary Functions Using Exception
Handling", <CITE>ACM Transactions on Mathematical Software</CITE>, Volume 20
(1994), pp 215--244, Corrigenda, p553

<LI>

T. E. Hull, Thomas F. Fairgrieve, Ping Tak Peter Tang,
"Implementing the complex arcsin and arccosine functions using exception
handling", <CITE>ACM Transactions on Mathematical Software</CITE>, Volume 23
(1997) pp 299--335
</UL>

<P>
The general formulas and details of branch cuts can be found in the
following books,

</P>

<UL class="itemize">
<LI>

Abramowitz and Stegun, <CITE>Handbook of Mathematical Functions</CITE>,
"Circular Functions in Terms of Real and Imaginary Parts", Formulas
4.3.55--58,
"Inverse Circular Functions in Terms of Real and Imaginary Parts",
Formulas 4.4.37--39,
"Hyperbolic Functions in Terms of Real and Imaginary Parts",
Formulas 4.5.49--52,
"Inverse Hyperbolic Functions--relation to Inverse Circular Functions",
Formulas 4.6.14--19.

<LI>

Dave Gillespie, <CITE>Calc Manual</CITE>, Free Software Foundation, ISBN
1-882114-18-3
</UL>



<H1><A NAME="SEC51" HREF="gsl_manual.html#TOC51">Polynomials</A></H1>
<P>
<A NAME="IDX214"></A>

</P>
<P>
This chapter describes functions for evaluating and solving polynomials.
There are routines for finding real and complex roots of quadratic and
cubic equations using analytic methods.  An iterative polynomial solver
is also available for finding the roots of general polynomials with real
coefficients (of any order).  The functions are declared in the header
file <CODE>gsl_poly.h</CODE>.

</P>



<H2><A NAME="SEC52" HREF="gsl_manual.html#TOC52">Polynomial Evaluation</A></H2>
<P>
<A NAME="IDX215"></A>
<A NAME="IDX216"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_poly_eval</B> <I>(const double <VAR>c</VAR>[], const int <VAR>len</VAR>, const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX217"></A>
This function evaluates the polynomial 
c[0] + c[1] x + c[2] x^2 + \dots + c[len-1] x^{len-1} using
Horner's method for stability.  The function is inlined when possible.
</DL>

</P>


<H2><A NAME="SEC53" HREF="gsl_manual.html#TOC53">Divided Difference Representation of Polynomials</A></H2>
<P>
<A NAME="IDX218"></A>
<A NAME="IDX219"></A>

</P>
<P>
The functions described here manipulate polynomials stored in Newton's
divided-difference representation.  The use of divided-differences is
described in Abramowitz &#38; Stegun sections 25.1.4 and 25.2.26.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_poly_dd_init</B> <I>(double <VAR>dd</VAR>[], const double <VAR>xa</VAR>[], const double <VAR>ya</VAR>[], size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX220"></A>
This function computes a divided-difference representation of the
interpolating polynomial for the points (<VAR>xa</VAR>, <VAR>ya</VAR>) stored in
the arrays <VAR>xa</VAR> and <VAR>ya</VAR> of length <VAR>size</VAR>.  On output the
divided-differences of (<VAR>xa</VAR>,<VAR>ya</VAR>) are stored in the array
<VAR>dd</VAR>, also of length <VAR>size</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_poly_dd_eval</B> <I>(const double <VAR>dd</VAR>[], const double <VAR>xa</VAR>[], const size_t <VAR>size</VAR>, const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX221"></A>
This function evaluates the polynomial stored in divided-difference form
in the arrays <VAR>dd</VAR> and <VAR>xa</VAR> of length <VAR>size</VAR> at the point
<VAR>x</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_poly_dd_taylor</B> <I>(double <VAR>c</VAR>[], double <VAR>xp</VAR>, const double <VAR>dd</VAR>[], const double <VAR>xa</VAR>[], size_t <VAR>size</VAR>, double <VAR>w</VAR>[])</I>
<DD><A NAME="IDX222"></A>
This function converts the divided-difference representation of a
polynomial to a Taylor expansion.  The divided-difference representation
is supplied in the arrays <VAR>dd</VAR> and <VAR>xa</VAR> of length <VAR>size</VAR>.
On output the Taylor coefficients of the polynomial expanded about the
point <VAR>xp</VAR> are stored in the array <VAR>c</VAR> also of length
<VAR>size</VAR>.  A workspace of length <VAR>size</VAR> must be provided in the
array <VAR>w</VAR>.
</DL>

</P>


<H2><A NAME="SEC54" HREF="gsl_manual.html#TOC54">Quadratic Equations</A></H2>
<P>
<A NAME="IDX223"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_poly_solve_quadratic</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>c</VAR>, double * <VAR>x0</VAR>, double * <VAR>x1</VAR>)</I>
<DD><A NAME="IDX224"></A>
This function finds the real roots of the quadratic equation,

<SPAN class="ifinfo">


<PRE class="example">
a x^2 + b x + c = 0
</PRE>

</SPAN>

<P>
The number of real roots (either zero, one or two) is returned, and
their locations are stored in <VAR>x0</VAR> and <VAR>x1</VAR>.  If no real roots
are found then <VAR>x0</VAR> and <VAR>x1</VAR> are not modified.  If one real root
is found (i.e. if a=0) then it is stored in <VAR>x0</VAR>.  When two
real roots are found they are stored in <VAR>x0</VAR> and <VAR>x1</VAR> in
ascending order.  The case of coincident roots is not considered
special.  For example (x-1)^2=0 will have two roots, which happen
to have exactly equal values.

</P>
<P>
The number of roots found depends on the sign of the discriminant
b^2 - 4 a c.  This will be subject to rounding and cancellation
errors when computed in double precision, and will also be subject to
errors if the coefficients of the polynomial are inexact.  These errors
may cause a discrete change in the number of roots.  However, for
polynomials with small integer coefficients the discriminant can always
be computed exactly.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_poly_complex_solve_quadratic</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>c</VAR>, gsl_complex * <VAR>z0</VAR>, gsl_complex * <VAR>z1</VAR>)</I>
<DD><A NAME="IDX225"></A>

</P>
<P>
This function finds the complex roots of the quadratic equation,

<SPAN class="ifinfo">


<PRE class="example">
a z^2 + b z + c = 0
</PRE>

</SPAN>

<P>
The number of complex roots is returned (either one or two) and the
locations of the roots are stored in <VAR>z0</VAR> and <VAR>z1</VAR>.  The roots
are returned in ascending order, sorted first by their real components
and then by their imaginary components.  If only one real root is found
(i.e. if a=0) then it is stored in <VAR>z0</VAR>.

</P>
</DL>



<H2><A NAME="SEC55" HREF="gsl_manual.html#TOC55">Cubic Equations</A></H2>
<P>
<A NAME="IDX226"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_poly_solve_cubic</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>c</VAR>, double * <VAR>x0</VAR>, double * <VAR>x1</VAR>, double * <VAR>x2</VAR>)</I>
<DD><A NAME="IDX227"></A>

</P>
<P>
This function finds the real roots of the cubic equation,

<SPAN class="ifinfo">


<PRE class="example">
x^3 + a x^2 + b x + c = 0
</PRE>

</SPAN>

<P>
with a leading coefficient of unity.  The number of real roots (either
one or three) is returned, and their locations are stored in <VAR>x0</VAR>,
<VAR>x1</VAR> and <VAR>x2</VAR>.  If one real root is found then only <VAR>x0</VAR> is
modified.  When three real roots are found they are stored in <VAR>x0</VAR>,
<VAR>x1</VAR> and <VAR>x2</VAR> in ascending order.  The case of coincident roots
is not considered special.  For example, the equation (x-1)^3=0
will have three roots with exactly equal values.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_poly_complex_solve_cubic</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>c</VAR>, gsl_complex * <VAR>z0</VAR>, gsl_complex * <VAR>z1</VAR>, gsl_complex * <VAR>z2</VAR>)</I>
<DD><A NAME="IDX228"></A>

</P>
<P>
This function finds the complex roots of the cubic equation,

<SPAN class="ifinfo">


<PRE class="example">
z^3 + a z^2 + b z + c = 0
</PRE>

</SPAN>

<P>
The number of complex roots is returned (always three) and the locations
of the roots are stored in <VAR>z0</VAR>, <VAR>z1</VAR> and <VAR>z2</VAR>.  The roots
are returned in ascending order, sorted first by their real components
and then by their imaginary components.

</P>
</DL>



<H2><A NAME="SEC56" HREF="gsl_manual.html#TOC56">General Polynomial Equations</A></H2>
<P>
<A NAME="IDX229"></A>

</P>
<P>
The roots of polynomial equations cannot be found analytically beyond
the special cases of the quadratic, cubic and quartic equation.  The
algorithm described in this section uses an iterative method to find the
approximate locations of roots of higher order polynomials.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_poly_complex_workspace * <B>gsl_poly_complex_workspace_alloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX230"></A>
This function allocates space for a <CODE>gsl_poly_complex_workspace</CODE>
struct and a workspace suitable for solving a polynomial with <VAR>n</VAR>
coefficients using the routine <CODE>gsl_poly_complex_solve</CODE>.

</P>
<P>
The function returns a pointer to the newly allocated
<CODE>gsl_poly_complex_workspace</CODE> if no errors were detected, and a null
pointer in the case of error.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_poly_complex_workspace_free</B> <I>(gsl_poly_complex_workspace * <VAR>w</VAR>)</I>
<DD><A NAME="IDX231"></A>
This function frees all the memory associated with the workspace
<VAR>w</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_poly_complex_solve</B> <I>(const double * <VAR>a</VAR>, size_t <VAR>n</VAR>, gsl_poly_complex_workspace * <VAR>w</VAR>, gsl_complex_packed_ptr <VAR>z</VAR>)</I>
<DD><A NAME="IDX232"></A>
This function computes the roots of the general polynomial 
P(x) = a_0 + a_1 x + a_2 x^2 + ... + a_{n-1} x^{n-1} using 
balanced-QR reduction of the companion matrix.  The parameter <VAR>n</VAR>
specifies the length of the coefficient array.  The coefficient of the
highest order term must be non-zero.  The function requires a workspace
<VAR>w</VAR> of the appropriate size.  The n-1 roots are returned in
the packed complex array <VAR>z</VAR> of length 2(n-1), alternating
real and imaginary parts.

</P>
<P>
The function returns <CODE>GSL_SUCCESS</CODE> if all the roots are found and
<CODE>GSL_EFAILED</CODE> if the QR reduction does not converge.  Note that due
to finite precision, roots of higher multiplicity are returned as a
cluster of simple roots with reduced accuracy.  The solution of
polynomials with higher-order roots requires specialized algorithms that
take the multiplicity structure into account (see e.g. Z. Zeng,
Algorithm 835, ACM Transactions on Mathematical Software, Volume 30,
Issue 2 (2004), pp 218--236).
</DL>

</P>


<H2><A NAME="SEC57" HREF="gsl_manual.html#TOC57">Examples</A></H2>

<P>
To demonstrate the use of the general polynomial solver we will take the
polynomial P(x) = x^5 - 1 which has the following roots,

<SPAN class="ifinfo">


<PRE class="example">
1, e^{2\pi i /5}, e^{4\pi i /5}, e^{6\pi i /5}, e^{8\pi i /5}
</PRE>

</SPAN>

<P>
The following program will find these roots.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_poly.h&#62;

int
main (void)
{
  int i;
  /* coefficients of P(x) =  -1 + x^5  */
  double a[6] = { -1, 0, 0, 0, 0, 1 };  
  double z[10];

  gsl_poly_complex_workspace * w 
      = gsl_poly_complex_workspace_alloc (6);
  
  gsl_poly_complex_solve (a, 6, w, z);

  gsl_poly_complex_workspace_free (w);

  for (i = 0; i &#60; 5; i++)
    {
      printf ("z%d = %+.18f %+.18f\n", 
              i, z[2*i], z[2*i+1]);
    }

  return 0;
}
</PRE>

<P>
The output of the program is,

</P>

<PRE class="example">
$ ./a.out 
z0 = -0.809016994374947451 +0.587785252292473137
z1 = -0.809016994374947451 -0.587785252292473137
z2 = +0.309016994374947451 +0.951056516295153642
z3 = +0.309016994374947451 -0.951056516295153642
z4 = +1.000000000000000000 +0.000000000000000000
</PRE>

<P>
which agrees with the analytic result, z_n = \exp(2 \pi n i/5).

</P>


<H2><A NAME="SEC58" HREF="gsl_manual.html#TOC58">References and Further Reading</A></H2>

<P>
The balanced-QR method and its error analysis are described in the
following papers,

</P>

<UL class="itemize">
<LI>

R.S. Martin, G. Peters and J.H. Wilkinson, "The QR Algorithm for Real
Hessenberg Matrices", <CITE>Numerische Mathematik</CITE>, 14 (1970), 219--231.

<LI>

B.N. Parlett and C. Reinsch, "Balancing a Matrix for Calculation of
Eigenvalues and Eigenvectors", <CITE>Numerische Mathematik</CITE>, 13 (1969),
293--304.

<LI>

A. Edelman and H. Murakami, "Polynomial roots from companion matrix
eigenvalues", <CITE>Mathematics of Computation</CITE>, Vol. 64, No. 210
(1995), 763--776.
</UL>

<P>
The formulas for divided differences are given in Abramowitz and Stegun,

</P>

<UL class="itemize">
<LI>

Abramowitz and Stegun, <CITE>Handbook of Mathematical Functions</CITE>,
Sections 25.1.4 and 25.2.26.
</UL>



<H1><A NAME="SEC59" HREF="gsl_manual.html#TOC59">Special Functions</A></H1>
<P>
<A NAME="IDX233"></A>

</P>
<P>
This chapter describes the GSL special function library.  The library
includes routines for calculating the values of Airy functions, Bessel
functions, Clausen functions, Coulomb wave functions, Coupling
coefficients, the Dawson function, Debye functions, Dilogarithms,
Elliptic integrals, Jacobi elliptic functions, Error functions,
Exponential integrals, Fermi-Dirac functions, Gamma functions,
Gegenbauer functions, Hypergeometric functions, Laguerre functions,
Legendre functions and Spherical Harmonics, the Psi (Digamma) Function,
Synchrotron functions, Transport functions, Trigonometric functions and
Zeta functions.  Each routine also computes an estimate of the numerical
error in the calculated value of the function.

</P>
<P>
The functions in this chapter are declared in individual header files,
such as <TT>'gsl_sf_airy.h'</TT>, <TT>'gsl_sf_bessel.h'</TT>, etc.  The complete
set of header files can be included using the file <TT>'gsl_sf.h'</TT>.

</P>



<H2><A NAME="SEC60" HREF="gsl_manual.html#TOC60">Usage</A></H2>

<P>
The special functions are available in two calling conventions, a
<I>natural form</I> which returns the numerical value of the function and
an <I>error-handling form</I> which returns an error code.  The two types
of function provide alternative ways of accessing the same underlying
code.

</P>
<P>
The <I>natural form</I> returns only the value of the function and can be
used directly in mathematical expressions.  For example, the following
function call will compute the value of the Bessel function
J_0(x),

</P>

<PRE class="example">
double y = gsl_sf_bessel_J0 (x);
</PRE>

<P>
There is no way to access an error code or to estimate the error using
this method.  To allow access to this information the alternative
error-handling form stores the value and error in a modifiable argument,

</P>

<PRE class="example">
gsl_sf_result result;
int status = gsl_sf_bessel_J0_e (x, &#38;result);
</PRE>

<P>
The error-handling functions have the suffix <CODE>_e</CODE>. The returned
status value indicates error conditions such as overflow, underflow or
loss of precision.  If there are no errors the error-handling functions
return <CODE>GSL_SUCCESS</CODE>.

</P>


<H2><A NAME="SEC61" HREF="gsl_manual.html#TOC61">The gsl_sf_result struct</A></H2>
<P>
<A NAME="IDX234"></A>
<A NAME="IDX235"></A>

</P>
<P>
The error handling form of the special functions always calculate an
error estimate along with the value of the result.  Therefore,
structures are provided for amalgamating a value and error estimate.
These structures are declared in the header file <TT>'gsl_sf_result.h'</TT>.

</P>
<P>
The <CODE>gsl_sf_result</CODE> struct contains value and error fields.

</P>

<PRE class="example">
typedef struct
{
  double val;
  double err;
} gsl_sf_result;
</PRE>

<P>
The field <VAR>val</VAR> contains the value and the field <VAR>err</VAR> contains
an estimate of the absolute error in the value.

</P>
<P>
In some cases, an overflow or underflow can be detected and handled by a
function.  In this case, it may be possible to return a scaling exponent
as well as an error/value pair in order to save the result from
exceeding the dynamic range of the built-in types.  The
<CODE>gsl_sf_result_e10</CODE> struct contains value and error fields as well
as an exponent field such that the actual result is obtained as
<CODE>result * 10^(e10)</CODE>.

</P>

<PRE class="example">
typedef struct
{
  double val;
  double err;
  int    e10;
} gsl_sf_result_e10;
</PRE>



<H2><A NAME="SEC62" HREF="gsl_manual.html#TOC62">Modes</A></H2>

<P>
The goal of the library is to achieve double precision accuracy wherever
possible.  However the cost of evaluating some special functions to
double precision can be significant, particularly where very high order
terms are required.  In these cases a <CODE>mode</CODE> argument allows the
accuracy of the function to be reduced in order to improve performance.
The following precision levels are available for the mode argument,

</P>
<DL COMPACT>

<DT><CODE>GSL_PREC_DOUBLE</CODE>
<DD>
Double-precision, a relative accuracy of approximately 
2 * 10^-16.
<DT><CODE>GSL_PREC_SINGLE</CODE>
<DD>
Single-precision, a relative accuracy of approximately 
10^-7.
<DT><CODE>GSL_PREC_APPROX</CODE>
<DD>
Approximate values, a relative accuracy of approximately 
5 * 10^-4.
</DL>
<P>
The approximate mode provides the fastest evaluation at the lowest
accuracy.

</P>


<H2><A NAME="SEC63" HREF="gsl_manual.html#TOC63">Airy Functions and Derivatives</A></H2>
<P>
<A NAME="IDX236"></A>
<A NAME="IDX237"></A>
<A NAME="IDX238"></A>

</P>
<P>
The Airy functions Ai(x) and Bi(x) are defined by the
integral representations,

<SPAN class="ifinfo">


<PRE class="example">
Ai(x) = (1/\pi) \int_0^\infty \cos((1/3) t^3 + xt) dt
Bi(x) = (1/\pi) \int_0^\infty (e^(-(1/3) t^3) + \sin((1/3) t^3 + xt)) dt
</PRE>

</SPAN>

<P>
For further information see Abramowitz &#38; Stegun, Section 10.4. The Airy
functions are defined in the header file <TT>'gsl_sf_airy.h'</TT>.

</P>



<H3><A NAME="SEC64" HREF="gsl_manual.html#TOC64">Airy Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_airy_Ai</B> <I>(double <VAR>x</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX239"></A>
<DT><U>Function:</U> int <B>gsl_sf_airy_Ai_e</B> <I>(double <VAR>x</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX240"></A>
These routines compute the Airy function Ai(x) with an accuracy
specified by <VAR>mode</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_airy_Bi</B> <I>(double <VAR>x</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX241"></A>
<DT><U>Function:</U> int <B>gsl_sf_airy_Bi_e</B> <I>(double <VAR>x</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX242"></A>
These routines compute the Airy function Bi(x) with an accuracy
specified by <VAR>mode</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_airy_Ai_scaled</B> <I>(double <VAR>x</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX243"></A>
<DT><U>Function:</U> int <B>gsl_sf_airy_Ai_scaled_e</B> <I>(double <VAR>x</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX244"></A>
These routines compute a scaled version of the Airy function
S_A(x) Ai(x).  For x&#62;0 the scaling factor S_A(x) is 
\exp(+(2/3) x^(3/2)), 
and is 1
for x&#60;0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_airy_Bi_scaled</B> <I>(double <VAR>x</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX245"></A>
<DT><U>Function:</U> int <B>gsl_sf_airy_Bi_scaled_e</B> <I>(double <VAR>x</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX246"></A>
These routines compute a scaled version of the Airy function
S_B(x) Bi(x).  For x&#62;0 the scaling factor S_B(x) is 
exp(-(2/3) x^(3/2)), and is 1 for x&#60;0.
</DL>

</P>



<H3><A NAME="SEC65" HREF="gsl_manual.html#TOC65">Derivatives of Airy Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_airy_Ai_deriv</B> <I>(double <VAR>x</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX247"></A>
<DT><U>Function:</U> int <B>gsl_sf_airy_Ai_deriv_e</B> <I>(double <VAR>x</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX248"></A>
These routines compute the Airy function derivative Ai'(x) with
an accuracy specified by <VAR>mode</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_airy_Bi_deriv</B> <I>(double <VAR>x</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX249"></A>
<DT><U>Function:</U> int <B>gsl_sf_airy_Bi_deriv_e</B> <I>(double <VAR>x</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX250"></A>
These routines compute the Airy function derivative Bi'(x) with
an accuracy specified by <VAR>mode</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_airy_Ai_deriv_scaled</B> <I>(double <VAR>x</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX251"></A>
<DT><U>Function:</U> int <B>gsl_sf_airy_Ai_deriv_scaled_e</B> <I>(double <VAR>x</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX252"></A>
These routines compute the scaled Airy function derivative 
S_A(x) Ai'(x).  
For x&#62;0 the scaling factor S_A(x) is 
\exp(+(2/3) x^(3/2)), and is 1 for x&#60;0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_airy_Bi_deriv_scaled</B> <I>(double <VAR>x</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX253"></A>
<DT><U>Function:</U> int <B>gsl_sf_airy_Bi_deriv_scaled_e</B> <I>(double <VAR>x</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX254"></A>
These routines compute the scaled Airy function derivative 
S_B(x) Bi'(x).
For x&#62;0 the scaling factor S_B(x) is 
exp(-(2/3) x^(3/2)), and is 1 for x&#60;0.
</DL>

</P>



<H3><A NAME="SEC66" HREF="gsl_manual.html#TOC66">Zeros of Airy Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_airy_zero_Ai</B> <I>(unsigned int <VAR>s</VAR>)</I>
<DD><A NAME="IDX255"></A>
<DT><U>Function:</U> int <B>gsl_sf_airy_zero_Ai_e</B> <I>(unsigned int <VAR>s</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX256"></A>
These routines compute the location of the <VAR>s</VAR>-th zero of the Airy
function Ai(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_airy_zero_Bi</B> <I>(unsigned int <VAR>s</VAR>)</I>
<DD><A NAME="IDX257"></A>
<DT><U>Function:</U> int <B>gsl_sf_airy_zero_Bi_e</B> <I>(unsigned int <VAR>s</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX258"></A>
These routines compute the location of the <VAR>s</VAR>-th zero of the Airy
function Bi(x).
</DL>

</P>



<H3><A NAME="SEC67" HREF="gsl_manual.html#TOC67">Zeros of Derivatives of Airy Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_airy_zero_Ai_deriv</B> <I>(unsigned int <VAR>s</VAR>)</I>
<DD><A NAME="IDX259"></A>
<DT><U>Function:</U> int <B>gsl_sf_airy_zero_Ai_deriv_e</B> <I>(unsigned int <VAR>s</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX260"></A>
These routines compute the location of the <VAR>s</VAR>-th zero of the Airy
function derivative Ai'(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_airy_zero_Bi_deriv</B> <I>(unsigned int <VAR>s</VAR>)</I>
<DD><A NAME="IDX261"></A>
<DT><U>Function:</U> int <B>gsl_sf_airy_zero_Bi_deriv_e</B> <I>(unsigned int <VAR>s</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX262"></A>
These routines compute the location of the <VAR>s</VAR>-th zero of the Airy
function derivative Bi'(x).
</DL>

</P>



<H2><A NAME="SEC68" HREF="gsl_manual.html#TOC68">Bessel Functions</A></H2>
<P>
<A NAME="IDX263"></A>

</P>
<P>
The routines described in this section compute the Cylindrical Bessel
functions J_n(x), Y_n(x), Modified cylindrical Bessel
functions I_n(x), K_n(x), Spherical Bessel functions
j_l(x), y_l(x), and Modified Spherical Bessel functions
i_l(x), k_l(x).  For more information see Abramowitz &#38; Stegun,
Chapters 9 and 10.  The Bessel functions are defined in the header file
<TT>'gsl_sf_bessel.h'</TT>.

</P>



<H3><A NAME="SEC69" HREF="gsl_manual.html#TOC69">Regular Cylindrical Bessel Functions</A></H3>
<P>
<A NAME="IDX264"></A>
<A NAME="IDX265"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_J0</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX266"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_J0_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX267"></A>
These routines compute the regular cylindrical Bessel function of zeroth
order, J_0(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_J1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX268"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_J1_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX269"></A>
These routines compute the regular cylindrical Bessel function of first
order, J_1(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_Jn</B> <I>(int <VAR>n</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX270"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_Jn_e</B> <I>(int <VAR>n</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX271"></A>
These routines compute the regular cylindrical Bessel function of 
order <VAR>n</VAR>, J_n(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_bessel_Jn_array</B> <I>(int <VAR>nmin</VAR>, int <VAR>nmax</VAR>, double <VAR>x</VAR>, double <VAR>result_array</VAR>[])</I>
<DD><A NAME="IDX272"></A>
This routine computes the values of the regular cylindrical Bessel
functions J_n(x) for n from <VAR>nmin</VAR> to <VAR>nmax</VAR>
inclusive, storing the results in the array <VAR>result_array</VAR>.  The
values are computed using recurrence relations for efficiency, and
therefore may differ slightly from the exact values.
</DL>

</P>



<H3><A NAME="SEC70" HREF="gsl_manual.html#TOC70">Irregular Cylindrical Bessel Functions</A></H3>
<P>
<A NAME="IDX273"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_Y0</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX274"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_Y0_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX275"></A>
These routines compute the irregular cylindrical Bessel function of zeroth
order, Y_0(x), for x&#62;0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_Y1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX276"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_Y1_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX277"></A>
These routines compute the irregular cylindrical Bessel function of first
order, Y_1(x), for x&#62;0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_Yn</B> <I>(int <VAR>n</VAR>,double <VAR>x</VAR>)</I>
<DD><A NAME="IDX278"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_Yn_e</B> <I>(int <VAR>n</VAR>,double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX279"></A>
These routines compute the irregular cylindrical Bessel function of 
order <VAR>n</VAR>, Y_n(x), for x&#62;0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_bessel_Yn_array</B> <I>(int <VAR>nmin</VAR>, int <VAR>nmax</VAR>, double <VAR>x</VAR>, double <VAR>result_array</VAR>[])</I>
<DD><A NAME="IDX280"></A>
This routine computes the values of the irregular cylindrical Bessel
functions Y_n(x) for n from <VAR>nmin</VAR> to <VAR>nmax</VAR>
inclusive, storing the results in the array <VAR>result_array</VAR>.  The
domain of the function is x&#62;0.  The values are computed using
recurrence relations for efficiency, and therefore may differ slightly
from the exact values.
</DL>

</P>



<H3><A NAME="SEC71" HREF="gsl_manual.html#TOC71">Regular Modified Cylindrical Bessel Functions</A></H3>
<P>
<A NAME="IDX281"></A>
<A NAME="IDX282"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_I0</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX283"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_I0_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX284"></A>
These routines compute the regular modified cylindrical Bessel function
of zeroth order, I_0(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_I1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX285"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_I1_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX286"></A>
These routines compute the regular modified cylindrical Bessel function
of first order, I_1(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_In</B> <I>(int <VAR>n</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX287"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_In_e</B> <I>(int <VAR>n</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX288"></A>
These routines compute the regular modified cylindrical Bessel function
of order <VAR>n</VAR>, I_n(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_bessel_In_array</B> <I>(int <VAR>nmin</VAR>, int <VAR>nmax</VAR>, double <VAR>x</VAR>, double <VAR>result_array</VAR>[])</I>
<DD><A NAME="IDX289"></A>
This routine computes the values of the regular modified cylindrical
Bessel functions I_n(x) for n from <VAR>nmin</VAR> to
<VAR>nmax</VAR> inclusive, storing the results in the array
<VAR>result_array</VAR>.  The start of the range <VAR>nmin</VAR> must be positive
or zero.  The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_I0_scaled</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX290"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_I0_scaled_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX291"></A>
These routines compute the scaled regular modified cylindrical Bessel
function of zeroth order \exp(-|x|) I_0(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_I1_scaled</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX292"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_I1_scaled_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX293"></A>
These routines compute the scaled regular modified cylindrical Bessel
function of first order \exp(-|x|) I_1(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_In_scaled</B> <I>(int <VAR>n</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX294"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_In_scaled_e</B> <I>(int <VAR>n</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX295"></A>
These routines compute the scaled regular modified cylindrical Bessel
function of order <VAR>n</VAR>, \exp(-|x|) I_n(x) 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_bessel_In_scaled_array</B> <I>(int <VAR>nmin</VAR>, int <VAR>nmax</VAR>, double <VAR>x</VAR>, double <VAR>result_array</VAR>[])</I>
<DD><A NAME="IDX296"></A>
This routine computes the values of the scaled regular cylindrical
Bessel functions \exp(-|x|) I_n(x) for n from
<VAR>nmin</VAR> to <VAR>nmax</VAR> inclusive, storing the results in the array
<VAR>result_array</VAR>. The start of the range <VAR>nmin</VAR> must be positive
or zero.  The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
</DL>

</P>



<H3><A NAME="SEC72" HREF="gsl_manual.html#TOC72">Irregular Modified Cylindrical Bessel Functions</A></H3>
<P>
<A NAME="IDX297"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_K0</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX298"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_K0_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX299"></A>
These routines compute the irregular modified cylindrical Bessel
function of zeroth order, K_0(x), for x &#62; 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_K1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX300"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_K1_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX301"></A>
These routines compute the irregular modified cylindrical Bessel
function of first order, K_1(x), for x &#62; 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_Kn</B> <I>(int <VAR>n</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX302"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_Kn_e</B> <I>(int <VAR>n</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX303"></A>
These routines compute the irregular modified cylindrical Bessel
function of order <VAR>n</VAR>, K_n(x), for x &#62; 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_bessel_Kn_array</B> <I>(int <VAR>nmin</VAR>, int <VAR>nmax</VAR>, double <VAR>x</VAR>, double <VAR>result_array</VAR>[])</I>
<DD><A NAME="IDX304"></A>
This routine computes the values of the irregular modified cylindrical
Bessel functions K_n(x) for n from <VAR>nmin</VAR> to
<VAR>nmax</VAR> inclusive, storing the results in the array
<VAR>result_array</VAR>. The start of the range <VAR>nmin</VAR> must be positive
or zero. The domain of the function is x&#62;0. The values are
computed using recurrence relations for efficiency, and therefore
may differ slightly from the exact values.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_K0_scaled</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX305"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_K0_scaled_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX306"></A>
These routines compute the scaled irregular modified cylindrical Bessel
function of zeroth order \exp(x) K_0(x) for x&#62;0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_K1_scaled</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX307"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_K1_scaled_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX308"></A>
These routines compute the scaled irregular modified cylindrical Bessel
function of first order \exp(x) K_1(x) for x&#62;0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_Kn_scaled</B> <I>(int <VAR>n</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX309"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_Kn_scaled_e</B> <I>(int <VAR>n</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX310"></A>
These routines compute the scaled irregular modified cylindrical Bessel
function of order <VAR>n</VAR>, \exp(x) K_n(x), for x&#62;0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_bessel_Kn_scaled_array</B> <I>(int <VAR>nmin</VAR>, int <VAR>nmax</VAR>, double <VAR>x</VAR>, double <VAR>result_array</VAR>[])</I>
<DD><A NAME="IDX311"></A>
This routine computes the values of the scaled irregular cylindrical
Bessel functions \exp(x) K_n(x) for n from <VAR>nmin</VAR> to
<VAR>nmax</VAR> inclusive, storing the results in the array
<VAR>result_array</VAR>. The start of the range <VAR>nmin</VAR> must be positive
or zero.  The domain of the function is x&#62;0. The values are
computed using recurrence relations for efficiency, and therefore
may differ slightly from the exact values.
</DL>

</P>



<H3><A NAME="SEC73" HREF="gsl_manual.html#TOC73">Regular Spherical Bessel Functions</A></H3>
<P>
<A NAME="IDX312"></A>
<A NAME="IDX313"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_j0</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX314"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_j0_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX315"></A>
These routines compute the regular spherical Bessel function of zeroth
order, j_0(x) = \sin(x)/x.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_j1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX316"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_j1_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX317"></A>
These routines compute the regular spherical Bessel function of first
order, j_1(x) = (\sin(x)/x - \cos(x))/x.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_j2</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX318"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_j2_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX319"></A>
These routines compute the regular spherical Bessel function of second
order, j_2(x) = ((3/x^2 - 1)\sin(x) - 3\cos(x)/x)/x.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_jl</B> <I>(int <VAR>l</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX320"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_jl_e</B> <I>(int <VAR>l</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX321"></A>
These routines compute the regular spherical Bessel function of 
order <VAR>l</VAR>, j_l(x), for 
l &#62;= 0 and 
x &#62;= 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_bessel_jl_array</B> <I>(int <VAR>lmax</VAR>, double <VAR>x</VAR>, double <VAR>result_array</VAR>[])</I>
<DD><A NAME="IDX322"></A>
This routine computes the values of the regular spherical Bessel
functions j_l(x) for l from 0 to <VAR>lmax</VAR>
inclusive  for 
lmax &#62;= 0 and 
x &#62;= 0, storing the results in the array <VAR>result_array</VAR>.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_bessel_jl_steed_array</B> <I>(int <VAR>lmax</VAR>, double <VAR>x</VAR>, double * <VAR>jl_x_array</VAR>)</I>
<DD><A NAME="IDX323"></A>
This routine uses Steed's method to compute the values of the regular
spherical Bessel functions j_l(x) for l from 0 to
<VAR>lmax</VAR> inclusive for 
lmax &#62;= 0 and 
x &#62;= 0, storing the results in the array
<VAR>result_array</VAR>.
The Steed/Barnett algorithm is described in <CITE>Comp. Phys. Comm.</CITE> 21,
297 (1981).  Steed's method is more stable than the
recurrence used in the other functions but is also slower.
</DL>

</P>



<H3><A NAME="SEC74" HREF="gsl_manual.html#TOC74">Irregular Spherical Bessel Functions</A></H3>
<P>
<A NAME="IDX324"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_y0</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX325"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_y0_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX326"></A>
These routines compute the irregular spherical Bessel function of zeroth
order, y_0(x) = -\cos(x)/x.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_y1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX327"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_y1_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX328"></A>
These routines compute the irregular spherical Bessel function of first
order, y_1(x) = -(\cos(x)/x + \sin(x))/x.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_y2</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX329"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_y2_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX330"></A>
These routines compute the irregular spherical Bessel function of second
order, y_2(x) = (-3/x^3 + 1/x)\cos(x) - (3/x^2)\sin(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_yl</B> <I>(int <VAR>l</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX331"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_yl_e</B> <I>(int <VAR>l</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX332"></A>
These routines compute the irregular spherical Bessel function of 
order <VAR>l</VAR>, y_l(x), for 
l &#62;= 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_bessel_yl_array</B> <I>(int <VAR>lmax</VAR>, double <VAR>x</VAR>, double <VAR>result_array</VAR>[])</I>
<DD><A NAME="IDX333"></A>
This routine computes the values of the irregular spherical Bessel
functions y_l(x) for l from 0 to <VAR>lmax</VAR>
inclusive  for 
lmax &#62;= 0, storing the results in the array <VAR>result_array</VAR>.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
</DL>

</P>



<H3><A NAME="SEC75" HREF="gsl_manual.html#TOC75">Regular Modified Spherical Bessel Functions</A></H3>
<P>
<A NAME="IDX334"></A>
<A NAME="IDX335"></A>

</P>
<P>
The regular modified spherical Bessel functions i_l(x) 
are related to the modified Bessel functions of fractional order,
i_l(x) = \sqrt{\pi/(2x)} I_{l+1/2}(x)

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_i0_scaled</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX336"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_i0_scaled_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX337"></A>
These routines compute the scaled regular modified spherical Bessel
function of zeroth order, \exp(-|x|) i_0(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_i1_scaled</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX338"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_i1_scaled_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX339"></A>
These routines compute the scaled regular modified spherical Bessel
function of first order, \exp(-|x|) i_1(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_i2_scaled</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX340"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_i2_scaled_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX341"></A>
These routines compute the scaled regular modified spherical Bessel
function of second order,  \exp(-|x|) i_2(x)  
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_il_scaled</B> <I>(int <VAR>l</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX342"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_il_scaled_e</B> <I>(int <VAR>l</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX343"></A>
These routines compute the scaled regular modified spherical Bessel
function of order <VAR>l</VAR>,  \exp(-|x|) i_l(x) 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_bessel_il_scaled_array</B> <I>(int <VAR>lmax</VAR>, double <VAR>x</VAR>, double <VAR>result_array</VAR>[])</I>
<DD><A NAME="IDX344"></A>
This routine computes the values of the scaled regular modified
cylindrical Bessel functions \exp(-|x|) i_l(x) for l from
0 to <VAR>lmax</VAR> inclusive for 
lmax &#62;= 0, storing the results in
the array <VAR>result_array</VAR>. 
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
</DL>

</P>



<H3><A NAME="SEC76" HREF="gsl_manual.html#TOC76">Irregular Modified Spherical Bessel Functions</A></H3>
<P>
<A NAME="IDX345"></A>

</P>
<P>
The irregular modified spherical Bessel functions k_l(x)
are related to the irregular modified Bessel functions of fractional order,
k_l(x) = \sqrt{\pi/(2x)} K_{l+1/2}(x).

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_k0_scaled</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX346"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_k0_scaled_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX347"></A>
These routines compute the scaled irregular modified spherical Bessel
function of zeroth order, \exp(x) k_0(x), for x&#62;0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_k1_scaled</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX348"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_k1_scaled_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX349"></A>
These routines compute the scaled irregular modified spherical Bessel
function of first order, \exp(x) k_1(x), for x&#62;0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_k2_scaled</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX350"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_k2_scaled_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX351"></A>
These routines compute the scaled irregular modified spherical Bessel
function of second order, \exp(x) k_2(x), for x&#62;0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_kl_scaled</B> <I>(int <VAR>l</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX352"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_kl_scaled_e</B> <I>(int <VAR>l</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX353"></A>
These routines compute the scaled irregular modified spherical Bessel
function of order <VAR>l</VAR>, \exp(x) k_l(x), for x&#62;0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_bessel_kl_scaled_array</B> <I>(int <VAR>lmax</VAR>, double <VAR>x</VAR>, double <VAR>result_array</VAR>[])</I>
<DD><A NAME="IDX354"></A>
This routine computes the values of the scaled irregular modified
spherical Bessel functions \exp(x) k_l(x) for l from
0 to <VAR>lmax</VAR> inclusive for 
lmax &#62;= 0 and x&#62;0, storing the results in
the array <VAR>result_array</VAR>. 
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
</DL>

</P>



<H3><A NAME="SEC77" HREF="gsl_manual.html#TOC77">Regular Bessel Function--Fractional Order</A></H3>
<P>
<A NAME="IDX355"></A>
<A NAME="IDX356"></A>
<A NAME="IDX357"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_Jnu</B> <I>(double <VAR>nu</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX358"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_Jnu_e</B> <I>(double <VAR>nu</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX359"></A>
These routines compute the regular cylindrical Bessel function of
fractional order \nu, J_\nu(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_bessel_sequence_Jnu_e</B> <I>(double <VAR>nu</VAR>, gsl_mode_t <VAR>mode</VAR>, size_t <VAR>size</VAR>, double <VAR>v</VAR>[])</I>
<DD><A NAME="IDX360"></A>
This function computes the regular cylindrical Bessel function of
fractional order \nu, J_\nu(x), evaluated at a series of
x values.  The array <VAR>v</VAR> of length <VAR>size</VAR> contains the
x values.  They are assumed to be strictly ordered and positive.
The array is over-written with the values of J_\nu(x_i).
</DL>

</P>



<H3><A NAME="SEC78" HREF="gsl_manual.html#TOC78">Irregular Bessel Functions--Fractional Order</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_Ynu</B> <I>(double <VAR>nu</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX361"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_Ynu_e</B> <I>(double <VAR>nu</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX362"></A>
These routines compute the irregular cylindrical Bessel function of
fractional order \nu, Y_\nu(x).
</DL>

</P>



<H3><A NAME="SEC79" HREF="gsl_manual.html#TOC79">Regular Modified Bessel Functions--Fractional Order</A></H3>
<P>
<A NAME="IDX363"></A>
<A NAME="IDX364"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_Inu</B> <I>(double <VAR>nu</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX365"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_Inu_e</B> <I>(double <VAR>nu</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX366"></A>
These routines compute the regular modified Bessel function of
fractional order \nu, I_\nu(x) for x&#62;0,
\nu&#62;0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_Inu_scaled</B> <I>(double <VAR>nu</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX367"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_Inu_scaled_e</B> <I>(double <VAR>nu</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX368"></A>
These routines compute the scaled regular modified Bessel function of
fractional order \nu, \exp(-|x|)I_\nu(x) for x&#62;0,
\nu&#62;0.
</DL>

</P>



<H3><A NAME="SEC80" HREF="gsl_manual.html#TOC80">Irregular Modified Bessel Functions--Fractional Order</A></H3>
<P>
<A NAME="IDX369"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_Knu</B> <I>(double <VAR>nu</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX370"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_Knu_e</B> <I>(double <VAR>nu</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX371"></A>
These routines compute the irregular modified Bessel function of
fractional order \nu, K_\nu(x) for x&#62;0,
\nu&#62;0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_lnKnu</B> <I>(double <VAR>nu</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX372"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_lnKnu_e</B> <I>(double <VAR>nu</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX373"></A>
These routines compute the logarithm of the irregular modified Bessel
function of fractional order \nu, \ln(K_\nu(x)) for
x&#62;0, \nu&#62;0. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_Knu_scaled</B> <I>(double <VAR>nu</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX374"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_Knu_scaled_e</B> <I>(double <VAR>nu</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX375"></A>
These routines compute the scaled irregular modified Bessel function of
fractional order \nu, \exp(+|x|) K_\nu(x) for x&#62;0,
\nu&#62;0.
</DL>

</P>


<H3><A NAME="SEC81" HREF="gsl_manual.html#TOC81">Zeros of Regular Bessel Functions</A></H3>
<P>
<A NAME="IDX376"></A>
<A NAME="IDX377"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_zero_J0</B> <I>(unsigned int <VAR>s</VAR>)</I>
<DD><A NAME="IDX378"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_zero_J0_e</B> <I>(unsigned int <VAR>s</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX379"></A>
These routines compute the location of the <VAR>s</VAR>-th positive zero of
the Bessel function J_0(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_zero_J1</B> <I>(unsigned int <VAR>s</VAR>)</I>
<DD><A NAME="IDX380"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_zero_J1_e</B> <I>(unsigned int <VAR>s</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX381"></A>
These routines compute the location of the <VAR>s</VAR>-th positive zero of
the Bessel function J_1(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_bessel_zero_Jnu</B> <I>(double <VAR>nu</VAR>, unsigned int <VAR>s</VAR>)</I>
<DD><A NAME="IDX382"></A>
<DT><U>Function:</U> int <B>gsl_sf_bessel_zero_Jnu_e</B> <I>(double <VAR>nu</VAR>, unsigned int <VAR>s</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX383"></A>
These routines compute the location of the <VAR>s</VAR>-th positive zero of
the Bessel function J_\nu(x).  The current implementation does not
support negative values of <VAR>nu</VAR>. 
</DL>

</P>



<H2><A NAME="SEC82" HREF="gsl_manual.html#TOC82">Clausen Functions</A></H2>
<P>
<A NAME="IDX384"></A>

</P>
<P>
The Clausen function is defined by the following integral,

<SPAN class="ifinfo">


<PRE class="example">
Cl_2(x) = - \int_0^x dt \log(2 \sin(t/2))
</PRE>

</SPAN>

<P>
It is related to the dilogarithm by 
Cl_2(\theta) = \Im Li_2(\exp(i\theta)).  
The Clausen functions are declared in the header file
<TT>'gsl_sf_clausen.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_clausen</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX385"></A>
<DT><U>Function:</U> int <B>gsl_sf_clausen_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX386"></A>
These routines compute the Clausen integral Cl_2(x).
</DL>

</P>


<H2><A NAME="SEC83" HREF="gsl_manual.html#TOC83">Coulomb Functions</A></H2>
<P>
<A NAME="IDX387"></A>
<A NAME="IDX388"></A>

</P>
<P>
The prototypes of the Coulomb functions are declared in the header file
<TT>'gsl_sf_coulomb.h'</TT>.  Both bound state and scattering solutions are
available.

</P>



<H3><A NAME="SEC84" HREF="gsl_manual.html#TOC84">Normalized Hydrogenic Bound States</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_hydrogenicR_1</B> <I>(double <VAR>Z</VAR>, double <VAR>r</VAR>)</I>
<DD><A NAME="IDX389"></A>
<DT><U>Function:</U> int <B>gsl_sf_hydrogenicR_1_e</B> <I>(double <VAR>Z</VAR>, double <VAR>r</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX390"></A>
These routines compute the lowest-order normalized hydrogenic bound
state radial wavefunction 
R_1 := 2Z \sqrt{Z} \exp(-Z r).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_hydrogenicR</B> <I>(int <VAR>n</VAR>, int <VAR>l</VAR>, double <VAR>Z</VAR>, double <VAR>r</VAR>)</I>
<DD><A NAME="IDX391"></A>
<DT><U>Function:</U> int <B>gsl_sf_hydrogenicR_e</B> <I>(int <VAR>n</VAR>, int <VAR>l</VAR>, double <VAR>Z</VAR>, double <VAR>r</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX392"></A>
These routines compute the <VAR>n</VAR>-th normalized hydrogenic bound state
radial wavefunction,

<SPAN class="ifinfo">


<PRE class="example">
R_n := 2 (Z^{3/2}/n^2) \sqrt{(n-l-1)!/(n+l)!} \exp(-Z r/n) (2Z/n)^l
          L^{2l+1}_{n-l-1}(2Z/n r).  
</PRE>

</SPAN>

<P>
The normalization is chosen such that the wavefunction \psi is
given by 
\psi(n,l,r) = R_n Y_{lm}.
</DL>

</P>


<H3><A NAME="SEC85" HREF="gsl_manual.html#TOC85">Coulomb Wave Functions</A></H3>

<P>
The Coulomb wave functions F_L(\eta,x), G_L(\eta,x) are
described in Abramowitz &#38; Stegun, Chapter 14.  Because there can be a
large dynamic range of values for these functions, overflows are handled
gracefully.  If an overflow occurs, <CODE>GSL_EOVRFLW</CODE> is signalled and
exponent(s) are returned through the modifiable parameters <VAR>exp_F</VAR>,
<VAR>exp_G</VAR>. The full solution can be reconstructed from the following
relations,

<SPAN class="ifinfo">


<PRE class="example">
F_L(eta,x)  =  fc[k_L] * exp(exp_F)
G_L(eta,x)  =  gc[k_L] * exp(exp_G)

F_L'(eta,x) = fcp[k_L] * exp(exp_F)
G_L'(eta,x) = gcp[k_L] * exp(exp_G)
</PRE>

</SPAN>

<P>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_coulomb_wave_FG_e</B> <I>(double <VAR>eta</VAR>, double <VAR>x</VAR>, double <VAR>L_F</VAR>, int <VAR>k</VAR>, gsl_sf_result * <VAR>F</VAR>, gsl_sf_result * <VAR>Fp</VAR>, gsl_sf_result * <VAR>G</VAR>, gsl_sf_result * <VAR>Gp</VAR>, double * <VAR>exp_F</VAR>, double * <VAR>exp_G</VAR>)</I>
<DD><A NAME="IDX393"></A>
This function computes the Coulomb wave functions F_L(\eta,x),
G_{L-k}(\eta,x) and their derivatives 
F'_L(\eta,x), 
G'_{L-k}(\eta,x)
with respect to x.  The parameters are restricted to L,
L-k &#62; -1/2, x &#62; 0 and integer k.  Note that L
itself is not restricted to being an integer. The results are stored in
the parameters <VAR>F</VAR>, <VAR>G</VAR> for the function values and <VAR>Fp</VAR>,
<VAR>Gp</VAR> for the derivative values.  If an overflow occurs,
<CODE>GSL_EOVRFLW</CODE> is returned and scaling exponents are stored in
the modifiable parameters <VAR>exp_F</VAR>, <VAR>exp_G</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_coulomb_wave_F_array</B> <I>(double <VAR>L_min</VAR>, int <VAR>kmax</VAR>, double <VAR>eta</VAR>, double <VAR>x</VAR>, double <VAR>fc_array</VAR>[], double * <VAR>F_exponent</VAR>)</I>
<DD><A NAME="IDX394"></A>
This function computes the Coulomb wave function F_L(\eta,x) for
L = Lmin \dots Lmin + kmax, storing the results in <VAR>fc_array</VAR>.
In the case of overflow the exponent is stored in <VAR>F_exponent</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_coulomb_wave_FG_array</B> <I>(double <VAR>L_min</VAR>, int <VAR>kmax</VAR>, double <VAR>eta</VAR>, double <VAR>x</VAR>, double <VAR>fc_array</VAR>[], double <VAR>gc_array</VAR>[], double * <VAR>F_exponent</VAR>, double * <VAR>G_exponent</VAR>)</I>
<DD><A NAME="IDX395"></A>
This function computes the functions F_L(\eta,x),
G_L(\eta,x) for L = Lmin \dots Lmin + kmax storing the
results in <VAR>fc_array</VAR> and <VAR>gc_array</VAR>.  In the case of overflow the
exponents are stored in <VAR>F_exponent</VAR> and <VAR>G_exponent</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_coulomb_wave_FGp_array</B> <I>(double <VAR>L_min</VAR>, int <VAR>kmax</VAR>, double <VAR>eta</VAR>, double <VAR>x</VAR>, double <VAR>fc_array</VAR>[], double <VAR>fcp_array</VAR>[], double <VAR>gc_array</VAR>[], double <VAR>gcp_array</VAR>[], double * <VAR>F_exponent</VAR>, double * <VAR>G_exponent</VAR>)</I>
<DD><A NAME="IDX396"></A>
This function computes the functions F_L(\eta,x),
G_L(\eta,x) and their derivatives F'_L(\eta,x),
G'_L(\eta,x) for L = Lmin \dots Lmin + kmax storing the
results in <VAR>fc_array</VAR>, <VAR>gc_array</VAR>, <VAR>fcp_array</VAR> and <VAR>gcp_array</VAR>.
In the case of overflow the exponents are stored in <VAR>F_exponent</VAR> 
and <VAR>G_exponent</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_coulomb_wave_sphF_array</B> <I>(double <VAR>L_min</VAR>, int <VAR>kmax</VAR>, double <VAR>eta</VAR>, double <VAR>x</VAR>, double <VAR>fc_array</VAR>[], double <VAR>F_exponent</VAR>[])</I>
<DD><A NAME="IDX397"></A>
This function computes the Coulomb wave function divided by the argument
F_L(\eta, x)/x for L = Lmin \dots Lmin + kmax, storing the
results in <VAR>fc_array</VAR>.  In the case of overflow the exponent is
stored in <VAR>F_exponent</VAR>. This function reduces to spherical Bessel
functions in the limit \eta \to 0.
</DL>

</P>


<H3><A NAME="SEC86" HREF="gsl_manual.html#TOC86">Coulomb Wave Function Normalization Constant</A></H3>

<P>
The Coulomb wave function normalization constant is defined in
Abramowitz 14.1.7.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_coulomb_CL_e</B> <I>(double <VAR>L</VAR>, double <VAR>eta</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX398"></A>
This function computes the Coulomb wave function normalization constant
C_L(\eta) for L &#62; -1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_coulomb_CL_array</B> <I>(double <VAR>Lmin</VAR>, int <VAR>kmax</VAR>, double <VAR>eta</VAR>, double <VAR>cl</VAR>[])</I>
<DD><A NAME="IDX399"></A>
This function computes the Coulomb wave function normalization constant
C_L(\eta) for L = Lmin \dots Lmin + kmax, Lmin &#62; -1.
</DL>

</P>



<H2><A NAME="SEC87" HREF="gsl_manual.html#TOC87">Coupling Coefficients</A></H2>
<P>
<A NAME="IDX400"></A>
<A NAME="IDX401"></A>
<A NAME="IDX402"></A>
<A NAME="IDX403"></A>
<A NAME="IDX404"></A>
<A NAME="IDX405"></A>

</P>
<P>
The Wigner 3-j, 6-j and 9-j symbols give the coupling coefficients for
combined angular momentum vectors.  Since the arguments of the standard
coupling coefficient functions are integer or half-integer, the
arguments of the following functions are, by convention, integers equal
to twice the actual spin value.  For information on the 3-j coefficients
see Abramowitz &#38; Stegun, Section 27.9.  The functions described in this
section are declared in the header file <TT>'gsl_sf_coupling.h'</TT>.

</P>



<H3><A NAME="SEC88" HREF="gsl_manual.html#TOC88">3-j Symbols</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_coupling_3j</B> <I>(int <VAR>two_ja</VAR>, int <VAR>two_jb</VAR>, int <VAR>two_jc</VAR>, int <VAR>two_ma</VAR>, int <VAR>two_mb</VAR>, int <VAR>two_mc</VAR>)</I>
<DD><A NAME="IDX406"></A>
<DT><U>Function:</U> int <B>gsl_sf_coupling_3j_e</B> <I>(int <VAR>two_ja</VAR>, int <VAR>two_jb</VAR>, int <VAR>two_jc</VAR>, int <VAR>two_ma</VAR>, int <VAR>two_mb</VAR>, int <VAR>two_mc</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX407"></A>
These routines compute the Wigner 3-j coefficient, 

<SPAN class="ifinfo">


<PRE class="example">
(ja jb jc
 ma mb mc)
</PRE>

</SPAN>

<P>
where the arguments are given in half-integer units, ja =
<VAR>two_ja</VAR>/2, ma = <VAR>two_ma</VAR>/2, etc.
</DL>

</P>



<H3><A NAME="SEC89" HREF="gsl_manual.html#TOC89">6-j Symbols</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_coupling_6j</B> <I>(int <VAR>two_ja</VAR>, int <VAR>two_jb</VAR>, int <VAR>two_jc</VAR>, int <VAR>two_jd</VAR>, int <VAR>two_je</VAR>, int <VAR>two_jf</VAR>)</I>
<DD><A NAME="IDX408"></A>
<DT><U>Function:</U> int <B>gsl_sf_coupling_6j_e</B> <I>(int <VAR>two_ja</VAR>, int <VAR>two_jb</VAR>, int <VAR>two_jc</VAR>, int <VAR>two_jd</VAR>, int <VAR>two_je</VAR>, int <VAR>two_jf</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX409"></A>
These routines compute the Wigner 6-j coefficient, 

<SPAN class="ifinfo">


<PRE class="example">
{ja jb jc
 jd je jf}
</PRE>

</SPAN>

<P>
where the arguments are given in half-integer units, ja =
<VAR>two_ja</VAR>/2, ma = <VAR>two_ma</VAR>/2, etc.
</DL>

</P>



<H3><A NAME="SEC90" HREF="gsl_manual.html#TOC90">9-j Symbols</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_coupling_9j</B> <I>(int <VAR>two_ja</VAR>, int <VAR>two_jb</VAR>, int <VAR>two_jc</VAR>, int <VAR>two_jd</VAR>, int <VAR>two_je</VAR>, int <VAR>two_jf</VAR>, int <VAR>two_jg</VAR>, int <VAR>two_jh</VAR>, int <VAR>two_ji</VAR>)</I>
<DD><A NAME="IDX410"></A>
<DT><U>Function:</U> int <B>gsl_sf_coupling_9j_e</B> <I>(int <VAR>two_ja</VAR>, int <VAR>two_jb</VAR>, int <VAR>two_jc</VAR>, int <VAR>two_jd</VAR>, int <VAR>two_je</VAR>, int <VAR>two_jf</VAR>, int <VAR>two_jg</VAR>, int <VAR>two_jh</VAR>, int <VAR>two_ji</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX411"></A>
These routines compute the Wigner 9-j coefficient, 

<SPAN class="ifinfo">


<PRE class="example">
{ja jb jc
 jd je jf
 jg jh ji}
</PRE>

</SPAN>

<P>
where the arguments are given in half-integer units, ja =
<VAR>two_ja</VAR>/2, ma = <VAR>two_ma</VAR>/2, etc.
</DL>

</P>



<H2><A NAME="SEC91" HREF="gsl_manual.html#TOC91">Dawson Function</A></H2>
<P>
<A NAME="IDX412"></A>

</P>
<P>
The Dawson integral is defined by \exp(-x^2) \int_0^x dt
\exp(t^2).  A table of Dawson's integral can be found in Abramowitz &#38;
Stegun, Table 7.5.  The Dawson functions are declared in the header file
<TT>'gsl_sf_dawson.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_dawson</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX413"></A>
<DT><U>Function:</U> int <B>gsl_sf_dawson_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX414"></A>
These routines compute the value of Dawson's integral for <VAR>x</VAR>.
</DL>

</P>


<H2><A NAME="SEC92" HREF="gsl_manual.html#TOC92">Debye Functions</A></H2>
<P>
<A NAME="IDX415"></A>

</P>
<P>
The Debye functions D_n(x) are defined by the following integral,

<SPAN class="ifinfo">


<PRE class="example">
D_n(x) = n/x^n \int_0^x dt (t^n/(e^t - 1))
</PRE>

</SPAN>

<P>
For further information see Abramowitz &#38;
Stegun, Section 27.1.  The Debye functions are declared in the header
file <TT>'gsl_sf_debye.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_debye_1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX416"></A>
<DT><U>Function:</U> int <B>gsl_sf_debye_1_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX417"></A>
These routines compute the first-order Debye function 
D_1(x) = (1/x) \int_0^x dt (t/(e^t - 1)).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_debye_2</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX418"></A>
<DT><U>Function:</U> int <B>gsl_sf_debye_2_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX419"></A>
These routines compute the second-order Debye function 
D_2(x) = (2/x^2) \int_0^x dt (t^2/(e^t - 1)).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_debye_3</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX420"></A>
<DT><U>Function:</U> int <B>gsl_sf_debye_3_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX421"></A>
These routines compute the third-order Debye function 
D_3(x) = (3/x^3) \int_0^x dt (t^3/(e^t - 1)).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_debye_4</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX422"></A>
<DT><U>Function:</U> int <B>gsl_sf_debye_4_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX423"></A>
These routines compute the fourth-order Debye function 
D_4(x) = (4/x^4) \int_0^x dt (t^4/(e^t - 1)).
</DL>

</P>


<H2><A NAME="SEC93" HREF="gsl_manual.html#TOC93">Dilogarithm</A></H2>
<P>
<A NAME="IDX424"></A>

</P>
<P>
The functions described in this section are declared in the header file
<TT>'gsl_sf_dilog.h'</TT>.

</P>



<H3><A NAME="SEC94" HREF="gsl_manual.html#TOC94">Real Argument</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_dilog</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX425"></A>
<DT><U>Function:</U> int <B>gsl_sf_dilog_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX426"></A>
These routines compute the dilogarithm for a real argument. In Lewin's
notation this is Li_2(x), the real part of the dilogarithm of a
real x.  It is defined by the integral representation
Li_2(x) = - \Re \int_0^x ds \log(1-s) / s.  
Note that \Im(Li_2(x)) = 0 for 
x &#60;= 1, and -\pi\log(x) for x &#62; 1.

</P>
</DL>



<H3><A NAME="SEC95" HREF="gsl_manual.html#TOC95">Complex Argument</A></H3>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_complex_dilog_e</B> <I>(double <VAR>r</VAR>, double <VAR>theta</VAR>, gsl_sf_result * <VAR>result_re</VAR>, gsl_sf_result * <VAR>result_im</VAR>)</I>
<DD><A NAME="IDX427"></A>
This function computes the full complex-valued dilogarithm for the
complex argument z = r \exp(i \theta). The real and imaginary
parts of the result are returned in <VAR>result_re</VAR>, <VAR>result_im</VAR>.
</DL>

</P>


<H2><A NAME="SEC96" HREF="gsl_manual.html#TOC96">Elementary Operations</A></H2>
<P>
<A NAME="IDX428"></A>
<A NAME="IDX429"></A>

</P>
<P>
The following functions allow for the propagation of errors when
combining quantities by multiplication.  The functions are declared in
the header file <TT>'gsl_sf_elementary.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_multiply_e</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX430"></A>
This function multiplies <VAR>x</VAR> and <VAR>y</VAR> storing the product and its
associated error in <VAR>result</VAR>.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_multiply_err_e</B> <I>(double <VAR>x</VAR>, double <VAR>dx</VAR>, double <VAR>y</VAR>, double <VAR>dy</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX431"></A>
This function multiplies <VAR>x</VAR> and <VAR>y</VAR> with associated absolute
errors <VAR>dx</VAR> and <VAR>dy</VAR>.  The product 
xy +/- xy \sqrt((dx/x)^2 +(dy/y)^2) 
is stored in <VAR>result</VAR>.
</DL>

</P>


<H2><A NAME="SEC97" HREF="gsl_manual.html#TOC97">Elliptic Integrals</A></H2>
<P>
<A NAME="IDX432"></A>

</P>
<P>
The functions described in this section are declared in the header file
<TT>'gsl_sf_ellint.h'</TT>.

</P>



<H3><A NAME="SEC98" HREF="gsl_manual.html#TOC98">Definition of Legendre Forms</A></H3>
<P>
<A NAME="IDX433"></A>
The Legendre forms of elliptic integrals F(\phi,k),
E(\phi,k) and P(\phi,k,n) are defined by,

<SPAN class="ifinfo">


<PRE class="example">
  F(\phi,k) = \int_0^\phi dt 1/\sqrt((1 - k^2 \sin^2(t)))

  E(\phi,k) = \int_0^\phi dt   \sqrt((1 - k^2 \sin^2(t)))

P(\phi,k,n) = \int_0^\phi dt 1/((1 + n \sin^2(t))\sqrt(1 - k^2 \sin^2(t)))
</PRE>

</SPAN>

<P>
The complete Legendre forms are denoted by K(k) = F(\pi/2, k) and
E(k) = E(\pi/2, k).  Further information on the Legendre forms of
elliptic integrals can be found in Abramowitz &#38; Stegun, Chapter 17.  The
notation used here is based on Carlson, <CITE>Numerische Mathematik</CITE> 33
(1979) 1 and differs slightly from that used by Abramowitz &#38; Stegun.

</P>


<H3><A NAME="SEC99" HREF="gsl_manual.html#TOC99">Definition of Carlson Forms</A></H3>
<P>
<A NAME="IDX434"></A>
The Carlson symmetric forms of elliptical integrals RC(x,y),
RD(x,y,z), RF(x,y,z) and RJ(x,y,z,p) are defined
by,

<SPAN class="ifinfo">


<PRE class="example">
    RC(x,y) = 1/2 \int_0^\infty dt (t+x)^(-1/2) (t+y)^(-1)

  RD(x,y,z) = 3/2 \int_0^\infty dt (t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-3/2)

  RF(x,y,z) = 1/2 \int_0^\infty dt (t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-1/2)

RJ(x,y,z,p) = 3/2 \int_0^\infty dt 
                 (t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-1/2) (t+p)^(-1)
</PRE>

</SPAN>



<H3><A NAME="SEC100" HREF="gsl_manual.html#TOC100">Legendre Form of Complete Elliptic Integrals</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_ellint_Kcomp</B> <I>(double <VAR>k</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX435"></A>
<DT><U>Function:</U> int <B>gsl_sf_ellint_Kcomp_e</B> <I>(double <VAR>k</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX436"></A>
These routines compute the complete elliptic integral K(k) to the
accuracy specified by the mode variable <VAR>mode</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_ellint_Ecomp</B> <I>(double <VAR>k</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX437"></A>
<DT><U>Function:</U> int <B>gsl_sf_ellint_Ecomp_e</B> <I>(double <VAR>k</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX438"></A>
These routines compute the complete elliptic integral E(k) to the
accuracy specified by the mode variable <VAR>mode</VAR>.
</DL>

</P>



<H3><A NAME="SEC101" HREF="gsl_manual.html#TOC101">Legendre Form of Incomplete Elliptic Integrals</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_ellint_F</B> <I>(double <VAR>phi</VAR>, double <VAR>k</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX439"></A>
<DT><U>Function:</U> int <B>gsl_sf_ellint_F_e</B> <I>(double <VAR>phi</VAR>, double <VAR>k</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX440"></A>
These routines compute the incomplete elliptic integral F(\phi,k)
to the accuracy specified by the mode variable <VAR>mode</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_ellint_E</B> <I>(double <VAR>phi</VAR>, double <VAR>k</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX441"></A>
<DT><U>Function:</U> int <B>gsl_sf_ellint_E_e</B> <I>(double <VAR>phi</VAR>, double <VAR>k</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX442"></A>
These routines compute the incomplete elliptic integral E(\phi,k)
to the accuracy specified by the mode variable <VAR>mode</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_ellint_P</B> <I>(double <VAR>phi</VAR>, double <VAR>k</VAR>, double <VAR>n</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX443"></A>
<DT><U>Function:</U> int <B>gsl_sf_ellint_P_e</B> <I>(double <VAR>phi</VAR>, double <VAR>k</VAR>, double <VAR>n</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX444"></A>
These routines compute the incomplete elliptic integral P(\phi,k,n)
to the accuracy specified by the mode variable <VAR>mode</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_ellint_D</B> <I>(double <VAR>phi</VAR>, double <VAR>k</VAR>, double <VAR>n</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX445"></A>
<DT><U>Function:</U> int <B>gsl_sf_ellint_D_e</B> <I>(double <VAR>phi</VAR>, double <VAR>k</VAR>, double <VAR>n</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX446"></A>
These functions compute the incomplete elliptic integral
D(\phi,k,n) which is defined through the Carlson form RD(x,y,z)
by the following relation, 

<SPAN class="ifinfo">


<PRE class="example">
D(\phi,k,n) = RD (1-\sin^2(\phi), 1-k^2 \sin^2(\phi), 1).
</PRE>

</SPAN>

</DL>



<H3><A NAME="SEC102" HREF="gsl_manual.html#TOC102">Carlson Forms</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_ellint_RC</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX447"></A>
<DT><U>Function:</U> int <B>gsl_sf_ellint_RC_e</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX448"></A>
These routines compute the incomplete elliptic integral RC(x,y)
to the accuracy specified by the mode variable <VAR>mode</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_ellint_RD</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>, double <VAR>z</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX449"></A>
<DT><U>Function:</U> int <B>gsl_sf_ellint_RD_e</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>, double <VAR>z</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX450"></A>
These routines compute the incomplete elliptic integral RD(x,y,z)
to the accuracy specified by the mode variable <VAR>mode</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_ellint_RF</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>, double <VAR>z</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX451"></A>
<DT><U>Function:</U> int <B>gsl_sf_ellint_RF_e</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>, double <VAR>z</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX452"></A>
These routines compute the incomplete elliptic integral RF(x,y,z)
to the accuracy specified by the mode variable <VAR>mode</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_ellint_RJ</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>, double <VAR>z</VAR>, double <VAR>p</VAR>, gsl_mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX453"></A>
<DT><U>Function:</U> int <B>gsl_sf_ellint_RJ_e</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>, double <VAR>z</VAR>, double <VAR>p</VAR>, gsl_mode_t <VAR>mode</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX454"></A>
These routines compute the incomplete elliptic integral RJ(x,y,z,p)
to the accuracy specified by the mode variable <VAR>mode</VAR>.
</DL>

</P>


<H2><A NAME="SEC103" HREF="gsl_manual.html#TOC103">Elliptic Functions (Jacobi)</A></H2>
<P>
<A NAME="IDX455"></A>
<A NAME="IDX456"></A>

</P>
<P>
The Jacobian Elliptic functions are defined in Abramowitz &#38; Stegun,
Chapter 16.  The functions are declared in the header file
<TT>'gsl_sf_elljac.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_elljac_e</B> <I>(double <VAR>u</VAR>, double <VAR>m</VAR>, double * <VAR>sn</VAR>, double * <VAR>cn</VAR>, double * <VAR>dn</VAR>)</I>
<DD><A NAME="IDX457"></A>
This function computes the Jacobian elliptic functions sn(u|m),
cn(u|m), dn(u|m) by descending Landen
transformations.
</DL>

</P>


<H2><A NAME="SEC104" HREF="gsl_manual.html#TOC104">Error Functions</A></H2>
<P>
<A NAME="IDX458"></A>
<A NAME="IDX459"></A>
<A NAME="IDX460"></A>

</P>
<P>
The error function is described in Abramowitz &#38; Stegun, Chapter 7.  The
functions in this section are declared in the header file
<TT>'gsl_sf_erf.h'</TT>.

</P>



<H3><A NAME="SEC105" HREF="gsl_manual.html#TOC105">Error Function</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_erf</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX461"></A>
<DT><U>Function:</U> int <B>gsl_sf_erf_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX462"></A>
These routines compute the error function 
erf(x), where
erf(x) = (2/\sqrt(\pi)) \int_0^x dt \exp(-t^2).
</DL>

</P>


<H3><A NAME="SEC106" HREF="gsl_manual.html#TOC106">Complementary Error Function</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_erfc</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX463"></A>
<DT><U>Function:</U> int <B>gsl_sf_erfc_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX464"></A>
These routines compute the complementary error function 
erfc(x) = 1 - erf(x) = (2/\sqrt(\pi)) \int_x^\infty \exp(-t^2).
</DL>

</P>



<H3><A NAME="SEC107" HREF="gsl_manual.html#TOC107">Log Complementary Error Function</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_log_erfc</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX465"></A>
<DT><U>Function:</U> int <B>gsl_sf_log_erfc_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX466"></A>
These routines compute the logarithm of the complementary error function
\log(\erfc(x)).
</DL>

</P>



<H3><A NAME="SEC108" HREF="gsl_manual.html#TOC108">Probability functions</A></H3>

<P>
The probability functions for the Normal or Gaussian distribution are
described in Abramowitz &#38; Stegun, Section 26.2.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_erf_Z</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX467"></A>
<DT><U>Function:</U> int <B>gsl_sf_erf_Z_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX468"></A>
These routines compute the Gaussian probability density function 
Z(x) = (1/\sqrt{2\pi}) \exp(-x^2/2).  
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_erf_Q</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX469"></A>
<DT><U>Function:</U> int <B>gsl_sf_erf_Q_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX470"></A>
These routines compute the upper tail of the Gaussian probability
function 
Q(x) = (1/\sqrt{2\pi}) \int_x^\infty dt \exp(-t^2/2).
</DL>

</P>
<P>
<A NAME="IDX471"></A>
<A NAME="IDX472"></A>
The <I>hazard function</I> for the normal distribution, 
also known as the inverse Mill's ratio, is defined as,

<SPAN class="ifinfo">


<PRE class="example">
h(x) = Z(x)/Q(x) = \sqrt{2/\pi} \exp(-x^2 / 2) / \erfc(x/\sqrt 2)
</PRE>

</SPAN>

<P>
It decreases rapidly as x approaches -\infty and asymptotes
to h(x) \sim x as x approaches +\infty.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_hazard</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX473"></A>
<DT><U>Function:</U> int <B>gsl_sf_hazard_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX474"></A>
These routines compute the hazard function for the normal distribution.
</DL>

</P>


<H2><A NAME="SEC109" HREF="gsl_manual.html#TOC109">Exponential Functions</A></H2>
<P>
<A NAME="IDX475"></A>
<A NAME="IDX476"></A>

</P>
<P>
The functions described in this section are declared in the header file
<TT>'gsl_sf_exp.h'</TT>.

</P>



<H3><A NAME="SEC110" HREF="gsl_manual.html#TOC110">Exponential Function</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_exp</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX477"></A>
<DT><U>Function:</U> int <B>gsl_sf_exp_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX478"></A>
These routines provide an exponential function \exp(x) using GSL
semantics and error checking.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_exp_e10_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result_e10 * <VAR>result</VAR>)</I>
<DD><A NAME="IDX479"></A>
This function computes the exponential \exp(x) using the
<CODE>gsl_sf_result_e10</CODE> type to return a result with extended range.
This function may be useful if the value of \exp(x) would
overflow the  numeric range of <CODE>double</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_exp_mult</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>)</I>
<DD><A NAME="IDX480"></A>
<DT><U>Function:</U> int <B>gsl_sf_exp_mult_e</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX481"></A>
These routines exponentiate <VAR>x</VAR> and multiply by the factor <VAR>y</VAR>
to return the product y \exp(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_exp_mult_e10_e</B> <I>(const double <VAR>x</VAR>, const double <VAR>y</VAR>, gsl_sf_result_e10 * <VAR>result</VAR>)</I>
<DD><A NAME="IDX482"></A>
This function computes the product y \exp(x) using the
<CODE>gsl_sf_result_e10</CODE> type to return a result with extended numeric
range.
</DL>

</P>



<H3><A NAME="SEC111" HREF="gsl_manual.html#TOC111">Relative Exponential Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_expm1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX483"></A>
<DT><U>Function:</U> int <B>gsl_sf_expm1_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX484"></A>
These routines compute the quantity \exp(x)-1 using an algorithm
that is accurate for small x.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_exprel</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX485"></A>
<DT><U>Function:</U> int <B>gsl_sf_exprel_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX486"></A>
These routines compute the quantity (\exp(x)-1)/x using an
algorithm that is accurate for small x.  For small x the
algorithm is based on the expansion (\exp(x)-1)/x = 1 + x/2 +
x^2/(2*3) + x^3/(2*3*4) + \dots.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_exprel_2</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX487"></A>
<DT><U>Function:</U> int <B>gsl_sf_exprel_2_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX488"></A>
These routines compute the quantity 2(\exp(x)-1-x)/x^2 using an
algorithm that is accurate for small x.  For small x the
algorithm is based on the expansion 2(\exp(x)-1-x)/x^2 = 
1 + x/3 + x^2/(3*4) + x^3/(3*4*5) + \dots.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_exprel_n</B> <I>(int <VAR>n</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX489"></A>
<DT><U>Function:</U> int <B>gsl_sf_exprel_n_e</B> <I>(int <VAR>n</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX490"></A>
These routines compute the N-relative exponential, which is the
<VAR>n</VAR>-th generalization of the functions <CODE>gsl_sf_exprel</CODE> and
<CODE>gsl_sf_exprel2</CODE>.  The N-relative exponential is given by,

<SPAN class="ifinfo">


<PRE class="example">
exprel_N(x) = N!/x^N (\exp(x) - \sum_{k=0}^{N-1} x^k/k!)
            = 1 + x/(N+1) + x^2/((N+1)(N+2)) + ...
            = 1F1 (1,1+N,x)
</PRE>

</SPAN>

</DL>



<H3><A NAME="SEC112" HREF="gsl_manual.html#TOC112">Exponentiation With Error Estimate</A></H3>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_exp_err_e</B> <I>(double <VAR>x</VAR>, double <VAR>dx</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX491"></A>
This function exponentiates <VAR>x</VAR> with an associated absolute error
<VAR>dx</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_exp_err_e10_e</B> <I>(double <VAR>x</VAR>, double <VAR>dx</VAR>, gsl_sf_result_e10 * <VAR>result</VAR>)</I>
<DD><A NAME="IDX492"></A>
This function exponentiates a quantity <VAR>x</VAR> with an associated absolute 
error <VAR>dx</VAR> using the <CODE>gsl_sf_result_e10</CODE> type to return a result with
extended range.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_exp_mult_err_e</B> <I>(double <VAR>x</VAR>, double <VAR>dx</VAR>, double <VAR>y</VAR>, double <VAR>dy</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX493"></A>
This routine computes the product y \exp(x) for the quantities
<VAR>x</VAR>, <VAR>y</VAR> with associated absolute errors <VAR>dx</VAR>, <VAR>dy</VAR>.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_exp_mult_err_e10_e</B> <I>(double <VAR>x</VAR>, double <VAR>dx</VAR>, double <VAR>y</VAR>, double <VAR>dy</VAR>, gsl_sf_result_e10 * <VAR>result</VAR>)</I>
<DD><A NAME="IDX494"></A>
This routine computes the product y \exp(x) for the quantities
<VAR>x</VAR>, <VAR>y</VAR> with associated absolute errors <VAR>dx</VAR>, <VAR>dy</VAR> using the
<CODE>gsl_sf_result_e10</CODE> type to return a result with extended range.
</DL>

</P>



<H2><A NAME="SEC113" HREF="gsl_manual.html#TOC113">Exponential Integrals</A></H2>
<P>
<A NAME="IDX495"></A>
<A NAME="IDX496"></A>

</P>
<P>
Information on the exponential integrals can be found in Abramowitz &#38;
Stegun, Chapter 5.  These functions are declared in the header file
<TT>'gsl_sf_expint.h'</TT>.

</P>



<H3><A NAME="SEC114" HREF="gsl_manual.html#TOC114">Exponential Integral</A></H3>
<P>
<A NAME="IDX497"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_expint_E1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX498"></A>
<DT><U>Function:</U> int <B>gsl_sf_expint_E1_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX499"></A>
These routines compute the exponential integral E_1(x),

<SPAN class="ifinfo">


<PRE class="example">
E_1(x) := \Re \int_1^\infty dt \exp(-xt)/t.
</PRE>

</SPAN>

<P>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_expint_E2</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX500"></A>
<DT><U>Function:</U> int <B>gsl_sf_expint_E2_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX501"></A>
These routines compute the second-order exponential integral E_2(x),

<SPAN class="ifinfo">


<PRE class="example">
E_2(x) := \Re \int_1^\infty dt \exp(-xt)/t^2.
</PRE>

</SPAN>

<P>
</DL>

</P>


<H3><A NAME="SEC115" HREF="gsl_manual.html#TOC115">Ei(x)</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_expint_Ei</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX502"></A>
<DT><U>Function:</U> int <B>gsl_sf_expint_Ei_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX503"></A>
These routines compute the exponential integral Ei(x),

<SPAN class="ifinfo">


<PRE class="example">
Ei(x) := - PV(\int_{-x}^\infty dt \exp(-t)/t)
</PRE>

</SPAN>

<P>
where PV denotes the principal value of the integral.
</DL>

</P>



<H3><A NAME="SEC116" HREF="gsl_manual.html#TOC116">Hyperbolic Integrals</A></H3>
<P>
<A NAME="IDX504"></A>
<A NAME="IDX505"></A>
<A NAME="IDX506"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_Shi</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX507"></A>
<DT><U>Function:</U> int <B>gsl_sf_Shi_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX508"></A>
These routines compute the integral Shi(x) = \int_0^x dt \sinh(t)/t.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_Chi</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX509"></A>
<DT><U>Function:</U> int <B>gsl_sf_Chi_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX510"></A>
These routines compute the integral  Chi(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh[t]-1)/t] , where \gamma_E is the Euler constant (available as the macro <CODE>M_EULER</CODE>).
</DL>

</P>



<H3><A NAME="SEC117" HREF="gsl_manual.html#TOC117">Ei_3(x)</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_expint_3</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX511"></A>
<DT><U>Function:</U> int <B>gsl_sf_expint_3_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX512"></A>
These routines compute the third-order exponential integral 
Ei_3(x) = \int_0^xdt \exp(-t^3) for 
x &#62;= 0.
</DL>

</P>


<H3><A NAME="SEC118" HREF="gsl_manual.html#TOC118">Trigonometric Integrals</A></H3>
<P>
<A NAME="IDX513"></A>
<A NAME="IDX514"></A>
<A NAME="IDX515"></A>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_Si</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX516"></A>
<DT><U>Function:</U> int <B>gsl_sf_Si_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX517"></A>
These routines compute the Sine integral
Si(x) = \int_0^x dt \sin(t)/t.
</DL>

</P>
<P>
 
<DL>
<DT><U>Function:</U> double <B>gsl_sf_Ci</B> <I>(const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX518"></A>
<DT><U>Function:</U> int <B>gsl_sf_Ci_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX519"></A>
These routines compute the Cosine integral Ci(x) = -\int_x^\infty dt
\cos(t)/t for x &#62; 0.  
</DL>

</P>



<H3><A NAME="SEC119" HREF="gsl_manual.html#TOC119">Arctangent Integral</A></H3>
<P>
<A NAME="IDX520"></A>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_atanint</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX521"></A>
<DT><U>Function:</U> int <B>gsl_sf_atanint_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX522"></A>
These routines compute the Arctangent integral, which is defined as AtanInt(x) = \int_0^x dt \arctan(t)/t.
</DL>

</P>



<H2><A NAME="SEC120" HREF="gsl_manual.html#TOC120">Fermi-Dirac Function</A></H2>
<P>
<A NAME="IDX523"></A>

</P>
<P>
The functions described in this section are declared in the header file
<TT>'gsl_sf_fermi_dirac.h'</TT>.

</P>



<H3><A NAME="SEC121" HREF="gsl_manual.html#TOC121">Complete Fermi-Dirac Integrals</A></H3>
<P>
<A NAME="IDX524"></A>
<A NAME="IDX525"></A>
The complete Fermi-Dirac integral F_j(x) is given by,

<SPAN class="ifinfo">


<PRE class="example">
F_j(x)   := (1/r\Gamma(j+1)) \int_0^\infty dt (t^j / (\exp(t-x) + 1))
</PRE>

</SPAN>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_fermi_dirac_m1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX526"></A>
<DT><U>Function:</U> int <B>gsl_sf_fermi_dirac_m1_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX527"></A>
These routines compute the complete Fermi-Dirac integral with an index of -1. 
This integral is given by 
F_{-1}(x) = e^x / (1 + e^x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_fermi_dirac_0</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX528"></A>
<DT><U>Function:</U> int <B>gsl_sf_fermi_dirac_0_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX529"></A>
These routines compute the complete Fermi-Dirac integral with an index of 0. 
This integral is given by F_0(x) = \ln(1 + e^x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_fermi_dirac_1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX530"></A>
<DT><U>Function:</U> int <B>gsl_sf_fermi_dirac_1_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX531"></A>
These routines compute the complete Fermi-Dirac integral with an index of 1,
F_1(x) = \int_0^\infty dt (t /(\exp(t-x)+1)).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_fermi_dirac_2</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX532"></A>
<DT><U>Function:</U> int <B>gsl_sf_fermi_dirac_2_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX533"></A>
These routines compute the complete Fermi-Dirac integral with an index
of 2,
F_2(x) = (1/2) \int_0^\infty dt (t^2 /(\exp(t-x)+1)).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_fermi_dirac_int</B> <I>(int <VAR>j</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX534"></A>
<DT><U>Function:</U> int <B>gsl_sf_fermi_dirac_int_e</B> <I>(int <VAR>j</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX535"></A>
These routines compute the complete Fermi-Dirac integral with an integer
index of j,
F_j(x) = (1/\Gamma(j+1)) \int_0^\infty dt (t^j /(\exp(t-x)+1)).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_fermi_dirac_mhalf</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX536"></A>
<DT><U>Function:</U> int <B>gsl_sf_fermi_dirac_mhalf_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX537"></A>
These routines compute the complete Fermi-Dirac integral 
F_{-1/2}(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_fermi_dirac_half</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX538"></A>
<DT><U>Function:</U> int <B>gsl_sf_fermi_dirac_half_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX539"></A>
These routines compute the complete Fermi-Dirac integral 
F_{1/2}(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_fermi_dirac_3half</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX540"></A>
<DT><U>Function:</U> int <B>gsl_sf_fermi_dirac_3half_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX541"></A>
These routines compute the complete Fermi-Dirac integral 
F_{3/2}(x).
</DL>

</P>



<H3><A NAME="SEC122" HREF="gsl_manual.html#TOC122">Incomplete Fermi-Dirac Integrals</A></H3>
<P>
<A NAME="IDX542"></A>
<A NAME="IDX543"></A>
The incomplete Fermi-Dirac integral F_j(x,b) is given by,

<SPAN class="ifinfo">


<PRE class="example">
F_j(x,b)   := (1/\Gamma(j+1)) \int_b^\infty dt (t^j / (\Exp(t-x) + 1))
</PRE>

</SPAN>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_fermi_dirac_inc_0</B> <I>(double <VAR>x</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX544"></A>
<DT><U>Function:</U> int <B>gsl_sf_fermi_dirac_inc_0_e</B> <I>(double <VAR>x</VAR>, double <VAR>b</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX545"></A>
These routines compute the incomplete Fermi-Dirac integral with an index
of zero,
F_0(x,b) = \ln(1 + e^{b-x}) - (b-x).
</DL>

</P>



<H2><A NAME="SEC123" HREF="gsl_manual.html#TOC123">Gamma and Beta Functions</A></H2>
<P>
<A NAME="IDX546"></A>

</P>
<P>
The Gamma function is defined by the following integral,

<SPAN class="ifinfo">


<PRE class="example">
\Gamma(x) = \int_0^\infty dt  t^{x-1} \exp(-t)
</PRE>

</SPAN>

<P>
It is related to the factorial function by \Gamma(n)=(n-1)!
for positive integer n.  Further information on the Gamma function
can be found in Abramowitz &#38; Stegun, Chapter 6.  The functions
described in this section are declared in the header file
<TT>'gsl_sf_gamma.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_gamma</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX547"></A>
<DT><U>Function:</U> int <B>gsl_sf_gamma_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX548"></A>
These routines compute the Gamma function \Gamma(x), subject to x
not being a negative integer.  The function is computed using the real
Lanczos method. The maximum value of x such that \Gamma(x) is not
considered an overflow is given by the macro <CODE>GSL_SF_GAMMA_XMAX</CODE>
and is 171.0.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_lngamma</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX549"></A>
<DT><U>Function:</U> int <B>gsl_sf_lngamma_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX550"></A>
<A NAME="IDX551"></A>
These routines compute the logarithm of the Gamma function,
\log(\Gamma(x)), subject to x not a being negative
integer.  For x&#60;0 the real part of \log(\Gamma(x)) is
returned, which is equivalent to \log(|\Gamma(x)|).  The function
is computed using the real Lanczos method.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_lngamma_sgn_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result_lg</VAR>, double * <VAR>sgn</VAR>)</I>
<DD><A NAME="IDX552"></A>
This routine computes the sign of the gamma function and the logarithm of
its magnitude, subject to x not being a negative integer.  The
function is computed using the real Lanczos method.  The value of the
gamma function can be reconstructed using the relation \Gamma(x) =
sgn * \exp(resultlg).
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_gammastar</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX553"></A>
<DT><U>Function:</U> int <B>gsl_sf_gammastar_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX554"></A>
<A NAME="IDX555"></A>
These routines compute the regulated Gamma Function \Gamma^*(x)
for x &#62; 0. The regulated gamma function is given by,

<SPAN class="ifinfo">


<PRE class="example">
\Gamma^*(x) = \Gamma(x)/(\sqrt{2\pi} x^{(x-1/2)} \exp(-x))
            = (1 + (1/12x) + ...)  for x \to \infty
</PRE>

</SPAN>

<P>
and is a useful suggestion of Temme.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_gammainv</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX556"></A>
<DT><U>Function:</U> int <B>gsl_sf_gammainv_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX557"></A>
<A NAME="IDX558"></A>
These routines compute the reciprocal of the gamma function,
1/\Gamma(x) using the real Lanczos method.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_lngamma_complex_e</B> <I>(double <VAR>zr</VAR>, double <VAR>zi</VAR>, gsl_sf_result * <VAR>lnr</VAR>, gsl_sf_result * <VAR>arg</VAR>)</I>
<DD><A NAME="IDX559"></A>
<A NAME="IDX560"></A>
This routine computes \log(\Gamma(z)) for complex z=z_r+i
z_i and z not a negative integer, using the complex Lanczos
method.  The returned parameters are lnr = \log|\Gamma(z)| and
arg = \arg(\Gamma(z)) in (-\pi,\pi].  Note that the phase
part (<VAR>arg</VAR>) is not well-determined when |z| is very large,
due to inevitable roundoff in restricting to (-\pi,\pi].  This
will result in a <CODE>GSL_ELOSS</CODE> error when it occurs.  The absolute
value part (<VAR>lnr</VAR>), however, never suffers from loss of precision.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_taylorcoeff</B> <I>(int <VAR>n</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX561"></A>
<DT><U>Function:</U> int <B>gsl_sf_taylorcoeff_e</B> <I>(int <VAR>n</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX562"></A>
<A NAME="IDX563"></A>
These routines compute the Taylor coefficient x^n / n! for 
x &#62;= 0, 
n &#62;= 0.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_fact</B> <I>(unsigned int <VAR>n</VAR>)</I>
<DD><A NAME="IDX564"></A>
<DT><U>Function:</U> int <B>gsl_sf_fact_e</B> <I>(unsigned int <VAR>n</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX565"></A>
<A NAME="IDX566"></A>
These routines compute the factorial n!.  The factorial is
related to the Gamma function by n! = \Gamma(n+1).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_doublefact</B> <I>(unsigned int <VAR>n</VAR>)</I>
<DD><A NAME="IDX567"></A>
<DT><U>Function:</U> int <B>gsl_sf_doublefact_e</B> <I>(unsigned int <VAR>n</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX568"></A>
<A NAME="IDX569"></A>
These routines compute the double factorial n!! = n(n-2)(n-4) \dots. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_lnfact</B> <I>(unsigned int <VAR>n</VAR>)</I>
<DD><A NAME="IDX570"></A>
<DT><U>Function:</U> int <B>gsl_sf_lnfact_e</B> <I>(unsigned int <VAR>n</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX571"></A>
<A NAME="IDX572"></A>
These routines compute the logarithm of the factorial of <VAR>n</VAR>,
\log(n!).  The algorithm is faster than computing
\ln(\Gamma(n+1)) via <CODE>gsl_sf_lngamma</CODE> for n &#60; 170,
but defers for larger <VAR>n</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_lndoublefact</B> <I>(unsigned int <VAR>n</VAR>)</I>
<DD><A NAME="IDX573"></A>
<DT><U>Function:</U> int <B>gsl_sf_lndoublefact_e</B> <I>(unsigned int <VAR>n</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX574"></A>
<A NAME="IDX575"></A>
These routines compute the logarithm of the double factorial of <VAR>n</VAR>,
\log(n!!).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_choose</B> <I>(unsigned int <VAR>n</VAR>, unsigned int <VAR>m</VAR>)</I>
<DD><A NAME="IDX576"></A>
<DT><U>Function:</U> int <B>gsl_sf_choose_e</B> <I>(unsigned int <VAR>n</VAR>, unsigned int <VAR>m</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX577"></A>
<A NAME="IDX578"></A>
These routines compute the combinatorial factor <CODE>n choose m</CODE>
= n!/(m!(n-m)!)
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_lnchoose</B> <I>(unsigned int <VAR>n</VAR>, unsigned int <VAR>m</VAR>)</I>
<DD><A NAME="IDX579"></A>
<DT><U>Function:</U> int <B>gsl_sf_lnchoose_e</B> <I>(unsigned int <VAR>n</VAR>, unsigned int <VAR>m</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX580"></A>
<A NAME="IDX581"></A>
These routines compute the logarithm of <CODE>n choose m</CODE>.  This is
equivalent to the sum \log(n!) - \log(m!) - \log((n-m)!).
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_poch</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX582"></A>
<DT><U>Function:</U> int <B>gsl_sf_poch_e</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX583"></A>
<A NAME="IDX584"></A>
<A NAME="IDX585"></A>
These routines compute the Pochhammer symbol (a)_x := \Gamma(a +
x)/\Gamma(a), subject to a and a+x not being negative
integers. The Pochhammer symbol is also known as the Apell symbol and
sometimes written as (a,x).
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_lnpoch</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX586"></A>
<DT><U>Function:</U> int <B>gsl_sf_lnpoch_e</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX587"></A>
<A NAME="IDX588"></A>
These routines compute the logarithm of the Pochhammer symbol,
\log((a)_x) = \log(\Gamma(a + x)/\Gamma(a)) for a &#62; 0,
a+x &#62; 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_lnpoch_sgn_e</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>, double * <VAR>sgn</VAR>)</I>
<DD><A NAME="IDX589"></A>
These routines compute the sign of the Pochhammer symbol and the
logarithm of its magnitude.  The computed parameters are result =
\log(|(a)_x|) and sgn = \sgn((a)_x) where (a)_x :=
\Gamma(a + x)/\Gamma(a), subject to a, a+x not being
negative integers.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_pochrel</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX590"></A>
<DT><U>Function:</U> int <B>gsl_sf_pochrel_e</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX591"></A>
<A NAME="IDX592"></A>
These routines compute the relative Pochhammer symbol ((a)_x -
1)/x where (a)_x := \Gamma(a + x)/\Gamma(a).
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_gamma_inc_Q</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX593"></A>
<DT><U>Function:</U> int <B>gsl_sf_gamma_inc_Q_e</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX594"></A>
<A NAME="IDX595"></A>
These routines compute the normalized incomplete Gamma Function
Q(a,x) = 1/\Gamma(a) \int_x^\infty dt t^{a-1} \exp(-t)
for a &#62; 0, 
x &#62;= 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_gamma_inc_P</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX596"></A>
<DT><U>Function:</U> int <B>gsl_sf_gamma_inc_P_e</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX597"></A>
<A NAME="IDX598"></A>
These routines compute the complementary normalized incomplete Gamma Function
P(a,x) = 1/\Gamma(a) \int_0^x dt t^{a-1} \exp(-t)
for a &#62; 0, 
x &#62;= 0. 

</P>
<P>
Note that Abramowitz &#38; Stegun call P(a,x) the incomplete gamma
function (section 6.5).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_gamma_inc</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX599"></A>
<DT><U>Function:</U> int <B>gsl_sf_gamma_inc_e</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX600"></A>
<A NAME="IDX601"></A>
These functions compute the incomplete Gamma Function
the normalization factor included in the previously defined functions:
\Gamma(a,x) = \int_x^\infty dt t^{a-1} \exp(-t)
for a real and 
x &#62;= 0.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_beta</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX602"></A>
<DT><U>Function:</U> int <B>gsl_sf_beta_e</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX603"></A>
<A NAME="IDX604"></A>
These routines compute the Beta Function, B(a,b) =
\Gamma(a)\Gamma(b)/\Gamma(a+b) for a &#62; 0, b &#62; 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_lnbeta</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX605"></A>
<DT><U>Function:</U> int <B>gsl_sf_lnbeta_e</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX606"></A>
<A NAME="IDX607"></A>
These routines compute the logarithm of the Beta Function, \log(B(a,b))
for a &#62; 0, b &#62; 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_beta_inc</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX608"></A>
<DT><U>Function:</U> int <B>gsl_sf_beta_inc_e</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX609"></A>
<A NAME="IDX610"></A>
<A NAME="IDX611"></A>
<A NAME="IDX612"></A>
These routines compute the normalized incomplete Beta function
B_x(a,b)/B(a,b) where 
B_x(a,b) = \int_0^x t^{a-1} (1-t)^{b-1} dt
for a &#62; 0, b &#62; 0, and 
0 &#60;= x &#60;= 1.
</DL>

</P>



<H2><A NAME="SEC124" HREF="gsl_manual.html#TOC124">Gegenbauer Functions</A></H2>
<P>
<A NAME="IDX613"></A>

</P>
<P>
The Gegenbauer polynomials are defined in Abramowitz &#38; Stegun, Chapter
22, where they are known as Ultraspherical polynomials.  The functions
described in this section are declared in the header file
<TT>'gsl_sf_gegenbauer.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_gegenpoly_1</B> <I>(double <VAR>lambda</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX614"></A>
<DT><U>Function:</U> double <B>gsl_sf_gegenpoly_2</B> <I>(double <VAR>lambda</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX615"></A>
<DT><U>Function:</U> double <B>gsl_sf_gegenpoly_3</B> <I>(double <VAR>lambda</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX616"></A>
<DT><U>Function:</U> int <B>gsl_sf_gegenpoly_1_e</B> <I>(double <VAR>lambda</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX617"></A>
<DT><U>Function:</U> int <B>gsl_sf_gegenpoly_2_e</B> <I>(double <VAR>lambda</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX618"></A>
<DT><U>Function:</U> int <B>gsl_sf_gegenpoly_3_e</B> <I>(double <VAR>lambda</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX619"></A>
These functions evaluate the Gegenbauer polynomials
C^{(\lambda)}_n(x) using explicit
representations for n =1, 2, 3.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_gegenpoly_n</B> <I>(int <VAR>n</VAR>, double <VAR>lambda</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX620"></A>
<DT><U>Function:</U> int <B>gsl_sf_gegenpoly_n_e</B> <I>(int <VAR>n</VAR>, double <VAR>lambda</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX621"></A>
These functions evaluate the Gegenbauer polynomial 
C^{(\lambda)}_n(x) for a specific value of <VAR>n</VAR>,
<VAR>lambda</VAR>, <VAR>x</VAR> subject to \lambda &#62; -1/2, 
n &#62;= 0.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_gegenpoly_array</B> <I>(int <VAR>nmax</VAR>, double <VAR>lambda</VAR>, double <VAR>x</VAR>, double <VAR>result_array</VAR>[])</I>
<DD><A NAME="IDX622"></A>
This function computes an array of Gegenbauer polynomials
C^{(\lambda)}_n(x) for n = 0, 1, 2, \dots, nmax, subject
to \lambda &#62; -1/2, 
nmax &#62;= 0.
</DL>

</P>


<H2><A NAME="SEC125" HREF="gsl_manual.html#TOC125">Hypergeometric Functions</A></H2>
<P>
<A NAME="IDX623"></A>
<A NAME="IDX624"></A>

</P>
<P>
Hypergeometric functions are described in Abramowitz &#38; Stegun, Chapters
13 and 15.  These functions are declared in the header file
<TT>'gsl_sf_hyperg.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_hyperg_0F1</B> <I>(double <VAR>c</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX625"></A>
<DT><U>Function:</U> int <B>gsl_sf_hyperg_0F1_e</B> <I>(double <VAR>c</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX626"></A>
These routines compute the hypergeometric function 
0F1(c,x).  
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_hyperg_1F1_int</B> <I>(int <VAR>m</VAR>, int <VAR>n</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX627"></A>
<DT><U>Function:</U> int <B>gsl_sf_hyperg_1F1_int_e</B> <I>(int <VAR>m</VAR>, int <VAR>n</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX628"></A>
These routines compute the confluent hypergeometric function
1F1(m,n,x) = M(m,n,x) for integer parameters <VAR>m</VAR>, <VAR>n</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_hyperg_1F1</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX629"></A>
<DT><U>Function:</U> int <B>gsl_sf_hyperg_1F1_e</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX630"></A>
These routines compute the confluent hypergeometric function
1F1(a,b,x) = M(a,b,x) for general parameters <VAR>a</VAR>, <VAR>b</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_hyperg_U_int</B> <I>(int <VAR>m</VAR>, int <VAR>n</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX631"></A>
<DT><U>Function:</U> int <B>gsl_sf_hyperg_U_int_e</B> <I>(int <VAR>m</VAR>, int <VAR>n</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX632"></A>
These routines compute the confluent hypergeometric function
U(m,n,x) for integer parameters <VAR>m</VAR>, <VAR>n</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_hyperg_U_int_e10_e</B> <I>(int <VAR>m</VAR>, int <VAR>n</VAR>, double <VAR>x</VAR>, gsl_sf_result_e10 * <VAR>result</VAR>)</I>
<DD><A NAME="IDX633"></A>
This routine computes the confluent hypergeometric function
U(m,n,x) for integer parameters <VAR>m</VAR>, <VAR>n</VAR> using the
<CODE>gsl_sf_result_e10</CODE> type to return a result with extended range.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_hyperg_U</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX634"></A>
<DT><U>Function:</U> int <B>gsl_sf_hyperg_U_e</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX635"></A>
These routines compute the confluent hypergeometric function U(a,b,x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_hyperg_U_e10_e</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>x</VAR>, gsl_sf_result_e10 * <VAR>result</VAR>)</I>
<DD><A NAME="IDX636"></A>
This routine computes the confluent hypergeometric function
U(a,b,x) using the <CODE>gsl_sf_result_e10</CODE> type to return a
result with extended range. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_hyperg_2F1</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>c</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX637"></A>
<DT><U>Function:</U> int <B>gsl_sf_hyperg_2F1_e</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>c</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX638"></A>
These routines compute the Gauss hypergeometric function 
2F1(a,b,c,x) for |x| &#60; 1.  

</P>
<P>
If the arguments (a,b,c,x) are too close to a singularity then
the function can return the error code <CODE>GSL_EMAXITER</CODE> when the
series approximation converges too slowly.  This occurs in the region of
x=1, c - a - b = m for integer m.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_hyperg_2F1_conj</B> <I>(double <VAR>aR</VAR>, double <VAR>aI</VAR>, double <VAR>c</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX639"></A>
<DT><U>Function:</U> int <B>gsl_sf_hyperg_2F1_conj_e</B> <I>(double <VAR>aR</VAR>, double <VAR>aI</VAR>, double <VAR>c</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX640"></A>
These routines compute the Gauss hypergeometric function
2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters 
for |x| &#60; 1.
exceptions:
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_hyperg_2F1_renorm</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>c</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX641"></A>
<DT><U>Function:</U> int <B>gsl_sf_hyperg_2F1_renorm_e</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>c</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX642"></A>
These routines compute the renormalized Gauss hypergeometric function
2F1(a,b,c,x) / \Gamma(c) for |x| &#60; 1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_hyperg_2F1_conj_renorm</B> <I>(double <VAR>aR</VAR>, double <VAR>aI</VAR>, double <VAR>c</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX643"></A>
<DT><U>Function:</U> int <B>gsl_sf_hyperg_2F1_conj_renorm_e</B> <I>(double <VAR>aR</VAR>, double <VAR>aI</VAR>, double <VAR>c</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX644"></A>
These routines compute the renormalized Gauss hypergeometric function
2F1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c) for |x| &#60; 1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_hyperg_2F0</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX645"></A>
<DT><U>Function:</U> int <B>gsl_sf_hyperg_2F0_e</B> <I>(double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX646"></A>
These routines compute the hypergeometric function 
2F0(a,b,x).  The series representation
is a divergent hypergeometric series.  However, for x &#60; 0 we
have 
2F0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)
</DL>

</P>


<H2><A NAME="SEC126" HREF="gsl_manual.html#TOC126">Laguerre Functions</A></H2>
<P>
<A NAME="IDX647"></A>
<A NAME="IDX648"></A>

</P>
<P>
The Laguerre polynomials are defined in terms of confluent
hypergeometric functions as
L^a_n(x) = ((a+1)_n / n!) 1F1(-n,a+1,x).  These functions are
declared in the header file <TT>'gsl_sf_laguerre.h'</TT>.

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_laguerre_1</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX649"></A>
<DT><U>Function:</U> double <B>gsl_sf_laguerre_2</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX650"></A>
<DT><U>Function:</U> double <B>gsl_sf_laguerre_3</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX651"></A>
<DT><U>Function:</U> int <B>gsl_sf_laguerre_1_e</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX652"></A>
<DT><U>Function:</U> int <B>gsl_sf_laguerre_2_e</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX653"></A>
<DT><U>Function:</U> int <B>gsl_sf_laguerre_3_e</B> <I>(double <VAR>a</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX654"></A>
These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_laguerre_n</B> <I>(const int <VAR>n</VAR>, const double <VAR>a</VAR>, const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX655"></A>
<DT><U>Function:</U> int <B>gsl_sf_laguerre_n_e</B> <I>(int <VAR>n</VAR>, double <VAR>a</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX656"></A>
These routines evaluate the generalized Laguerre polynomials
L^a_n(x) for a &#62; -1, 
n &#62;= 0.

</P>
</DL>



<H2><A NAME="SEC127" HREF="gsl_manual.html#TOC127">Lambert W Functions</A></H2>
<P>
<A NAME="IDX657"></A>
<A NAME="IDX658"></A>

</P>
<P>
Lambert's W functions, W(x), are defined to be solutions
of the equation W(x) \exp(W(x)) = x. This function has
multiple branches for x &#60; 0; however, it has only
two real-valued branches. We define W_0(x) to be the
principal branch, where W &#62; -1 for x &#60; 0, and 
W_{-1}(x) to be the other real branch, where
W &#60; -1 for x &#60; 0.  The Lambert functions are
declared in the header file <TT>'gsl_sf_lambert.h'</TT>.

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_lambert_W0</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX659"></A>
<DT><U>Function:</U> int <B>gsl_sf_lambert_W0_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX660"></A>
These compute the principal branch of the Lambert W function, W_0(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_lambert_Wm1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX661"></A>
<DT><U>Function:</U> int <B>gsl_sf_lambert_Wm1_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX662"></A>
These compute the secondary real-valued branch of the Lambert W function, 
W_{-1}(x).
</DL>

</P>



<H2><A NAME="SEC128" HREF="gsl_manual.html#TOC128">Legendre Functions and Spherical Harmonics</A></H2>
<P>
<A NAME="IDX663"></A>
<A NAME="IDX664"></A>
<A NAME="IDX665"></A>
<A NAME="IDX666"></A>

</P>
<P>
The Legendre Functions and Legendre Polynomials are described in
Abramowitz &#38; Stegun, Chapter 8.  These functions are declared in 
the header file <TT>'gsl_sf_legendre.h'</TT>.

</P>



<H3><A NAME="SEC129" HREF="gsl_manual.html#TOC129">Legendre Polynomials</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_legendre_P1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX667"></A>
<DT><U>Function:</U> double <B>gsl_sf_legendre_P2</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX668"></A>
<DT><U>Function:</U> double <B>gsl_sf_legendre_P3</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX669"></A>
<DT><U>Function:</U> int <B>gsl_sf_legendre_P1_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX670"></A>
<DT><U>Function:</U> int <B>gsl_sf_legendre_P2_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX671"></A>
<DT><U>Function:</U> int <B>gsl_sf_legendre_P3_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX672"></A>
These functions evaluate the Legendre polynomials
P_l(x) using explicit
representations for l=1, 2, 3.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_legendre_Pl</B> <I>(int <VAR>l</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX673"></A>
<DT><U>Function:</U> int <B>gsl_sf_legendre_Pl_e</B> <I>(int <VAR>l</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX674"></A>
These functions evaluate the Legendre polynomial 
P_l(x) for a specific value of <VAR>l</VAR>,
<VAR>x</VAR> subject to 
l &#62;= 0, 
|x| &#60;= 1
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_legendre_Pl_array</B> <I>(int <VAR>lmax</VAR>, double <VAR>x</VAR>, double <VAR>result_array</VAR>[])</I>
<DD><A NAME="IDX675"></A>
<DT><U>Function:</U> int <B>gsl_sf_legendre_Pl_deriv_array</B> <I>(int <VAR>lmax</VAR>, double <VAR>x</VAR>, double <VAR>result_array</VAR>[], double <VAR>result_deriv_array</VAR>[])</I>
<DD><A NAME="IDX676"></A>

</P>
<P>
These functions compute an array of Legendre polynomials
P_l(x), and optionally their derivatives dP_l(x)/dx, 
for l = 0, \dots, lmax, 
|x| &#60;= 1
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_legendre_Q0</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX677"></A>
<DT><U>Function:</U> int <B>gsl_sf_legendre_Q0_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX678"></A>
These routines compute the Legendre function Q_0(x) for x &#62;
-1, 
x != 1.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_legendre_Q1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX679"></A>
<DT><U>Function:</U> int <B>gsl_sf_legendre_Q1_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX680"></A>
These routines compute the Legendre function Q_1(x) for x &#62;
-1, 
x != 1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_legendre_Ql</B> <I>(int <VAR>l</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX681"></A>
<DT><U>Function:</U> int <B>gsl_sf_legendre_Ql_e</B> <I>(int <VAR>l</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX682"></A>
These routines compute the Legendre function Q_l(x) for x &#62;
-1, 
x != 1 and 
l &#62;= 0.
</DL>

</P>



<H3><A NAME="SEC130" HREF="gsl_manual.html#TOC130">Associated Legendre Polynomials and Spherical Harmonics</A></H3>

<P>
The following functions compute the associated Legendre Polynomials
P_l^m(x).  Note that this function grows combinatorially with
l and can overflow for l larger than about 150.  There is
no trouble for small m, but overflow occurs when m and
l are both large.  Rather than allow overflows, these functions
refuse to calculate P_l^m(x) and return <CODE>GSL_EOVRFLW</CODE> when
they can sense that l and m are too big.

</P>
<P>
If you want to calculate a spherical harmonic, then <EM>do not</EM> use
these functions.  Instead use <CODE>gsl_sf_legendre_sphPlm()</CODE> below,
which uses a similar recursion, but with the normalized functions.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_legendre_Plm</B> <I>(int <VAR>l</VAR>, int <VAR>m</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX683"></A>
<DT><U>Function:</U> int <B>gsl_sf_legendre_Plm_e</B> <I>(int <VAR>l</VAR>, int <VAR>m</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX684"></A>
These routines compute the associated Legendre polynomial
P_l^m(x) for 
m &#62;= 0, 
l &#62;= m, 
|x| &#60;= 1. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_legendre_Plm_array</B> <I>(int <VAR>lmax</VAR>, int <VAR>m</VAR>, double <VAR>x</VAR>, double <VAR>result_array</VAR>[])</I>
<DD><A NAME="IDX685"></A>
<DT><U>Function:</U> int <B>gsl_sf_legendre_Plm_deriv_array</B> <I>(int <VAR>lmax</VAR>, int <VAR>m</VAR>, double <VAR>x</VAR>, double <VAR>result_array</VAR>[], double <VAR>result_deriv_array</VAR>[])</I>
<DD><A NAME="IDX686"></A>
These functions compute an array of Legendre polynomials
P_l^m(x), and optionally their derivatives dP_l^m(x)/dx,
for 
m &#62;= 0, 
l = |m|, ..., lmax, 
|x| &#60;= 1.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_legendre_sphPlm</B> <I>(int <VAR>l</VAR>, int <VAR>m</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX687"></A>
<DT><U>Function:</U> int <B>gsl_sf_legendre_sphPlm_e</B> <I>(int <VAR>l</VAR>, int <VAR>m</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX688"></A>
These routines compute the normalized associated Legendre polynomial
$\sqrt{(2l+1)/(4\pi)} \sqrt{(l-m)!/(l+m)!} P_l^m(x)$ suitable
for use in spherical harmonics.  The parameters must satisfy 
m &#62;= 0, 
l &#62;= m, 
|x| &#60;= 1. Theses routines avoid the overflows
that occur for the standard normalization of P_l^m(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_legendre_sphPlm_array</B> <I>(int <VAR>lmax</VAR>, int <VAR>m</VAR>, double <VAR>x</VAR>, double <VAR>result_array</VAR>[])</I>
<DD><A NAME="IDX689"></A>
<DT><U>Function:</U> int <B>gsl_sf_legendre_sphPlm_deriv_array</B> <I>(int <VAR>lmax</VAR>, int <VAR>m</VAR>, double <VAR>x</VAR>, double <VAR>result_array</VAR>[], double <VAR>result_deriv_array</VAR>[])</I>
<DD><A NAME="IDX690"></A>
These functions compute an array of normalized associated Legendre functions
$\sqrt{(2l+1)/(4\pi)} \sqrt{(l-m)!/(l+m)!} P_l^m(x)$,
and optionally their derivatives,
for 
m &#62;= 0, 
l = |m|, ..., lmax, 
|x| &#60;= 1.0
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_legendre_array_size</B> <I>(const int <VAR>lmax</VAR>, const int <VAR>m</VAR>)</I>
<DD><A NAME="IDX691"></A>
This function returns the size of <VAR>result_array</VAR>[] needed for the array
versions of P_l^m(x), <VAR>lmax</VAR> - <VAR>m</VAR> + 1.
</DL>

</P>


<H3><A NAME="SEC131" HREF="gsl_manual.html#TOC131">Conical Functions</A></H3>

<P>
The Conical Functions 
P^\mu_{-(1/2)+i\lambda}(x) and 
Q^\mu_{-(1/2)+i\lambda} 
are described in Abramowitz &#38; Stegun, Section 8.12.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_conicalP_half</B> <I>(double <VAR>lambda</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX692"></A>
<DT><U>Function:</U> int <B>gsl_sf_conicalP_half_e</B> <I>(double <VAR>lambda</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX693"></A>
These routines compute the irregular Spherical Conical Function
P^{1/2}_{-1/2 + i \lambda}(x) for x &#62; -1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_conicalP_mhalf</B> <I>(double <VAR>lambda</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX694"></A>
<DT><U>Function:</U> int <B>gsl_sf_conicalP_mhalf_e</B> <I>(double <VAR>lambda</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX695"></A>
These routines compute the regular Spherical Conical Function
P^{-1/2}_{-1/2 + i \lambda}(x) for x &#62; -1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_conicalP_0</B> <I>(double <VAR>lambda</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX696"></A>
<DT><U>Function:</U> int <B>gsl_sf_conicalP_0_e</B> <I>(double <VAR>lambda</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX697"></A>
These routines compute the conical function
P^0_{-1/2 + i \lambda}(x)
for x &#62; -1.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_conicalP_1</B> <I>(double <VAR>lambda</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX698"></A>
<DT><U>Function:</U> int <B>gsl_sf_conicalP_1_e</B> <I>(double <VAR>lambda</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX699"></A>
These routines compute the conical function 
P^1_{-1/2 + i \lambda}(x) for x &#62; -1.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_conicalP_sph_reg</B> <I>(int <VAR>l</VAR>, double <VAR>lambda</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX700"></A>
<DT><U>Function:</U> int <B>gsl_sf_conicalP_sph_reg_e</B> <I>(int <VAR>l</VAR>, double <VAR>lambda</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX701"></A>
These routines compute the Regular Spherical Conical Function
P^{-1/2-l}_{-1/2 + i \lambda}(x) for x &#62; -1, 
l &#62;= -1.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_conicalP_cyl_reg</B> <I>(int <VAR>m</VAR>, double <VAR>lambda</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX702"></A>
<DT><U>Function:</U> int <B>gsl_sf_conicalP_cyl_reg_e</B> <I>(int <VAR>m</VAR>, double <VAR>lambda</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX703"></A>
These routines compute the Regular Cylindrical Conical Function
P^{-m}_{-1/2 + i \lambda}(x) for x &#62; -1, 
m &#62;= -1.
</DL>

</P>



<H3><A NAME="SEC132" HREF="gsl_manual.html#TOC132">Radial Functions for Hyperbolic Space</A></H3>

<P>
The following spherical functions are specializations of Legendre
functions which give the regular eigenfunctions of the Laplacian on a
3-dimensional hyperbolic space H3d.  Of particular interest is
the flat limit, \lambda \to \infty, \eta \to 0,
\lambda\eta fixed.
  
<DL>
<DT><U>Function:</U> double <B>gsl_sf_legendre_H3d_0</B> <I>(double <VAR>lambda</VAR>, double <VAR>eta</VAR>)</I>
<DD><A NAME="IDX704"></A>
<DT><U>Function:</U> int <B>gsl_sf_legendre_H3d_0_e</B> <I>(double <VAR>lambda</VAR>, double <VAR>eta</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX705"></A>
These routines compute the zeroth radial eigenfunction of the Laplacian on the
3-dimensional hyperbolic space,
L^{H3d}_0(\lambda,\eta) := \sin(\lambda\eta)/(\lambda\sinh(\eta))
for 
\eta &#62;= 0.
In the flat limit this takes the form
L^{H3d}_0(\lambda,\eta) = j_0(\lambda\eta).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_legendre_H3d_1</B> <I>(double <VAR>lambda</VAR>, double <VAR>eta</VAR>)</I>
<DD><A NAME="IDX706"></A>
<DT><U>Function:</U> int <B>gsl_sf_legendre_H3d_1_e</B> <I>(double <VAR>lambda</VAR>, double <VAR>eta</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX707"></A>
These routines compute the first radial eigenfunction of the Laplacian on
the 3-dimensional hyperbolic space,
L^{H3d}_1(\lambda,\eta) := 1/\sqrt{\lambda^2 + 1} \sin(\lambda \eta)/(\lambda \sinh(\eta)) (\coth(\eta) - \lambda \cot(\lambda\eta))
for 
\eta &#62;= 0.
In the flat limit this takes the form 
L^{H3d}_1(\lambda,\eta) = j_1(\lambda\eta).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_legendre_H3d</B> <I>(int <VAR>l</VAR>, double <VAR>lambda</VAR>, double <VAR>eta</VAR>)</I>
<DD><A NAME="IDX708"></A>
<DT><U>Function:</U> int <B>gsl_sf_legendre_H3d_e</B> <I>(int <VAR>l</VAR>, double <VAR>lambda</VAR>, double <VAR>eta</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX709"></A>
These routines compute the <VAR>l</VAR>-th radial eigenfunction of the
Laplacian on the 3-dimensional hyperbolic space 
\eta &#62;= 0, 
l &#62;= 0. In the flat limit this takes the form
L^{H3d}_l(\lambda,\eta) = j_l(\lambda\eta).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_legendre_H3d_array</B> <I>(int <VAR>lmax</VAR>, double <VAR>lambda</VAR>, double <VAR>eta</VAR>, double <VAR>result_array</VAR>[])</I>
<DD><A NAME="IDX710"></A>
This function computes an array of radial eigenfunctions
L^{H3d}_l(\lambda, \eta) 
for 
0 &#60;= l &#60;= lmax.
</DL>

</P>



<H2><A NAME="SEC133" HREF="gsl_manual.html#TOC133">Logarithm and Related Functions</A></H2>
<P>
<A NAME="IDX711"></A>

</P>
<P>
Information on the properties of the Logarithm function can be found in
Abramowitz &#38; Stegun, Chapter 4.  The functions described in this section
are declared in the header file <TT>'gsl_sf_log.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_log</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX712"></A>
<DT><U>Function:</U> int <B>gsl_sf_log_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX713"></A>
These routines compute the logarithm of <VAR>x</VAR>, \log(x), for
x &#62; 0.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_log_abs</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX714"></A>
<DT><U>Function:</U> int <B>gsl_sf_log_abs_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX715"></A>
These routines compute the logarithm of the magnitude of <VAR>x</VAR>,
\log(|x|), for x \ne 0.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_complex_log_e</B> <I>(double <VAR>zr</VAR>, double <VAR>zi</VAR>, gsl_sf_result * <VAR>lnr</VAR>, gsl_sf_result * <VAR>theta</VAR>)</I>
<DD><A NAME="IDX716"></A>
This routine computes the complex logarithm of z = z_r + i
z_i. The results are returned as <VAR>lnr</VAR>, <VAR>theta</VAR> such that
\exp(lnr + i \theta) = z_r + i z_i, where \theta lies in
the range [-\pi,\pi].
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_log_1plusx</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX717"></A>
<DT><U>Function:</U> int <B>gsl_sf_log_1plusx_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX718"></A>
These routines compute \log(1 + x) for x &#62; -1 using an
algorithm that is accurate for small x.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_log_1plusx_mx</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX719"></A>
<DT><U>Function:</U> int <B>gsl_sf_log_1plusx_mx_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX720"></A>
These routines compute \log(1 + x) - x for x &#62; -1 using an
algorithm that is accurate for small x.
</DL>

</P>


<H2><A NAME="SEC134" HREF="gsl_manual.html#TOC134">Power Function</A></H2>
<P>
<A NAME="IDX721"></A>
<A NAME="IDX722"></A>

</P>
<P>
The following functions are equivalent to the function <CODE>gsl_pow_int</CODE>
(see section <A HREF="gsl_manual.html#SEC36">Small integer powers</A>) with an error estimate.  These functions are
declared in the header file <TT>'gsl_sf_pow_int.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_pow_int</B> <I>(double <VAR>x</VAR>, int <VAR>n</VAR>)</I>
<DD><A NAME="IDX723"></A>
<DT><U>Function:</U> int <B>gsl_sf_pow_int_e</B> <I>(double <VAR>x</VAR>, int <VAR>n</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX724"></A>
These routines compute the power x^n for integer <VAR>n</VAR>.  The
power is computed using the minimum number of multiplications. For
example, x^8 is computed as ((x^2)^2)^2, requiring only 3
multiplications.  For reasons of efficiency, these functions do not
check for overflow or underflow conditions.
</DL>

</P>

<PRE class="example">
#include &#60;gsl/gsl_sf_pow_int.h&#62;
/* compute 3.0**12 */
double y = gsl_sf_pow_int(3.0, 12); 
</PRE>



<H2><A NAME="SEC135" HREF="gsl_manual.html#TOC135">Psi (Digamma) Function</A></H2>
<P>
<A NAME="IDX725"></A>
<A NAME="IDX726"></A>
<A NAME="IDX727"></A>

</P>
<P>
The polygamma functions of order m are defined by

<SPAN class="ifinfo">


<PRE class="example">
\psi^{(m)}(x) = (d/dx)^m \psi(x) = (d/dx)^{m+1} \log(\Gamma(x))
</PRE>

</SPAN>

<P>
where \psi(x) = \Gamma'(x)/\Gamma(x) is known as the digamma function.
These functions are declared in the header file <TT>'gsl_sf_psi.h'</TT>.

</P>



<H3><A NAME="SEC136" HREF="gsl_manual.html#TOC136">Digamma Function</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_psi_int</B> <I>(int <VAR>n</VAR>)</I>
<DD><A NAME="IDX728"></A>
<DT><U>Function:</U> int <B>gsl_sf_psi_int_e</B> <I>(int <VAR>n</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX729"></A>
These routines compute the digamma function \psi(n) for positive
integer <VAR>n</VAR>.  The digamma function is also called the Psi function.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_psi</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX730"></A>
<DT><U>Function:</U> int <B>gsl_sf_psi_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX731"></A>
These routines compute the digamma function \psi(x) for general
x, x \ne 0.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_psi_1piy</B> <I>(double <VAR>y</VAR>)</I>
<DD><A NAME="IDX732"></A>
<DT><U>Function:</U> int <B>gsl_sf_psi_1piy_e</B> <I>(double <VAR>y</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX733"></A>
These routines compute the real part of the digamma function on the line
1+i y, \Re[\psi(1 + i y)].
</DL>

</P>



<H3><A NAME="SEC137" HREF="gsl_manual.html#TOC137">Trigamma Function</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_psi_1_int</B> <I>(int <VAR>n</VAR>)</I>
<DD><A NAME="IDX734"></A>
<DT><U>Function:</U> int <B>gsl_sf_psi_1_int_e</B> <I>(int <VAR>n</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX735"></A>
These routines compute the Trigamma function \psi'(n) for
positive integer n.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_psi_1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX736"></A>
<DT><U>Function:</U> int <B>gsl_sf_psi_1_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX737"></A>
These routines compute the Trigamma function \psi'(x) for
general x.
</DL>

</P>


<H3><A NAME="SEC138" HREF="gsl_manual.html#TOC138">Polygamma Function</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_psi_n</B> <I>(int <VAR>m</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX738"></A>
<DT><U>Function:</U> int <B>gsl_sf_psi_n_e</B> <I>(int <VAR>m</VAR>, double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX739"></A>
These routines compute the polygamma function 
\psi^{(m)}(x) for
m &#62;= 0, x &#62; 0.  
</DL>

</P>


<H2><A NAME="SEC139" HREF="gsl_manual.html#TOC139">Synchrotron Functions</A></H2>
<P>
<A NAME="IDX740"></A>

</P>
<P>
The functions described in this section are declared in the header file
<TT>'gsl_sf_synchrotron.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_synchrotron_1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX741"></A>
<DT><U>Function:</U> int <B>gsl_sf_synchrotron_1_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX742"></A>
These routines compute the first synchrotron function 
x \int_x^\infty dt K_{5/3}(t) for 
x &#62;= 0.
</DL>
 
<DL>
<DT><U>Function:</U> double <B>gsl_sf_synchrotron_2</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX743"></A>
<DT><U>Function:</U> int <B>gsl_sf_synchrotron_2_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX744"></A>
These routines compute the second synchrotron function 
x K_{2/3}(x) for 
x &#62;= 0.
</DL>

</P>


<H2><A NAME="SEC140" HREF="gsl_manual.html#TOC140">Transport Functions</A></H2>
<P>
<A NAME="IDX745"></A>

</P>
<P>
The transport functions J(n,x) are defined by the integral 
representations
J(n,x) := \int_0^x dt t^n e^t /(e^t - 1)^2.
They are declared in the header file <TT>'gsl_sf_transport.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_transport_2</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX746"></A>
<DT><U>Function:</U> int <B>gsl_sf_transport_2_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX747"></A>
These routines compute the transport function J(2,x).
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_transport_3</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX748"></A>
<DT><U>Function:</U> int <B>gsl_sf_transport_3_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX749"></A>
These routines compute the transport function J(3,x).
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_transport_4</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX750"></A>
<DT><U>Function:</U> int <B>gsl_sf_transport_4_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX751"></A>
These routines compute the transport function J(4,x).
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_transport_5</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX752"></A>
<DT><U>Function:</U> int <B>gsl_sf_transport_5_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX753"></A>
These routines compute the transport function J(5,x).
</DL>

</P>


<H2><A NAME="SEC141" HREF="gsl_manual.html#TOC141">Trigonometric Functions</A></H2>
<P>
<A NAME="IDX754"></A>

</P>
<P>
The library includes its own trigonometric functions in order to provide
consistency across platforms and reliable error estimates.  These
functions are declared in the header file <TT>'gsl_sf_trig.h'</TT>.

</P>



<H3><A NAME="SEC142" HREF="gsl_manual.html#TOC142">Circular Trigonometric Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_sin</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX755"></A>
<DT><U>Function:</U> int <B>gsl_sf_sin_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX756"></A>
<A NAME="IDX757"></A>
These routines compute the sine function \sin(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_cos</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX758"></A>
<DT><U>Function:</U> int <B>gsl_sf_cos_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX759"></A>
<A NAME="IDX760"></A>
These routines compute the cosine function \cos(x).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_hypot</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>)</I>
<DD><A NAME="IDX761"></A>
<DT><U>Function:</U> int <B>gsl_sf_hypot_e</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX762"></A>
<A NAME="IDX763"></A>
These routines compute the hypotenuse function 
\sqrt{x^2 + y^2} avoiding overflow and underflow.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_sinc</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX764"></A>
<DT><U>Function:</U> int <B>gsl_sf_sinc_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX765"></A>
<A NAME="IDX766"></A>
These routines compute \sinc(x) = \sin(\pi x) / (\pi x) for any
value of <VAR>x</VAR>.
</DL>

</P>


<H3><A NAME="SEC143" HREF="gsl_manual.html#TOC143">Trigonometric Functions for Complex Arguments</A></H3>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_complex_sin_e</B> <I>(double <VAR>zr</VAR>, double <VAR>zi</VAR>, gsl_sf_result * <VAR>szr</VAR>, gsl_sf_result * <VAR>szi</VAR>)</I>
<DD><A NAME="IDX767"></A>
<A NAME="IDX768"></A>
This function computes the complex sine, \sin(z_r + i z_i) storing
the real and imaginary parts in <VAR>szr</VAR>, <VAR>szi</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_complex_cos_e</B> <I>(double <VAR>zr</VAR>, double <VAR>zi</VAR>, gsl_sf_result * <VAR>czr</VAR>, gsl_sf_result * <VAR>czi</VAR>)</I>
<DD><A NAME="IDX769"></A>
<A NAME="IDX770"></A>
This function computes the complex cosine, \cos(z_r + i z_i) storing
the real and imaginary parts in <VAR>szr</VAR>, <VAR>szi</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_complex_logsin_e</B> <I>(double <VAR>zr</VAR>, double <VAR>zi</VAR>, gsl_sf_result * <VAR>lszr</VAR>, gsl_sf_result * <VAR>lszi</VAR>)</I>
<DD><A NAME="IDX771"></A>
<A NAME="IDX772"></A>
This function computes the logarithm of the complex sine,
\log(\sin(z_r + i z_i)) storing the real and imaginary parts in
<VAR>szr</VAR>, <VAR>szi</VAR>.
</DL>

</P>


<H3><A NAME="SEC144" HREF="gsl_manual.html#TOC144">Hyperbolic Trigonometric Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_lnsinh</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX773"></A>
<DT><U>Function:</U> int <B>gsl_sf_lnsinh_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX774"></A>
<A NAME="IDX775"></A>
These routines compute \log(\sinh(x)) for x &#62; 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_lncosh</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX776"></A>
<DT><U>Function:</U> int <B>gsl_sf_lncosh_e</B> <I>(double <VAR>x</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX777"></A>
<A NAME="IDX778"></A>
These routines compute \log(\cosh(x)) for any <VAR>x</VAR>.
</DL>

</P>



<H3><A NAME="SEC145" HREF="gsl_manual.html#TOC145">Conversion Functions</A></H3>
<P>
<A NAME="IDX779"></A>
<A NAME="IDX780"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_polar_to_rect</B> <I>(double <VAR>r</VAR>, double <VAR>theta</VAR>, gsl_sf_result * <VAR>x</VAR>, gsl_sf_result * <VAR>y</VAR>);</I>
<DD><A NAME="IDX781"></A>
This function converts the polar coordinates (<VAR>r</VAR>,<VAR>theta</VAR>) to
rectilinear coordinates (<VAR>x</VAR>,<VAR>y</VAR>), x = r\cos(\theta),
y = r\sin(\theta).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sf_rect_to_polar</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>, gsl_sf_result * <VAR>r</VAR>, gsl_sf_result * <VAR>theta</VAR>)</I>
<DD><A NAME="IDX782"></A>
This function converts the rectilinear coordinates (<VAR>x</VAR>,<VAR>y</VAR>) to
polar coordinates (<VAR>r</VAR>,<VAR>theta</VAR>), such that x =
r\cos(\theta), y = r\sin(\theta).  The argument <VAR>theta</VAR>
lies in the range [-\pi, \pi].
</DL>

</P>


<H3><A NAME="SEC146" HREF="gsl_manual.html#TOC146">Restriction Functions</A></H3>
<P>
<A NAME="IDX783"></A>
<A NAME="IDX784"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_angle_restrict_symm</B> <I>(double <VAR>theta</VAR>)</I>
<DD><A NAME="IDX785"></A>
<DT><U>Function:</U> int <B>gsl_sf_angle_restrict_symm_e</B> <I>(double * <VAR>theta</VAR>)</I>
<DD><A NAME="IDX786"></A>
These routines force the angle <VAR>theta</VAR> to lie in the range
(-\pi,\pi].
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_angle_restrict_pos</B> <I>(double <VAR>theta</VAR>)</I>
<DD><A NAME="IDX787"></A>
<DT><U>Function:</U> int <B>gsl_sf_angle_restrict_pos_e</B> <I>(double * <VAR>theta</VAR>)</I>
<DD><A NAME="IDX788"></A>
These routines force the angle <VAR>theta</VAR> to lie in the range [0,
2\pi).
</DL>

</P>



<H3><A NAME="SEC147" HREF="gsl_manual.html#TOC147">Trigonometric Functions With Error Estimates</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_sin_err</B> <I>(double <VAR>x</VAR>, double <VAR>dx</VAR>)</I>
<DD><A NAME="IDX789"></A>
<DT><U>Function:</U> int <B>gsl_sf_sin_err_e</B> <I>(double <VAR>x</VAR>, double <VAR>dx</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX790"></A>
These routines compute the sine of an angle <VAR>x</VAR> with an associated 
absolute error <VAR>dx</VAR>,
\sin(x \pm dx).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_cos_err</B> <I>(double <VAR>x</VAR>, double <VAR>dx</VAR>)</I>
<DD><A NAME="IDX791"></A>
<DT><U>Function:</U> int <B>gsl_sf_cos_err_e</B> <I>(double <VAR>x</VAR>, double <VAR>dx</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX792"></A>
These routines compute the cosine of an angle <VAR>x</VAR> with an associated
absolute error <VAR>dx</VAR>,
\cos(x \pm dx).
</DL>

</P>



<H2><A NAME="SEC148" HREF="gsl_manual.html#TOC148">Zeta Functions</A></H2>
<P>
<A NAME="IDX793"></A>

</P>
<P>
The Riemann zeta function is defined in Abramowitz &#38; Stegun, Section
23.2.  The functions described in this section are declared in the
header file <TT>'gsl_sf_zeta.h'</TT>.

</P>



<H3><A NAME="SEC149" HREF="gsl_manual.html#TOC149">Riemann Zeta Function</A></H3>

<P>
The Riemann zeta function is defined by the infinite sum 
\zeta(s) = \sum_{k=1}^\infty k^{-s}.  

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_zeta_int</B> <I>(int <VAR>n</VAR>)</I>
<DD><A NAME="IDX794"></A>
<DT><U>Function:</U> int <B>gsl_sf_zeta_int_e</B> <I>(int <VAR>n</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX795"></A>
These routines compute the Riemann zeta function \zeta(n) 
for integer <VAR>n</VAR>,
n \ne 1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_zeta</B> <I>(double <VAR>s</VAR>)</I>
<DD><A NAME="IDX796"></A>
<DT><U>Function:</U> int <B>gsl_sf_zeta_e</B> <I>(double <VAR>s</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX797"></A>
These routines compute the Riemann zeta function \zeta(s)
for arbitrary <VAR>s</VAR>,
s \ne 1.
</DL>

</P>



<H3><A NAME="SEC150" HREF="gsl_manual.html#TOC150">Riemann Zeta Function Minus One</A></H3>

<P>
For large positive argument, the Riemann zeta function approaches one.
In this region the fractional part is interesting, and therefore we
need a function to evaluate it explicitly.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_zetam1_int</B> <I>(int <VAR>n</VAR>)</I>
<DD><A NAME="IDX798"></A>
<DT><U>Function:</U> int <B>gsl_sf_zetam1_int_e</B> <I>(int <VAR>n</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX799"></A>
These routines compute \zeta(n) - 1 for integer <VAR>n</VAR>,
n \ne 1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_zetam1</B> <I>(double <VAR>s</VAR>)</I>
<DD><A NAME="IDX800"></A>
<DT><U>Function:</U> int <B>gsl_sf_zetam1_e</B> <I>(double <VAR>s</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX801"></A>
These routines compute \zeta(s) - 1 for arbitrary <VAR>s</VAR>,
s \ne 1.
</DL>

</P>



<H3><A NAME="SEC151" HREF="gsl_manual.html#TOC151">Hurwitz Zeta Function</A></H3>

<P>
The Hurwitz zeta function is defined by
\zeta(s,q) = \sum_0^\infty (k+q)^{-s}.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_hzeta</B> <I>(double <VAR>s</VAR>, double <VAR>q</VAR>)</I>
<DD><A NAME="IDX802"></A>
<DT><U>Function:</U> int <B>gsl_sf_hzeta_e</B> <I>(double <VAR>s</VAR>, double <VAR>q</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX803"></A>
These routines compute the Hurwitz zeta function \zeta(s,q) for
s &#62; 1, q &#62; 0.
</DL>

</P>



<H3><A NAME="SEC152" HREF="gsl_manual.html#TOC152">Eta Function</A></H3>

<P>
The eta function is defined by
\eta(s) = (1-2^{1-s}) \zeta(s).

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_eta_int</B> <I>(int <VAR>n</VAR>)</I>
<DD><A NAME="IDX804"></A>
<DT><U>Function:</U> int <B>gsl_sf_eta_int_e</B> <I>(int <VAR>n</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX805"></A>
These routines compute the eta function \eta(n) for integer <VAR>n</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_sf_eta</B> <I>(double <VAR>s</VAR>)</I>
<DD><A NAME="IDX806"></A>
<DT><U>Function:</U> int <B>gsl_sf_eta_e</B> <I>(double <VAR>s</VAR>, gsl_sf_result * <VAR>result</VAR>)</I>
<DD><A NAME="IDX807"></A>
These routines compute the eta function \eta(s) for arbitrary <VAR>s</VAR>.
</DL>

</P>



<H2><A NAME="SEC153" HREF="gsl_manual.html#TOC153">Examples</A></H2>

<P>
The following example demonstrates the use of the error handling form of
the special functions, in this case to compute the Bessel function
J_0(5.0),

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_errno.h&#62;
#include &#60;gsl/gsl_sf_bessel.h&#62;

int
main (void)
{
  double x = 5.0;
  gsl_sf_result result;

  double expected = -0.17759677131433830434739701;
  
  int status = gsl_sf_bessel_J0_e (x, &#38;result);

  printf ("status  = %s\n", gsl_strerror(status));
  printf ("J0(5.0) = %.18f\n"
          "      +/- % .18f\n", 
          result.val, result.err);
  printf ("exact   = %.18f\n", expected);
  return status;
}
</PRE>

<P>
Here are the results of running the program,

</P>

<PRE class="example">
$ ./a.out 
status  = success
J0(5.0) = -0.177596771314338292 
      +/-  0.000000000000000193
exact   = -0.177596771314338292
</PRE>

<P>
The next program computes the same quantity using the natural form of
the function. In this case the error term <VAR>result.err</VAR> and return
status are not accessible.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_sf_bessel.h&#62;

int
main (void)
{
  double x = 5.0;
  double expected = -0.17759677131433830434739701;
  
  double y = gsl_sf_bessel_J0 (x);

  printf ("J0(5.0) = %.18f\n", y);
  printf ("exact   = %.18f\n", expected);
  return 0;
}
</PRE>

<P>
The results of the function are the same,

</P>

<PRE class="example">
$ ./a.out 
J0(5.0) = -0.177596771314338292
exact   = -0.177596771314338292
</PRE>



<H2><A NAME="SEC154" HREF="gsl_manual.html#TOC154">References and Further Reading</A></H2>

<P>
The library follows the conventions of <CITE>Abramowitz &#38; Stegun</CITE> where
possible,

<UL class="itemize">
<LI>

Abramowitz &#38; Stegun (eds.), <CITE>Handbook of Mathematical Functions</CITE>
</UL>

<P>
The following papers contain information on the algorithms used 
to compute the special functions,
<A NAME="IDX808"></A>

<UL class="itemize">
<LI>

MISCFUN: A software package to compute uncommon special functions.
<CITE>ACM Trans. Math. Soft.</CITE>, vol. 22, 1996, 288--301

<LI>

G.N. Watson, A Treatise on the Theory of Bessel Functions,
2nd Edition (Cambridge University Press, 1944).

<LI>

G. Nemeth, Mathematical Approximations of Special Functions,
Nova Science Publishers, ISBN 1-56072-052-2

<LI>

B.C. Carlson, Special Functions of Applied Mathematics (1977)

<LI>

W.J. Thompson, Atlas for Computing Mathematical Functions, John Wiley &#38; Sons,
New York (1997).

<LI>

Y.Y. Luke, Algorithms for the Computation of Mathematical Functions, Academic
Press, New York (1977).

</UL>



<H1><A NAME="SEC155" HREF="gsl_manual.html#TOC155">Vectors and Matrices</A></H1>
<P>
<A NAME="IDX809"></A>
<A NAME="IDX810"></A>
<A NAME="IDX811"></A>

</P>
<P>
The functions described in this chapter provide a simple vector and
matrix interface to ordinary C arrays. The memory management of these
arrays is implemented using a single underlying type, known as a
block. By writing your functions in terms of vectors and matrices you
can pass a single structure containing both data and dimensions as an
argument without needing additional function parameters.  The structures
are compatible with the vector and matrix formats used by BLAS
routines.

</P>



<H2><A NAME="SEC156" HREF="gsl_manual.html#TOC156">Data types</A></H2>

<P>
All the functions are available for each of the standard data-types.
The versions for <CODE>double</CODE> have the prefix <CODE>gsl_block</CODE>,
<CODE>gsl_vector</CODE> and <CODE>gsl_matrix</CODE>.  Similarly the versions for
single-precision <CODE>float</CODE> arrays have the prefix
<CODE>gsl_block_float</CODE>, <CODE>gsl_vector_float</CODE> and
<CODE>gsl_matrix_float</CODE>.  The full list of available types is given
below,

</P>

<PRE class="example">
gsl_block                       double         
gsl_block_float                 float         
gsl_block_long_double           long double   
gsl_block_int                   int           
gsl_block_uint                  unsigned int  
gsl_block_long                  long          
gsl_block_ulong                 unsigned long 
gsl_block_short                 short         
gsl_block_ushort                unsigned short
gsl_block_char                  char          
gsl_block_uchar                 unsigned char 
gsl_block_complex               complex double        
gsl_block_complex_float         complex float         
gsl_block_complex_long_double   complex long double   
</PRE>

<P>
Corresponding types exist for the <CODE>gsl_vector</CODE> and
<CODE>gsl_matrix</CODE> functions.

</P>



<H2><A NAME="SEC157" HREF="gsl_manual.html#TOC157">Blocks</A></H2>

<P>
For consistency all memory is allocated through a <CODE>gsl_block</CODE>
structure.  The structure contains two components, the size of an area of
memory and a pointer to the memory.  The <CODE>gsl_block</CODE> structure looks
like this,

</P>

<PRE class="example">
typedef struct
{
  size_t size;
  double * data;
} gsl_block;
</PRE>

<P>
Vectors and matrices are made by <I>slicing</I> an underlying block. A
slice is a set of elements formed from an initial offset and a
combination of indices and step-sizes. In the case of a matrix the
step-size for the column index represents the row-length.  The step-size
for a vector is known as the <I>stride</I>.

</P>
<P>
The functions for allocating and deallocating blocks are defined in
<TT>'gsl_block.h'</TT>

</P>



<H3><A NAME="SEC158" HREF="gsl_manual.html#TOC158">Block allocation</A></H3>

<P>
The functions for allocating memory to a block follow the style of
<CODE>malloc</CODE> and <CODE>free</CODE>.  In addition they also perform their own
error checking.  If there is insufficient memory available to allocate a
block then the functions call the GSL error handler (with an error
number of <CODE>GSL_ENOMEM</CODE>) in addition to returning a null
pointer.  Thus if you use the library error handler to abort your program
then it isn't necessary to check every <CODE>alloc</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_block * <B>gsl_block_alloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX812"></A>
This function allocates memory for a block of <VAR>n</VAR> double-precision
elements, returning a pointer to the block struct.  The block is not
initialized and so the values of its elements are undefined.  Use the
function <CODE>gsl_block_calloc</CODE> if you want to ensure that all the
elements are initialized to zero.

</P>
<P>
A null pointer is returned if insufficient memory is available to create
the block.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_block * <B>gsl_block_calloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX813"></A>
This function allocates memory for a block and initializes all the
elements of the block to zero.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_block_free</B> <I>(gsl_block * <VAR>b</VAR>)</I>
<DD><A NAME="IDX814"></A>
This function frees the memory used by a block <VAR>b</VAR> previously
allocated with <CODE>gsl_block_alloc</CODE> or <CODE>gsl_block_calloc</CODE>.
</DL>

</P>


<H3><A NAME="SEC159" HREF="gsl_manual.html#TOC159">Reading and writing blocks</A></H3>

<P>
The library provides functions for reading and writing blocks to a file
as binary data or formatted text.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_block_fwrite</B> <I>(FILE * <VAR>stream</VAR>, const gsl_block * <VAR>b</VAR>)</I>
<DD><A NAME="IDX815"></A>
This function writes the elements of the block <VAR>b</VAR> to the stream
<VAR>stream</VAR> in binary format.  The return value is 0 for success and
<CODE>GSL_EFAILED</CODE> if there was a problem writing to the file.  Since the
data is written in the native binary format it may not be portable
between different architectures.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_block_fread</B> <I>(FILE * <VAR>stream</VAR>, gsl_block * <VAR>b</VAR>)</I>
<DD><A NAME="IDX816"></A>
This function reads into the block <VAR>b</VAR> from the open stream
<VAR>stream</VAR> in binary format.  The block <VAR>b</VAR> must be preallocated
with the correct length since the function uses the size of <VAR>b</VAR> to
determine how many bytes to read.  The return value is 0 for success and
<CODE>GSL_EFAILED</CODE> if there was a problem reading from the file.  The
data is assumed to have been written in the native binary format on the
same architecture.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_block_fprintf</B> <I>(FILE * <VAR>stream</VAR>, const gsl_block * <VAR>b</VAR>, const char * <VAR>format</VAR>)</I>
<DD><A NAME="IDX817"></A>
This function writes the elements of the block <VAR>b</VAR> line-by-line to
the stream <VAR>stream</VAR> using the format specifier <VAR>format</VAR>, which
should be one of the <CODE>%g</CODE>, <CODE>%e</CODE> or <CODE>%f</CODE> formats for
floating point numbers and <CODE>%d</CODE> for integers.  The function returns
0 for success and <CODE>GSL_EFAILED</CODE> if there was a problem writing to
the file.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_block_fscanf</B> <I>(FILE * <VAR>stream</VAR>, gsl_block * <VAR>b</VAR>)</I>
<DD><A NAME="IDX818"></A>
This function reads formatted data from the stream <VAR>stream</VAR> into the
block <VAR>b</VAR>.  The block <VAR>b</VAR> must be preallocated with the correct
length since the function uses the size of <VAR>b</VAR> to determine how many
numbers to read.  The function returns 0 for success and
<CODE>GSL_EFAILED</CODE> if there was a problem reading from the file.
</DL>

</P>


<H3><A NAME="SEC160" HREF="gsl_manual.html#TOC160">Example programs for blocks</A></H3>

<P>
The following program shows how to allocate a block,

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_block.h&#62;

int
main (void)
{
  gsl_block * b = gsl_block_alloc (100);
  
  printf ("length of block = %u\n", b-&#62;size);
  printf ("block data address = %#x\n", b-&#62;data);

  gsl_block_free (b);
  return 0;
}
</PRE>

<P>
Here is the output from the program,

</P>

<PRE class="example">
length of block = 100
block data address = 0x804b0d8
</PRE>



<H2><A NAME="SEC161" HREF="gsl_manual.html#TOC161">Vectors</A></H2>
<P>
<A NAME="IDX819"></A>
<A NAME="IDX820"></A>

</P>
<P>
Vectors are defined by a <CODE>gsl_vector</CODE> structure which describes a
slice of a block.  Different vectors can be created which point to the
same block.  A vector slice is a set of equally-spaced elements of an
area of memory.

</P>
<P>
The <CODE>gsl_vector</CODE> structure contains five components, the
<I>size</I>, the <I>stride</I>, a pointer to the memory where the elements
are stored, <VAR>data</VAR>, a pointer to the block owned by the vector,
<VAR>block</VAR>, if any, and an ownership flag, <VAR>owner</VAR>.  The structure
is very simple and looks like this,

</P>

<PRE class="example">
typedef struct
{
  size_t size;
  size_t stride;
  double * data;
  gsl_block * block;
  int owner;
} gsl_vector;
</PRE>

<P>
The <VAR>size</VAR> is simply the number of vector elements.  The range of
valid indices runs from 0 to <CODE>size-1</CODE>.  The <VAR>stride</VAR> is the
step-size from one element to the next in physical memory, measured in
units of the appropriate datatype.  The pointer <VAR>data</VAR> gives the
location of the first element of the vector in memory.  The pointer
<VAR>block</VAR> stores the location of the memory block in which the vector
elements are located (if any).  If the vector owns this block then the
<VAR>owner</VAR> field is set to one and the block will be deallocated when the
vector is freed.  If the vector points to a block owned by another
object then the <VAR>owner</VAR> field is zero and any underlying block will not be
deallocated with the vector.

</P>
<P>
The functions for allocating and accessing vectors are defined in
<TT>'gsl_vector.h'</TT>

</P>



<H3><A NAME="SEC162" HREF="gsl_manual.html#TOC162">Vector allocation</A></H3>

<P>
The functions for allocating memory to a vector follow the style of
<CODE>malloc</CODE> and <CODE>free</CODE>.  In addition they also perform their own
error checking.  If there is insufficient memory available to allocate a
vector then the functions call the GSL error handler (with an error
number of <CODE>GSL_ENOMEM</CODE>) in addition to returning a null
pointer.  Thus if you use the library error handler to abort your program
then it isn't necessary to check every <CODE>alloc</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_vector * <B>gsl_vector_alloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX821"></A>
This function creates a vector of length <VAR>n</VAR>, returning a pointer to
a newly initialized vector struct. A new block is allocated for the
elements of the vector, and stored in the <VAR>block</VAR> component of the
vector struct.  The block is "owned" by the vector, and will be
deallocated when the vector is deallocated.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_vector * <B>gsl_vector_calloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX822"></A>
This function allocates memory for a vector of length <VAR>n</VAR> and
initializes all the elements of the vector to zero.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_vector_free</B> <I>(gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX823"></A>
This function frees a previously allocated vector <VAR>v</VAR>.  If the
vector was created using <CODE>gsl_vector_alloc</CODE> then the block
underlying the vector will also be deallocated.  If the vector has been
created from another object then the memory is still owned by that
object and will not be deallocated.
</DL>

</P>


<H3><A NAME="SEC163" HREF="gsl_manual.html#TOC163">Accessing vector elements</A></H3>
<P>
<A NAME="IDX824"></A>
<A NAME="IDX825"></A>
<A NAME="IDX826"></A>
<A NAME="IDX827"></A>
<A NAME="IDX828"></A>

</P>
<P>
Unlike FORTRAN compilers, C compilers do not usually provide
support for range checking of vectors and matrices.  Range checking is
available in the GNU C Compiler bounds-checking extension, but it is not
part of the default installation of GCC.  The functions
<CODE>gsl_vector_get</CODE> and <CODE>gsl_vector_set</CODE> can perform portable
range checking for you and report an error if you attempt to access
elements outside the allowed range.

</P>
<P>
The functions for accessing the elements of a vector or matrix are
defined in <TT>'gsl_vector.h'</TT> and declared <CODE>extern inline</CODE> to
eliminate function-call overhead.  You must compile your program with
the macro <CODE>HAVE_INLINE</CODE> defined to use these functions.  

</P>
<P>
If necessary you can turn off range checking completely without
modifying any source files by recompiling your program with the
preprocessor definition <CODE>GSL_RANGE_CHECK_OFF</CODE>.  Provided your
compiler supports inline functions the effect of turning off range
checking is to replace calls to <CODE>gsl_vector_get(v,i)</CODE> by
<CODE>v-&#62;data[i*v-&#62;stride]</CODE> and calls to <CODE>gsl_vector_set(v,i,x)</CODE> by
<CODE>v-&#62;data[i*v-&#62;stride]=x</CODE>.  Thus there should be no performance
penalty for using the range checking functions when range checking is
turned off.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_vector_get</B> <I>(const gsl_vector * <VAR>v</VAR>, size_t <VAR>i</VAR>)</I>
<DD><A NAME="IDX829"></A>
This function returns the <VAR>i</VAR>-th element of a vector <VAR>v</VAR>.  If
<VAR>i</VAR> lies outside the allowed range of 0 to <VAR>n</VAR>-1 then the error
handler is invoked and 0 is returned.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_vector_set</B> <I>(gsl_vector * <VAR>v</VAR>, size_t <VAR>i</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX830"></A>
This function sets the value of the <VAR>i</VAR>-th element of a vector
<VAR>v</VAR> to <VAR>x</VAR>.  If <VAR>i</VAR> lies outside the allowed range of 0 to
<VAR>n</VAR>-1 then the error handler is invoked.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double * <B>gsl_vector_ptr</B> <I>(gsl_vector * <VAR>v</VAR>, size_t <VAR>i</VAR>)</I>
<DD><A NAME="IDX831"></A>
<DT><U>Function:</U> const double * <B>gsl_vector_const_ptr</B> <I>(const gsl_vector * <VAR>v</VAR>, size_t <VAR>i</VAR>)</I>
<DD><A NAME="IDX832"></A>
These functions return a pointer to the <VAR>i</VAR>-th element of a vector
<VAR>v</VAR>.  If <VAR>i</VAR> lies outside the allowed range of 0 to <VAR>n</VAR>-1
then the error handler is invoked and a null pointer is returned.
</DL>

</P>


<H3><A NAME="SEC164" HREF="gsl_manual.html#TOC164">Initializing vector elements</A></H3>
<P>
<A NAME="IDX833"></A>
<A NAME="IDX834"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_vector_set_all</B> <I>(gsl_vector * <VAR>v</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX835"></A>
This function sets all the elements of the vector <VAR>v</VAR> to the value
<VAR>x</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_vector_set_zero</B> <I>(gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX836"></A>
This function sets all the elements of the vector <VAR>v</VAR> to zero.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_vector_set_basis</B> <I>(gsl_vector * <VAR>v</VAR>, size_t <VAR>i</VAR>)</I>
<DD><A NAME="IDX837"></A>
This function makes a basis vector by setting all the elements of the
vector <VAR>v</VAR> to zero except for the <VAR>i</VAR>-th element which is set to
one.
</DL>

</P>


<H3><A NAME="SEC165" HREF="gsl_manual.html#TOC165">Reading and writing vectors</A></H3>

<P>
The library provides functions for reading and writing vectors to a file
as binary data or formatted text.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_vector_fwrite</B> <I>(FILE * <VAR>stream</VAR>, const gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX838"></A>
This function writes the elements of the vector <VAR>v</VAR> to the stream
<VAR>stream</VAR> in binary format.  The return value is 0 for success and
<CODE>GSL_EFAILED</CODE> if there was a problem writing to the file.  Since the
data is written in the native binary format it may not be portable
between different architectures.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_vector_fread</B> <I>(FILE * <VAR>stream</VAR>, gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX839"></A>
This function reads into the vector <VAR>v</VAR> from the open stream
<VAR>stream</VAR> in binary format.  The vector <VAR>v</VAR> must be preallocated
with the correct length since the function uses the size of <VAR>v</VAR> to
determine how many bytes to read.  The return value is 0 for success and
<CODE>GSL_EFAILED</CODE> if there was a problem reading from the file.  The
data is assumed to have been written in the native binary format on the
same architecture.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_vector_fprintf</B> <I>(FILE * <VAR>stream</VAR>, const gsl_vector * <VAR>v</VAR>, const char * <VAR>format</VAR>)</I>
<DD><A NAME="IDX840"></A>
This function writes the elements of the vector <VAR>v</VAR> line-by-line to
the stream <VAR>stream</VAR> using the format specifier <VAR>format</VAR>, which
should be one of the <CODE>%g</CODE>, <CODE>%e</CODE> or <CODE>%f</CODE> formats for
floating point numbers and <CODE>%d</CODE> for integers.  The function returns
0 for success and <CODE>GSL_EFAILED</CODE> if there was a problem writing to
the file.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_vector_fscanf</B> <I>(FILE * <VAR>stream</VAR>, gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX841"></A>
This function reads formatted data from the stream <VAR>stream</VAR> into the
vector <VAR>v</VAR>.  The vector <VAR>v</VAR> must be preallocated with the correct
length since the function uses the size of <VAR>v</VAR> to determine how many
numbers to read.  The function returns 0 for success and
<CODE>GSL_EFAILED</CODE> if there was a problem reading from the file.
</DL>

</P>


<H3><A NAME="SEC166" HREF="gsl_manual.html#TOC166">Vector views</A></H3>

<P>
In addition to creating vectors from slices of blocks it is also
possible to slice vectors and create vector views.  For example, a
subvector of another vector can be described with a view, or two views
can be made which provide access to the even and odd elements of a
vector.

</P>
<P>
A vector view is a temporary object, stored on the stack, which can be
used to operate on a subset of vector elements.  Vector views can be
defined for both constant and non-constant vectors, using separate types
that preserve constness.  A vector view has the type
<CODE>gsl_vector_view</CODE> and a constant vector view has the type
<CODE>gsl_vector_const_view</CODE>.  In both cases the elements of the view
can be accessed as a <CODE>gsl_vector</CODE> using the <CODE>vector</CODE> component
of the view object.  A pointer to a vector of type <CODE>gsl_vector *</CODE>
or <CODE>const gsl_vector *</CODE> can be obtained by taking the address of
this component with the <CODE>&#38;</CODE> operator.  

</P>
<P>
When using this pointer it is important to ensure that the view itself
remains in scope--the simplest way to do so is by always writing the
pointer as <CODE>&#38;</CODE><VAR>view</VAR><CODE>.vector</CODE>, and never storing this value
in another variable.  

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_vector_view <B>gsl_vector_subvector</B> <I>(gsl_vector * <VAR>v</VAR>, size_t <VAR>offset</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX842"></A>
<DT><U>Function:</U> gsl_vector_const_view <B>gsl_vector_const_subvector</B> <I>(const gsl_vector * <VAR>v</VAR>, size_t <VAR>offset</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX843"></A>
These functions return a vector view of a subvector of another vector
<VAR>v</VAR>.  The start of the new vector is offset by <VAR>offset</VAR> elements
from the start of the original vector.  The new vector has <VAR>n</VAR>
elements.  Mathematically, the <VAR>i</VAR>-th element of the new vector
<VAR>v'</VAR> is given by,

</P>

<PRE class="example">
v'(i) = v-&#62;data[(offset + i)*v-&#62;stride]
</PRE>

<P>
where the index <VAR>i</VAR> runs from 0 to <CODE>n-1</CODE>.

</P>
<P>
The <CODE>data</CODE> pointer of the returned vector struct is set to null if
the combined parameters (<VAR>offset</VAR>,<VAR>n</VAR>) overrun the end of the
original vector.

</P>
<P>
The new vector is only a view of the block underlying the original
vector, <VAR>v</VAR>.  The block containing the elements of <VAR>v</VAR> is not
owned by the new vector.  When the view goes out of scope the original
vector <VAR>v</VAR> and its block will continue to exist.  The original
memory can only be deallocated by freeing the original vector.  Of
course, the original vector should not be deallocated while the view is
still in use.

</P>
<P>
The function <CODE>gsl_vector_const_subvector</CODE> is equivalent to
<CODE>gsl_vector_subvector</CODE> but can be used for vectors which are
declared <CODE>const</CODE>.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> gsl_vector_view <B>gsl_vector_subvector_with_stride</B> <I>(gsl_vector * <VAR>v</VAR>, size_t <VAR>offset</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX844"></A>
<DT><U>Function:</U> gsl_vector_const_view <B>gsl_vector_const_subvector_with_stride</B> <I>(const gsl_vector * <VAR>v</VAR>, size_t <VAR>offset</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX845"></A>
These functions return a vector view of a subvector of another vector
<VAR>v</VAR> with an additional stride argument. The subvector is formed in
the same way as for <CODE>gsl_vector_subvector</CODE> but the new vector has
<VAR>n</VAR> elements with a step-size of <VAR>stride</VAR> from one element to
the next in the original vector.  Mathematically, the <VAR>i</VAR>-th element
of the new vector <VAR>v'</VAR> is given by,

</P>

<PRE class="example">
v'(i) = v-&#62;data[(offset + i*stride)*v-&#62;stride]
</PRE>

<P>
where the index <VAR>i</VAR> runs from 0 to <CODE>n-1</CODE>.

</P>
<P>
Note that subvector views give direct access to the underlying elements
of the original vector. For example, the following code will zero the
even elements of the vector <CODE>v</CODE> of length <CODE>n</CODE>, while leaving the
odd elements untouched,

</P>

<PRE class="example">
gsl_vector_view v_even 
  = gsl_vector_subvector_with_stride (v, 0, 2, n/2);
gsl_vector_set_zero (&#38;v_even.vector);
</PRE>

<P>
A vector view can be passed to any subroutine which takes a vector
argument just as a directly allocated vector would be, using
<CODE>&#38;</CODE><VAR>view</VAR><CODE>.vector</CODE>.  For example, the following code
computes the norm of the odd elements of <CODE>v</CODE> using the BLAS
routine DNRM2,

</P>

<PRE class="example">
gsl_vector_view v_odd 
  = gsl_vector_subvector_with_stride (v, 1, 2, n/2);
double r = gsl_blas_dnrm2 (&#38;v_odd.vector);
</PRE>

<P>
The function <CODE>gsl_vector_const_subvector_with_stride</CODE> is equivalent
to <CODE>gsl_vector_subvector_with_stride</CODE> but can be used for vectors
which are declared <CODE>const</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_vector_view <B>gsl_vector_complex_real</B> <I>(gsl_vector_complex * <VAR>v</VAR>)</I>
<DD><A NAME="IDX846"></A>
<DT><U>Function:</U> gsl_vector_const_view <B>gsl_vector_complex_const_real</B> <I>(const gsl_vector_complex * <VAR>v</VAR>)</I>
<DD><A NAME="IDX847"></A>
These functions return a vector view of the real parts of the complex
vector <VAR>v</VAR>.

</P>
<P>
The function <CODE>gsl_vector_complex_const_real</CODE> is equivalent to
<CODE>gsl_vector_complex_real</CODE> but can be used for vectors which are
declared <CODE>const</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_vector_view <B>gsl_vector_complex_imag</B> <I>(gsl_vector_complex * <VAR>v</VAR>)</I>
<DD><A NAME="IDX848"></A>
<DT><U>Function:</U> gsl_vector_const_view <B>gsl_vector_complex_const_imag</B> <I>(const gsl_vector_complex * <VAR>v</VAR>)</I>
<DD><A NAME="IDX849"></A>
These functions return a vector view of the imaginary parts of the
complex vector <VAR>v</VAR>.

</P>
<P>
The function <CODE>gsl_vector_complex_const_imag</CODE> is equivalent to
<CODE>gsl_vector_complex_imag</CODE> but can be used for vectors which are
declared <CODE>const</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_vector_view <B>gsl_vector_view_array</B> <I>(double * <VAR>base</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX850"></A>
<DT><U>Function:</U> gsl_vector_const_view <B>gsl_vector_const_view_array</B> <I>(const double * <VAR>base</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX851"></A>
These functions return a vector view of an array.  The start of the new
vector is given by <VAR>base</VAR> and has <VAR>n</VAR> elements.  Mathematically,
the <VAR>i</VAR>-th element of the new vector <VAR>v'</VAR> is given by,

</P>

<PRE class="example">
v'(i) = base[i]
</PRE>

<P>
where the index <VAR>i</VAR> runs from 0 to <CODE>n-1</CODE>.

</P>
<P>
The array containing the elements of <VAR>v</VAR> is not owned by the new
vector view.  When the view goes out of scope the original array will
continue to exist.  The original memory can only be deallocated by
freeing the original pointer <VAR>base</VAR>.  Of course, the original array
should not be deallocated while the view is still in use.

</P>
<P>
The function <CODE>gsl_vector_const_view_array</CODE> is equivalent to
<CODE>gsl_vector_view_array</CODE> but can be used for arrays which are
declared <CODE>const</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_vector_view <B>gsl_vector_view_array_with_stride</B> <I>(double * <VAR>base</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX852"></A>
<DT><U>Function:</U> gsl_vector_const_view <B>gsl_vector_const_view_array_with_stride</B> <I>(const double * <VAR>base</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX853"></A>
These functions return a vector view of an array <VAR>base</VAR> with an
additional stride argument. The subvector is formed in the same way as
for <CODE>gsl_vector_view_array</CODE> but the new vector has <VAR>n</VAR> elements
with a step-size of <VAR>stride</VAR> from one element to the next in the
original array.  Mathematically, the <VAR>i</VAR>-th element of the new
vector <VAR>v'</VAR> is given by,

</P>

<PRE class="example">
v'(i) = base[i*stride]
</PRE>

<P>
where the index <VAR>i</VAR> runs from 0 to <CODE>n-1</CODE>.

</P>
<P>
Note that the view gives direct access to the underlying elements of the
original array.  A vector view can be passed to any subroutine which
takes a vector argument just as a directly allocated vector would be,
using <CODE>&#38;</CODE><VAR>view</VAR><CODE>.vector</CODE>.

</P>
<P>
The function <CODE>gsl_vector_const_view_array_with_stride</CODE> is
equivalent to <CODE>gsl_vector_view_array_with_stride</CODE> but can be used
for arrays which are declared <CODE>const</CODE>.
</DL>

</P>



<H3><A NAME="SEC167" HREF="gsl_manual.html#TOC167">Copying vectors</A></H3>

<P>
Common operations on vectors such as addition and multiplication are
available in the BLAS part of the library (see section <A HREF="gsl_manual.html#SEC215">BLAS Support</A>).  However, it is useful to have a small number of utility
functions which do not require the full BLAS code.  The following
functions fall into this category.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_vector_memcpy</B> <I>(gsl_vector * <VAR>dest</VAR>, const gsl_vector * <VAR>src</VAR>)</I>
<DD><A NAME="IDX854"></A>
This function copies the elements of the vector <VAR>src</VAR> into the
vector <VAR>dest</VAR>.  The two vectors must have the same length.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_vector_swap</B> <I>(gsl_vector * <VAR>v</VAR>, gsl_vector * <VAR>w</VAR>)</I>
<DD><A NAME="IDX855"></A>
This function exchanges the elements of the vectors <VAR>v</VAR> and <VAR>w</VAR>
by copying.  The two vectors must have the same length.
</DL>

</P>



<H3><A NAME="SEC168" HREF="gsl_manual.html#TOC168">Exchanging elements</A></H3>

<P>
The following function can be used to exchange, or permute, the elements
of a vector.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_vector_swap_elements</B> <I>(gsl_vector * <VAR>v</VAR>, size_t <VAR>i</VAR>, size_t <VAR>j</VAR>)</I>
<DD><A NAME="IDX856"></A>
This function exchanges the <VAR>i</VAR>-th and <VAR>j</VAR>-th elements of the
vector <VAR>v</VAR> in-place.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_vector_reverse</B> <I>(gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX857"></A>
This function reverses the order of the elements of the vector <VAR>v</VAR>.
</DL>

</P>



<H3><A NAME="SEC169" HREF="gsl_manual.html#TOC169">Vector operations</A></H3>

<P>
The following operations are only defined for real vectors.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_vector_add</B> <I>(gsl_vector * <VAR>a</VAR>, const gsl_vector * <VAR>b</VAR>)</I>
<DD><A NAME="IDX858"></A>
This function adds the elements of vector <VAR>b</VAR> to the elements of
vector <VAR>a</VAR>, a'_i = a_i + b_i. The two vectors must have the
same length.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_vector_sub</B> <I>(gsl_vector * <VAR>a</VAR>, const gsl_vector * <VAR>b</VAR>)</I>
<DD><A NAME="IDX859"></A>
This function subtracts the elements of vector <VAR>b</VAR> from the elements of
vector <VAR>a</VAR>, a'_i = a_i - b_i. The two vectors must have the
same length.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_vector_mul</B> <I>(gsl_vector * <VAR>a</VAR>, const gsl_vector * <VAR>b</VAR>)</I>
<DD><A NAME="IDX860"></A>
This function multiplies the elements of vector <VAR>a</VAR> by the elements of
vector <VAR>b</VAR>, a'_i = a_i * b_i. The two vectors must have the
same length.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_vector_div</B> <I>(gsl_vector * <VAR>a</VAR>, const gsl_vector * <VAR>b</VAR>)</I>
<DD><A NAME="IDX861"></A>
This function divides the elements of vector <VAR>a</VAR> by the elements of
vector <VAR>b</VAR>, a'_i = a_i / b_i. The two vectors must have the
same length.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_vector_scale</B> <I>(gsl_vector * <VAR>a</VAR>, const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX862"></A>
This function multiplies the elements of vector <VAR>a</VAR> by the constant
factor <VAR>x</VAR>, a'_i = x a_i.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_vector_add_constant</B> <I>(gsl_vector * <VAR>a</VAR>, const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX863"></A>
This function adds the constant value <VAR>x</VAR> to the elements of the
vector <VAR>a</VAR>, a'_i = a_i + x.
</DL>

</P>


<H3><A NAME="SEC170" HREF="gsl_manual.html#TOC170">Finding maximum and minimum elements of vectors</A></H3>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_vector_max</B> <I>(const gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX864"></A>
This function returns the maximum value in the vector <VAR>v</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_vector_min</B> <I>(const gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX865"></A>
This function returns the minimum value in the vector <VAR>v</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_vector_minmax</B> <I>(const gsl_vector * <VAR>v</VAR>, double * <VAR>min_out</VAR>, double * <VAR>max_out</VAR>)</I>
<DD><A NAME="IDX866"></A>
This function returns the minimum and maximum values in the vector
<VAR>v</VAR>, storing them in <VAR>min_out</VAR> and <VAR>max_out</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_vector_max_index</B> <I>(const gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX867"></A>
This function returns the index of the maximum value in the vector <VAR>v</VAR>.
When there are several equal maximum elements then the lowest index is
returned.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_vector_min_index</B> <I>(const gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX868"></A>
This function returns the index of the minimum value in the vector <VAR>v</VAR>.
When there are several equal minimum elements then the lowest index is
returned.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_vector_minmax_index</B> <I>(const gsl_vector * <VAR>v</VAR>, size_t * <VAR>imin</VAR>, size_t * <VAR>imax</VAR>)</I>
<DD><A NAME="IDX869"></A>
This function returns the indices of the minimum and maximum values in
the vector <VAR>v</VAR>, storing them in <VAR>imin</VAR> and <VAR>imax</VAR>. When
there are several equal minimum or maximum elements then the lowest
indices are returned.
</DL>

</P>


<H3><A NAME="SEC171" HREF="gsl_manual.html#TOC171">Vector properties</A></H3>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_vector_isnull</B> <I>(const gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX870"></A>
This function returns 1 if all the elements of the vector <VAR>v</VAR> are
zero, and 0 otherwise.
</DL>

</P>


<H3><A NAME="SEC172" HREF="gsl_manual.html#TOC172">Example programs for vectors</A></H3>

<P>
This program shows how to allocate, initialize and read from a vector
using the functions <CODE>gsl_vector_alloc</CODE>, <CODE>gsl_vector_set</CODE> and
<CODE>gsl_vector_get</CODE>.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_vector.h&#62;

int
main (void)
{
  int i;
  gsl_vector * v = gsl_vector_alloc (3);
  
  for (i = 0; i &#60; 3; i++)
    {
      gsl_vector_set (v, i, 1.23 + i);
    }
  
  for (i = 0; i &#60; 100; i++)
    {
      printf ("v_%d = %g\n", i, gsl_vector_get (v, i));
    }

  return 0;
}
</PRE>

<P>
Here is the output from the program.  The final loop attempts to read
outside the range of the vector <CODE>v</CODE>, and the error is trapped by
the range-checking code in <CODE>gsl_vector_get</CODE>.

</P>

<PRE class="example">
$ ./a.out
v_0 = 1.23
v_1 = 2.23
v_2 = 3.23
gsl: vector_source.c:12: ERROR: index out of range
Default GSL error handler invoked.
Aborted (core dumped)
</PRE>

<P>
The next program shows how to write a vector to a file.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_vector.h&#62;

int
main (void)
{
  int i; 
  gsl_vector * v = gsl_vector_alloc (100);
  
  for (i = 0; i &#60; 100; i++)
    {
      gsl_vector_set (v, i, 1.23 + i);
    }

  {  
     FILE * f = fopen ("test.dat", "w");
     gsl_vector_fprintf (f, v, "%.5g");
     fclose (f);
  }
  return 0;
}
</PRE>

<P>
After running this program the file <TT>'test.dat'</TT> should contain the
elements of <CODE>v</CODE>, written using the format specifier
<CODE>%.5g</CODE>.  The vector could then be read back in using the function
<CODE>gsl_vector_fscanf (f, v)</CODE> as follows:

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_vector.h&#62;

int
main (void)
{
  int i; 
  gsl_vector * v = gsl_vector_alloc (10);

  {  
     FILE * f = fopen ("test.dat", "r");
     gsl_vector_fscanf (f, v);
     fclose (f);
  }

  for (i = 0; i &#60; 10; i++)
    {
      printf ("%g\n", gsl_vector_get(v, i));
    }

  return 0;
}
</PRE>



<H2><A NAME="SEC173" HREF="gsl_manual.html#TOC173">Matrices</A></H2>
<P>
<A NAME="IDX871"></A>
<A NAME="IDX872"></A>
<A NAME="IDX873"></A>
<A NAME="IDX874"></A>

</P>
<P>
Matrices are defined by a <CODE>gsl_matrix</CODE> structure which describes a
generalized slice of a block.  Like a vector it represents a set of
elements in an area of memory, but uses two indices instead of one.

</P>
<P>
The <CODE>gsl_matrix</CODE> structure contains six components, the two
dimensions of the matrix, a physical dimension, a pointer to the memory
where the elements of the matrix are stored, <VAR>data</VAR>, a pointer to
the block owned by the matrix <VAR>block</VAR>, if any, and an ownership
flag, <VAR>owner</VAR>.  The physical dimension determines the memory layout
and can differ from the matrix dimension to allow the use of
submatrices.  The <CODE>gsl_matrix</CODE> structure is very simple and looks
like this,

</P>

<PRE class="example">
typedef struct
{
  size_t size1;
  size_t size2;
  size_t tda;
  double * data;
  gsl_block * block;
  int owner;
} gsl_matrix;
</PRE>

<P>
Matrices are stored in row-major order, meaning that each row of
elements forms a contiguous block in memory.  This is the standard
"C-language ordering" of two-dimensional arrays. Note that FORTRAN
stores arrays in column-major order. The number of rows is <VAR>size1</VAR>.
The range of valid row indices runs from 0 to <CODE>size1-1</CODE>.  Similarly
<VAR>size2</VAR> is the number of columns.  The range of valid column indices
runs from 0 to <CODE>size2-1</CODE>.  The physical row dimension <VAR>tda</VAR>, or
<I>trailing dimension</I>, specifies the size of a row of the matrix as
laid out in memory.

</P>
<P>
For example, in the following matrix <VAR>size1</VAR> is 3, <VAR>size2</VAR> is 4,
and <VAR>tda</VAR> is 8.  The physical memory layout of the matrix begins in
the top left hand-corner and proceeds from left to right along each row
in turn.

</P>

<PRE class="example">
00 01 02 03 XX XX XX XX
10 11 12 13 XX XX XX XX
20 21 22 23 XX XX XX XX
</PRE>

<P>
Each unused memory location is represented by "<CODE>XX</CODE>".  The
pointer <VAR>data</VAR> gives the location of the first element of the matrix
in memory.  The pointer <VAR>block</VAR> stores the location of the memory
block in which the elements of the matrix are located (if any).  If the
matrix owns this block then the <VAR>owner</VAR> field is set to one and the
block will be deallocated when the matrix is freed.  If the matrix is
only a slice of a block owned by another object then the <VAR>owner</VAR> field is
zero and any underlying block will not be freed.

</P>
<P>
The functions for allocating and accessing matrices are defined in
<TT>'gsl_matrix.h'</TT>

</P>



<H3><A NAME="SEC174" HREF="gsl_manual.html#TOC174">Matrix allocation</A></H3>

<P>
The functions for allocating memory to a matrix follow the style of
<CODE>malloc</CODE> and <CODE>free</CODE>.  They also perform their own error
checking.  If there is insufficient memory available to allocate a vector
then the functions call the GSL error handler (with an error number of
<CODE>GSL_ENOMEM</CODE>) in addition to returning a null pointer.  Thus if you
use the library error handler to abort your program then it isn't
necessary to check every <CODE>alloc</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_matrix * <B>gsl_matrix_alloc</B> <I>(size_t <VAR>n1</VAR>, size_t <VAR>n2</VAR>)</I>
<DD><A NAME="IDX875"></A>
This function creates a matrix of size <VAR>n1</VAR> rows by <VAR>n2</VAR>
columns, returning a pointer to a newly initialized matrix struct. A new
block is allocated for the elements of the matrix, and stored in the
<VAR>block</VAR> component of the matrix struct.  The block is "owned" by the
matrix, and will be deallocated when the matrix is deallocated.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_matrix * <B>gsl_matrix_calloc</B> <I>(size_t <VAR>n1</VAR>, size_t <VAR>n2</VAR>)</I>
<DD><A NAME="IDX876"></A>
This function allocates memory for a matrix of size <VAR>n1</VAR> rows by
<VAR>n2</VAR> columns and initializes all the elements of the matrix to zero.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_matrix_free</B> <I>(gsl_matrix * <VAR>m</VAR>)</I>
<DD><A NAME="IDX877"></A>
This function frees a previously allocated matrix <VAR>m</VAR>.  If the
matrix was created using <CODE>gsl_matrix_alloc</CODE> then the block
underlying the matrix will also be deallocated.  If the matrix has been
created from another object then the memory is still owned by that
object and will not be deallocated.
</DL>

</P>


<H3><A NAME="SEC175" HREF="gsl_manual.html#TOC175">Accessing matrix elements</A></H3>
<P>
<A NAME="IDX878"></A>
<A NAME="IDX879"></A>

</P>
<P>
The functions for accessing the elements of a matrix use the same range
checking system as vectors.  You can turn off range checking by recompiling
your program with the preprocessor definition
<CODE>GSL_RANGE_CHECK_OFF</CODE>.

</P>
<P>
The elements of the matrix are stored in "C-order", where the second
index moves continuously through memory.  More precisely, the element
accessed by the function <CODE>gsl_matrix_get(m,i,j)</CODE> and
<CODE>gsl_matrix_set(m,i,j,x)</CODE> is 

</P>

<PRE class="example">
m-&#62;data[i * m-&#62;tda + j]
</PRE>

<P>
where <VAR>tda</VAR> is the physical row-length of the matrix.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_matrix_get</B> <I>(const gsl_matrix * <VAR>m</VAR>, size_t <VAR>i</VAR>, size_t <VAR>j</VAR>)</I>
<DD><A NAME="IDX880"></A>
This function returns the (i,j)-th element of a matrix
<VAR>m</VAR>.  If <VAR>i</VAR> or <VAR>j</VAR> lie outside the allowed range of 0 to
<VAR>n1</VAR>-1 and 0 to <VAR>n2</VAR>-1 then the error handler is invoked and 0
is returned.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_matrix_set</B> <I>(gsl_matrix * <VAR>m</VAR>, size_t <VAR>i</VAR>, size_t <VAR>j</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX881"></A>
This function sets the value of the (i,j)-th element of a
matrix <VAR>m</VAR> to <VAR>x</VAR>.  If <VAR>i</VAR> or <VAR>j</VAR> lies outside the
allowed range of 0 to <VAR>n1</VAR>-1 and 0 to <VAR>n2</VAR>-1 then the error
handler is invoked.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double * <B>gsl_matrix_ptr</B> <I>(gsl_matrix * <VAR>m</VAR>, size_t <VAR>i</VAR>, size_t <VAR>j</VAR>)</I>
<DD><A NAME="IDX882"></A>
<DT><U>Function:</U> const double * <B>gsl_matrix_const_ptr</B> <I>(const gsl_matrix * <VAR>m</VAR>, size_t <VAR>i</VAR>, size_t <VAR>j</VAR>)</I>
<DD><A NAME="IDX883"></A>
These functions return a pointer to the (i,j)-th element of a
matrix <VAR>m</VAR>.  If <VAR>i</VAR> or <VAR>j</VAR> lie outside the allowed range of
0 to <VAR>n1</VAR>-1 and 0 to <VAR>n2</VAR>-1 then the error handler is invoked
and a null pointer is returned.
</DL>

</P>


<H3><A NAME="SEC176" HREF="gsl_manual.html#TOC176">Initializing matrix elements</A></H3>
<P>
<A NAME="IDX884"></A>
<A NAME="IDX885"></A>
<A NAME="IDX886"></A>
<A NAME="IDX887"></A>
<A NAME="IDX888"></A>
<A NAME="IDX889"></A>
<A NAME="IDX890"></A>
<A NAME="IDX891"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_matrix_set_all</B> <I>(gsl_matrix * <VAR>m</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX892"></A>
This function sets all the elements of the matrix <VAR>m</VAR> to the value
<VAR>x</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_matrix_set_zero</B> <I>(gsl_matrix * <VAR>m</VAR>)</I>
<DD><A NAME="IDX893"></A>
This function sets all the elements of the matrix <VAR>m</VAR> to zero.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_matrix_set_identity</B> <I>(gsl_matrix * <VAR>m</VAR>)</I>
<DD><A NAME="IDX894"></A>
This function sets the elements of the matrix <VAR>m</VAR> to the
corresponding elements of the identity matrix, m(i,j) =
\delta(i,j), i.e. a unit diagonal with all off-diagonal elements zero.
This applies to both square and rectangular matrices.
</DL>

</P>


<H3><A NAME="SEC177" HREF="gsl_manual.html#TOC177">Reading and writing matrices</A></H3>

<P>
The library provides functions for reading and writing matrices to a file
as binary data or formatted text.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_fwrite</B> <I>(FILE * <VAR>stream</VAR>, const gsl_matrix * <VAR>m</VAR>)</I>
<DD><A NAME="IDX895"></A>
This function writes the elements of the matrix <VAR>m</VAR> to the stream
<VAR>stream</VAR> in binary format.  The return value is 0 for success and
<CODE>GSL_EFAILED</CODE> if there was a problem writing to the file.  Since the
data is written in the native binary format it may not be portable
between different architectures.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_fread</B> <I>(FILE * <VAR>stream</VAR>, gsl_matrix * <VAR>m</VAR>)</I>
<DD><A NAME="IDX896"></A>
This function reads into the matrix <VAR>m</VAR> from the open stream
<VAR>stream</VAR> in binary format.  The matrix <VAR>m</VAR> must be preallocated
with the correct dimensions since the function uses the size of <VAR>m</VAR> to
determine how many bytes to read.  The return value is 0 for success and
<CODE>GSL_EFAILED</CODE> if there was a problem reading from the file.  The
data is assumed to have been written in the native binary format on the
same architecture.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_fprintf</B> <I>(FILE * <VAR>stream</VAR>, const gsl_matrix * <VAR>m</VAR>, const char * <VAR>format</VAR>)</I>
<DD><A NAME="IDX897"></A>
This function writes the elements of the matrix <VAR>m</VAR> line-by-line to
the stream <VAR>stream</VAR> using the format specifier <VAR>format</VAR>, which
should be one of the <CODE>%g</CODE>, <CODE>%e</CODE> or <CODE>%f</CODE> formats for
floating point numbers and <CODE>%d</CODE> for integers.  The function returns
0 for success and <CODE>GSL_EFAILED</CODE> if there was a problem writing to
the file.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_fscanf</B> <I>(FILE * <VAR>stream</VAR>, gsl_matrix * <VAR>m</VAR>)</I>
<DD><A NAME="IDX898"></A>
This function reads formatted data from the stream <VAR>stream</VAR> into the
matrix <VAR>m</VAR>.  The matrix <VAR>m</VAR> must be preallocated with the correct
dimensions since the function uses the size of <VAR>m</VAR> to determine how many
numbers to read.  The function returns 0 for success and
<CODE>GSL_EFAILED</CODE> if there was a problem reading from the file.
</DL>

</P>


<H3><A NAME="SEC178" HREF="gsl_manual.html#TOC178">Matrix views</A></H3>

<P>
A matrix view is a temporary object, stored on the stack, which can be
used to operate on a subset of matrix elements.  Matrix views can be
defined for both constant and non-constant matrices using separate types
that preserve constness.  A matrix view has the type
<CODE>gsl_matrix_view</CODE> and a constant matrix view has the type
<CODE>gsl_matrix_const_view</CODE>.  In both cases the elements of the view
can by accessed using the <CODE>matrix</CODE> component of the view object.  A
pointer <CODE>gsl_matrix *</CODE> or <CODE>const gsl_matrix *</CODE> can be obtained
by taking the address of the <CODE>matrix</CODE> component with the <CODE>&#38;</CODE>
operator.  In addition to matrix views it is also possible to create
vector views of a matrix, such as row or column views.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_matrix_view <B>gsl_matrix_submatrix</B> <I>(gsl_matrix * <VAR>m</VAR>, size_t <VAR>k1</VAR>, size_t <VAR>k2</VAR>, size_t <VAR>n1</VAR>, size_t <VAR>n2</VAR>)</I>
<DD><A NAME="IDX899"></A>
<DT><U>Function:</U> gsl_matrix_const_view <B>gsl_matrix_const_submatrix</B> <I>(const gsl_matrix * <VAR>m</VAR>, size_t <VAR>k1</VAR>, size_t <VAR>k2</VAR>, size_t <VAR>n1</VAR>, size_t <VAR>n2</VAR>)</I>
<DD><A NAME="IDX900"></A>
These functions return a matrix view of a submatrix of the matrix
<VAR>m</VAR>.  The upper-left element of the submatrix is the element
(<VAR>k1</VAR>,<VAR>k2</VAR>) of the original matrix.  The submatrix has <VAR>n1</VAR>
rows and <VAR>n2</VAR> columns.  The physical number of columns in memory
given by <VAR>tda</VAR> is unchanged.  Mathematically, the
(i,j)-th element of the new matrix is given by,

</P>

<PRE class="example">
m'(i,j) = m-&#62;data[(k1*m-&#62;tda + k2) + i*m-&#62;tda + j]
</PRE>

<P>
where the index <VAR>i</VAR> runs from 0 to <CODE>n1-1</CODE> and the index <VAR>j</VAR>
runs from 0 to <CODE>n2-1</CODE>.

</P>
<P>
The <CODE>data</CODE> pointer of the returned matrix struct is set to null if
the combined parameters (<VAR>i</VAR>,<VAR>j</VAR>,<VAR>n1</VAR>,<VAR>n2</VAR>,<VAR>tda</VAR>)
overrun the ends of the original matrix.

</P>
<P>
The new matrix view is only a view of the block underlying the existing
matrix, <VAR>m</VAR>.  The block containing the elements of <VAR>m</VAR> is not
owned by the new matrix view.  When the view goes out of scope the
original matrix <VAR>m</VAR> and its block will continue to exist.  The
original memory can only be deallocated by freeing the original matrix.
Of course, the original matrix should not be deallocated while the view
is still in use.

</P>
<P>
The function <CODE>gsl_matrix_const_submatrix</CODE> is equivalent to
<CODE>gsl_matrix_submatrix</CODE> but can be used for matrices which are
declared <CODE>const</CODE>.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> gsl_matrix_view <B>gsl_matrix_view_array</B> <I>(double * <VAR>base</VAR>, size_t <VAR>n1</VAR>, size_t <VAR>n2</VAR>)</I>
<DD><A NAME="IDX901"></A>
<DT><U>Function:</U> gsl_matrix_const_view <B>gsl_matrix_const_view_array</B> <I>(const double * <VAR>base</VAR>, size_t <VAR>n1</VAR>, size_t <VAR>n2</VAR>)</I>
<DD><A NAME="IDX902"></A>
These functions return a matrix view of the array <VAR>base</VAR>.  The
matrix has <VAR>n1</VAR> rows and <VAR>n2</VAR> columns.  The physical number of
columns in memory is also given by <VAR>n2</VAR>.  Mathematically, the
(i,j)-th element of the new matrix is given by,

</P>

<PRE class="example">
m'(i,j) = base[i*n2 + j]
</PRE>

<P>
where the index <VAR>i</VAR> runs from 0 to <CODE>n1-1</CODE> and the index <VAR>j</VAR>
runs from 0 to <CODE>n2-1</CODE>.

</P>
<P>
The new matrix is only a view of the array <VAR>base</VAR>.  When the view
goes out of scope the original array <VAR>base</VAR> will continue to exist.
The original memory can only be deallocated by freeing the original
array.  Of course, the original array should not be deallocated while
the view is still in use.

</P>
<P>
The function <CODE>gsl_matrix_const_view_array</CODE> is equivalent to
<CODE>gsl_matrix_view_array</CODE> but can be used for matrices which are
declared <CODE>const</CODE>.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> gsl_matrix_view <B>gsl_matrix_view_array_with_tda</B> <I>(double * <VAR>base</VAR>, size_t <VAR>n1</VAR>, size_t <VAR>n2</VAR>, size_t <VAR>tda</VAR>)</I>
<DD><A NAME="IDX903"></A>
<DT><U>Function:</U> gsl_matrix_const_view <B>gsl_matrix_const_view_array_with_tda</B> <I>(const double * <VAR>base</VAR>, size_t <VAR>n1</VAR>, size_t <VAR>n2</VAR>, size_t <VAR>tda</VAR>)</I>
<DD><A NAME="IDX904"></A>
These functions return a matrix view of the array <VAR>base</VAR> with a
physical number of columns <VAR>tda</VAR> which may differ from the corresponding
dimension of the matrix.  The matrix has <VAR>n1</VAR> rows and <VAR>n2</VAR>
columns, and the physical number of columns in memory is given by
<VAR>tda</VAR>.  Mathematically, the (i,j)-th element of the new
matrix is given by,

</P>

<PRE class="example">
m'(i,j) = base[i*tda + j]
</PRE>

<P>
where the index <VAR>i</VAR> runs from 0 to <CODE>n1-1</CODE> and the index <VAR>j</VAR>
runs from 0 to <CODE>n2-1</CODE>.

</P>
<P>
The new matrix is only a view of the array <VAR>base</VAR>.  When the view
goes out of scope the original array <VAR>base</VAR> will continue to exist.
The original memory can only be deallocated by freeing the original
array.  Of course, the original array should not be deallocated while
the view is still in use.

</P>
<P>
The function <CODE>gsl_matrix_const_view_array_with_tda</CODE> is equivalent
to <CODE>gsl_matrix_view_array_with_tda</CODE> but can be used for matrices
which are declared <CODE>const</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_matrix_view <B>gsl_matrix_view_vector</B> <I>(gsl_vector * <VAR>v</VAR>, size_t <VAR>n1</VAR>, size_t <VAR>n2</VAR>)</I>
<DD><A NAME="IDX905"></A>
<DT><U>Function:</U> gsl_matrix_const_view <B>gsl_matrix_const_view_vector</B> <I>(const gsl_vector * <VAR>v</VAR>, size_t <VAR>n1</VAR>, size_t <VAR>n2</VAR>)</I>
<DD><A NAME="IDX906"></A>
These functions return a matrix view of the vector <VAR>v</VAR>.  The matrix
has <VAR>n1</VAR> rows and <VAR>n2</VAR> columns. The vector must have unit
stride. The physical number of columns in memory is also given by
<VAR>n2</VAR>.  Mathematically, the (i,j)-th element of the new
matrix is given by,

</P>

<PRE class="example">
m'(i,j) = v-&#62;data[i*n2 + j]
</PRE>

<P>
where the index <VAR>i</VAR> runs from 0 to <CODE>n1-1</CODE> and the index <VAR>j</VAR>
runs from 0 to <CODE>n2-1</CODE>.

</P>
<P>
The new matrix is only a view of the vector <VAR>v</VAR>.  When the view
goes out of scope the original vector <VAR>v</VAR> will continue to exist.
The original memory can only be deallocated by freeing the original
vector.  Of course, the original vector should not be deallocated while
the view is still in use.

</P>
<P>
The function <CODE>gsl_matrix_const_view_vector</CODE> is equivalent to
<CODE>gsl_matrix_view_vector</CODE> but can be used for matrices which are
declared <CODE>const</CODE>.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> gsl_matrix_view <B>gsl_matrix_view_vector_with_tda</B> <I>(gsl_vector * <VAR>v</VAR>, size_t <VAR>n1</VAR>, size_t <VAR>n2</VAR>, size_t <VAR>tda</VAR>)</I>
<DD><A NAME="IDX907"></A>
<DT><U>Function:</U> gsl_matrix_const_view <B>gsl_matrix_const_view_vector_with_tda</B> <I>(const gsl_vector * <VAR>v</VAR>, size_t <VAR>n1</VAR>, size_t <VAR>n2</VAR>, size_t <VAR>tda</VAR>)</I>
<DD><A NAME="IDX908"></A>
These functions return a matrix view of the vector <VAR>v</VAR> with a
physical number of columns <VAR>tda</VAR> which may differ from the
corresponding matrix dimension.  The vector must have unit stride. The
matrix has <VAR>n1</VAR> rows and <VAR>n2</VAR> columns, and the physical number
of columns in memory is given by <VAR>tda</VAR>.  Mathematically, the
(i,j)-th element of the new matrix is given by,

</P>

<PRE class="example">
m'(i,j) = v-&#62;data[i*tda + j]
</PRE>

<P>
where the index <VAR>i</VAR> runs from 0 to <CODE>n1-1</CODE> and the index <VAR>j</VAR>
runs from 0 to <CODE>n2-1</CODE>.

</P>
<P>
The new matrix is only a view of the vector <VAR>v</VAR>.  When the view
goes out of scope the original vector <VAR>v</VAR> will continue to exist.
The original memory can only be deallocated by freeing the original
vector.  Of course, the original vector should not be deallocated while
the view is still in use.

</P>
<P>
The function <CODE>gsl_matrix_const_view_vector_with_tda</CODE> is equivalent
to <CODE>gsl_matrix_view_vector_with_tda</CODE> but can be used for matrices
which are declared <CODE>const</CODE>.
</DL>

</P>



<H3><A NAME="SEC179" HREF="gsl_manual.html#TOC179">Creating row and column views</A></H3>

<P>
In general there are two ways to access an object, by reference or by
copying.  The functions described in this section create vector views
which allow access to a row or column of a matrix by reference.
Modifying elements of the view is equivalent to modifying the matrix,
since both the vector view and the matrix point to the same memory
block.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_vector_view <B>gsl_matrix_row</B> <I>(gsl_matrix * <VAR>m</VAR>, size_t <VAR>i</VAR>)</I>
<DD><A NAME="IDX909"></A>
<DT><U>Function:</U> gsl_vector_const_view <B>gsl_matrix_const_row</B> <I>(const gsl_matrix * <VAR>m</VAR>, size_t <VAR>i</VAR>)</I>
<DD><A NAME="IDX910"></A>
These functions return a vector view of the <VAR>i</VAR>-th row of the matrix
<VAR>m</VAR>.  The <CODE>data</CODE> pointer of the new vector is set to null if
<VAR>i</VAR> is out of range.

</P>
<P>
The function <CODE>gsl_vector_const_row</CODE> is equivalent to
<CODE>gsl_matrix_row</CODE> but can be used for matrices which are declared
<CODE>const</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_vector_view <B>gsl_matrix_column</B> <I>(gsl_matrix * <VAR>m</VAR>, size_t <VAR>j</VAR>)</I>
<DD><A NAME="IDX911"></A>
<DT><U>Function:</U> gsl_vector_const_view <B>gsl_matrix_const_column</B> <I>(const gsl_matrix * <VAR>m</VAR>, size_t <VAR>j</VAR>)</I>
<DD><A NAME="IDX912"></A>
These functions return a vector view of the <VAR>j</VAR>-th column of the
matrix <VAR>m</VAR>.  The <CODE>data</CODE> pointer of the new vector is set to
null if <VAR>j</VAR> is out of range.

</P>
<P>
The function <CODE>gsl_vector_const_column</CODE> is equivalent to
<CODE>gsl_matrix_column</CODE> but can be used for matrices which are declared
<CODE>const</CODE>.
</DL>

</P>
<P>
<A NAME="IDX913"></A>
<A NAME="IDX914"></A>
<DL>
<DT><U>Function:</U> gsl_vector_view <B>gsl_matrix_diagonal</B> <I>(gsl_matrix * <VAR>m</VAR>)</I>
<DD><A NAME="IDX915"></A>
<DT><U>Function:</U> gsl_vector_const_view <B>gsl_matrix_const_diagonal</B> <I>(const gsl_matrix * <VAR>m</VAR>)</I>
<DD><A NAME="IDX916"></A>
These functions returns a vector view of the diagonal of the matrix
<VAR>m</VAR>. The matrix <VAR>m</VAR> is not required to be square. For a
rectangular matrix the length of the diagonal is the same as the smaller
dimension of the matrix.

</P>
<P>
The function <CODE>gsl_matrix_const_diagonal</CODE> is equivalent to
<CODE>gsl_matrix_diagonal</CODE> but can be used for matrices which are
declared <CODE>const</CODE>.
</DL>

</P>
<P>
<A NAME="IDX917"></A>
<A NAME="IDX918"></A>
<DL>
<DT><U>Function:</U> gsl_vector_view <B>gsl_matrix_subdiagonal</B> <I>(gsl_matrix * <VAR>m</VAR>, size_t <VAR>k</VAR>)</I>
<DD><A NAME="IDX919"></A>
<DT><U>Function:</U> gsl_vector_const_view <B>gsl_matrix_const_subdiagonal</B> <I>(const gsl_matrix * <VAR>m</VAR>, size_t <VAR>k</VAR>)</I>
<DD><A NAME="IDX920"></A>
These functions return a vector view of the <VAR>k</VAR>-th subdiagonal of
the matrix <VAR>m</VAR>. The matrix <VAR>m</VAR> is not required to be square.
The diagonal of the matrix corresponds to k = 0.

</P>
<P>
The function <CODE>gsl_matrix_const_subdiagonal</CODE> is equivalent to
<CODE>gsl_matrix_subdiagonal</CODE> but can be used for matrices which are
declared <CODE>const</CODE>.
</DL>

</P>
<P>
<A NAME="IDX921"></A>
<A NAME="IDX922"></A>
<DL>
<DT><U>Function:</U> gsl_vector_view <B>gsl_matrix_superdiagonal</B> <I>(gsl_matrix * <VAR>m</VAR>, size_t <VAR>k</VAR>)</I>
<DD><A NAME="IDX923"></A>
<DT><U>Function:</U> gsl_vector_const_view <B>gsl_matrix_const_superdiagonal</B> <I>(const gsl_matrix * <VAR>m</VAR>, size_t <VAR>k</VAR>)</I>
<DD><A NAME="IDX924"></A>
These functions return a vector view of the <VAR>k</VAR>-th superdiagonal of
the matrix <VAR>m</VAR>. The matrix <VAR>m</VAR> is not required to be square. The
diagonal of the matrix corresponds to k = 0.

</P>
<P>
The function <CODE>gsl_matrix_const_superdiagonal</CODE> is equivalent to
<CODE>gsl_matrix_superdiagonal</CODE> but can be used for matrices which are
declared <CODE>const</CODE>.
</DL>

</P>



<H3><A NAME="SEC180" HREF="gsl_manual.html#TOC180">Copying matrices</A></H3>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_memcpy</B> <I>(gsl_matrix * <VAR>dest</VAR>, const gsl_matrix * <VAR>src</VAR>)</I>
<DD><A NAME="IDX925"></A>
This function copies the elements of the matrix <VAR>src</VAR> into the
matrix <VAR>dest</VAR>.  The two matrices must have the same size.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_swap</B> <I>(gsl_matrix * <VAR>m1</VAR>, gsl_matrix * <VAR>m2</VAR>)</I>
<DD><A NAME="IDX926"></A>
This function exchanges the elements of the matrices <VAR>m1</VAR> and
<VAR>m2</VAR> by copying.  The two matrices must have the same size.
</DL>

</P>


<H3><A NAME="SEC181" HREF="gsl_manual.html#TOC181">Copying rows and columns</A></H3>

<P>
The functions described in this section copy a row or column of a matrix
into a vector.  This allows the elements of the vector and the matrix to
be modified independently.  Note that if the matrix and the vector point
to overlapping regions of memory then the result will be undefined.  The
same effect can be achieved with more generality using
<CODE>gsl_vector_memcpy</CODE> with vector views of rows and columns.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_get_row</B> <I>(gsl_vector * <VAR>v</VAR>, const gsl_matrix * <VAR>m</VAR>, size_t <VAR>i</VAR>)</I>
<DD><A NAME="IDX927"></A>
This function copies the elements of the <VAR>i</VAR>-th row of the matrix
<VAR>m</VAR> into the vector <VAR>v</VAR>.  The length of the vector must be the
same as the length of the row.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_get_col</B> <I>(gsl_vector * <VAR>v</VAR>, const gsl_matrix * <VAR>m</VAR>, size_t <VAR>j</VAR>)</I>
<DD><A NAME="IDX928"></A>
This function copies the elements of the <VAR>j</VAR>-th column of the matrix
<VAR>m</VAR> into the vector <VAR>v</VAR>.  The length of the vector must be the
same as the length of the column.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_set_row</B> <I>(gsl_matrix * <VAR>m</VAR>, size_t <VAR>i</VAR>, const gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX929"></A>
This function copies the elements of the vector <VAR>v</VAR> into the
<VAR>i</VAR>-th row of the matrix <VAR>m</VAR>.  The length of the vector must be
the same as the length of the row.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_set_col</B> <I>(gsl_matrix * <VAR>m</VAR>, size_t <VAR>j</VAR>, const gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX930"></A>
This function copies the elements of the vector <VAR>v</VAR> into the
<VAR>j</VAR>-th column of the matrix <VAR>m</VAR>.  The length of the vector must be
the same as the length of the column.
</DL>

</P>


<H3><A NAME="SEC182" HREF="gsl_manual.html#TOC182">Exchanging rows and columns</A></H3>

<P>
The following functions can be used to exchange the rows and columns of
a matrix.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_swap_rows</B> <I>(gsl_matrix * <VAR>m</VAR>, size_t <VAR>i</VAR>, size_t <VAR>j</VAR>)</I>
<DD><A NAME="IDX931"></A>
This function exchanges the <VAR>i</VAR>-th and <VAR>j</VAR>-th rows of the matrix
<VAR>m</VAR> in-place.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_swap_columns</B> <I>(gsl_matrix * <VAR>m</VAR>, size_t <VAR>i</VAR>, size_t <VAR>j</VAR>)</I>
<DD><A NAME="IDX932"></A>
This function exchanges the <VAR>i</VAR>-th and <VAR>j</VAR>-th columns of the
matrix <VAR>m</VAR> in-place.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_swap_rowcol</B> <I>(gsl_matrix * <VAR>m</VAR>, size_t <VAR>i</VAR>, size_t <VAR>j</VAR>)</I>
<DD><A NAME="IDX933"></A>
This function exchanges the <VAR>i</VAR>-th row and <VAR>j</VAR>-th column of the
matrix <VAR>m</VAR> in-place.  The matrix must be square for this operation to
be possible.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_transpose_memcpy</B> <I>(gsl_matrix * <VAR>dest</VAR>, const gsl_matrix * <VAR>src</VAR>)</I>
<DD><A NAME="IDX934"></A>
This function makes the matrix <VAR>dest</VAR> the transpose of the matrix
<VAR>src</VAR> by copying the elements of <VAR>src</VAR> into <VAR>dest</VAR>.  This
function works for all matrices provided that the dimensions of the matrix
<VAR>dest</VAR> match the transposed dimensions of the matrix <VAR>src</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_transpose</B> <I>(gsl_matrix * <VAR>m</VAR>)</I>
<DD><A NAME="IDX935"></A>
This function replaces the matrix <VAR>m</VAR> by its transpose by copying
the elements of the matrix in-place.  The matrix must be square for this
operation to be possible.
</DL>

</P>


<H3><A NAME="SEC183" HREF="gsl_manual.html#TOC183">Matrix operations</A></H3>

<P>
The following operations are defined for real and complex matrices.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_add</B> <I>(gsl_matrix * <VAR>a</VAR>, const gsl_matrix * <VAR>b</VAR>)</I>
<DD><A NAME="IDX936"></A>
This function adds the elements of matrix <VAR>b</VAR> to the elements of
matrix <VAR>a</VAR>, a'(i,j) = a(i,j) + b(i,j). The two matrices must have the
same dimensions.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_sub</B> <I>(gsl_matrix * <VAR>a</VAR>, const gsl_matrix * <VAR>b</VAR>)</I>
<DD><A NAME="IDX937"></A>
This function subtracts the elements of matrix <VAR>b</VAR> from the elements of
matrix <VAR>a</VAR>, a'(i,j) = a(i,j) - b(i,j). The two matrices must have the
same dimensions.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_mul_elements</B> <I>(gsl_matrix * <VAR>a</VAR>, const gsl_matrix * <VAR>b</VAR>)</I>
<DD><A NAME="IDX938"></A>
This function multiplies the elements of matrix <VAR>a</VAR> by the elements of
matrix <VAR>b</VAR>, a'(i,j) = a(i,j) * b(i,j). The two matrices must have the
same dimensions.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_div_elements</B> <I>(gsl_matrix * <VAR>a</VAR>, const gsl_matrix * <VAR>b</VAR>)</I>
<DD><A NAME="IDX939"></A>
This function divides the elements of matrix <VAR>a</VAR> by the elements of
matrix <VAR>b</VAR>, a'(i,j) = a(i,j) / b(i,j). The two matrices must have the
same dimensions.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_scale</B> <I>(gsl_matrix * <VAR>a</VAR>, const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX940"></A>
This function multiplies the elements of matrix <VAR>a</VAR> by the constant
factor <VAR>x</VAR>, a'(i,j) = x a(i,j).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_add_constant</B> <I>(gsl_matrix * <VAR>a</VAR>, const double <VAR>x</VAR>)</I>
<DD><A NAME="IDX941"></A>
This function adds the constant value <VAR>x</VAR> to the elements of the
matrix <VAR>a</VAR>, a'(i,j) = a(i,j) + x.
</DL>

</P>


<H3><A NAME="SEC184" HREF="gsl_manual.html#TOC184">Finding maximum and minimum elements of matrices</A></H3>

<P>
The following operations are only defined for real matrices.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_matrix_max</B> <I>(const gsl_matrix * <VAR>m</VAR>)</I>
<DD><A NAME="IDX942"></A>
This function returns the maximum value in the matrix <VAR>m</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_matrix_min</B> <I>(const gsl_matrix * <VAR>m</VAR>)</I>
<DD><A NAME="IDX943"></A>
This function returns the minimum value in the matrix <VAR>m</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_matrix_minmax</B> <I>(const gsl_matrix * <VAR>m</VAR>, double * <VAR>min_out</VAR>, double * <VAR>max_out</VAR>)</I>
<DD><A NAME="IDX944"></A>
This function returns the minimum and maximum values in the matrix
<VAR>m</VAR>, storing them in <VAR>min_out</VAR> and <VAR>max_out</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_matrix_max_index</B> <I>(const gsl_matrix * <VAR>m</VAR>, size_t * <VAR>imax</VAR>, size_t * <VAR>jmax</VAR>)</I>
<DD><A NAME="IDX945"></A>
This function returns the indices of the maximum value in the matrix
<VAR>m</VAR>, storing them in <VAR>imax</VAR> and <VAR>jmax</VAR>.  When there are
several equal maximum elements then the first element found is returned,
searching in row-major order.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_matrix_min_index</B> <I>(const gsl_matrix * <VAR>m</VAR>, size_t * <VAR>imax</VAR>, size_t * <VAR>jmax</VAR>)</I>
<DD><A NAME="IDX946"></A>
This function returns the indices of the minimum value in the matrix
<VAR>m</VAR>, storing them in <VAR>imax</VAR> and <VAR>jmax</VAR>.  When there are
several equal minimum elements then the first element found is returned,
searching in row-major order.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_matrix_minmax_index</B> <I>(const gsl_matrix * <VAR>m</VAR>, size_t * <VAR>imin</VAR>, size_t * <VAR>imax</VAR>)</I>
<DD><A NAME="IDX947"></A>
This function returns the indices of the minimum and maximum values in
the matrix <VAR>m</VAR>, storing them in (<VAR>imin</VAR>,<VAR>jmin</VAR>) and
(<VAR>imax</VAR>,<VAR>jmax</VAR>). When there are several equal minimum or maximum
elements then the first elements found are returned, searching in
row-major order.
</DL>

</P>


<H3><A NAME="SEC185" HREF="gsl_manual.html#TOC185">Matrix properties</A></H3>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_matrix_isnull</B> <I>(const gsl_matrix * <VAR>m</VAR>)</I>
<DD><A NAME="IDX948"></A>
This function returns 1 if all the elements of the matrix <VAR>m</VAR> are
zero, and 0 otherwise.
</DL>

</P>


<H3><A NAME="SEC186" HREF="gsl_manual.html#TOC186">Example programs for matrices</A></H3>

<P>
The program below shows how to allocate, initialize and read from a matrix
using the functions <CODE>gsl_matrix_alloc</CODE>, <CODE>gsl_matrix_set</CODE> and
<CODE>gsl_matrix_get</CODE>.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_matrix.h&#62;

int
main (void)
{
  int i, j; 
  gsl_matrix * m = gsl_matrix_alloc (10, 3);
  
  for (i = 0; i &#60; 10; i++)
    for (j = 0; j &#60; 3; j++)
      gsl_matrix_set (m, i, j, 0.23 + 100*i + j);
  
  for (i = 0; i &#60; 100; i++)
    for (j = 0; j &#60; 3; j++)
      printf ("m(%d,%d) = %g\n", i, j, 
              gsl_matrix_get (m, i, j));

  return 0;
}
</PRE>

<P>
Here is the output from the program.  The final loop attempts to read
outside the range of the matrix <CODE>m</CODE>, and the error is trapped by
the range-checking code in <CODE>gsl_matrix_get</CODE>.

</P>

<PRE class="example">
$ ./a.out
m(0,0) = 0.23
m(0,1) = 1.23
m(0,2) = 2.23
m(1,0) = 100.23
m(1,1) = 101.23
m(1,2) = 102.23
...
m(9,2) = 902.23
gsl: matrix_source.c:13: ERROR: first index out of range
Default GSL error handler invoked.
Aborted (core dumped)
</PRE>

<P>
The next program shows how to write a matrix to a file.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_matrix.h&#62;

int
main (void)
{
  int i, j, k = 0; 
  gsl_matrix * m = gsl_matrix_alloc (100, 100);
  gsl_matrix * a = gsl_matrix_alloc (100, 100);
  
  for (i = 0; i &#60; 100; i++)
    for (j = 0; j &#60; 100; j++)
      gsl_matrix_set (m, i, j, 0.23 + i + j);

  {  
     FILE * f = fopen ("test.dat", "wb");
     gsl_matrix_fwrite (f, m);
     fclose (f);
  }

  {  
     FILE * f = fopen ("test.dat", "rb");
     gsl_matrix_fread (f, a);
     fclose (f);
  }

  for (i = 0; i &#60; 100; i++)
    for (j = 0; j &#60; 100; j++)
      {
        double mij = gsl_matrix_get (m, i, j);
        double aij = gsl_matrix_get (a, i, j);
        if (mij != aij) k++;
      }

  printf ("differences = %d (should be zero)\n", k);
  return (k &#62; 0);
}
</PRE>

<P>
After running this program the file <TT>'test.dat'</TT> should contain the
elements of <CODE>m</CODE>, written in binary format.  The matrix which is read
back in using the function <CODE>gsl_matrix_fread</CODE> should be exactly
equal to the original matrix.

</P>
<P>
The following program demonstrates the use of vector views.  The program
computes the column norms of a matrix.

</P>

<PRE class="example">
#include &#60;math.h&#62;
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_matrix.h&#62;
#include &#60;gsl/gsl_blas.h&#62;

int
main (void)
{
  size_t i,j;

  gsl_matrix *m = gsl_matrix_alloc (10, 10);

  for (i = 0; i &#60; 10; i++)
    for (j = 0; j &#60; 10; j++)
      gsl_matrix_set (m, i, j, sin (i) + cos (j));

  for (j = 0; j &#60; 10; j++)
    {
      gsl_vector_view column = gsl_matrix_column (m, j);
      double d;

      d = gsl_blas_dnrm2 (&#38;column.vector);

      printf ("matrix column %d, norm = %g\n", j, d);
    }

  gsl_matrix_free (m);

  return 0;
}
</PRE>

<P>
Here is the output of the program, 

</P>

<PRE class="example">
$ ./a.out
matrix column 0, norm = 4.31461
matrix column 1, norm = 3.1205
matrix column 2, norm = 2.19316
matrix column 3, norm = 3.26114
matrix column 4, norm = 2.53416
matrix column 5, norm = 2.57281
matrix column 6, norm = 4.20469
matrix column 7, norm = 3.65202
matrix column 8, norm = 2.08524
matrix column 9, norm = 3.07313
</PRE>

<P>
The results can be confirmed using GNU OCTAVE,

</P>

<PRE class="example">
$ octave
GNU Octave, version 2.0.16.92
octave&#62; m = sin(0:9)' * ones(1,10) 
               + ones(10,1) * cos(0:9); 
octave&#62; sqrt(sum(m.^2))
ans =
  4.3146  3.1205  2.1932  3.2611  2.5342  2.5728
  4.2047  3.6520  2.0852  3.0731
</PRE>



<H2><A NAME="SEC187" HREF="gsl_manual.html#TOC187">References and Further Reading</A></H2>

<P>
The block, vector and matrix objects in GSL follow the <CODE>valarray</CODE>
model of C++.  A description of this model can be found in the following
reference,

</P>

<UL class="itemize">
<LI>

B. Stroustrup,
<CITE>The C++ Programming Language</CITE> (3rd Ed), 
Section 22.4 Vector Arithmetic.
Addison-Wesley 1997, ISBN 0-201-88954-4.
</UL>



<H1><A NAME="SEC188" HREF="gsl_manual.html#TOC188">Permutations</A></H1>
<P>
<A NAME="IDX949"></A>

</P>
<P>
This chapter describes functions for creating and manipulating
permutations. A permutation p is represented by an array of
n integers in the range 0 to n-1, where each value
p_i occurs once and only once.  The application of a permutation
p to a vector v yields a new vector v' where
v'_i = v_{p_i}. 
For example, the array (0,1,3,2) represents a permutation
which exchanges the last two elements of a four element vector.
The corresponding identity permutation is (0,1,2,3).   

</P>
<P>
Note that the permutations produced by the linear algebra routines
correspond to the exchange of matrix columns, and so should be considered
as applying to row-vectors in the form v' = v P rather than
column-vectors, when permuting the elements of a vector.

</P>
<P>
The functions described in this chapter are defined in the header file
<TT>'gsl_permutation.h'</TT>.

</P>



<H2><A NAME="SEC189" HREF="gsl_manual.html#TOC189">The Permutation struct</A></H2>

<P>
A permutation is defined by a structure containing two components, the size
of the permutation and a pointer to the permutation array.  The elements
of the permutation array are all of type <CODE>size_t</CODE>.  The
<CODE>gsl_permutation</CODE> structure looks like this,

</P>

<PRE class="example">
typedef struct
{
  size_t size;
  size_t * data;
} gsl_permutation;
</PRE>

<P>

</P>


<H2><A NAME="SEC190" HREF="gsl_manual.html#TOC190">Permutation allocation</A></H2>

<P>
<DL>
<DT><U>Function:</U> gsl_permutation * <B>gsl_permutation_alloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX950"></A>
This function allocates memory for a new permutation of size <VAR>n</VAR>.
The permutation is not initialized and its elements are undefined.  Use
the function <CODE>gsl_permutation_calloc</CODE> if you want to create a
permutation which is initialized to the identity. A null pointer is
returned if insufficient memory is available to create the permutation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_permutation * <B>gsl_permutation_calloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX951"></A>
This function allocates memory for a new permutation of size <VAR>n</VAR> and
initializes it to the identity. A null pointer is returned if
insufficient memory is available to create the permutation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_permutation_init</B> <I>(gsl_permutation * <VAR>p</VAR>)</I>
<DD><A NAME="IDX952"></A>
<A NAME="IDX953"></A>
This function initializes the permutation <VAR>p</VAR> to the identity, i.e.
(0,1,2,...,n-1).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_permutation_free</B> <I>(gsl_permutation * <VAR>p</VAR>)</I>
<DD><A NAME="IDX954"></A>
This function frees all the memory used by the permutation <VAR>p</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_permutation_memcpy</B> <I>(gsl_permutation * <VAR>dest</VAR>, const gsl_permutation * <VAR>src</VAR>)</I>
<DD><A NAME="IDX955"></A>
This function copies the elements of the permutation <VAR>src</VAR> into the
permutation <VAR>dest</VAR>.  The two permutations must have the same size.
</DL>

</P>


<H2><A NAME="SEC191" HREF="gsl_manual.html#TOC191">Accessing permutation elements</A></H2>

<P>
The following functions can be used to access and manipulate
permutations.

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_permutation_get</B> <I>(const gsl_permutation * <VAR>p</VAR>, const size_t <VAR>i</VAR>)</I>
<DD><A NAME="IDX956"></A>
This function returns the value of the <VAR>i</VAR>-th element of the
permutation <VAR>p</VAR>.  If <VAR>i</VAR> lies outside the allowed range of 0 to
<VAR>n</VAR>-1 then the error handler is invoked and 0 is returned.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_permutation_swap</B> <I>(gsl_permutation * <VAR>p</VAR>, const size_t <VAR>i</VAR>, const size_t <VAR>j</VAR>)</I>
<DD><A NAME="IDX957"></A>
<A NAME="IDX958"></A>
<A NAME="IDX959"></A>
This function exchanges the <VAR>i</VAR>-th and <VAR>j</VAR>-th elements of the
permutation <VAR>p</VAR>.
</DL>

</P>


<H2><A NAME="SEC192" HREF="gsl_manual.html#TOC192">Permutation properties</A></H2>

<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_permutation_size</B> <I>(const gsl_permutation * <VAR>p</VAR>)</I>
<DD><A NAME="IDX960"></A>
This function returns the size of the permutation <VAR>p</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> size_t * <B>gsl_permutation_data</B> <I>(const gsl_permutation * <VAR>p</VAR>)</I>
<DD><A NAME="IDX961"></A>
This function returns a pointer to the array of elements in the
permutation <VAR>p</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_permutation_valid</B> <I>(gsl_permutation * <VAR>p</VAR>)</I>
<DD><A NAME="IDX962"></A>
<A NAME="IDX963"></A>
<A NAME="IDX964"></A>
This function checks that the permutation <VAR>p</VAR> is valid.  The <VAR>n</VAR>
elements should contain each of the numbers 0 to <VAR>n</VAR>-1 once and only
once.
</DL>

</P>


<H2><A NAME="SEC193" HREF="gsl_manual.html#TOC193">Permutation functions</A></H2>

<P>
<DL>
<DT><U>Function:</U> void <B>gsl_permutation_reverse</B> <I>(gsl_permutation * <VAR>p</VAR>)</I>
<DD><A NAME="IDX965"></A>
<A NAME="IDX966"></A>
This function reverses the elements of the permutation <VAR>p</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_permutation_inverse</B> <I>(gsl_permutation * <VAR>inv</VAR>, const gsl_permutation * <VAR>p</VAR>)</I>
<DD><A NAME="IDX967"></A>
<A NAME="IDX968"></A>
This function computes the inverse of the permutation <VAR>p</VAR>, storing
the result in <VAR>inv</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_permutation_next</B> <I>(gsl_permutation * <VAR>p</VAR>)</I>
<DD><A NAME="IDX969"></A>
<A NAME="IDX970"></A>
This function advances the permutation <VAR>p</VAR> to the next permutation
in lexicographic order and returns <CODE>GSL_SUCCESS</CODE>.  If no further
permutations are available it returns <CODE>GSL_FAILURE</CODE> and leaves
<VAR>p</VAR> unmodified.  Starting with the identity permutation and
repeatedly applying this function will iterate through all possible
permutations of a given order.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_permutation_prev</B> <I>(gsl_permutation * <VAR>p</VAR>)</I>
<DD><A NAME="IDX971"></A>
This function steps backwards from the permutation <VAR>p</VAR> to the
previous permutation in lexicographic order, returning
<CODE>GSL_SUCCESS</CODE>.  If no previous permutation is available it returns
<CODE>GSL_FAILURE</CODE> and leaves <VAR>p</VAR> unmodified.
</DL>

</P>


<H2><A NAME="SEC194" HREF="gsl_manual.html#TOC194">Applying Permutations</A></H2>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_permute</B> <I>(const size_t * <VAR>p</VAR>, double * <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX972"></A>
This function applies the permutation <VAR>p</VAR> to the array <VAR>data</VAR> of
size <VAR>n</VAR> with stride <VAR>stride</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_permute_inverse</B> <I>(const size_t * <VAR>p</VAR>, double * <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX973"></A>
This function applies the inverse of the permutation <VAR>p</VAR> to the
array <VAR>data</VAR> of size <VAR>n</VAR> with stride <VAR>stride</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_permute_vector</B> <I>(const gsl_permutation * <VAR>p</VAR>, gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX974"></A>
This function applies the permutation <VAR>p</VAR> to the elements of the
vector <VAR>v</VAR>, considered as a row-vector acted on by a permutation
matrix from the right, v' = v P.  The j-th column of the
permutation matrix P is given by the p_j-th column of the
identity matrix. The permutation <VAR>p</VAR> and the vector <VAR>v</VAR> must
have the same length.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_permute_vector_inverse</B> <I>(const gsl_permutation * <VAR>p</VAR>, gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX975"></A>
This function applies the inverse of the permutation <VAR>p</VAR> to the
elements of the vector <VAR>v</VAR>, considered as a row-vector acted on by
an inverse permutation matrix from the right, v' = v P^T.  Note
that for permutation matrices the inverse is the same as the transpose.
The j-th column of the permutation matrix P is given by
the p_j-th column of the identity matrix. The permutation <VAR>p</VAR>
and the vector <VAR>v</VAR> must have the same length.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_permutation_mul</B> <I>(gsl_permutation * <VAR>p</VAR>, const gsl_permutation * <VAR>pa</VAR>, const gsl_permutation * <VAR>pb</VAR>)</I>
<DD><A NAME="IDX976"></A>
This function combines the two permutations <VAR>pa</VAR> and <VAR>pb</VAR> into a
single permutation <VAR>p</VAR>, where p = pa . pb. The permutation
<VAR>p</VAR> is equivalent to applying pb first and then <VAR>pa</VAR>.
</DL>

</P>


<H2><A NAME="SEC195" HREF="gsl_manual.html#TOC195">Reading and writing permutations</A></H2>

<P>
The library provides functions for reading and writing permutations to a
file as binary data or formatted text.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_permutation_fwrite</B> <I>(FILE * <VAR>stream</VAR>, const gsl_permutation * <VAR>p</VAR>)</I>
<DD><A NAME="IDX977"></A>
This function writes the elements of the permutation <VAR>p</VAR> to the
stream <VAR>stream</VAR> in binary format.  The function returns
<CODE>GSL_EFAILED</CODE> if there was a problem writing to the file.  Since the
data is written in the native binary format it may not be portable
between different architectures.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_permutation_fread</B> <I>(FILE * <VAR>stream</VAR>, gsl_permutation * <VAR>p</VAR>)</I>
<DD><A NAME="IDX978"></A>
This function reads into the permutation <VAR>p</VAR> from the open stream
<VAR>stream</VAR> in binary format.  The permutation <VAR>p</VAR> must be
preallocated with the correct length since the function uses the size of
<VAR>p</VAR> to determine how many bytes to read.  The function returns
<CODE>GSL_EFAILED</CODE> if there was a problem reading from the file.  The
data is assumed to have been written in the native binary format on the
same architecture.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_permutation_fprintf</B> <I>(FILE * <VAR>stream</VAR>, const gsl_permutation * <VAR>p</VAR>, const char * <VAR>format</VAR>)</I>
<DD><A NAME="IDX979"></A>
This function writes the elements of the permutation <VAR>p</VAR>
line-by-line to the stream <VAR>stream</VAR> using the format specifier
<VAR>format</VAR>, which should be suitable for a type of <VAR>size_t</VAR>.  On a
GNU system the type modifier <CODE>Z</CODE> represents <CODE>size_t</CODE>, so
<CODE>"%Zu\n"</CODE> is a suitable format.  The function returns
<CODE>GSL_EFAILED</CODE> if there was a problem writing to the file.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_permutation_fscanf</B> <I>(FILE * <VAR>stream</VAR>, gsl_permutation * <VAR>p</VAR>)</I>
<DD><A NAME="IDX980"></A>
This function reads formatted data from the stream <VAR>stream</VAR> into the
permutation <VAR>p</VAR>.  The permutation <VAR>p</VAR> must be preallocated with
the correct length since the function uses the size of <VAR>p</VAR> to
determine how many numbers to read.  The function returns
<CODE>GSL_EFAILED</CODE> if there was a problem reading from the file.
</DL>

</P>


<H2><A NAME="SEC196" HREF="gsl_manual.html#TOC196">Permutations in cyclic form</A></H2>

<P>
A permutation can be represented in both <I>linear</I> and <I>cyclic</I>
notations.  The functions described in this section convert between the
two forms.  The linear notation is an index mapping, and has already
been described above.  The cyclic notation expresses a permutation as a
series of circular rearrangements of groups of elements, or
<I>cycles</I>.

</P>
<P>
For example, under the cycle (1 2 3), 1 is replaced by 2, 2 is replaced
by 3 and 3 is replaced by 1 in a circular fashion. Cycles of different
sets of elements can be combined independently, for example (1 2 3) (4
5) combines the cycle (1 2 3) with the cycle (4 5), which is an exchange
of elements 4 and 5.  A cycle of length one represents an element which
is unchanged by the permutation and is referred to as a <I>singleton</I>.

</P>
<P>
It can be shown that every permutation can be decomposed into
combinations of cycles.  The decomposition is not unique, but can always
be rearranged into a standard <I>canonical form</I> by a reordering of
elements.  The library uses the canonical form defined in Knuth's
<CITE>Art of Computer Programming</CITE> (Vol 1, 3rd Ed, 1997) Section 1.3.3,
p.178.

</P>
<P>
The procedure for obtaining the canonical form given by Knuth is,

</P>

<OL class="enumerate">
<LI>Write all singleton cycles explicitly

<LI>Within each cycle, put the smallest number first

<LI>Order the cycles in decreasing order of the first number in the cycle.

</OL>

<P>
For example, the linear representation (2 4 3 0 1) is represented as (1
4) (0 2 3) in canonical form. The permutation corresponds to an
exchange of elements 1 and 4, and rotation of elements 0, 2 and 3.

</P>
<P>
The important property of the canonical form is that it can be
reconstructed from the contents of each cycle without the brackets. In
addition, by removing the brackets it can be considered as a linear
representation of a different permutation. In the example given above
the permutation (2 4 3 0 1) would become (1 4 0 2 3).  This mapping has
many applications in the theory of permutations.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_permutation_linear_to_canonical</B> <I>(gsl_permutation * <VAR>q</VAR>, const gsl_permutation * <VAR>p</VAR>)</I>
<DD><A NAME="IDX981"></A>
This function computes the canonical form of the permutation <VAR>p</VAR> and
stores it in the output argument <VAR>q</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_permutation_canonical_to_linear</B> <I>(gsl_permutation * <VAR>p</VAR>, const gsl_permutation * <VAR>q</VAR>)</I>
<DD><A NAME="IDX982"></A>
This function converts a permutation <VAR>q</VAR> in canonical form back into
linear form storing it in the output argument <VAR>p</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_permutation_inversions</B> <I>(const gsl_permutation * <VAR>p</VAR>)</I>
<DD><A NAME="IDX983"></A>
This function counts the number of inversions in the permutation
<VAR>p</VAR>.  An inversion is any pair of elements that are not in order.
For example, the permutation 2031 has three inversions, corresponding to
the pairs (2,0) (2,1) and (3,1).  The identity permutation has no
inversions.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_permutation_linear_cycles</B> <I>(const gsl_permutation * <VAR>p</VAR>)</I>
<DD><A NAME="IDX984"></A>
This function counts the number of cycles in the permutation <VAR>p</VAR>, given in linear form.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_permutation_canonical_cycles</B> <I>(const gsl_permutation * <VAR>q</VAR>)</I>
<DD><A NAME="IDX985"></A>
This function counts the number of cycles in the permutation <VAR>q</VAR>, given in canonical form.
</DL>

</P>



<H2><A NAME="SEC197" HREF="gsl_manual.html#TOC197">Examples</A></H2>
<P>
The example program below creates a random permutation (by shuffling the
elements of the identity) and finds its inverse.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_rng.h&#62;
#include &#60;gsl/gsl_randist.h&#62;
#include &#60;gsl/gsl_permutation.h&#62;

int
main (void) 
{
  const size_t N = 10;
  const gsl_rng_type * T;
  gsl_rng * r;

  gsl_permutation * p = gsl_permutation_alloc (N);
  gsl_permutation * q = gsl_permutation_alloc (N);

  gsl_rng_env_setup();
  T = gsl_rng_default;
  r = gsl_rng_alloc (T);

  printf ("initial permutation:");  
  gsl_permutation_init (p);
  gsl_permutation_fprintf (stdout, p, " %u");
  printf ("\n");

  printf (" random permutation:");  
  gsl_ran_shuffle (r, p-&#62;data, N, sizeof(size_t));
  gsl_permutation_fprintf (stdout, p, " %u");
  printf ("\n");

  printf ("inverse permutation:");  
  gsl_permutation_inverse (q, p);
  gsl_permutation_fprintf (stdout, q, " %u");
  printf ("\n");

  return 0;
}
</PRE>

<P>
Here is the output from the program,

</P>

<PRE class="example">
$ ./a.out 
initial permutation: 0 1 2 3 4 5 6 7 8 9
 random permutation: 1 3 5 2 7 6 0 4 9 8
inverse permutation: 6 0 3 1 7 2 5 4 9 8
</PRE>

<P>
The random permutation <CODE>p[i]</CODE> and its inverse <CODE>q[i]</CODE> are
related through the identity <CODE>p[q[i]] = i</CODE>, which can be verified
from the output.

</P>
<P>
The next example program steps forwards through all possible third order
permutations, starting from the identity,

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_permutation.h&#62;

int
main (void) 
{
  gsl_permutation * p = gsl_permutation_alloc (3);

  gsl_permutation_init (p);

  do 
   {
      gsl_permutation_fprintf (stdout, p, " %u");
      printf ("\n");
   }
  while (gsl_permutation_next(p) == GSL_SUCCESS);

  return 0;
}
</PRE>

<P>
Here is the output from the program,

</P>

<PRE class="example">
$ ./a.out 
 0 1 2
 0 2 1
 1 0 2
 1 2 0
 2 0 1
 2 1 0
</PRE>

<P>
The permutations are generated in lexicographic order.  To reverse the
sequence, begin with the final permutation (which is the reverse of the
identity) and replace <CODE>gsl_permutation_next</CODE> with
<CODE>gsl_permutation_prev</CODE>.

</P>


<H2><A NAME="SEC198" HREF="gsl_manual.html#TOC198">References and Further Reading</A></H2>

<P>
The subject of permutations is covered extensively in Knuth's
<CITE>Sorting and Searching</CITE>,

</P>

<UL class="itemize">
<LI>

Donald E. Knuth, <CITE>The Art of Computer Programming: Sorting and
Searching</CITE> (Vol 3, 3rd Ed, 1997), Addison-Wesley, ISBN 0201896850.
</UL>

<P>
For the definition of the <I>canonical form</I> see,

</P>

<UL class="itemize">
<LI>

Donald E. Knuth, <CITE>The Art of Computer Programming: Fundamental
Algorithms</CITE> (Vol 1, 3rd Ed, 1997), Addison-Wesley, ISBN 0201896850.
Section 1.3.3, <CITE>An Unusual Correspondence</CITE>, p.178--179.
</UL>



<H1><A NAME="SEC199" HREF="gsl_manual.html#TOC199">Combinations</A></H1>
<P>
<A NAME="IDX986"></A>

</P>
<P>
This chapter describes functions for creating and manipulating
combinations. A combination c is represented by an array of
k integers in the range 0 to n-1, where each value
c_i occurs at most once.  The combination c corresponds to
indices of k elements chosen from an n element vector.
Combinations are useful for iterating over all k-element subsets
of a set.

</P>
<P>
The functions described in this chapter are defined in the header file
<TT>'gsl_combination.h'</TT>.

</P>



<H2><A NAME="SEC200" HREF="gsl_manual.html#TOC200">The Combination struct</A></H2>

<P>
A combination is defined by a structure containing three components, the
values of n and k, and a pointer to the combination array.
The elements of the combination array are all of type <CODE>size_t</CODE>, and
are stored in increasing order.  The <CODE>gsl_combination</CODE> structure
looks like this,

</P>

<PRE class="example">
typedef struct
{
  size_t n;
  size_t k;
  size_t *data;
} gsl_combination;
</PRE>

<P>

</P>


<H2><A NAME="SEC201" HREF="gsl_manual.html#TOC201">Combination allocation</A></H2>

<P>
<DL>
<DT><U>Function:</U> gsl_combination * <B>gsl_combination_alloc</B> <I>(size_t <VAR>n</VAR>, size_t <VAR>k</VAR>)</I>
<DD><A NAME="IDX987"></A>
This function allocates memory for a new combination with parameters
<VAR>n</VAR>, <VAR>k</VAR>.  The combination is not initialized and its elements
are undefined.  Use the function <CODE>gsl_combination_calloc</CODE> if you
want to create a combination which is initialized to the
lexicographically first combination. A null pointer is returned if
insufficient memory is available to create the combination.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_combination * <B>gsl_combination_calloc</B> <I>(size_t <VAR>n</VAR>, size_t <VAR>k</VAR>)</I>
<DD><A NAME="IDX988"></A>
This function allocates memory for a new combination with parameters
<VAR>n</VAR>, <VAR>k</VAR> and initializes it to the lexicographically first
combination. A null pointer is returned if insufficient memory is
available to create the combination.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_combination_init_first</B> <I>(gsl_combination * <VAR>c</VAR>)</I>
<DD><A NAME="IDX989"></A>
This function initializes the combination <VAR>c</VAR> to the
lexicographically first combination, i.e.  (0,1,2,...,k-1).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_combination_init_last</B> <I>(gsl_combination * <VAR>c</VAR>)</I>
<DD><A NAME="IDX990"></A>
This function initializes the combination <VAR>c</VAR> to the
lexicographically last combination, i.e.  (n-k,n-k+1,...,n-1).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_combination_free</B> <I>(gsl_combination * <VAR>c</VAR>)</I>
<DD><A NAME="IDX991"></A>
This function frees all the memory used by the combination <VAR>c</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_combination_memcpy</B> <I>(gsl_combination * <VAR>dest</VAR>, const gsl_combination * <VAR>src</VAR>)</I>
<DD><A NAME="IDX992"></A>
This function copies the elements of the combination <VAR>src</VAR> into the
combination <VAR>dest</VAR>.  The two combinations must have the same size.
</DL>

</P>



<H2><A NAME="SEC202" HREF="gsl_manual.html#TOC202">Accessing combination elements</A></H2>

<P>
The following function can be used to access the elements of a combination.

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_combination_get</B> <I>(const gsl_combination * <VAR>c</VAR>, const size_t <VAR>i</VAR>)</I>
<DD><A NAME="IDX993"></A>
This function returns the value of the <VAR>i</VAR>-th element of the
combination <VAR>c</VAR>.  If <VAR>i</VAR> lies outside the allowed range of 0 to
<VAR>k</VAR>-1 then the error handler is invoked and 0 is returned.
</DL>

</P>


<H2><A NAME="SEC203" HREF="gsl_manual.html#TOC203">Combination properties</A></H2>

<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_combination_n</B> <I>(const gsl_combination * <VAR>c</VAR>)</I>
<DD><A NAME="IDX994"></A>
This function returns the range (n) of the combination <VAR>c</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_combination_k</B> <I>(const gsl_combination * <VAR>c</VAR>)</I>
<DD><A NAME="IDX995"></A>
This function returns the number of elements (k) in the combination <VAR>c</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> size_t * <B>gsl_combination_data</B> <I>(const gsl_combination * <VAR>c</VAR>)</I>
<DD><A NAME="IDX996"></A>
This function returns a pointer to the array of elements in the
combination <VAR>c</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_combination_valid</B> <I>(gsl_combination * <VAR>c</VAR>)</I>
<DD><A NAME="IDX997"></A>
<A NAME="IDX998"></A>
<A NAME="IDX999"></A>
This function checks that the combination <VAR>c</VAR> is valid.  The <VAR>k</VAR>
elements should lie in the range 0 to <VAR>n</VAR>-1, with each
value occurring once at most and in increasing order.
</DL>

</P>


<H2><A NAME="SEC204" HREF="gsl_manual.html#TOC204">Combination functions</A></H2>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_combination_next</B> <I>(gsl_combination * <VAR>c</VAR>)</I>
<DD><A NAME="IDX1000"></A>
<A NAME="IDX1001"></A>
This function advances the combination <VAR>c</VAR> to the next combination
in lexicographic order and returns <CODE>GSL_SUCCESS</CODE>.  If no further
combinations are available it returns <CODE>GSL_FAILURE</CODE> and leaves
<VAR>c</VAR> unmodified.  Starting with the first combination and
repeatedly applying this function will iterate through all possible
combinations of a given order.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_combination_prev</B> <I>(gsl_combination * <VAR>c</VAR>)</I>
<DD><A NAME="IDX1002"></A>
This function steps backwards from the combination <VAR>c</VAR> to the
previous combination in lexicographic order, returning
<CODE>GSL_SUCCESS</CODE>.  If no previous combination is available it returns
<CODE>GSL_FAILURE</CODE> and leaves <VAR>c</VAR> unmodified.
</DL>

</P>



<H2><A NAME="SEC205" HREF="gsl_manual.html#TOC205">Reading and writing combinations</A></H2>

<P>
The library provides functions for reading and writing combinations to a
file as binary data or formatted text.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_combination_fwrite</B> <I>(FILE * <VAR>stream</VAR>, const gsl_combination * <VAR>c</VAR>)</I>
<DD><A NAME="IDX1003"></A>
This function writes the elements of the combination <VAR>c</VAR> to the
stream <VAR>stream</VAR> in binary format.  The function returns
<CODE>GSL_EFAILED</CODE> if there was a problem writing to the file.  Since the
data is written in the native binary format it may not be portable
between different architectures.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_combination_fread</B> <I>(FILE * <VAR>stream</VAR>, gsl_combination * <VAR>c</VAR>)</I>
<DD><A NAME="IDX1004"></A>
This function reads elements from the open stream <VAR>stream</VAR> into the
combination <VAR>c</VAR> in binary format.  The combination <VAR>c</VAR> must be
preallocated with correct values of n and k since the
function uses the size of <VAR>c</VAR> to determine how many bytes to read.
The function returns <CODE>GSL_EFAILED</CODE> if there was a problem reading
from the file.  The data is assumed to have been written in the native
binary format on the same architecture.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_combination_fprintf</B> <I>(FILE * <VAR>stream</VAR>, const gsl_combination * <VAR>c</VAR>, const char * <VAR>format</VAR>)</I>
<DD><A NAME="IDX1005"></A>
This function writes the elements of the combination <VAR>c</VAR>
line-by-line to the stream <VAR>stream</VAR> using the format specifier
<VAR>format</VAR>, which should be suitable for a type of <VAR>size_t</VAR>.  On a
GNU system the type modifier <CODE>Z</CODE> represents <CODE>size_t</CODE>, so
<CODE>"%Zu\n"</CODE> is a suitable format.  The function returns
<CODE>GSL_EFAILED</CODE> if there was a problem writing to the file.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_combination_fscanf</B> <I>(FILE * <VAR>stream</VAR>, gsl_combination * <VAR>c</VAR>)</I>
<DD><A NAME="IDX1006"></A>
This function reads formatted data from the stream <VAR>stream</VAR> into the
combination <VAR>c</VAR>.  The combination <VAR>c</VAR> must be preallocated with
correct values of n and k since the function uses the size of <VAR>c</VAR> to
determine how many numbers to read.  The function returns
<CODE>GSL_EFAILED</CODE> if there was a problem reading from the file.
</DL>

</P>



<H2><A NAME="SEC206" HREF="gsl_manual.html#TOC206">Examples</A></H2>
<P>
The example program below prints all subsets of the set
{0,1,2,3} ordered by size.  Subsets of the same size are
ordered lexicographically.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_combination.h&#62;

int 
main (void) 
{
  gsl_combination * c;
  size_t i;

  printf ("All subsets of {0,1,2,3} by size:\n") ;
  for (i = 0; i &#60;= 4; i++)
    {
      c = gsl_combination_calloc (4, i);
      do
        {
          printf ("{");
          gsl_combination_fprintf (stdout, c, " %u");
          printf (" }\n");
        }
      while (gsl_combination_next (c) == GSL_SUCCESS);
      gsl_combination_free (c);
    }

  return 0;
}
</PRE>

<P>
Here is the output from the program,

</P>

<PRE class="example">
$ ./a.out 
All subsets of {0,1,2,3} by size:
{ }
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 0 1 }
{ 0 2 }
{ 0 3 }
{ 1 2 }
{ 1 3 }
{ 2 3 }
{ 0 1 2 }
{ 0 1 3 }
{ 0 2 3 }
{ 1 2 3 }
{ 0 1 2 3 }
</PRE>

<P>
All 16 subsets are generated, and the subsets of each size are sorted
lexicographically.

</P>



<H2><A NAME="SEC207" HREF="gsl_manual.html#TOC207">References and Further Reading</A></H2>

<P>
Further information on combinations can be found in,

</P>

<UL class="itemize">
<LI>

Donald L. Kreher, Douglas R. Stinson, <CITE>Combinatorial Algorithms:
Generation, Enumeration and Search</CITE>, 1998, CRC Press LLC, ISBN
084933988X
</UL>

<P>

</P>



<H1><A NAME="SEC208" HREF="gsl_manual.html#TOC208">Sorting</A></H1>
<P>
<A NAME="IDX1007"></A>
<A NAME="IDX1008"></A>
This chapter describes functions for sorting data, both directly and
indirectly (using an index).  All the functions use the <I>heapsort</I>
algorithm.  Heapsort is an O(N \log N) algorithm which operates
in-place and does not require any additional storage.  It also provides
consistent performance, the running time for its worst-case (ordered
data) being not significantly longer than the average and best cases.
Note that the heapsort algorithm does not preserve the relative ordering
of equal elements--it is an <I>unstable</I> sort.  However the resulting
order of equal elements will be consistent across different platforms
when using these functions.

</P>



<H2><A NAME="SEC209" HREF="gsl_manual.html#TOC209">Sorting objects</A></H2>

<P>
The following function provides a simple alternative to the standard
library function <CODE>qsort</CODE>.  It is intended for systems lacking
<CODE>qsort</CODE>, not as a replacement for it.  The function <CODE>qsort</CODE>
should be used whenever possible, as it will be faster and can provide
stable ordering of equal elements.  Documentation for <CODE>qsort</CODE> is
available in the <CITE>GNU C Library Reference Manual</CITE>.

</P>
<P>
The functions described in this section are defined in the header file
<TT>'gsl_heapsort.h'</TT>.

</P>
<P>
<A NAME="IDX1009"></A>
<DL>
<DT><U>Function:</U> void <B>gsl_heapsort</B> <I>(void * <VAR>array</VAR>, size_t <VAR>count</VAR>, size_t <VAR>size</VAR>, gsl_comparison_fn_t <VAR>compare</VAR>)</I>
<DD><A NAME="IDX1010"></A>

</P>
<P>
This function sorts the <VAR>count</VAR> elements of the array <VAR>array</VAR>,
each of size <VAR>size</VAR>, into ascending order using the comparison
function <VAR>compare</VAR>.  The type of the comparison function is defined by,

</P>

<PRE class="example">
int (*gsl_comparison_fn_t) (const void * a,
                            const void * b)
</PRE>

<P>
A comparison function should return a negative integer if the first
argument is less than the second argument, <CODE>0</CODE> if the two arguments
are equal and a positive integer if the first argument is greater than
the second argument.

</P>
<P>
For example, the following function can be used to sort doubles into
ascending numerical order.

</P>

<PRE class="example">
int
compare_doubles (const double * a,
                 const double * b)
{
    if (*a &#62; *b)
       return 1;
    else if (*a &#60; *b)
       return -1;
    else
       return 0;
}
</PRE>

<P>
The appropriate function call to perform the sort is,

</P>

<PRE class="example">
gsl_heapsort (array, count, sizeof(double), 
              compare_doubles);
</PRE>

<P>
Note that unlike <CODE>qsort</CODE> the heapsort algorithm cannot be made into
a stable sort by pointer arithmetic.  The trick of comparing pointers for
equal elements in the comparison function does not work for the heapsort
algorithm.  The heapsort algorithm performs an internal rearrangement of
the data which destroys its initial ordering.
</DL>

</P>
<P>
<A NAME="IDX1011"></A>
<DL>
<DT><U>Function:</U> int <B>gsl_heapsort_index</B> <I>(size_t * <VAR>p</VAR>, const void * <VAR>array</VAR>, size_t <VAR>count</VAR>, size_t <VAR>size</VAR>, gsl_comparison_fn_t <VAR>compare</VAR>)</I>
<DD><A NAME="IDX1012"></A>

</P>
<P>
This function indirectly sorts the <VAR>count</VAR> elements of the array
<VAR>array</VAR>, each of size <VAR>size</VAR>, into ascending order using the
comparison function <VAR>compare</VAR>.  The resulting permutation is stored
in <VAR>p</VAR>, an array of length <VAR>n</VAR>.  The elements of <VAR>p</VAR> give the
index of the array element which would have been stored in that position
if the array had been sorted in place.  The first element of <VAR>p</VAR>
gives the index of the least element in <VAR>array</VAR>, and the last
element of <VAR>p</VAR> gives the index of the greatest element in
<VAR>array</VAR>.  The array itself is not changed.
</DL>

</P>


<H2><A NAME="SEC210" HREF="gsl_manual.html#TOC210">Sorting vectors</A></H2>

<P>
The following functions will sort the elements of an array or vector,
either directly or indirectly.  They are defined for all real and integer
types using the normal suffix rules.  For example, the <CODE>float</CODE>
versions of the array functions are <CODE>gsl_sort_float</CODE> and
<CODE>gsl_sort_float_index</CODE>.  The corresponding vector functions are
<CODE>gsl_sort_vector_float</CODE> and <CODE>gsl_sort_vector_float_index</CODE>.  The
prototypes are available in the header files <TT>'gsl_sort_float.h'</TT>
<TT>'gsl_sort_vector_float.h'</TT>.  The complete set of prototypes can be
included using the header files <TT>'gsl_sort.h'</TT> and
<TT>'gsl_sort_vector.h'</TT>.

</P>
<P>
There are no functions for sorting complex arrays or vectors, since the
ordering of complex numbers is not uniquely defined.  To sort a complex
vector by magnitude compute a real vector containing the magnitudes
of the complex elements, and sort this vector indirectly.  The resulting
index gives the appropriate ordering of the original complex vector.

</P>
<P>
<A NAME="IDX1013"></A>
<A NAME="IDX1014"></A>
<DL>
<DT><U>Function:</U> void <B>gsl_sort</B> <I>(double * <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1015"></A>
This function sorts the <VAR>n</VAR> elements of the array <VAR>data</VAR> with
stride <VAR>stride</VAR> into ascending numerical order.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_sort_vector</B> <I>(gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX1016"></A>
This function sorts the elements of the vector <VAR>v</VAR> into ascending
numerical order.
</DL>

</P>
<P>
<A NAME="IDX1017"></A>
<DL>
<DT><U>Function:</U> int <B>gsl_sort_index</B> <I>(size_t * <VAR>p</VAR>, const double * <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1018"></A>
This function indirectly sorts the <VAR>n</VAR> elements of the array
<VAR>data</VAR> with stride <VAR>stride</VAR> into ascending order, storing the
resulting permutation in <VAR>p</VAR>.  The array <VAR>p</VAR> must be allocated with
a sufficient length to store the <VAR>n</VAR> elements of the permutation.
The elements of <VAR>p</VAR> give the index of the array element which would
have been stored in that position if the array had been sorted in place.
The array <VAR>data</VAR> is not changed.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sort_vector_index</B> <I>(gsl_permutation * <VAR>p</VAR>, const gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX1019"></A>
This function indirectly sorts the elements of the vector <VAR>v</VAR> into
ascending order, storing the resulting permutation in <VAR>p</VAR>.  The
elements of <VAR>p</VAR> give the index of the vector element which would
have been stored in that position if the vector had been sorted in
place.  The first element of <VAR>p</VAR> gives the index of the least element
in <VAR>v</VAR>, and the last element of <VAR>p</VAR> gives the index of the
greatest element in <VAR>v</VAR>.  The vector <VAR>v</VAR> is not changed.
</DL>

</P>


<H2><A NAME="SEC211" HREF="gsl_manual.html#TOC211">Selecting the k smallest or largest elements</A></H2>

<P>
The functions described in this section select the k smallest
or largest elements of a data set of size N.  The routines use an
O(kN) direct insertion algorithm which is suited to subsets that
are small compared with the total size of the dataset. For example, the
routines are useful for selecting the 10 largest values from one million
data points, but not for selecting the largest 100,000 values.  If the
subset is a significant part of the total dataset it may be faster
to sort all the elements of the dataset directly with an O(N \log
N) algorithm and obtain the smallest or largest values that way.

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_sort_smallest</B> <I>(double * <VAR>dest</VAR>, size_t <VAR>k</VAR>, const double * <VAR>src</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1020"></A>
This function copies the <VAR>k</VAR> smallest elements of the array
<VAR>src</VAR>, of size <VAR>n</VAR> and stride <VAR>stride</VAR>, in ascending
numerical order into the array <VAR>dest</VAR>.  The size <VAR>k</VAR> of the subset must be
less than or equal to <VAR>n</VAR>.  The data <VAR>src</VAR> is not modified by
this operation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_sort_largest</B> <I>(double * <VAR>dest</VAR>, size_t <VAR>k</VAR>, const double * <VAR>src</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1021"></A>
This function copies the <VAR>k</VAR> largest elements of the array
<VAR>src</VAR>, of size <VAR>n</VAR> and stride <VAR>stride</VAR>, in descending
numerical order into the array <VAR>dest</VAR>. <VAR>k</VAR> must be
less than or equal to <VAR>n</VAR>. The data <VAR>src</VAR> is not modified by
this operation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_sort_vector_smallest</B> <I>(double * <VAR>dest</VAR>, size_t <VAR>k</VAR>, const gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX1022"></A>
<DT><U>Function:</U> void <B>gsl_sort_vector_largest</B> <I>(double * <VAR>dest</VAR>, size_t <VAR>k</VAR>, const gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX1023"></A>
These functions copy the <VAR>k</VAR> smallest or largest elements of the
vector <VAR>v</VAR> into the array <VAR>dest</VAR>. <VAR>k</VAR>
must be less than or equal to the length of the vector <VAR>v</VAR>.
</DL>

</P>
<P>
The following functions find the indices of the k smallest or
largest elements of a dataset,

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_sort_smallest_index</B> <I>(size_t * <VAR>p</VAR>, size_t <VAR>k</VAR>, const double * <VAR>src</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1024"></A>
This function stores the indices of the <VAR>k</VAR> smallest elements of
the array <VAR>src</VAR>, of size <VAR>n</VAR> and stride <VAR>stride</VAR>, in the
array <VAR>p</VAR>.  The indices are chosen so that the corresponding data is
in ascending numerical order.  <VAR>k</VAR> must be
less than or equal to <VAR>n</VAR>. The data <VAR>src</VAR> is not modified by
this operation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_sort_largest_index</B> <I>(size_t * <VAR>p</VAR>, size_t <VAR>k</VAR>, const double * <VAR>src</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1025"></A>
This function stores the indices of the <VAR>k</VAR> largest elements of
the array <VAR>src</VAR>, of size <VAR>n</VAR> and stride <VAR>stride</VAR>, in the
array <VAR>p</VAR>.  The indices are chosen so that the corresponding data is
in descending numerical order.  <VAR>k</VAR> must be
less than or equal to <VAR>n</VAR>. The data <VAR>src</VAR> is not modified by
this operation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_sort_vector_smallest_index</B> <I>(size_t * <VAR>p</VAR>, size_t <VAR>k</VAR>, const gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX1026"></A>
<DT><U>Function:</U> void <B>gsl_sort_vector_largest_index</B> <I>(size_t * <VAR>p</VAR>, size_t <VAR>k</VAR>, const gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX1027"></A>
These functions store the indices of the <VAR>k</VAR> smallest or largest
elements of the vector <VAR>v</VAR> in the array <VAR>p</VAR>. <VAR>k</VAR> must be less than or equal to the length of the vector
<VAR>v</VAR>.
</DL>

</P>



<H2><A NAME="SEC212" HREF="gsl_manual.html#TOC212">Computing the rank</A></H2>

<P>
The <I>rank</I> of an element is its order in the sorted data.  The rank
is the inverse of the index permutation, <VAR>p</VAR>.  It can be computed
using the following algorithm,

</P>

<PRE class="example">
for (i = 0; i &#60; p-&#62;size; i++) 
{
    size_t pi = p-&#62;data[i];
    rank-&#62;data[pi] = i;
}
</PRE>

<P>
This can be computed directly from the function
<CODE>gsl_permutation_inverse(rank,p)</CODE>.

</P>
<P>
The following function will print the rank of each element of the vector
<VAR>v</VAR>,

</P>

<PRE class="example">
void
print_rank (gsl_vector * v)
{
  size_t i;
  size_t n = v-&#62;size;
  gsl_permutation * perm = gsl_permutation_alloc(n);
  gsl_permutation * rank = gsl_permutation_alloc(n);

  gsl_sort_vector_index (perm, v);
  gsl_permutation_inverse (rank, perm);

  for (i = 0; i &#60; n; i++)
   {
    double vi = gsl_vector_get(v, i);
    printf ("element = %d, value = %g, rank = %d\n",
             i, vi, rank-&#62;data[i]);
   }

  gsl_permutation_free (perm);
  gsl_permutation_free (rank);
}
</PRE>



<H2><A NAME="SEC213" HREF="gsl_manual.html#TOC213">Examples</A></H2>

<P>
The following example shows how to use the permutation <VAR>p</VAR> to print
the elements of the vector <VAR>v</VAR> in ascending order,

</P>

<PRE class="example">
gsl_sort_vector_index (p, v);

for (i = 0; i &#60; v-&#62;size; i++)
{
    double vpi = gsl_vector_get (v, p-&#62;data[i]);
    printf ("order = %d, value = %g\n", i, vpi);
}
</PRE>

<P>
The next example uses the function <CODE>gsl_sort_smallest</CODE> to select
the 5 smallest numbers from 100000 uniform random variates stored in an
array,

</P>

<PRE class="example">
#include &#60;gsl/gsl_rng.h&#62;
#include &#60;gsl/gsl_sort_double.h&#62;

int
main (void)
{
  const gsl_rng_type * T;
  gsl_rng * r;

  size_t i, k = 5, N = 100000;

  double * x = malloc (N * sizeof(double));
  double * small = malloc (k * sizeof(double));

  gsl_rng_env_setup();

  T = gsl_rng_default;
  r = gsl_rng_alloc (T);

  for (i = 0; i &#60; N; i++)
    {
      x[i] = gsl_rng_uniform(r);
    }

  gsl_sort_smallest (small, k, x, 1, N);

  printf ("%d smallest values from %d\n", k, N);

  for (i = 0; i &#60; k; i++)
    {
      printf ("%d: %.18f\n", i, small[i]);
    }
  return 0;
}
</PRE>

<P>
The output lists the 5 smallest values, in ascending order,

</P>

<PRE class="example">
$ ./a.out 
5 smallest values from 100000
0: 0.000003489200025797
1: 0.000008199829608202
2: 0.000008953968062997
3: 0.000010712770745158
4: 0.000033531803637743
</PRE>



<H2><A NAME="SEC214" HREF="gsl_manual.html#TOC214">References and Further Reading</A></H2>

<P>
The subject of sorting is covered extensively in Knuth's
<CITE>Sorting and Searching</CITE>,

</P>

<UL class="itemize">
<LI>

Donald E. Knuth, <CITE>The Art of Computer Programming: Sorting and
Searching</CITE> (Vol 3, 3rd Ed, 1997), Addison-Wesley, ISBN 0201896850.
</UL>

<P>
The Heapsort algorithm is described in the following book,

</P>

<UL class="itemize">
<LI>Robert Sedgewick, <CITE>Algorithms in C</CITE>, Addison-Wesley,

ISBN 0201514257.
</UL>



<H1><A NAME="SEC215" HREF="gsl_manual.html#TOC215">BLAS Support</A></H1>
<P>
<A NAME="IDX1028"></A>
<A NAME="IDX1029"></A>
<A NAME="IDX1030"></A>
<A NAME="IDX1031"></A>
<A NAME="IDX1032"></A>
<A NAME="IDX1033"></A>

</P>
<P>
The Basic Linear Algebra Subprograms (BLAS) define a set of fundamental
operations on vectors and matrices which can be used to create optimized
higher-level linear algebra functionality.

</P>
<P>
The library provides a low-level layer which corresponds directly to the
C-language BLAS standard, referred to here as "CBLAS", and a
higher-level interface for operations on GSL vectors and matrices.
Users who are interested in simple operations on GSL vector and matrix
objects should use the high-level layer, which is declared in the file
<CODE>gsl_blas.h</CODE>.  This should satisfy the needs of most users.  Note
that GSL matrices are implemented using dense-storage so the interface
only includes the corresponding dense-storage BLAS functions.  The full
BLAS functionality for band-format and packed-format matrices is
available through the low-level CBLAS interface.

</P>
<P>
The interface for the <CODE>gsl_cblas</CODE> layer is specified in the file
<CODE>gsl_cblas.h</CODE>.  This interface corresponds to the BLAS Technical
Forum's draft standard for the C interface to legacy BLAS
implementations. Users who have access to other conforming CBLAS
implementations can use these in place of the version provided by the
library.  Note that users who have only a Fortran BLAS library can
use a CBLAS conformant wrapper to convert it into a CBLAS
library.  A reference CBLAS wrapper for legacy Fortran
implementations exists as part of the draft CBLAS standard and can
be obtained from Netlib.  The complete set of CBLAS functions is
listed in an appendix (see section <A HREF="gsl_manual.html#SEC525">GSL CBLAS Library</A>).

</P>
<P>
There are three levels of BLAS operations,

</P>
<DL COMPACT>

<DT><B>Level 1</B>
<DD>
Vector operations, e.g. y = \alpha x + y
<DT><B>Level 2</B>
<DD>
Matrix-vector operations, e.g. y = \alpha A x + \beta y
<DT><B>Level 3</B>
<DD>
Matrix-matrix operations, e.g. C = \alpha A B + C
</DL>
<P>
Each routine has a name which specifies the operation, the type of
matrices involved and their precisions.  Some of the most common
operations and their names are given below,

</P>
<DL COMPACT>

<DT><B>DOT</B>
<DD>
scalar product, x^T y
<DT><B>AXPY</B>
<DD>
vector sum, \alpha x + y
<DT><B>MV</B>
<DD>
matrix-vector product, A x
<DT><B>SV</B>
<DD>
matrix-vector solve, inv(A) x
<DT><B>MM</B>
<DD>
matrix-matrix product, A B
<DT><B>SM</B>
<DD>
matrix-matrix solve, inv(A) B
</DL>
<P>
The types of matrices are,

</P>
<DL COMPACT>

<DT><B>GE</B>
<DD>
general
<DT><B>GB</B>
<DD>
general band
<DT><B>SY</B>
<DD>
symmetric
<DT><B>SB</B>
<DD>
symmetric band
<DT><B>SP</B>
<DD>
symmetric packed
<DT><B>HE</B>
<DD>
hermitian
<DT><B>HB</B>
<DD>
hermitian band
<DT><B>HP</B>
<DD>
hermitian packed
<DT><B>TR</B>
<DD>
triangular 
<DT><B>TB</B>
<DD>
triangular band
<DT><B>TP</B>
<DD>
triangular packed
</DL>
<P>
Each operation is defined for four precisions,

</P>
<DL COMPACT>

<DT><B>S</B>
<DD>
single real
<DT><B>D</B>
<DD>
double real
<DT><B>C</B>
<DD>
single complex
<DT><B>Z</B>
<DD>
double complex
</DL>
<P>
Thus, for example, the name SGEMM stands for "single-precision
general matrix-matrix multiply" and ZGEMM stands for
"double-precision complex matrix-matrix multiply".

</P>



<H2><A NAME="SEC216" HREF="gsl_manual.html#TOC216">GSL BLAS Interface</A></H2>

<P>
GSL provides dense vector and matrix objects, based on the relevant
built-in types.  The library provides an interface to the BLAS
operations which apply to these objects.  The interface to this
functionality is given in the file <CODE>gsl_blas.h</CODE>.

</P>



<H3><A NAME="SEC217" HREF="gsl_manual.html#TOC217">Level 1</A></H3>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_sdsdot</B> <I>(float <VAR>alpha</VAR>, const gsl_vector_float * <VAR>x</VAR>, const gsl_vector_float * <VAR>y</VAR>, float * <VAR>result</VAR>)</I>
<DD><A NAME="IDX1034"></A>
<A NAME="IDX1035"></A>
This function computes the sum \alpha + x^T y for the vectors
<VAR>x</VAR> and <VAR>y</VAR>, returning the result in <VAR>result</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_sdot</B> <I>(const gsl_vector_float * <VAR>x</VAR>, const gsl_vector_float * <VAR>y</VAR>, float * <VAR>result</VAR>)</I>
<DD><A NAME="IDX1036"></A>
<DT><U>Function:</U> int <B>gsl_blas_dsdot</B> <I>(const gsl_vector_float * <VAR>x</VAR>, const gsl_vector_float * <VAR>y</VAR>, double * <VAR>result</VAR>)</I>
<DD><A NAME="IDX1037"></A>
<DT><U>Function:</U> int <B>gsl_blas_ddot</B> <I>(const gsl_vector * <VAR>x</VAR>, const gsl_vector * <VAR>y</VAR>, double * <VAR>result</VAR>)</I>
<DD><A NAME="IDX1038"></A>
These functions compute the scalar product x^T y for the vectors
<VAR>x</VAR> and <VAR>y</VAR>, returning the result in <VAR>result</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_cdotu</B> <I>(const gsl_vector_complex_float * <VAR>x</VAR>, const gsl_vector_complex_float * <VAR>y</VAR>, gsl_complex_float * <VAR>dotu</VAR>)</I>
<DD><A NAME="IDX1039"></A>
<DT><U>Function:</U> int <B>gsl_blas_zdotu</B> <I>(const gsl_vector_complex * <VAR>x</VAR>, const gsl_vector_complex * <VAR>y</VAR>, gsl_complex * <VAR>dotu</VAR>)</I>
<DD><A NAME="IDX1040"></A>
These functions compute the complex scalar product x^T y for the
vectors <VAR>x</VAR> and <VAR>y</VAR>, returning the result in <VAR>result</VAR>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_cdotc</B> <I>(const gsl_vector_complex_float * <VAR>x</VAR>, const gsl_vector_complex_float * <VAR>y</VAR>, gsl_complex_float * <VAR>dotc</VAR>)</I>
<DD><A NAME="IDX1041"></A>
<DT><U>Function:</U> int <B>gsl_blas_zdotc</B> <I>(const gsl_vector_complex * <VAR>x</VAR>, const gsl_vector_complex * <VAR>y</VAR>, gsl_complex * <VAR>dotc</VAR>)</I>
<DD><A NAME="IDX1042"></A>
These functions compute the complex conjugate scalar product x^H
y for the vectors <VAR>x</VAR> and <VAR>y</VAR>, returning the result in
<VAR>result</VAR>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> float <B>gsl_blas_snrm2</B> <I>(const gsl_vector_float * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1043"></A>
<DT><U>Function:</U> double <B>gsl_blas_dnrm2</B> <I>(const gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1044"></A>
<A NAME="IDX1045"></A>
These functions compute the Euclidean norm 
||x||_2 = \sqrt {\sum x_i^2} of the vector <VAR>x</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> float <B>gsl_blas_scnrm2</B> <I>(const gsl_vector_complex_float * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1046"></A>
<DT><U>Function:</U> double <B>gsl_blas_dznrm2</B> <I>(const gsl_vector_complex * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1047"></A>
These functions compute the Euclidean norm of the complex vector <VAR>x</VAR>,

<SPAN class="ifinfo">


<PRE class="example">
||x||_2 = \sqrt {\sum (\Re(x_i)^2 + \Im(x_i)^2)}.
</PRE>

</SPAN>

<P>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> float <B>gsl_blas_sasum</B> <I>(const gsl_vector_float * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1048"></A>
<DT><U>Function:</U> double <B>gsl_blas_dasum</B> <I>(const gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1049"></A>
<A NAME="IDX1050"></A>
These functions compute the absolute sum \sum |x_i| of the
elements of the vector <VAR>x</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> float <B>gsl_blas_scasum</B> <I>(const gsl_vector_complex_float * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1051"></A>
<DT><U>Function:</U> double <B>gsl_blas_dzasum</B> <I>(const gsl_vector_complex * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1052"></A>
These functions compute the sum of the magnitudes of the real and
imaginary parts of the complex vector <VAR>x</VAR>, 
\sum |\Re(x_i)| + |\Im(x_i)|.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> CBLAS_INDEX_t <B>gsl_blas_isamax</B> <I>(const gsl_vector_float * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1053"></A>
<DT><U>Function:</U> CBLAS_INDEX_t <B>gsl_blas_idamax</B> <I>(const gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1054"></A>
<DT><U>Function:</U> CBLAS_INDEX_t <B>gsl_blas_icamax</B> <I>(const gsl_vector_complex_float * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1055"></A>
<DT><U>Function:</U> CBLAS_INDEX_t <B>gsl_blas_izamax</B> <I>(const gsl_vector_complex * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1056"></A>
<A NAME="IDX1057"></A>
These functions return the index of the largest element of the vector
<VAR>x</VAR>. The largest element is determined by its absolute magnitude for
real vectors and by the sum of the magnitudes of the real and imaginary
parts |\Re(x_i)| + |\Im(x_i)| for complex vectors.  If the
largest value occurs several times then the index of the first
occurrence is returned.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_sswap</B> <I>(gsl_vector_float * <VAR>x</VAR>, gsl_vector_float * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1058"></A>
<DT><U>Function:</U> int <B>gsl_blas_dswap</B> <I>(gsl_vector * <VAR>x</VAR>, gsl_vector * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1059"></A>
<DT><U>Function:</U> int <B>gsl_blas_cswap</B> <I>(gsl_vector_complex_float * <VAR>x</VAR>, gsl_vector_complex_float * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1060"></A>
<DT><U>Function:</U> int <B>gsl_blas_zswap</B> <I>(gsl_vector_complex * <VAR>x</VAR>, gsl_vector_complex * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1061"></A>
<A NAME="IDX1062"></A>
These functions exchange the elements of the vectors <VAR>x</VAR> and <VAR>y</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_scopy</B> <I>(const gsl_vector_float * <VAR>x</VAR>, gsl_vector_float * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1063"></A>
<DT><U>Function:</U> int <B>gsl_blas_dcopy</B> <I>(const gsl_vector * <VAR>x</VAR>, gsl_vector * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1064"></A>
<DT><U>Function:</U> int <B>gsl_blas_ccopy</B> <I>(const gsl_vector_complex_float * <VAR>x</VAR>, gsl_vector_complex_float * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1065"></A>
<DT><U>Function:</U> int <B>gsl_blas_zcopy</B> <I>(const gsl_vector_complex * <VAR>x</VAR>, gsl_vector_complex * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1066"></A>
<A NAME="IDX1067"></A>
These functions copy the elements of the vector <VAR>x</VAR> into the vector
<VAR>y</VAR>.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_saxpy</B> <I>(float <VAR>alpha</VAR>, const gsl_vector_float * <VAR>x</VAR>, gsl_vector_float * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1068"></A>
<DT><U>Function:</U> int <B>gsl_blas_daxpy</B> <I>(double <VAR>alpha</VAR>, const gsl_vector * <VAR>x</VAR>, gsl_vector * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1069"></A>
<DT><U>Function:</U> int <B>gsl_blas_caxpy</B> <I>(const gsl_complex_float <VAR>alpha</VAR>, const gsl_vector_complex_float * <VAR>x</VAR>, gsl_vector_complex_float * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1070"></A>
<DT><U>Function:</U> int <B>gsl_blas_zaxpy</B> <I>(const gsl_complex <VAR>alpha</VAR>, const gsl_vector_complex * <VAR>x</VAR>, gsl_vector_complex * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1071"></A>
<A NAME="IDX1072"></A>
These functions compute the sum y = \alpha x + y for the vectors
<VAR>x</VAR> and <VAR>y</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_blas_sscal</B> <I>(float <VAR>alpha</VAR>, gsl_vector_float * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1073"></A>
<DT><U>Function:</U> void <B>gsl_blas_dscal</B> <I>(double <VAR>alpha</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1074"></A>
<DT><U>Function:</U> void <B>gsl_blas_cscal</B> <I>(const gsl_complex_float <VAR>alpha</VAR>, gsl_vector_complex_float * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1075"></A>
<DT><U>Function:</U> void <B>gsl_blas_zscal</B> <I>(const gsl_complex <VAR>alpha</VAR>, gsl_vector_complex * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1076"></A>
<DT><U>Function:</U> void <B>gsl_blas_csscal</B> <I>(float <VAR>alpha</VAR>, gsl_vector_complex_float * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1077"></A>
<DT><U>Function:</U> void <B>gsl_blas_zdscal</B> <I>(double <VAR>alpha</VAR>, gsl_vector_complex * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1078"></A>
<A NAME="IDX1079"></A>
These functions rescale the vector <VAR>x</VAR> by the multiplicative factor
<VAR>alpha</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_srotg</B> <I>(float <VAR>a</VAR>[], float <VAR>b</VAR>[], float <VAR>c</VAR>[], float <VAR>s</VAR>[])</I>
<DD><A NAME="IDX1080"></A>
<DT><U>Function:</U> int <B>gsl_blas_drotg</B> <I>(double <VAR>a</VAR>[], double <VAR>b</VAR>[], double <VAR>c</VAR>[], double <VAR>s</VAR>[])</I>
<DD><A NAME="IDX1081"></A>
<A NAME="IDX1082"></A>
<A NAME="IDX1083"></A>
These functions compute a Givens rotation (c,s) which zeroes the
vector (a,b),

<SPAN class="ifinfo">


<PRE class="example">
[  c  s ] [ a ] = [ r ]
[ -s  c ] [ b ]   [ 0 ]
</PRE>

</SPAN>

<P>
The variables <VAR>a</VAR> and <VAR>b</VAR> are overwritten by the routine.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_srot</B> <I>(gsl_vector_float * <VAR>x</VAR>, gsl_vector_float * <VAR>y</VAR>, float <VAR>c</VAR>, float <VAR>s</VAR>)</I>
<DD><A NAME="IDX1084"></A>
<DT><U>Function:</U> int <B>gsl_blas_drot</B> <I>(gsl_vector * <VAR>x</VAR>, gsl_vector * <VAR>y</VAR>, const double <VAR>c</VAR>, const double <VAR>s</VAR>)</I>
<DD><A NAME="IDX1085"></A>
These functions apply a Givens rotation (x', y') = (c x + s y, -s
x + c y) to the vectors <VAR>x</VAR>, <VAR>y</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_srotmg</B> <I>(float <VAR>d1</VAR>[], float <VAR>d2</VAR>[], float <VAR>b1</VAR>[], float <VAR>b2</VAR>, float <VAR>P</VAR>[])</I>
<DD><A NAME="IDX1086"></A>
<DT><U>Function:</U> int <B>gsl_blas_drotmg</B> <I>(double <VAR>d1</VAR>[], double <VAR>d2</VAR>[], double <VAR>b1</VAR>[], double <VAR>b2</VAR>, double <VAR>P</VAR>[])</I>
<DD><A NAME="IDX1087"></A>
<A NAME="IDX1088"></A>
<A NAME="IDX1089"></A>
These functions compute a modified Givens transformation.  The modified
Givens transformation is defined in the original Level-1 BLAS
specification, given in the references.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_srotm</B> <I>(gsl_vector_float * <VAR>x</VAR>, gsl_vector_float * <VAR>y</VAR>, const float <VAR>P</VAR>[])</I>
<DD><A NAME="IDX1090"></A>
<DT><U>Function:</U> int <B>gsl_blas_drotm</B> <I>(gsl_vector * <VAR>x</VAR>, gsl_vector * <VAR>y</VAR>, const double <VAR>P</VAR>[])</I>
<DD><A NAME="IDX1091"></A>
These functions apply a modified Givens transformation.  
</DL>

</P>


<H3><A NAME="SEC218" HREF="gsl_manual.html#TOC218">Level 2</A></H3>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_sgemv</B> <I>(CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, float <VAR>alpha</VAR>, const gsl_matrix_float * <VAR>A</VAR>, const gsl_vector_float * <VAR>x</VAR>, float <VAR>beta</VAR>, gsl_vector_float * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1092"></A>
<DT><U>Function:</U> int <B>gsl_blas_dgemv</B> <I>(CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, double <VAR>alpha</VAR>, const gsl_matrix * <VAR>A</VAR>, const gsl_vector * <VAR>x</VAR>, double <VAR>beta</VAR>, gsl_vector * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1093"></A>
<DT><U>Function:</U> int <B>gsl_blas_cgemv</B> <I>(CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, const gsl_complex_float <VAR>alpha</VAR>, const gsl_matrix_complex_float * <VAR>A</VAR>, const gsl_vector_complex_float * <VAR>x</VAR>, const gsl_complex_float <VAR>beta</VAR>, gsl_vector_complex_float * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1094"></A>
<DT><U>Function:</U> int <B>gsl_blas_zgemv</B> <I>(CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, const gsl_complex <VAR>alpha</VAR>, const gsl_matrix_complex * <VAR>A</VAR>, const gsl_vector_complex * <VAR>x</VAR>, const gsl_complex <VAR>beta</VAR>, gsl_vector_complex * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1095"></A>
<A NAME="IDX1096"></A>
These functions compute the matrix-vector product and sum y =
\alpha op(A) x + \beta y, where op(A) = A,
A^T, A^H for <VAR>TransA</VAR> = <CODE>CblasNoTrans</CODE>,
<CODE>CblasTrans</CODE>, <CODE>CblasConjTrans</CODE>.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_strmv</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_DIAG_t <VAR>Diag</VAR>, const gsl_matrix_float * <VAR>A</VAR>, gsl_vector_float * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1097"></A>
<DT><U>Function:</U> int <B>gsl_blas_dtrmv</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_DIAG_t <VAR>Diag</VAR>, const gsl_matrix * <VAR>A</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1098"></A>
<DT><U>Function:</U> int <B>gsl_blas_ctrmv</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_DIAG_t <VAR>Diag</VAR>, const gsl_matrix_complex_float * <VAR>A</VAR>, gsl_vector_complex_float * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1099"></A>
<DT><U>Function:</U> int <B>gsl_blas_ztrmv</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_DIAG_t <VAR>Diag</VAR>, const gsl_matrix_complex * <VAR>A</VAR>, gsl_vector_complex * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1100"></A>
<A NAME="IDX1101"></A>
These functions compute the matrix-vector product 
x =\alpha op(A) x for the triangular matrix <VAR>A</VAR>, where
op(A) = A, A^T, A^H for <VAR>TransA</VAR> =
<CODE>CblasNoTrans</CODE>, <CODE>CblasTrans</CODE>, <CODE>CblasConjTrans</CODE>.  When
<VAR>Uplo</VAR> is <CODE>CblasUpper</CODE> then the upper triangle of <VAR>A</VAR> is
used, and when <VAR>Uplo</VAR> is <CODE>CblasLower</CODE> then the lower triangle
of <VAR>A</VAR> is used.  If <VAR>Diag</VAR> is <CODE>CblasNonUnit</CODE> then the
diagonal of the matrix is used, but if <VAR>Diag</VAR> is <CODE>CblasUnit</CODE>
then the diagonal elements of the matrix <VAR>A</VAR> are taken as unity and
are not referenced.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_strsv</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_DIAG_t <VAR>Diag</VAR>, const gsl_matrix_float * <VAR>A</VAR>, gsl_vector_float * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1102"></A>
<DT><U>Function:</U> int <B>gsl_blas_dtrsv</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_DIAG_t <VAR>Diag</VAR>, const gsl_matrix * <VAR>A</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1103"></A>
<DT><U>Function:</U> int <B>gsl_blas_ctrsv</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_DIAG_t <VAR>Diag</VAR>, const gsl_matrix_complex_float * <VAR>A</VAR>, gsl_vector_complex_float * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1104"></A>
<DT><U>Function:</U> int <B>gsl_blas_ztrsv</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_DIAG_t <VAR>Diag</VAR>, const gsl_matrix_complex * <VAR>A</VAR>, gsl_vector_complex * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1105"></A>
<A NAME="IDX1106"></A>
These functions compute inv(op(A)) x for <VAR>x</VAR>, where
op(A) = A, A^T, A^H for <VAR>TransA</VAR> =
<CODE>CblasNoTrans</CODE>, <CODE>CblasTrans</CODE>, <CODE>CblasConjTrans</CODE>.  When
<VAR>Uplo</VAR> is <CODE>CblasUpper</CODE> then the upper triangle of <VAR>A</VAR> is
used, and when <VAR>Uplo</VAR> is <CODE>CblasLower</CODE> then the lower triangle
of <VAR>A</VAR> is used.  If <VAR>Diag</VAR> is <CODE>CblasNonUnit</CODE> then the
diagonal of the matrix is used, but if <VAR>Diag</VAR> is <CODE>CblasUnit</CODE>
then the diagonal elements of the matrix <VAR>A</VAR> are taken as unity and
are not referenced.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_ssymv</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, float <VAR>alpha</VAR>, const gsl_matrix_float * <VAR>A</VAR>, const gsl_vector_float * <VAR>x</VAR>, float <VAR>beta</VAR>, gsl_vector_float * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1107"></A>
<DT><U>Function:</U> int <B>gsl_blas_dsymv</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, double <VAR>alpha</VAR>, const gsl_matrix * <VAR>A</VAR>, const gsl_vector * <VAR>x</VAR>, double <VAR>beta</VAR>, gsl_vector * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1108"></A>
<A NAME="IDX1109"></A>
These functions compute the matrix-vector product and sum y =
\alpha A x + \beta y for the symmetric matrix <VAR>A</VAR>.  Since the
matrix <VAR>A</VAR> is symmetric only its upper half or lower half need to be
stored.  When <VAR>Uplo</VAR> is <CODE>CblasUpper</CODE> then the upper triangle
and diagonal of <VAR>A</VAR> are used, and when <VAR>Uplo</VAR> is
<CODE>CblasLower</CODE> then the lower triangle and diagonal of <VAR>A</VAR> are
used.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_chemv</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, const gsl_complex_float <VAR>alpha</VAR>, const gsl_matrix_complex_float * <VAR>A</VAR>, const gsl_vector_complex_float * <VAR>x</VAR>, const gsl_complex_float <VAR>beta</VAR>, gsl_vector_complex_float * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1110"></A>
<DT><U>Function:</U> int <B>gsl_blas_zhemv</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, const gsl_complex <VAR>alpha</VAR>, const gsl_matrix_complex * <VAR>A</VAR>, const gsl_vector_complex * <VAR>x</VAR>, const gsl_complex <VAR>beta</VAR>, gsl_vector_complex * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1111"></A>
<A NAME="IDX1112"></A>
These functions compute the matrix-vector product and sum y =
\alpha A x + \beta y for the hermitian matrix <VAR>A</VAR>.  Since the
matrix <VAR>A</VAR> is hermitian only its upper half or lower half need to be
stored.  When <VAR>Uplo</VAR> is <CODE>CblasUpper</CODE> then the upper triangle
and diagonal of <VAR>A</VAR> are used, and when <VAR>Uplo</VAR> is
<CODE>CblasLower</CODE> then the lower triangle and diagonal of <VAR>A</VAR> are
used.  The imaginary elements of the diagonal are automatically assumed
to be zero and are not referenced.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_sger</B> <I>(float <VAR>alpha</VAR>, const gsl_vector_float * <VAR>x</VAR>, const gsl_vector_float * <VAR>y</VAR>, gsl_matrix_float * <VAR>A</VAR>)</I>
<DD><A NAME="IDX1113"></A>
<DT><U>Function:</U> int <B>gsl_blas_dger</B> <I>(double <VAR>alpha</VAR>, const gsl_vector * <VAR>x</VAR>, const gsl_vector * <VAR>y</VAR>, gsl_matrix * <VAR>A</VAR>)</I>
<DD><A NAME="IDX1114"></A>
<DT><U>Function:</U> int <B>gsl_blas_cgeru</B> <I>(const gsl_complex_float <VAR>alpha</VAR>, const gsl_vector_complex_float * <VAR>x</VAR>, const gsl_vector_complex_float * <VAR>y</VAR>, gsl_matrix_complex_float * <VAR>A</VAR>)</I>
<DD><A NAME="IDX1115"></A>
<DT><U>Function:</U> int <B>gsl_blas_zgeru</B> <I>(const gsl_complex <VAR>alpha</VAR>, const gsl_vector_complex * <VAR>x</VAR>, const gsl_vector_complex * <VAR>y</VAR>, gsl_matrix_complex * <VAR>A</VAR>)</I>
<DD><A NAME="IDX1116"></A>
<A NAME="IDX1117"></A>
<A NAME="IDX1118"></A>
These functions compute the rank-1 update A = \alpha x y^T + A of
the matrix <VAR>A</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_cgerc</B> <I>(const gsl_complex_float <VAR>alpha</VAR>, const gsl_vector_complex_float * <VAR>x</VAR>, const gsl_vector_complex_float * <VAR>y</VAR>, gsl_matrix_complex_float * <VAR>A</VAR>)</I>
<DD><A NAME="IDX1119"></A>
<DT><U>Function:</U> int <B>gsl_blas_zgerc</B> <I>(const gsl_complex <VAR>alpha</VAR>, const gsl_vector_complex * <VAR>x</VAR>, const gsl_vector_complex * <VAR>y</VAR>, gsl_matrix_complex * <VAR>A</VAR>)</I>
<DD><A NAME="IDX1120"></A>
<A NAME="IDX1121"></A>
These functions compute the conjugate rank-1 update A = \alpha x
y^H + A of the matrix <VAR>A</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_ssyr</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, float <VAR>alpha</VAR>, const gsl_vector_float * <VAR>x</VAR>, gsl_matrix_float * <VAR>A</VAR>)</I>
<DD><A NAME="IDX1122"></A>
<DT><U>Function:</U> int <B>gsl_blas_dsyr</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, double <VAR>alpha</VAR>, const gsl_vector * <VAR>x</VAR>, gsl_matrix * <VAR>A</VAR>)</I>
<DD><A NAME="IDX1123"></A>
<A NAME="IDX1124"></A>
These functions compute the symmetric rank-1 update A = \alpha x
x^T + A of the symmetric matrix <VAR>A</VAR>.  Since the matrix <VAR>A</VAR> is
symmetric only its upper half or lower half need to be stored.  When
<VAR>Uplo</VAR> is <CODE>CblasUpper</CODE> then the upper triangle and diagonal of
<VAR>A</VAR> are used, and when <VAR>Uplo</VAR> is <CODE>CblasLower</CODE> then the
lower triangle and diagonal of <VAR>A</VAR> are used.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_cher</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, float <VAR>alpha</VAR>, const gsl_vector_complex_float * <VAR>x</VAR>, gsl_matrix_complex_float * <VAR>A</VAR>)</I>
<DD><A NAME="IDX1125"></A>
<DT><U>Function:</U> int <B>gsl_blas_zher</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, double <VAR>alpha</VAR>, const gsl_vector_complex * <VAR>x</VAR>, gsl_matrix_complex * <VAR>A</VAR>)</I>
<DD><A NAME="IDX1126"></A>
<A NAME="IDX1127"></A>
These functions compute the hermitian rank-1 update A = \alpha x
x^H + A of the hermitian matrix <VAR>A</VAR>.  Since the matrix <VAR>A</VAR> is
hermitian only its upper half or lower half need to be stored.  When
<VAR>Uplo</VAR> is <CODE>CblasUpper</CODE> then the upper triangle and diagonal of
<VAR>A</VAR> are used, and when <VAR>Uplo</VAR> is <CODE>CblasLower</CODE> then the
lower triangle and diagonal of <VAR>A</VAR> are used.  The imaginary elements
of the diagonal are automatically set to zero.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_ssyr2</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, float <VAR>alpha</VAR>, const gsl_vector_float * <VAR>x</VAR>, const gsl_vector_float * <VAR>y</VAR>, gsl_matrix_float * <VAR>A</VAR>)</I>
<DD><A NAME="IDX1128"></A>
<DT><U>Function:</U> int <B>gsl_blas_dsyr2</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, double <VAR>alpha</VAR>, const gsl_vector * <VAR>x</VAR>, const gsl_vector * <VAR>y</VAR>, gsl_matrix * <VAR>A</VAR>)</I>
<DD><A NAME="IDX1129"></A>
<A NAME="IDX1130"></A>
These functions compute the symmetric rank-2 update A = \alpha x
y^T + \alpha y x^T + A of the symmetric matrix <VAR>A</VAR>.  Since the
matrix <VAR>A</VAR> is symmetric only its upper half or lower half need to be
stored.  When <VAR>Uplo</VAR> is <CODE>CblasUpper</CODE> then the upper triangle
and diagonal of <VAR>A</VAR> are used, and when <VAR>Uplo</VAR> is
<CODE>CblasLower</CODE> then the lower triangle and diagonal of <VAR>A</VAR> are
used.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_cher2</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, const gsl_complex_float <VAR>alpha</VAR>, const gsl_vector_complex_float * <VAR>x</VAR>, const gsl_vector_complex_float * <VAR>y</VAR>, gsl_matrix_complex_float * <VAR>A</VAR>)</I>
<DD><A NAME="IDX1131"></A>
<DT><U>Function:</U> int <B>gsl_blas_zher2</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, const gsl_complex <VAR>alpha</VAR>, const gsl_vector_complex * <VAR>x</VAR>, const gsl_vector_complex * <VAR>y</VAR>, gsl_matrix_complex * <VAR>A</VAR>)</I>
<DD><A NAME="IDX1132"></A>
<A NAME="IDX1133"></A>
These functions compute the hermitian rank-2 update A = \alpha x
y^H + \alpha^* y x^H A of the hermitian matrix <VAR>A</VAR>.  Since the
matrix <VAR>A</VAR> is hermitian only its upper half or lower half need to be
stored.  When <VAR>Uplo</VAR> is <CODE>CblasUpper</CODE> then the upper triangle
and diagonal of <VAR>A</VAR> are used, and when <VAR>Uplo</VAR> is
<CODE>CblasLower</CODE> then the lower triangle and diagonal of <VAR>A</VAR> are
used.  The imaginary elements of the diagonal are automatically set to zero.
</DL>

</P>


<H3><A NAME="SEC219" HREF="gsl_manual.html#TOC219">Level 3</A></H3>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_sgemm</B> <I>(CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_TRANSPOSE_t <VAR>TransB</VAR>, float <VAR>alpha</VAR>, const gsl_matrix_float * <VAR>A</VAR>, const gsl_matrix_float * <VAR>B</VAR>, float <VAR>beta</VAR>, gsl_matrix_float * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1134"></A>
<DT><U>Function:</U> int <B>gsl_blas_dgemm</B> <I>(CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_TRANSPOSE_t <VAR>TransB</VAR>, double <VAR>alpha</VAR>, const gsl_matrix * <VAR>A</VAR>, const gsl_matrix * <VAR>B</VAR>, double <VAR>beta</VAR>, gsl_matrix * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1135"></A>
<DT><U>Function:</U> int <B>gsl_blas_cgemm</B> <I>(CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_TRANSPOSE_t <VAR>TransB</VAR>, const gsl_complex_float <VAR>alpha</VAR>, const gsl_matrix_complex_float * <VAR>A</VAR>, const gsl_matrix_complex_float * <VAR>B</VAR>, const gsl_complex_float <VAR>beta</VAR>, gsl_matrix_complex_float * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1136"></A>
<DT><U>Function:</U> int <B>gsl_blas_zgemm</B> <I>(CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_TRANSPOSE_t <VAR>TransB</VAR>, const gsl_complex <VAR>alpha</VAR>, const gsl_matrix_complex * <VAR>A</VAR>, const gsl_matrix_complex * <VAR>B</VAR>, const gsl_complex <VAR>beta</VAR>, gsl_matrix_complex * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1137"></A>
<A NAME="IDX1138"></A>
These functions compute the matrix-matrix product and sum C =
\alpha op(A) op(B) + \beta C where op(A) = A, A^T,
A^H for <VAR>TransA</VAR> = <CODE>CblasNoTrans</CODE>, <CODE>CblasTrans</CODE>,
<CODE>CblasConjTrans</CODE> and similarly for the parameter <VAR>TransB</VAR>.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_ssymm</B> <I>(CBLAS_SIDE_t <VAR>Side</VAR>, CBLAS_UPLO_t <VAR>Uplo</VAR>, float <VAR>alpha</VAR>, const gsl_matrix_float * <VAR>A</VAR>, const gsl_matrix_float * <VAR>B</VAR>, float <VAR>beta</VAR>, gsl_matrix_float * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1139"></A>
<DT><U>Function:</U> int <B>gsl_blas_dsymm</B> <I>(CBLAS_SIDE_t <VAR>Side</VAR>, CBLAS_UPLO_t <VAR>Uplo</VAR>, double <VAR>alpha</VAR>, const gsl_matrix * <VAR>A</VAR>, const gsl_matrix * <VAR>B</VAR>, double <VAR>beta</VAR>, gsl_matrix * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1140"></A>
<DT><U>Function:</U> int <B>gsl_blas_csymm</B> <I>(CBLAS_SIDE_t <VAR>Side</VAR>, CBLAS_UPLO_t <VAR>Uplo</VAR>, const gsl_complex_float <VAR>alpha</VAR>, const gsl_matrix_complex_float * <VAR>A</VAR>, const gsl_matrix_complex_float * <VAR>B</VAR>, const gsl_complex_float <VAR>beta</VAR>, gsl_matrix_complex_float * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1141"></A>
<DT><U>Function:</U> int <B>gsl_blas_zsymm</B> <I>(CBLAS_SIDE_t <VAR>Side</VAR>, CBLAS_UPLO_t <VAR>Uplo</VAR>, const gsl_complex <VAR>alpha</VAR>, const gsl_matrix_complex * <VAR>A</VAR>, const gsl_matrix_complex * <VAR>B</VAR>, const gsl_complex <VAR>beta</VAR>, gsl_matrix_complex * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1142"></A>
<A NAME="IDX1143"></A>
These functions compute the matrix-matrix product and sum C =
\alpha A B + \beta C for <VAR>Side</VAR> is <CODE>CblasLeft</CODE> and C =
\alpha B A + \beta C for <VAR>Side</VAR> is <CODE>CblasRight</CODE>, where the
matrix <VAR>A</VAR> is symmetric.  When <VAR>Uplo</VAR> is <CODE>CblasUpper</CODE> then
the upper triangle and diagonal of <VAR>A</VAR> are used, and when <VAR>Uplo</VAR>
is <CODE>CblasLower</CODE> then the lower triangle and diagonal of <VAR>A</VAR> are
used.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_chemm</B> <I>(CBLAS_SIDE_t <VAR>Side</VAR>, CBLAS_UPLO_t <VAR>Uplo</VAR>, const gsl_complex_float <VAR>alpha</VAR>, const gsl_matrix_complex_float * <VAR>A</VAR>, const gsl_matrix_complex_float * <VAR>B</VAR>, const gsl_complex_float <VAR>beta</VAR>, gsl_matrix_complex_float * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1144"></A>
<DT><U>Function:</U> int <B>gsl_blas_zhemm</B> <I>(CBLAS_SIDE_t <VAR>Side</VAR>, CBLAS_UPLO_t <VAR>Uplo</VAR>, const gsl_complex <VAR>alpha</VAR>, const gsl_matrix_complex * <VAR>A</VAR>, const gsl_matrix_complex * <VAR>B</VAR>, const gsl_complex <VAR>beta</VAR>, gsl_matrix_complex * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1145"></A>
<A NAME="IDX1146"></A>
These functions compute the matrix-matrix product and sum C =
\alpha A B + \beta C for <VAR>Side</VAR> is <CODE>CblasLeft</CODE> and C =
\alpha B A + \beta C for <VAR>Side</VAR> is <CODE>CblasRight</CODE>, where the
matrix <VAR>A</VAR> is hermitian.  When <VAR>Uplo</VAR> is <CODE>CblasUpper</CODE> then
the upper triangle and diagonal of <VAR>A</VAR> are used, and when <VAR>Uplo</VAR>
is <CODE>CblasLower</CODE> then the lower triangle and diagonal of <VAR>A</VAR> are
used.  The imaginary elements of the diagonal are automatically set to
zero.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_strmm</B> <I>(CBLAS_SIDE_t <VAR>Side</VAR>, CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_DIAG_t <VAR>Diag</VAR>, float <VAR>alpha</VAR>, const gsl_matrix_float * <VAR>A</VAR>, gsl_matrix_float * <VAR>B</VAR>)</I>
<DD><A NAME="IDX1147"></A>
<DT><U>Function:</U> int <B>gsl_blas_dtrmm</B> <I>(CBLAS_SIDE_t <VAR>Side</VAR>, CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_DIAG_t <VAR>Diag</VAR>, double <VAR>alpha</VAR>, const gsl_matrix * <VAR>A</VAR>, gsl_matrix * <VAR>B</VAR>)</I>
<DD><A NAME="IDX1148"></A>
<DT><U>Function:</U> int <B>gsl_blas_ctrmm</B> <I>(CBLAS_SIDE_t <VAR>Side</VAR>, CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_DIAG_t <VAR>Diag</VAR>, const gsl_complex_float <VAR>alpha</VAR>, const gsl_matrix_complex_float * <VAR>A</VAR>, gsl_matrix_complex_float * <VAR>B</VAR>)</I>
<DD><A NAME="IDX1149"></A>
<DT><U>Function:</U> int <B>gsl_blas_ztrmm</B> <I>(CBLAS_SIDE_t <VAR>Side</VAR>, CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_DIAG_t <VAR>Diag</VAR>, const gsl_complex <VAR>alpha</VAR>, const gsl_matrix_complex * <VAR>A</VAR>, gsl_matrix_complex * <VAR>B</VAR>)</I>
<DD><A NAME="IDX1150"></A>
<A NAME="IDX1151"></A>
These functions compute the matrix-matrix product B = \alpha op(A)
B for <VAR>Side</VAR> is <CODE>CblasLeft</CODE> and B = \alpha B op(A) for
<VAR>Side</VAR> is <CODE>CblasRight</CODE>.  The matrix <VAR>A</VAR> is triangular and
op(A) = A, A^T, A^H for <VAR>TransA</VAR> =
<CODE>CblasNoTrans</CODE>, <CODE>CblasTrans</CODE>, <CODE>CblasConjTrans</CODE> When
<VAR>Uplo</VAR> is <CODE>CblasUpper</CODE> then the upper triangle of <VAR>A</VAR> is
used, and when <VAR>Uplo</VAR> is <CODE>CblasLower</CODE> then the lower triangle
of <VAR>A</VAR> is used.  If <VAR>Diag</VAR> is <CODE>CblasNonUnit</CODE> then the
diagonal of <VAR>A</VAR> is used, but if <VAR>Diag</VAR> is <CODE>CblasUnit</CODE> then
the diagonal elements of the matrix <VAR>A</VAR> are taken as unity and are
not referenced.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_strsm</B> <I>(CBLAS_SIDE_t <VAR>Side</VAR>, CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_DIAG_t <VAR>Diag</VAR>, float <VAR>alpha</VAR>, const gsl_matrix_float * <VAR>A</VAR>, gsl_matrix_float * <VAR>B</VAR>)</I>
<DD><A NAME="IDX1152"></A>
<DT><U>Function:</U> int <B>gsl_blas_dtrsm</B> <I>(CBLAS_SIDE_t <VAR>Side</VAR>, CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_DIAG_t <VAR>Diag</VAR>, double <VAR>alpha</VAR>, const gsl_matrix * <VAR>A</VAR>, gsl_matrix * <VAR>B</VAR>)</I>
<DD><A NAME="IDX1153"></A>
<DT><U>Function:</U> int <B>gsl_blas_ctrsm</B> <I>(CBLAS_SIDE_t <VAR>Side</VAR>, CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_DIAG_t <VAR>Diag</VAR>, const gsl_complex_float <VAR>alpha</VAR>, const gsl_matrix_complex_float * <VAR>A</VAR>, gsl_matrix_complex_float * <VAR>B</VAR>)</I>
<DD><A NAME="IDX1154"></A>
<DT><U>Function:</U> int <B>gsl_blas_ztrsm</B> <I>(CBLAS_SIDE_t <VAR>Side</VAR>, CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>TransA</VAR>, CBLAS_DIAG_t <VAR>Diag</VAR>, const gsl_complex <VAR>alpha</VAR>, const gsl_matrix_complex * <VAR>A</VAR>, gsl_matrix_complex * <VAR>B</VAR>)</I>
<DD><A NAME="IDX1155"></A>
<A NAME="IDX1156"></A>
These functions compute the inverse-matrix matrix product 
B = \alpha op(inv(A))B for <VAR>Side</VAR> is 
<CODE>CblasLeft</CODE> and B = \alpha B op(inv(A)) for
<VAR>Side</VAR> is <CODE>CblasRight</CODE>.  The matrix <VAR>A</VAR> is triangular and
op(A) = A, A^T, A^H for <VAR>TransA</VAR> =
<CODE>CblasNoTrans</CODE>, <CODE>CblasTrans</CODE>, <CODE>CblasConjTrans</CODE> When
<VAR>Uplo</VAR> is <CODE>CblasUpper</CODE> then the upper triangle of <VAR>A</VAR> is
used, and when <VAR>Uplo</VAR> is <CODE>CblasLower</CODE> then the lower triangle
of <VAR>A</VAR> is used.  If <VAR>Diag</VAR> is <CODE>CblasNonUnit</CODE> then the
diagonal of <VAR>A</VAR> is used, but if <VAR>Diag</VAR> is <CODE>CblasUnit</CODE> then
the diagonal elements of the matrix <VAR>A</VAR> are taken as unity and are
not referenced.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_ssyrk</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>Trans</VAR>, float <VAR>alpha</VAR>, const gsl_matrix_float * <VAR>A</VAR>, float <VAR>beta</VAR>, gsl_matrix_float * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1157"></A>
<DT><U>Function:</U> int <B>gsl_blas_dsyrk</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>Trans</VAR>, double <VAR>alpha</VAR>, const gsl_matrix * <VAR>A</VAR>, double <VAR>beta</VAR>, gsl_matrix * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1158"></A>
<DT><U>Function:</U> int <B>gsl_blas_csyrk</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>Trans</VAR>, const gsl_complex_float <VAR>alpha</VAR>, const gsl_matrix_complex_float * <VAR>A</VAR>, const gsl_complex_float <VAR>beta</VAR>, gsl_matrix_complex_float * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1159"></A>
<DT><U>Function:</U> int <B>gsl_blas_zsyrk</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>Trans</VAR>, const gsl_complex <VAR>alpha</VAR>, const gsl_matrix_complex * <VAR>A</VAR>, const gsl_complex <VAR>beta</VAR>, gsl_matrix_complex * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1160"></A>
<A NAME="IDX1161"></A>
These functions compute a rank-k update of the symmetric matrix <VAR>C</VAR>,
C = \alpha A A^T + \beta C when <VAR>Trans</VAR> is
<CODE>CblasNoTrans</CODE> and C = \alpha A^T A + \beta C when
<VAR>Trans</VAR> is <CODE>CblasTrans</CODE>.  Since the matrix <VAR>C</VAR> is symmetric
only its upper half or lower half need to be stored.  When <VAR>Uplo</VAR> is
<CODE>CblasUpper</CODE> then the upper triangle and diagonal of <VAR>C</VAR> are
used, and when <VAR>Uplo</VAR> is <CODE>CblasLower</CODE> then the lower triangle
and diagonal of <VAR>C</VAR> are used.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_cherk</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>Trans</VAR>, float <VAR>alpha</VAR>, const gsl_matrix_complex_float * <VAR>A</VAR>, float <VAR>beta</VAR>, gsl_matrix_complex_float * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1162"></A>
<DT><U>Function:</U> int <B>gsl_blas_zherk</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>Trans</VAR>, double <VAR>alpha</VAR>, const gsl_matrix_complex * <VAR>A</VAR>, double <VAR>beta</VAR>, gsl_matrix_complex * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1163"></A>
<A NAME="IDX1164"></A>
These functions compute a rank-k update of the hermitian matrix <VAR>C</VAR>,
C = \alpha A A^H + \beta C when <VAR>Trans</VAR> is
<CODE>CblasNoTrans</CODE> and C = \alpha A^H A + \beta C when
<VAR>Trans</VAR> is <CODE>CblasTrans</CODE>.  Since the matrix <VAR>C</VAR> is hermitian
only its upper half or lower half need to be stored.  When <VAR>Uplo</VAR> is
<CODE>CblasUpper</CODE> then the upper triangle and diagonal of <VAR>C</VAR> are
used, and when <VAR>Uplo</VAR> is <CODE>CblasLower</CODE> then the lower triangle
and diagonal of <VAR>C</VAR> are used.  The imaginary elements of the
diagonal are automatically set to zero.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_ssyr2k</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>Trans</VAR>, float <VAR>alpha</VAR>, const gsl_matrix_float * <VAR>A</VAR>, const gsl_matrix_float * <VAR>B</VAR>, float <VAR>beta</VAR>, gsl_matrix_float * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1165"></A>
<DT><U>Function:</U> int <B>gsl_blas_dsyr2k</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>Trans</VAR>, double <VAR>alpha</VAR>, const gsl_matrix * <VAR>A</VAR>, const gsl_matrix * <VAR>B</VAR>, double <VAR>beta</VAR>, gsl_matrix * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1166"></A>
<DT><U>Function:</U> int <B>gsl_blas_csyr2k</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>Trans</VAR>, const gsl_complex_float <VAR>alpha</VAR>, const gsl_matrix_complex_float * <VAR>A</VAR>, const gsl_matrix_complex_float * <VAR>B</VAR>, const gsl_complex_float <VAR>beta</VAR>, gsl_matrix_complex_float * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1167"></A>
<DT><U>Function:</U> int <B>gsl_blas_zsyr2k</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>Trans</VAR>, const gsl_complex <VAR>alpha</VAR>, const gsl_matrix_complex * <VAR>A</VAR>, const gsl_matrix_complex * <VAR>B</VAR>, const gsl_complex <VAR>beta</VAR>, gsl_matrix_complex * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1168"></A>
<A NAME="IDX1169"></A>
These functions compute a rank-2k update of the symmetric matrix <VAR>C</VAR>,
C = \alpha A B^T + \alpha B A^T + \beta C when <VAR>Trans</VAR> is
<CODE>CblasNoTrans</CODE> and C = \alpha A^T B + \alpha B^T A + \beta C when
<VAR>Trans</VAR> is <CODE>CblasTrans</CODE>.  Since the matrix <VAR>C</VAR> is symmetric
only its upper half or lower half need to be stored.  When <VAR>Uplo</VAR> is
<CODE>CblasUpper</CODE> then the upper triangle and diagonal of <VAR>C</VAR> are
used, and when <VAR>Uplo</VAR> is <CODE>CblasLower</CODE> then the lower triangle
and diagonal of <VAR>C</VAR> are used.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_blas_cher2k</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>Trans</VAR>, const gsl_complex_float <VAR>alpha</VAR>, const gsl_matrix_complex_float * <VAR>A</VAR>, const gsl_matrix_complex_float * <VAR>B</VAR>, float <VAR>beta</VAR>, gsl_matrix_complex_float * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1170"></A>
<DT><U>Function:</U> int <B>gsl_blas_zher2k</B> <I>(CBLAS_UPLO_t <VAR>Uplo</VAR>, CBLAS_TRANSPOSE_t <VAR>Trans</VAR>, const gsl_complex <VAR>alpha</VAR>, const gsl_matrix_complex * <VAR>A</VAR>, const gsl_matrix_complex * <VAR>B</VAR>, double <VAR>beta</VAR>, gsl_matrix_complex * <VAR>C</VAR>)</I>
<DD><A NAME="IDX1171"></A>
<A NAME="IDX1172"></A>
These functions compute a rank-2k update of the hermitian matrix <VAR>C</VAR>,
C = \alpha A B^H + \alpha^* B A^H + \beta C when <VAR>Trans</VAR> is
<CODE>CblasNoTrans</CODE> and C = \alpha A^H B + \alpha^* B^H A + \beta C when
<VAR>Trans</VAR> is <CODE>CblasConjTrans</CODE>.  Since the matrix <VAR>C</VAR> is hermitian
only its upper half or lower half need to be stored.  When <VAR>Uplo</VAR> is
<CODE>CblasUpper</CODE> then the upper triangle and diagonal of <VAR>C</VAR> are
used, and when <VAR>Uplo</VAR> is <CODE>CblasLower</CODE> then the lower triangle
and diagonal of <VAR>C</VAR> are used.  The imaginary elements of the
diagonal are automatically set to zero.
</DL>

</P>


<H2><A NAME="SEC220" HREF="gsl_manual.html#TOC220">Examples</A></H2>

<P>
The following program computes the product of two matrices using the
Level-3 BLAS function DGEMM,

<SPAN class="ifinfo">


<PRE class="example">
[ 0.11 0.12 0.13 ]  [ 1011 1012 ]     [ 367.76 368.12 ]
[ 0.21 0.22 0.23 ]  [ 1021 1022 ]  =  [ 674.06 674.72 ]
                    [ 1031 1032 ]
</PRE>

</SPAN>

<P>
The matrices are stored in row major order, according to the C convention 
for arrays.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_blas.h&#62;

int
main (void)
{
  double a[] = { 0.11, 0.12, 0.13,
                 0.21, 0.22, 0.23 };

  double b[] = { 1011, 1012,
                 1021, 1022,
                 1031, 1032 };

  double c[] = { 0.00, 0.00,
                 0.00, 0.00 };

  gsl_matrix_view A = gsl_matrix_view_array(a, 2, 3);
  gsl_matrix_view B = gsl_matrix_view_array(b, 3, 2);
  gsl_matrix_view C = gsl_matrix_view_array(c, 2, 2);

  /* Compute C = A B */

  gsl_blas_dgemm (CblasNoTrans, CblasNoTrans,
                  1.0, &#38;A.matrix, &#38;B.matrix,
                  0.0, &#38;C.matrix);

  printf ("[ %g, %g\n", c[0], c[1]);
  printf ("  %g, %g ]\n", c[2], c[3]);

  return 0;  
}
</PRE>

<P>
Here is the output from the program,

</P>

<PRE class="example">
$ ./a.out
[ 367.76, 368.12
  674.06, 674.72 ]</PRE>



<H2><A NAME="SEC221" HREF="gsl_manual.html#TOC221">References and Further Reading</A></H2>

<P>
Information on the BLAS standards, including both the legacy and
draft interface standards, is available online from the BLAS
Homepage and BLAS Technical Forum web-site.

</P>

<UL class="itemize">
<LI>

<CITE>BLAS Homepage</CITE> <BR>
<A HREF="http://www.netlib.org/blas/">http://www.netlib.org/blas/</A>
<LI>

<CITE>BLAS Technical Forum</CITE> <BR>
<A HREF="http://www.netlib.org/cgi-bin/checkout/blast/blast.pl">http://www.netlib.org/cgi-bin/checkout/blast/blast.pl</A>
</UL>

<P>
The following papers contain the specifications for Level 1, Level 2 and
Level 3 BLAS.

</P>

<UL class="itemize">
<LI>

C. Lawson, R. Hanson, D. Kincaid, F. Krogh, "Basic Linear Algebra
Subprograms for Fortran Usage", <CITE>ACM Transactions on Mathematical
Software</CITE>, Vol. 5 (1979), Pages 308--325.

<LI>

J.J. Dongarra, J. DuCroz, S. Hammarling, R. Hanson, "An Extended Set of
Fortran Basic Linear Algebra Subprograms", <CITE>ACM Transactions on
Mathematical Software</CITE>, Vol. 14, No. 1 (1988), Pages 1--32.

<LI>

J.J. Dongarra, I. Duff, J. DuCroz, S. Hammarling, "A Set of
Level 3 Basic Linear Algebra Subprograms", <CITE>ACM Transactions on
Mathematical Software</CITE>, Vol. 16 (1990), Pages 1--28.
</UL>

<P>
Postscript versions of the latter two papers are available from
<A HREF="http://www.netlib.org/blas/">http://www.netlib.org/blas/</A>. A CBLAS wrapper for Fortran BLAS
libraries is available from the same location.

</P>


<H1><A NAME="SEC222" HREF="gsl_manual.html#TOC222">Linear Algebra</A></H1>
<P>
<A NAME="IDX1173"></A>
<A NAME="IDX1174"></A>
<A NAME="IDX1175"></A>
<A NAME="IDX1176"></A>

</P>
<P>
This chapter describes functions for solving linear systems.  The
library provides simple linear algebra operations which operate directly
on the <CODE>gsl_vector</CODE> and <CODE>gsl_matrix</CODE> objects.  These are
intended for use with "small" systems where simple algorithms are
acceptable.

</P>
<P>
<A NAME="IDX1177"></A>
Anyone interested in large systems will want to use the sophisticated
routines found in LAPACK. The Fortran version of LAPACK is
recommended as the standard package for large-scale linear algebra.  It
supports blocked algorithms, specialized data representations and other
optimizations.

</P>
<P>
The functions described in this chapter are declared in the header file
<TT>'gsl_linalg.h'</TT>.

</P>



<H2><A NAME="SEC223" HREF="gsl_manual.html#TOC223">LU Decomposition</A></H2>
<P>
<A NAME="IDX1178"></A>

</P>
<P>
A general square matrix A has an LU decomposition into
upper and lower triangular matrices,

<SPAN class="ifinfo">


<PRE class="example">
P A = L U
</PRE>

</SPAN>

<P>
where P is a permutation matrix, L is unit lower
triangular matrix and U is upper triangular matrix. For square
matrices this decomposition can be used to convert the linear system
A x = b into a pair of triangular systems (L y = P b,
U x = y), which can be solved by forward and back-substitution.
Note that the LU decomposition is valid for singular matrices.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_LU_decomp</B> <I>(gsl_matrix * <VAR>A</VAR>, gsl_permutation * <VAR>p</VAR>, int * <VAR>signum</VAR>)</I>
<DD><A NAME="IDX1179"></A>
<DT><U>Function:</U> int <B>gsl_linalg_complex_LU_decomp</B> <I>(gsl_matrix_complex * <VAR>A</VAR>, gsl_permutation * <VAR>p</VAR>, int * <VAR>signum</VAR>)</I>
<DD><A NAME="IDX1180"></A>
These functions factorize the square matrix <VAR>A</VAR> into the LU
decomposition PA = LU.  On output the diagonal and upper
triangular part of the input matrix <VAR>A</VAR> contain the matrix
U. The lower triangular part of the input matrix (excluding the
diagonal) contains L.  The diagonal elements of L are
unity, and are not stored.

</P>
<P>
The permutation matrix P is encoded in the permutation
<VAR>p</VAR>. The j-th column of the matrix P is given by the
k-th column of the identity matrix, where k = p_j the
j-th element of the permutation vector. The sign of the
permutation is given by <VAR>signum</VAR>. It has the value (-1)^n,
where n is the number of interchanges in the permutation.

</P>
<P>
The algorithm used in the decomposition is Gaussian Elimination with
partial pivoting (Golub &#38; Van Loan, <CITE>Matrix Computations</CITE>,
Algorithm 3.4.1).
</DL>

</P>
<P>
<A NAME="IDX1181"></A>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_LU_solve</B> <I>(const gsl_matrix * <VAR>LU</VAR>, const gsl_permutation * <VAR>p</VAR>, const gsl_vector * <VAR>b</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1182"></A>
<DT><U>Function:</U> int <B>gsl_linalg_complex_LU_solve</B> <I>(const gsl_matrix_complex * <VAR>LU</VAR>, const gsl_permutation * <VAR>p</VAR>, const gsl_vector_complex * <VAR>b</VAR>, gsl_vector_complex * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1183"></A>
These functions solve the square system A x = b using the LU
decomposition of A into (<VAR>LU</VAR>, <VAR>p</VAR>) given by
<CODE>gsl_linalg_LU_decomp</CODE> or <CODE>gsl_linalg_complex_LU_decomp</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_LU_svx</B> <I>(const gsl_matrix * <VAR>LU</VAR>, const gsl_permutation * <VAR>p</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1184"></A>
<DT><U>Function:</U> int <B>gsl_linalg_complex_LU_svx</B> <I>(const gsl_matrix_complex * <VAR>LU</VAR>, const gsl_permutation * <VAR>p</VAR>, gsl_vector_complex * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1185"></A>
These functions solve the square system A x = b in-place using the
LU decomposition of A into (<VAR>LU</VAR>,<VAR>p</VAR>). On input
<VAR>x</VAR> should contain the right-hand side b, which is replaced
by the solution on output.
</DL>

</P>
<P>
<A NAME="IDX1186"></A>
<A NAME="IDX1187"></A>
<A NAME="IDX1188"></A>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_LU_refine</B> <I>(const gsl_matrix * <VAR>A</VAR>, const gsl_matrix * <VAR>LU</VAR>, const gsl_permutation * <VAR>p</VAR>, const gsl_vector * <VAR>b</VAR>, gsl_vector * <VAR>x</VAR>, gsl_vector * <VAR>residual</VAR>)</I>
<DD><A NAME="IDX1189"></A>
<DT><U>Function:</U> int <B>gsl_linalg_complex_LU_refine</B> <I>(const gsl_matrix_complex * <VAR>A</VAR>, const gsl_matrix_complex * <VAR>LU</VAR>, const gsl_permutation * <VAR>p</VAR>, const gsl_vector_complex * <VAR>b</VAR>, gsl_vector_complex * <VAR>x</VAR>, gsl_vector_complex * <VAR>residual</VAR>)</I>
<DD><A NAME="IDX1190"></A>
These functions apply an iterative improvement to <VAR>x</VAR>, the solution
of A x = b, using the LU decomposition of A into
(<VAR>LU</VAR>,<VAR>p</VAR>). The initial residual r = A x - b is also
computed and stored in <VAR>residual</VAR>.
</DL>

</P>
<P>
<A NAME="IDX1191"></A>
<A NAME="IDX1192"></A>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_LU_invert</B> <I>(const gsl_matrix * <VAR>LU</VAR>, const gsl_permutation * <VAR>p</VAR>, gsl_matrix * <VAR>inverse</VAR>)</I>
<DD><A NAME="IDX1193"></A>
<DT><U>Function:</U> int <B>gsl_linalg_complex_LU_invert</B> <I>(const gsl_matrix_complex * <VAR>LU</VAR>, const gsl_permutation * <VAR>p</VAR>, gsl_matrix_complex * <VAR>inverse</VAR>)</I>
<DD><A NAME="IDX1194"></A>
These functions compute the inverse of a matrix A from its
LU decomposition (<VAR>LU</VAR>,<VAR>p</VAR>), storing the result in the
matrix <VAR>inverse</VAR>. The inverse is computed by solving the system
A x = b for each column of the identity matrix.  It is preferable
to avoid direct use of the inverse whenever possible, as the linear
solver functions can obtain the same result more efficiently and
reliably (consult any introductory textbook on numerical linear algebra
for details).
</DL>

</P>
<P>
<A NAME="IDX1195"></A>
<A NAME="IDX1196"></A>
<DL>
<DT><U>Function:</U> double <B>gsl_linalg_LU_det</B> <I>(gsl_matrix * <VAR>LU</VAR>, int <VAR>signum</VAR>)</I>
<DD><A NAME="IDX1197"></A>
<DT><U>Function:</U> gsl_complex <B>gsl_linalg_complex_LU_det</B> <I>(gsl_matrix_complex * <VAR>LU</VAR>, int <VAR>signum</VAR>)</I>
<DD><A NAME="IDX1198"></A>
These functions compute the determinant of a matrix A from its
LU decomposition, <VAR>LU</VAR>. The determinant is computed as the
product of the diagonal elements of U and the sign of the row
permutation <VAR>signum</VAR>.
</DL>

</P>
<P>
<A NAME="IDX1199"></A>
<DL>
<DT><U>Function:</U> double <B>gsl_linalg_LU_lndet</B> <I>(gsl_matrix * <VAR>LU</VAR>)</I>
<DD><A NAME="IDX1200"></A>
<DT><U>Function:</U> double <B>gsl_linalg_complex_LU_lndet</B> <I>(gsl_matrix_complex * <VAR>LU</VAR>)</I>
<DD><A NAME="IDX1201"></A>
These functions compute the logarithm of the absolute value of the
determinant of a matrix A, \ln|\det(A)|, from its LU
decomposition, <VAR>LU</VAR>.  This function may be useful if the direct
computation of the determinant would overflow or underflow.
</DL>

</P>
<P>
<A NAME="IDX1202"></A>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_LU_sgndet</B> <I>(gsl_matrix * <VAR>LU</VAR>, int <VAR>signum</VAR>)</I>
<DD><A NAME="IDX1203"></A>
<DT><U>Function:</U> gsl_complex <B>gsl_linalg_complex_LU_sgndet</B> <I>(gsl_matrix_complex * <VAR>LU</VAR>, int <VAR>signum</VAR>)</I>
<DD><A NAME="IDX1204"></A>
These functions compute the sign or phase factor of the determinant of a
matrix A, \det(A)/|\det(A)|, from its LU decomposition,
<VAR>LU</VAR>.
</DL>

</P>


<H2><A NAME="SEC224" HREF="gsl_manual.html#TOC224">QR Decomposition</A></H2>
<P>
<A NAME="IDX1205"></A>

</P>
<P>
A general rectangular M-by-N matrix A has a
QR decomposition into the product of an orthogonal
M-by-M square matrix Q (where Q^T Q = I) and
an M-by-N right-triangular matrix R,

<SPAN class="ifinfo">


<PRE class="example">
A = Q R
</PRE>

</SPAN>

<P>
This decomposition can be used to convert the linear system A x =
b into the triangular system R x = Q^T b, which can be solved by
back-substitution. Another use of the QR decomposition is to
compute an orthonormal basis for a set of vectors. The first N
columns of Q form an orthonormal basis for the range of A,
ran(A), when A has full column rank.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QR_decomp</B> <I>(gsl_matrix * <VAR>A</VAR>, gsl_vector * <VAR>tau</VAR>)</I>
<DD><A NAME="IDX1206"></A>
This function factorizes the M-by-N matrix <VAR>A</VAR> into
the QR decomposition A = Q R.  On output the diagonal and
upper triangular part of the input matrix contain the matrix
R. The vector <VAR>tau</VAR> and the columns of the lower triangular
part of the matrix <VAR>A</VAR> contain the Householder coefficients and
Householder vectors which encode the orthogonal matrix <VAR>Q</VAR>.  The
vector <VAR>tau</VAR> must be of length k=\min(M,N). The matrix
Q is related to these components by, Q = Q_k ... Q_2 Q_1
where Q_i = I - \tau_i v_i v_i^T and v_i is the
Householder vector v_i =
(0,...,1,A(i+1,i),A(i+2,i),...,A(m,i)). This is the same storage scheme
as used by LAPACK.

</P>
<P>
The algorithm used to perform the decomposition is Householder QR (Golub
&#38; Van Loan, <CITE>Matrix Computations</CITE>, Algorithm 5.2.1).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QR_solve</B> <I>(const gsl_matrix * <VAR>QR</VAR>, const gsl_vector * <VAR>tau</VAR>, const gsl_vector * <VAR>b</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1207"></A>
This function solves the square system A x = b using the QR
decomposition of A into (<VAR>QR</VAR>, <VAR>tau</VAR>) given by
<CODE>gsl_linalg_QR_decomp</CODE>. The least-squares solution for rectangular systems can
be found using <CODE>gsl_linalg_QR_lssolve</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QR_svx</B> <I>(const gsl_matrix * <VAR>QR</VAR>, const gsl_vector * <VAR>tau</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1208"></A>
This function solves the square system A x = b in-place using the
QR decomposition of A into (<VAR>QR</VAR>,<VAR>tau</VAR>) given by
<CODE>gsl_linalg_QR_decomp</CODE>. On input <VAR>x</VAR> should contain the
right-hand side b, which is replaced by the solution on output.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QR_lssolve</B> <I>(const gsl_matrix * <VAR>QR</VAR>, const gsl_vector * <VAR>tau</VAR>, const gsl_vector * <VAR>b</VAR>, gsl_vector * <VAR>x</VAR>, gsl_vector * <VAR>residual</VAR>)</I>
<DD><A NAME="IDX1209"></A>
This function finds the least squares solution to the overdetermined
system A x = b where the matrix <VAR>A</VAR> has more rows than
columns.  The least squares solution minimizes the Euclidean norm of the
residual, ||Ax - b||.The routine uses the QR decomposition
of A into (<VAR>QR</VAR>, <VAR>tau</VAR>) given by
<CODE>gsl_linalg_QR_decomp</CODE>.  The solution is returned in <VAR>x</VAR>.  The
residual is computed as a by-product and stored in <VAR>residual</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QR_QTvec</B> <I>(const gsl_matrix * <VAR>QR</VAR>, const gsl_vector * <VAR>tau</VAR>, gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX1210"></A>
This function applies the matrix Q^T encoded in the decomposition
(<VAR>QR</VAR>,<VAR>tau</VAR>) to the vector <VAR>v</VAR>, storing the result Q^T
v in <VAR>v</VAR>.  The matrix multiplication is carried out directly using
the encoding of the Householder vectors without needing to form the full
matrix Q^T.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QR_Qvec</B> <I>(const gsl_matrix * <VAR>QR</VAR>, const gsl_vector * <VAR>tau</VAR>, gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX1211"></A>
This function applies the matrix Q encoded in the decomposition
(<VAR>QR</VAR>,<VAR>tau</VAR>) to the vector <VAR>v</VAR>, storing the result Q
v in <VAR>v</VAR>.  The matrix multiplication is carried out directly using
the encoding of the Householder vectors without needing to form the full
matrix Q.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QR_Rsolve</B> <I>(const gsl_matrix * <VAR>QR</VAR>, const gsl_vector * <VAR>b</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1212"></A>
This function solves the triangular system R x = b for
<VAR>x</VAR>. It may be useful if the product b' = Q^T b has already
been computed using <CODE>gsl_linalg_QR_QTvec</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QR_Rsvx</B> <I>(const gsl_matrix * <VAR>QR</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1213"></A>
This function solves the triangular system R x = b for <VAR>x</VAR>
in-place. On input <VAR>x</VAR> should contain the right-hand side b
and is replaced by the solution on output. This function may be useful if
the product b' = Q^T b has already been computed using
<CODE>gsl_linalg_QR_QTvec</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QR_unpack</B> <I>(const gsl_matrix * <VAR>QR</VAR>, const gsl_vector * <VAR>tau</VAR>, gsl_matrix * <VAR>Q</VAR>, gsl_matrix * <VAR>R</VAR>)</I>
<DD><A NAME="IDX1214"></A>
This function unpacks the encoded QR decomposition
(<VAR>QR</VAR>,<VAR>tau</VAR>) into the matrices <VAR>Q</VAR> and <VAR>R</VAR>, where
<VAR>Q</VAR> is M-by-M and <VAR>R</VAR> is M-by-N. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QR_QRsolve</B> <I>(gsl_matrix * <VAR>Q</VAR>, gsl_matrix * <VAR>R</VAR>, const gsl_vector * <VAR>b</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1215"></A>
This function solves the system R x = Q^T b for <VAR>x</VAR>. It can
be used when the QR decomposition of a matrix is available in
unpacked form as (<VAR>Q</VAR>, <VAR>R</VAR>).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QR_update</B> <I>(gsl_matrix * <VAR>Q</VAR>, gsl_matrix * <VAR>R</VAR>, gsl_vector * <VAR>w</VAR>, const gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX1216"></A>
This function performs a rank-1 update w v^T of the QR
decomposition (<VAR>Q</VAR>, <VAR>R</VAR>). The update is given by Q'R' = Q
R + w v^T where the output matrices Q' and R' are also
orthogonal and right triangular. Note that <VAR>w</VAR> is destroyed by the
update.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_R_solve</B> <I>(const gsl_matrix * <VAR>R</VAR>, const gsl_vector * <VAR>b</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1217"></A>
This function solves the triangular system R x = b for the
N-by-N matrix <VAR>R</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_R_svx</B> <I>(const gsl_matrix * <VAR>R</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1218"></A>
This function solves the triangular system R x = b in-place. On
input <VAR>x</VAR> should contain the right-hand side b, which is
replaced by the solution on output.
</DL>

</P>


<H2><A NAME="SEC225" HREF="gsl_manual.html#TOC225">QR Decomposition with Column Pivoting</A></H2>
<P>
<A NAME="IDX1219"></A>

</P>
<P>
The QR decomposition can be extended to the rank deficient case
by introducing a column permutation P,

<SPAN class="ifinfo">


<PRE class="example">
A P = Q R
</PRE>

</SPAN>

<P>
The first r columns of Q form an orthonormal basis
for the range of A for a matrix with column rank r.  This
decomposition can also be used to convert the linear system A x =
b into the triangular system R y = Q^T b, x = P y, which can be
solved by back-substitution and permutation.  We denote the QR
decomposition with column pivoting by QRP^T since A = Q R
P^T.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QRPT_decomp</B> <I>(gsl_matrix * <VAR>A</VAR>, gsl_vector * <VAR>tau</VAR>, gsl_permutation * <VAR>p</VAR>, int * <VAR>signum</VAR>, gsl_vector * <VAR>norm</VAR>)</I>
<DD><A NAME="IDX1220"></A>
This function factorizes the M-by-N matrix <VAR>A</VAR> into
the QRP^T decomposition A = Q R P^T.  On output the
diagonal and upper triangular part of the input matrix contain the
matrix R. The permutation matrix P is stored in the
permutation <VAR>p</VAR>.  The sign of the permutation is given by
<VAR>signum</VAR>. It has the value (-1)^n, where n is the
number of interchanges in the permutation. The vector <VAR>tau</VAR> and the
columns of the lower triangular part of the matrix <VAR>A</VAR> contain the
Householder coefficients and vectors which encode the orthogonal matrix
<VAR>Q</VAR>.  The vector <VAR>tau</VAR> must be of length k=\min(M,N). The
matrix Q is related to these components by, Q = Q_k ... Q_2
Q_1 where Q_i = I - \tau_i v_i v_i^T and v_i is the
Householder vector v_i =
(0,...,1,A(i+1,i),A(i+2,i),...,A(m,i)). This is the same storage scheme
as used by LAPACK.  The vector <VAR>norm</VAR> is a workspace of length
<VAR>N</VAR> used for column pivoting.

</P>
<P>
The algorithm used to perform the decomposition is Householder QR with
column pivoting (Golub &#38; Van Loan, <CITE>Matrix Computations</CITE>, Algorithm
5.4.1).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QRPT_decomp2</B> <I>(const gsl_matrix * <VAR>A</VAR>, gsl_matrix * <VAR>q</VAR>, gsl_matrix * <VAR>r</VAR>, gsl_vector * <VAR>tau</VAR>, gsl_permutation * <VAR>p</VAR>, int * <VAR>signum</VAR>, gsl_vector * <VAR>norm</VAR>)</I>
<DD><A NAME="IDX1221"></A>
This function factorizes the matrix <VAR>A</VAR> into the decomposition
A = Q R P^T without modifying <VAR>A</VAR> itself and storing the
output in the separate matrices <VAR>q</VAR> and <VAR>r</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QRPT_solve</B> <I>(const gsl_matrix * <VAR>QR</VAR>, const gsl_vector * <VAR>tau</VAR>, const gsl_permutation * <VAR>p</VAR>, const gsl_vector * <VAR>b</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1222"></A>
This function solves the square system A x = b using the QRP^T
decomposition of A into (<VAR>QR</VAR>, <VAR>tau</VAR>, <VAR>p</VAR>) given by
<CODE>gsl_linalg_QRPT_decomp</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QRPT_svx</B> <I>(const gsl_matrix * <VAR>QR</VAR>, const gsl_vector * <VAR>tau</VAR>, const gsl_permutation * <VAR>p</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1223"></A>
This function solves the square system A x = b in-place using the
QRP^T decomposition of A into
(<VAR>QR</VAR>,<VAR>tau</VAR>,<VAR>p</VAR>). On input <VAR>x</VAR> should contain the
right-hand side b, which is replaced by the solution on output.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QRPT_QRsolve</B> <I>(const gsl_matrix * <VAR>Q</VAR>, const gsl_matrix * <VAR>R</VAR>, const gsl_permutation * <VAR>p</VAR>, const gsl_vector * <VAR>b</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1224"></A>
This function solves the square system R P^T x = Q^T b for
<VAR>x</VAR>. It can be used when the QR decomposition of a matrix is
available in unpacked form as (<VAR>Q</VAR>, <VAR>R</VAR>).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QRPT_update</B> <I>(gsl_matrix * <VAR>Q</VAR>, gsl_matrix * <VAR>R</VAR>, const gsl_permutation * <VAR>p</VAR>, gsl_vector * <VAR>u</VAR>, const gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX1225"></A>
This function performs a rank-1 update w v^T of the QRP^T
decomposition (<VAR>Q</VAR>, <VAR>R</VAR>, <VAR>p</VAR>). The update is given by
Q'R' = Q R + w v^T where the output matrices Q' and
R' are also orthogonal and right triangular. Note that <VAR>w</VAR> is
destroyed by the update. The permutation <VAR>p</VAR> is not changed.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QRPT_Rsolve</B> <I>(const gsl_matrix * <VAR>QR</VAR>, const gsl_permutation * <VAR>p</VAR>, const gsl_vector * <VAR>b</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1226"></A>
This function solves the triangular system R P^T x = b for the
N-by-N matrix R contained in <VAR>QR</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_QRPT_Rsvx</B> <I>(const gsl_matrix * <VAR>QR</VAR>, const gsl_permutation * <VAR>p</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1227"></A>
This function solves the triangular system R P^T x = b in-place
for the N-by-N matrix R contained in <VAR>QR</VAR>. On
input <VAR>x</VAR> should contain the right-hand side b, which is
replaced by the solution on output.
</DL>

</P>


<H2><A NAME="SEC226" HREF="gsl_manual.html#TOC226">Singular Value Decomposition</A></H2>
<P>
<A NAME="IDX1228"></A>
<A NAME="IDX1229"></A>

</P>
<P>
A general rectangular M-by-N matrix A has a
singular value decomposition (SVD) into the product of an
M-by-N orthogonal matrix U, an N-by-N
diagonal matrix of singular values S and the transpose of an
N-by-N orthogonal square matrix V,

<SPAN class="ifinfo">


<PRE class="example">
A = U S V^T
</PRE>

</SPAN>

<P>
The singular values
\sigma_i = S_{ii} are all non-negative and are
generally chosen to form a non-increasing sequence 
\sigma_1 &#62;= \sigma_2 &#62;= ... &#62;= \sigma_N &#62;= 0.

</P>
<P>
The singular value decomposition of a matrix has many practical uses.
The condition number of the matrix is given by the ratio of the largest
singular value to the smallest singular value. The presence of a zero
singular value indicates that the matrix is singular. The number of
non-zero singular values indicates the rank of the matrix.  In practice
singular value decomposition of a rank-deficient matrix will not produce
exact zeroes for singular values, due to finite numerical
precision. Small singular values should be edited by choosing a suitable
tolerance.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_SV_decomp</B> <I>(gsl_matrix * <VAR>A</VAR>, gsl_matrix * <VAR>V</VAR>, gsl_vector * <VAR>S</VAR>, gsl_vector * <VAR>work</VAR>)</I>
<DD><A NAME="IDX1230"></A>
This function factorizes the M-by-N matrix <VAR>A</VAR> into
the singular value decomposition A = U S V^T for 
M &#62;= N.  On output the matrix <VAR>A</VAR> is replaced by
U. The diagonal elements of the singular value matrix S
are stored in the vector <VAR>S</VAR>. The singular values are non-negative
and form a non-increasing sequence from S_1 to S_N. The
matrix <VAR>V</VAR> contains the elements of V in untransposed
form. To form the product U S V^T it is necessary to take the
transpose of <VAR>V</VAR>.  A workspace of length <VAR>N</VAR> is required in
<VAR>work</VAR>.

</P>
<P>
This routine uses the Golub-Reinsch SVD algorithm.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_SV_decomp_mod</B> <I>(gsl_matrix * <VAR>A</VAR>, gsl_matrix * <VAR>X</VAR>, gsl_matrix * <VAR>V</VAR>, gsl_vector * <VAR>S</VAR>, gsl_vector * <VAR>work</VAR>)</I>
<DD><A NAME="IDX1231"></A>
This function computes the SVD using the modified Golub-Reinsch
algorithm, which is faster for 
M&#62;&#62;N.  It requires the vector <VAR>work</VAR> of length <VAR>N</VAR> and the
N-by-N matrix <VAR>X</VAR> as additional working space.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_SV_decomp_jacobi</B> <I>(gsl_matrix * <VAR>A</VAR>, gsl_matrix * <VAR>V</VAR>, gsl_vector * <VAR>S</VAR>)</I>
<DD><A NAME="IDX1232"></A>
This function computes the SVD of the M-by-N matrix <VAR>A</VAR>
using one-sided Jacobi orthogonalization for 
M &#62;= N.  The Jacobi method can compute singular values to higher
relative accuracy than Golub-Reinsch algorithms (see references for
details).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_SV_solve</B> <I>(gsl_matrix * <VAR>U</VAR>, gsl_matrix * <VAR>V</VAR>, gsl_vector * <VAR>S</VAR>, const gsl_vector * <VAR>b</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1233"></A>
This function solves the system A x = b using the singular value
decomposition (<VAR>U</VAR>, <VAR>S</VAR>, <VAR>V</VAR>) of A given by
<CODE>gsl_linalg_SV_decomp</CODE>.

</P>
<P>
Only non-zero singular values are used in computing the solution. The
parts of the solution corresponding to singular values of zero are
ignored.  Other singular values can be edited out by setting them to
zero before calling this function. 

</P>
<P>
In the over-determined case where <VAR>A</VAR> has more rows than columns the
system is solved in the least squares sense, returning the solution
<VAR>x</VAR> which minimizes ||A x - b||_2.
</DL>

</P>


<H2><A NAME="SEC227" HREF="gsl_manual.html#TOC227">Cholesky Decomposition</A></H2>
<P>
<A NAME="IDX1234"></A>
<A NAME="IDX1235"></A>
<A NAME="IDX1236"></A>

</P>
<P>
A symmetric, positive definite square matrix A has a Cholesky
decomposition into a product of a lower triangular matrix L and
its transpose L^T,

<SPAN class="ifinfo">


<PRE class="example">
A = L L^T
</PRE>

</SPAN>

<P>
This is sometimes referred to as taking the square-root of a matrix. The
Cholesky decomposition can only be carried out when all the eigenvalues
of the matrix are positive.  This decomposition can be used to convert
the linear system A x = b into a pair of triangular systems
(L y = b, L^T x = y), which can be solved by forward and
back-substitution.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_cholesky_decomp</B> <I>(gsl_matrix * <VAR>A</VAR>)</I>
<DD><A NAME="IDX1237"></A>
This function factorizes the positive-definite square matrix <VAR>A</VAR>
into the Cholesky decomposition A = L L^T. On output the diagonal
and lower triangular part of the input matrix <VAR>A</VAR> contain the matrix
L. The upper triangular part of the input matrix contains
L^T, the diagonal terms being identical for both L and
L^T.  If the matrix is not positive-definite then the
decomposition will fail, returning the error code <CODE>GSL_EDOM</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_cholesky_solve</B> <I>(const gsl_matrix * <VAR>cholesky</VAR>, const gsl_vector * <VAR>b</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1238"></A>
This function solves the system A x = b using the Cholesky
decomposition of A into the matrix <VAR>cholesky</VAR> given by
<CODE>gsl_linalg_cholesky_decomp</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_cholesky_svx</B> <I>(const gsl_matrix * <VAR>cholesky</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1239"></A>
This function solves the system A x = b in-place using the
Cholesky decomposition of A into the matrix <VAR>cholesky</VAR> given
by <CODE>gsl_linalg_cholesky_decomp</CODE>. On input <VAR>x</VAR> should contain
the right-hand side b, which is replaced by the solution on
output.
</DL>

</P>


<H2><A NAME="SEC228" HREF="gsl_manual.html#TOC228">Tridiagonal Decomposition of Real Symmetric Matrices</A></H2>
<P>
<A NAME="IDX1240"></A>

</P>
<P>
A symmetric matrix A can be factorized by similarity
transformations into the form,

<SPAN class="ifinfo">


<PRE class="example">
A = Q T Q^T
</PRE>

</SPAN>

<P>
where Q is an orthogonal matrix and T is a symmetric
tridiagonal matrix.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_symmtd_decomp</B> <I>(gsl_matrix * <VAR>A</VAR>, gsl_vector * <VAR>tau</VAR>)</I>
<DD><A NAME="IDX1241"></A>
This function factorizes the symmetric square matrix <VAR>A</VAR> into the
symmetric tridiagonal decomposition Q T Q^T.  On output the
diagonal and subdiagonal part of the input matrix <VAR>A</VAR> contain the
tridiagonal matrix T.  The remaining lower triangular part of the
input matrix contains the Householder vectors which, together with the
Householder coefficients <VAR>tau</VAR>, encode the orthogonal matrix
Q. This storage scheme is the same as used by LAPACK.  The
upper triangular part of <VAR>A</VAR> is not referenced.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_symmtd_unpack</B> <I>(const gsl_matrix * <VAR>A</VAR>, const gsl_vector * <VAR>tau</VAR>, gsl_matrix * <VAR>Q</VAR>, gsl_vector * <VAR>diag</VAR>, gsl_vector * <VAR>subdiag</VAR>)</I>
<DD><A NAME="IDX1242"></A>
This function unpacks the encoded symmetric tridiagonal decomposition
(<VAR>A</VAR>, <VAR>tau</VAR>) obtained from <CODE>gsl_linalg_symmtd_decomp</CODE> into
the orthogonal matrix <VAR>Q</VAR>, the vector of diagonal elements <VAR>diag</VAR>
and the vector of subdiagonal elements <VAR>subdiag</VAR>.  
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_symmtd_unpack_T</B> <I>(const gsl_matrix * <VAR>A</VAR>, gsl_vector * <VAR>diag</VAR>, gsl_vector * <VAR>subdiag</VAR>)</I>
<DD><A NAME="IDX1243"></A>
This function unpacks the diagonal and subdiagonal of the encoded
symmetric tridiagonal decomposition (<VAR>A</VAR>, <VAR>tau</VAR>) obtained from
<CODE>gsl_linalg_symmtd_decomp</CODE> into the vectors <VAR>diag</VAR> and <VAR>subdiag</VAR>.
</DL>

</P>


<H2><A NAME="SEC229" HREF="gsl_manual.html#TOC229">Tridiagonal Decomposition of Hermitian Matrices</A></H2>
<P>
<A NAME="IDX1244"></A>

</P>
<P>
A hermitian matrix A can be factorized by similarity
transformations into the form,

<SPAN class="ifinfo">


<PRE class="example">
A = U T U^T
</PRE>

</SPAN>

<P>
where U is a unitary matrix and T is a real symmetric
tridiagonal matrix.

</P>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_hermtd_decomp</B> <I>(gsl_matrix_complex * <VAR>A</VAR>, gsl_vector_complex * <VAR>tau</VAR>)</I>
<DD><A NAME="IDX1245"></A>
This function factorizes the hermitian matrix <VAR>A</VAR> into the symmetric
tridiagonal decomposition U T U^T.  On output the real parts of
the diagonal and subdiagonal part of the input matrix <VAR>A</VAR> contain
the tridiagonal matrix T.  The remaining lower triangular part of
the input matrix contains the Householder vectors which, together with
the Householder coefficients <VAR>tau</VAR>, encode the orthogonal matrix
Q. This storage scheme is the same as used by LAPACK.  The
upper triangular part of <VAR>A</VAR> and imaginary parts of the diagonal are
not referenced.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_hermtd_unpack</B> <I>(const gsl_matrix_complex * <VAR>A</VAR>, const gsl_vector_complex * <VAR>tau</VAR>, gsl_matrix_complex * <VAR>Q</VAR>, gsl_vector * <VAR>diag</VAR>, gsl_vector * <VAR>subdiag</VAR>)</I>
<DD><A NAME="IDX1246"></A>
This function unpacks the encoded tridiagonal decomposition (<VAR>A</VAR>,
<VAR>tau</VAR>) obtained from <CODE>gsl_linalg_hermtd_decomp</CODE> into the
unitary matrix <VAR>U</VAR>, the real vector of diagonal elements <VAR>diag</VAR> and
the real vector of subdiagonal elements <VAR>subdiag</VAR>. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_hermtd_unpack_T</B> <I>(const gsl_matrix_complex * <VAR>A</VAR>, gsl_vector * <VAR>diag</VAR>, gsl_vector * <VAR>subdiag</VAR>)</I>
<DD><A NAME="IDX1247"></A>
This function unpacks the diagonal and subdiagonal of the encoded
tridiagonal decomposition (<VAR>A</VAR>, <VAR>tau</VAR>) obtained from the
<CODE>gsl_linalg_hermtd_decomp</CODE> into the real vectors
<VAR>diag</VAR> and <VAR>subdiag</VAR>.
</DL>

</P>


<H2><A NAME="SEC230" HREF="gsl_manual.html#TOC230">Bidiagonalization</A></H2>
<P>
<A NAME="IDX1248"></A>

</P>
<P>
A general matrix A can be factorized by similarity
transformations into the form,

<SPAN class="ifinfo">


<PRE class="example">
A = U B V^T
</PRE>

</SPAN>

<P>
where U and V are orthogonal matrices and B is a
N-by-N bidiagonal matrix with non-zero entries only on the
diagonal and superdiagonal.  The size of <VAR>U</VAR> is M-by-N
and the size of <VAR>V</VAR> is N-by-N.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_bidiag_decomp</B> <I>(gsl_matrix * <VAR>A</VAR>, gsl_vector * <VAR>tau_U</VAR>, gsl_vector * <VAR>tau_V</VAR>)</I>
<DD><A NAME="IDX1249"></A>
This function factorizes the M-by-N matrix <VAR>A</VAR> into
bidiagonal form U B V^T.  The diagonal and superdiagonal of the
matrix B are stored in the diagonal and superdiagonal of <VAR>A</VAR>.
The orthogonal matrices U and <VAR>V</VAR> are stored as compressed
Householder vectors in the remaining elements of <VAR>A</VAR>.  The
Householder coefficients are stored in the vectors <VAR>tau_U</VAR> and
<VAR>tau_V</VAR>.  The length of <VAR>tau_U</VAR> must equal the number of
elements in the diagonal of <VAR>A</VAR> and the length of <VAR>tau_V</VAR> should
be one element shorter.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_bidiag_unpack</B> <I>(const gsl_matrix * <VAR>A</VAR>, const gsl_vector * <VAR>tau_U</VAR>, gsl_matrix * <VAR>U</VAR>, const gsl_vector * <VAR>tau_V</VAR>, gsl_matrix * <VAR>V</VAR>, gsl_vector * <VAR>diag</VAR>, gsl_vector * <VAR>superdiag</VAR>)</I>
<DD><A NAME="IDX1250"></A>
This function unpacks the bidiagonal decomposition of <VAR>A</VAR> given by
<CODE>gsl_linalg_bidiag_decomp</CODE>, (<VAR>A</VAR>, <VAR>tau_U</VAR>, <VAR>tau_V</VAR>)
into the separate orthogonal matrices <VAR>U</VAR>, <VAR>V</VAR> and the diagonal
vector <VAR>diag</VAR> and superdiagonal <VAR>superdiag</VAR>.  Note that <VAR>U</VAR>
is stored as a compact M-by-N orthogonal matrix satisfying
U^T U = I for efficiency.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_bidiag_unpack2</B> <I>(gsl_matrix * <VAR>A</VAR>, gsl_vector * <VAR>tau_U</VAR>, gsl_vector * <VAR>tau_V</VAR>, gsl_matrix * <VAR>V</VAR>)</I>
<DD><A NAME="IDX1251"></A>
This function unpacks the bidiagonal decomposition of <VAR>A</VAR> given by
<CODE>gsl_linalg_bidiag_decomp</CODE>, (<VAR>A</VAR>, <VAR>tau_U</VAR>, <VAR>tau_V</VAR>)
into the separate orthogonal matrices <VAR>U</VAR>, <VAR>V</VAR> and the diagonal
vector <VAR>diag</VAR> and superdiagonal <VAR>superdiag</VAR>.  The matrix <VAR>U</VAR>
is stored in-place in <VAR>A</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_bidiag_unpack_B</B> <I>(const gsl_matrix * <VAR>A</VAR>, gsl_vector * <VAR>diag</VAR>, gsl_vector * <VAR>superdiag</VAR>)</I>
<DD><A NAME="IDX1252"></A>
This function unpacks the diagonal and superdiagonal of the bidiagonal
decomposition of <VAR>A</VAR> given by <CODE>gsl_linalg_bidiag_decomp</CODE>, into
the diagonal vector <VAR>diag</VAR> and superdiagonal vector <VAR>superdiag</VAR>.
</DL>

</P>


<H2><A NAME="SEC231" HREF="gsl_manual.html#TOC231">Householder Transformations</A></H2>
<P>
<A NAME="IDX1253"></A>
<A NAME="IDX1254"></A>
<A NAME="IDX1255"></A>

</P>
<P>
A Householder transformation is a rank-1 modification of the identity
matrix which can be used to zero out selected elements of a vector.  A
Householder matrix P takes the form,

<SPAN class="ifinfo">


<PRE class="example">
P = I - \tau v v^T
</PRE>

</SPAN>

<P>
where v is a vector (called the <I>Householder vector</I>) and
\tau = 2/(v^T v).  The functions described in this section use the
rank-1 structure of the Householder matrix to create and apply
Householder transformations efficiently.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_linalg_householder_transform</B> <I>(gsl_vector * <VAR>v</VAR>)</I>
<DD><A NAME="IDX1256"></A>
This function prepares a Householder transformation P = I - \tau v
v^T which can be used to zero all the elements of the input vector except
the first.  On output the transformation is stored in the vector <VAR>v</VAR>
and the scalar \tau is returned.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_householder_hm</B> <I>(double tau, const gsl_vector * v, gsl_matrix * A)</I>
<DD><A NAME="IDX1257"></A>
This function applies the Householder matrix P defined by the
scalar <VAR>tau</VAR> and the vector <VAR>v</VAR> to the left-hand side of the
matrix <VAR>A</VAR>. On output the result P A is stored in <VAR>A</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_householder_mh</B> <I>(double tau, const gsl_vector * v, gsl_matrix * A)</I>
<DD><A NAME="IDX1258"></A>
This function applies the Householder matrix P defined by the
scalar <VAR>tau</VAR> and the vector <VAR>v</VAR> to the right-hand side of the
matrix <VAR>A</VAR>. On output the result A P is stored in <VAR>A</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_householder_hv</B> <I>(double tau, const gsl_vector * v, gsl_vector * w)</I>
<DD><A NAME="IDX1259"></A>
This function applies the Householder transformation P defined by
the scalar <VAR>tau</VAR> and the vector <VAR>v</VAR> to the vector <VAR>w</VAR>.  On
output the result P w is stored in <VAR>w</VAR>.
</DL>

</P>



<H2><A NAME="SEC232" HREF="gsl_manual.html#TOC232">Householder solver for linear systems</A></H2>
<P>
<A NAME="IDX1260"></A>
<A NAME="IDX1261"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_HH_solve</B> <I>(gsl_matrix * <VAR>A</VAR>, const gsl_vector * <VAR>b</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1262"></A>
This function solves the system A x = b directly using
Householder transformations. On output the solution is stored in <VAR>x</VAR>
and <VAR>b</VAR> is not modified. The matrix <VAR>A</VAR> is destroyed by the
Householder transformations.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_HH_svx</B> <I>(gsl_matrix * <VAR>A</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1263"></A>
This function solves the system A x = b in-place using
Householder transformations.  On input <VAR>x</VAR> should contain the
right-hand side b, which is replaced by the solution on output.  The
matrix <VAR>A</VAR> is destroyed by the Householder transformations.
</DL>

</P>


<H2><A NAME="SEC233" HREF="gsl_manual.html#TOC233">Tridiagonal Systems</A></H2>
<P>
<A NAME="IDX1264"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_solve_tridiag</B> <I>(const gsl_vector * <VAR>diag</VAR>, const gsl_vector * <VAR>e</VAR>, const gsl_vector * <VAR>f</VAR>, const gsl_vector * <VAR>b</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1265"></A>
This function solves the general N-by-N system A x =
b where <VAR>A</VAR> is tridiagonal (
N &#62;= 2). The super-diagonal and
sub-diagonal vectors <VAR>e</VAR> and <VAR>f</VAR> must be one element shorter
than the diagonal vector <VAR>diag</VAR>.  The form of <VAR>A</VAR> for the 4-by-4
case is shown below,

<SPAN class="ifinfo">


<PRE class="example">
A = ( d_0 e_0  0   0  )
    ( f_0 d_1 e_1  0  )
    (  0  f_1 d_2 e_2 )
    (  0   0  f_2 d_3 )
</PRE>

</SPAN>

</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_solve_symm_tridiag</B> <I>(const gsl_vector * <VAR>diag</VAR>, const gsl_vector * <VAR>e</VAR>, const gsl_vector * <VAR>b</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1266"></A>
This function solves the general N-by-N system A x =
b where <VAR>A</VAR> is symmetric tridiagonal (
N &#62;= 2).  The off-diagonal vector
<VAR>e</VAR> must be one element shorter than the diagonal vector <VAR>diag</VAR>.
The form of <VAR>A</VAR> for the 4-by-4 case is shown below,

<SPAN class="ifinfo">


<PRE class="example">
A = ( d_0 e_0  0   0  )
    ( e_0 d_1 e_1  0  )
    (  0  e_1 d_2 e_2 )
    (  0   0  e_2 d_3 )
</PRE>

</SPAN>

</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_solve_cyc_tridiag</B> <I>(const gsl_vector * <VAR>diag</VAR>, const gsl_vector * <VAR>e</VAR>, const gsl_vector * <VAR>f</VAR>, const gsl_vector * <VAR>b</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1267"></A>
This function solves the general N-by-N system A x =
b where <VAR>A</VAR> is cyclic tridiagonal (
N &#62;= 3).  The cyclic super-diagonal and
sub-diagonal vectors <VAR>e</VAR> and <VAR>f</VAR> must have the same number of
elements as the diagonal vector <VAR>diag</VAR>.  The form of <VAR>A</VAR> for the
4-by-4 case is shown below,

<SPAN class="ifinfo">


<PRE class="example">
A = ( d_0 e_0  0  f_3 )
    ( f_0 d_1 e_1  0  )
    (  0  f_1 d_2 e_2 )
    ( e_3  0  f_2 d_3 )
</PRE>

</SPAN>

</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_linalg_solve_symm_cyc_tridiag</B> <I>(const gsl_vector * <VAR>diag</VAR>, const gsl_vector * <VAR>e</VAR>, const gsl_vector * <VAR>b</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1268"></A>
This function solves the general N-by-N system A x =
b where <VAR>A</VAR> is symmetric cyclic tridiagonal (
N &#62;= 3).  The cyclic
off-diagonal vector <VAR>e</VAR> must have the same number of elements as the
diagonal vector <VAR>diag</VAR>.  The form of <VAR>A</VAR> for the 4-by-4 case is
shown below,

<SPAN class="ifinfo">


<PRE class="example">
A = ( d_0 e_0  0  e_3 )
    ( e_0 d_1 e_1  0  )
    (  0  e_1 d_2 e_2 )
    ( e_3  0  e_2 d_3 )
</PRE>

</SPAN>

</DL>



<H2><A NAME="SEC234" HREF="gsl_manual.html#TOC234">Examples</A></H2>

<P>
The following program solves the linear system A x = b. The
system to be solved is,

<SPAN class="ifinfo">


<PRE class="example">
[ 0.18 0.60 0.57 0.96 ] [x0]   [1.0]
[ 0.41 0.24 0.99 0.58 ] [x1] = [2.0]
[ 0.14 0.30 0.97 0.66 ] [x2]   [3.0]
[ 0.51 0.13 0.19 0.85 ] [x3]   [4.0]
</PRE>

</SPAN>

<P>
and the solution is found using LU decomposition of the matrix A.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_linalg.h&#62;

int
main (void)
{
  double a_data[] = { 0.18, 0.60, 0.57, 0.96,
                      0.41, 0.24, 0.99, 0.58,
                      0.14, 0.30, 0.97, 0.66,
                      0.51, 0.13, 0.19, 0.85 };

  double b_data[] = { 1.0, 2.0, 3.0, 4.0 };

  gsl_matrix_view m 
    = gsl_matrix_view_array (a_data, 4, 4);

  gsl_vector_view b
    = gsl_vector_view_array (b_data, 4);

  gsl_vector *x = gsl_vector_alloc (4);
  
  int s;

  gsl_permutation * p = gsl_permutation_alloc (4);

  gsl_linalg_LU_decomp (&#38;m.matrix, p, &#38;s);

  gsl_linalg_LU_solve (&#38;m.matrix, p, &#38;b.vector, x);

  printf ("x = \n");
  gsl_vector_fprintf (stdout, x, "%g");

  gsl_permutation_free (p);
  return 0;
}
</PRE>

<P>
Here is the output from the program,

</P>

<PRE class="example">
x = -4.05205
-12.6056
1.66091
8.69377
</PRE>

<P>
This can be verified by multiplying the solution x by the
original matrix A using GNU OCTAVE,

</P>

<PRE class="example">
octave&#62; A = [ 0.18, 0.60, 0.57, 0.96;
              0.41, 0.24, 0.99, 0.58; 
              0.14, 0.30, 0.97, 0.66; 
              0.51, 0.13, 0.19, 0.85 ];

octave&#62; x = [ -4.05205; -12.6056; 1.66091; 8.69377];

octave&#62; A * x
ans =
  1.0000
  2.0000
  3.0000
  4.0000
</PRE>

<P>
This reproduces the original right-hand side vector, b, in
accordance with the equation A x = b.

</P>


<H2><A NAME="SEC235" HREF="gsl_manual.html#TOC235">References and Further Reading</A></H2>

<P>
Further information on the algorithms described in this section can be
found in the following book,

</P>

<UL class="itemize">
<LI>

G. H. Golub, C. F. Van Loan, <CITE>Matrix Computations</CITE> (3rd Ed, 1996),
Johns Hopkins University Press, ISBN 0-8018-5414-8.
</UL>

<P>
The LAPACK library is described in the following manual,

</P>

<UL class="itemize">
<LI>

<CITE>LAPACK Users' Guide</CITE> (Third Edition, 1999), Published by SIAM,
ISBN 0-89871-447-8.

<A HREF="http://www.netlib.org/lapack">http://www.netlib.org/lapack</A> 
</UL>

<P>
The LAPACK source code can be found at the website above, along
with an online copy of the users guide.

</P>
<P>
The Modified Golub-Reinsch algorithm is described in the following paper,

</P>

<UL class="itemize">
<LI>

T.F. Chan, "An Improved Algorithm for Computing the Singular Value
Decomposition", <CITE>ACM Transactions on Mathematical Software</CITE>, 8
(1982), pp 72--83.
</UL>

<P>
The Jacobi algorithm for singular value decomposition is described in
the following papers,

</P>

<UL class="itemize">
<LI>

J.C. Nash, "A one-sided transformation method for the singular value
decomposition and algebraic eigenproblem", <CITE>Computer Journal</CITE>,
Volume 18, Number 1 (1973), p 74--76

<LI>

James Demmel, Kresimir Veselic, "Jacobi's Method is more accurate than
QR", <CITE>Lapack Working Note 15</CITE> (LAWN-15), October 1989. Available
from netlib, <A HREF="http://www.netlib.org/lapack/">http://www.netlib.org/lapack/</A> in the <CODE>lawns</CODE> or
<CODE>lawnspdf</CODE> directories.
</UL>



<H1><A NAME="SEC236" HREF="gsl_manual.html#TOC236">Eigensystems</A></H1>
<P>
<A NAME="IDX1269"></A>
This chapter describes functions for computing eigenvalues and
eigenvectors of matrices.  There are routines for real symmetric and
complex hermitian matrices, and eigenvalues can be computed with or
without eigenvectors.  The algorithms used are symmetric
bidiagonalization followed by QR reduction.

</P>
<P>
<A NAME="IDX1270"></A>
These routines are intended for "small" systems where simple algorithms are
acceptable.  Anyone interested in finding eigenvalues and eigenvectors of
large matrices will want to use the sophisticated routines found in
LAPACK. The Fortran version of LAPACK is recommended as the
standard package for large-scale linear algebra.

</P>
<P>
The functions described in this chapter are declared in the header file
<TT>'gsl_eigen.h'</TT>.

</P>



<H2><A NAME="SEC237" HREF="gsl_manual.html#TOC237">Real Symmetric Matrices</A></H2>
<P>
<A NAME="IDX1271"></A>
<A NAME="IDX1272"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_eigen_symm_workspace * <B>gsl_eigen_symm_alloc</B> <I>(const size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1273"></A>
This function allocates a workspace for computing eigenvalues of
<VAR>n</VAR>-by-<VAR>n</VAR> real symmetric matrices.  The size of the workspace
is O(2n).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_eigen_symm_free</B> <I>(gsl_eigen_symm_workspace * <VAR>w</VAR>)</I>
<DD><A NAME="IDX1274"></A>
This function frees the memory associated with the workspace <VAR>w</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_eigen_symm</B> <I>(gsl_matrix * <VAR>A</VAR>, gsl_vector * <VAR>eval</VAR>, gsl_eigen_symm_workspace * <VAR>w</VAR>)</I>
<DD><A NAME="IDX1275"></A>
This function computes the eigenvalues of the real symmetric matrix
<VAR>A</VAR>.  Additional workspace of the appropriate size must be provided
in <VAR>w</VAR>.  The diagonal and lower triangular part of <VAR>A</VAR> are
destroyed during the computation, but the strict upper triangular part
is not referenced.  The eigenvalues are stored in the vector <VAR>eval</VAR>
and are unordered.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_eigen_symmv_workspace * <B>gsl_eigen_symmv_alloc</B> <I>(const size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1276"></A>
This function allocates a workspace for computing eigenvalues and
eigenvectors of <VAR>n</VAR>-by-<VAR>n</VAR> real symmetric matrices.  The size of
the workspace is O(4n).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_eigen_symmv_free</B> <I>(gsl_eigen_symmv_workspace * <VAR>w</VAR>)</I>
<DD><A NAME="IDX1277"></A>
This function frees the memory associated with the workspace <VAR>w</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_eigen_symmv</B> <I>(gsl_matrix * <VAR>A</VAR>, gsl_vector * <VAR>eval</VAR>, gsl_matrix * <VAR>evec</VAR>, gsl_eigen_symmv_workspace * <VAR>w</VAR>)</I>
<DD><A NAME="IDX1278"></A>
This function computes the eigenvalues and eigenvectors of the real
symmetric matrix <VAR>A</VAR>.  Additional workspace of the appropriate size
must be provided in <VAR>w</VAR>.  The diagonal and lower triangular part of
<VAR>A</VAR> are destroyed during the computation, but the strict upper
triangular part is not referenced.  The eigenvalues are stored in the
vector <VAR>eval</VAR> and are unordered.  The corresponding eigenvectors are
stored in the columns of the matrix <VAR>evec</VAR>.  For example, the
eigenvector in the first column corresponds to the first eigenvalue.
The eigenvectors are guaranteed to be mutually orthogonal and normalised
to unit magnitude.
</DL>

</P>


<H2><A NAME="SEC238" HREF="gsl_manual.html#TOC238">Complex Hermitian Matrices</A></H2>

<P>
<A NAME="IDX1279"></A>
<A NAME="IDX1280"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_eigen_herm_workspace * <B>gsl_eigen_herm_alloc</B> <I>(const size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1281"></A>
This function allocates a workspace for computing eigenvalues of
<VAR>n</VAR>-by-<VAR>n</VAR> complex hermitian matrices.  The size of the workspace
is O(3n).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_eigen_herm_free</B> <I>(gsl_eigen_herm_workspace * <VAR>w</VAR>)</I>
<DD><A NAME="IDX1282"></A>
This function frees the memory associated with the workspace <VAR>w</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_eigen_herm</B> <I>(gsl_matrix_complex * <VAR>A</VAR>, gsl_vector * <VAR>eval</VAR>, gsl_eigen_herm_workspace * <VAR>w</VAR>)</I>
<DD><A NAME="IDX1283"></A>
This function computes the eigenvalues of the complex hermitian matrix
<VAR>A</VAR>.  Additional workspace of the appropriate size must be provided
in <VAR>w</VAR>.  The diagonal and lower triangular part of <VAR>A</VAR> are
destroyed during the computation, but the strict upper triangular part
is not referenced.  The imaginary parts of the diagonal are assumed to be
zero and are not referenced. The eigenvalues are stored in the vector
<VAR>eval</VAR> and are unordered.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_eigen_hermv_workspace * <B>gsl_eigen_hermv_alloc</B> <I>(const size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1284"></A>
This function allocates a workspace for computing eigenvalues and
eigenvectors of <VAR>n</VAR>-by-<VAR>n</VAR> complex hermitian matrices.  The size of
the workspace is O(5n).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_eigen_hermv_free</B> <I>(gsl_eigen_hermv_workspace * <VAR>w</VAR>)</I>
<DD><A NAME="IDX1285"></A>
This function frees the memory associated with the workspace <VAR>w</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_eigen_hermv</B> <I>(gsl_matrix_complex * <VAR>A</VAR>, gsl_vector * <VAR>eval</VAR>, gsl_matrix_complex * <VAR>evec</VAR>, gsl_eigen_hermv_workspace * <VAR>w</VAR>)</I>
<DD><A NAME="IDX1286"></A>
This function computes the eigenvalues and eigenvectors of the complex
hermitian matrix <VAR>A</VAR>.  Additional workspace of the appropriate size
must be provided in <VAR>w</VAR>.  The diagonal and lower triangular part of
<VAR>A</VAR> are destroyed during the computation, but the strict upper
triangular part is not referenced. The imaginary parts of the diagonal
are assumed to be zero and are not referenced.  The eigenvalues are
stored in the vector <VAR>eval</VAR> and are unordered.  The corresponding
complex eigenvectors are stored in the columns of the matrix <VAR>evec</VAR>.
For example, the eigenvector in the first column corresponds to the
first eigenvalue.  The eigenvectors are guaranteed to be mutually
orthogonal and normalised to unit magnitude.
</DL>

</P>


<H2><A NAME="SEC239" HREF="gsl_manual.html#TOC239">Sorting Eigenvalues and Eigenvectors</A></H2>
<P>
<A NAME="IDX1287"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_eigen_symmv_sort</B> <I>(gsl_vector * <VAR>eval</VAR>, gsl_matrix * <VAR>evec</VAR>, gsl_eigen_sort_t <VAR>sort_type</VAR>)</I>
<DD><A NAME="IDX1288"></A>
This function simultaneously sorts the eigenvalues stored in the vector
<VAR>eval</VAR> and the corresponding real eigenvectors stored in the columns
of the matrix <VAR>evec</VAR> into ascending or descending order according to
the value of the parameter <VAR>sort_type</VAR>,

</P>
<DL COMPACT>

<DT><CODE>GSL_EIGEN_SORT_VAL_ASC</CODE>
<DD>
ascending order in numerical value
<DT><CODE>GSL_EIGEN_SORT_VAL_DESC</CODE>
<DD>
descending order in numerical value
<DT><CODE>GSL_EIGEN_SORT_ABS_ASC</CODE>
<DD>
ascending order in magnitude
<DT><CODE>GSL_EIGEN_SORT_ABS_DESC</CODE>
<DD>
descending order in magnitude
</DL>

</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_eigen_hermv_sort</B> <I>(gsl_vector * <VAR>eval</VAR>, gsl_matrix_complex * <VAR>evec</VAR>, gsl_eigen_sort_t <VAR>sort_type</VAR>)</I>
<DD><A NAME="IDX1289"></A>
This function simultaneously sorts the eigenvalues stored in the vector
<VAR>eval</VAR> and the corresponding complex eigenvectors stored in the
columns of the matrix <VAR>evec</VAR> into ascending or descending order
according to the value of the parameter <VAR>sort_type</VAR> as shown above.
</DL>

</P>



<H2><A NAME="SEC240" HREF="gsl_manual.html#TOC240">Examples</A></H2>

<P>
The following program computes the eigenvalues and eigenvectors of the 4-th order Hilbert matrix, H(i,j) = 1/(i + j + 1).

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_math.h&#62;
#include &#60;gsl/gsl_eigen.h&#62;

int
main (void)
{
  double data[] = { 1.0  , 1/2.0, 1/3.0, 1/4.0,
                    1/2.0, 1/3.0, 1/4.0, 1/5.0,
                    1/3.0, 1/4.0, 1/5.0, 1/6.0,
                    1/4.0, 1/5.0, 1/6.0, 1/7.0 };

  gsl_matrix_view m 
    = gsl_matrix_view_array (data, 4, 4);

  gsl_vector *eval = gsl_vector_alloc (4);
  gsl_matrix *evec = gsl_matrix_alloc (4, 4);

  gsl_eigen_symmv_workspace * w = 
    gsl_eigen_symmv_alloc (4);
  
  gsl_eigen_symmv (&#38;m.matrix, eval, evec, w);

  gsl_eigen_symmv_free (w);

  gsl_eigen_symmv_sort (eval, evec, 
                        GSL_EIGEN_SORT_ABS_ASC);
  
  {
    int i;

    for (i = 0; i &#60; 4; i++)
      {
        double eval_i 
           = gsl_vector_get (eval, i);
        gsl_vector_view evec_i 
           = gsl_matrix_column (evec, i);

        printf ("eigenvalue = %g\n", eval_i);
        printf ("eigenvector = \n");
        gsl_vector_fprintf (stdout, 
                            &#38;evec_i.vector, "%g");
      }
  }

  return 0;
}
</PRE>

<P>
Here is the beginning of the output from the program,

</P>

<PRE class="example">
$ ./a.out 
eigenvalue = 9.67023e-05
eigenvector = 
-0.0291933
0.328712
-0.791411
0.514553
...
</PRE>

<P>
This can be compared with the corresponding output from GNU OCTAVE,

</P>

<PRE class="example">
octave&#62; [v,d] = eig(hilb(4));
octave&#62; diag(d)  
ans =

   9.6702e-05
   6.7383e-03
   1.6914e-01
   1.5002e+00

octave&#62; v 
v =

   0.029193   0.179186  -0.582076   0.792608
  -0.328712  -0.741918   0.370502   0.451923
   0.791411   0.100228   0.509579   0.322416
  -0.514553   0.638283   0.514048   0.252161
</PRE>

<P>
Note that the eigenvectors can differ by a change of sign, since the
sign of an eigenvector is arbitrary.

</P>


<H2><A NAME="SEC241" HREF="gsl_manual.html#TOC241">References and Further Reading</A></H2>

<P>
Further information on the algorithms described in this section can be
found in the following book,

</P>

<UL class="itemize">
<LI>

G. H. Golub, C. F. Van Loan, <CITE>Matrix Computations</CITE> (3rd Ed, 1996),
Johns Hopkins University Press, ISBN 0-8018-5414-8.
</UL>

<P>
The LAPACK library is described in,

</P>

<UL class="itemize">
<LI>

<CITE>LAPACK Users' Guide</CITE> (Third Edition, 1999), Published by SIAM,
ISBN 0-89871-447-8.

<A HREF="http://www.netlib.org/lapack">http://www.netlib.org/lapack</A> 
</UL>

<P>
The LAPACK source code can be found at the website above along with
an online copy of the users guide.

</P>


<H1><A NAME="SEC242" HREF="gsl_manual.html#TOC242">Fast Fourier Transforms (FFTs)</A></H1>
<P>
<A NAME="IDX1290"></A>
<A NAME="IDX1291"></A>
<A NAME="IDX1292"></A>
<A NAME="IDX1293"></A>
<A NAME="IDX1294"></A>

</P>
<P>
This chapter describes functions for performing Fast Fourier Transforms
(FFTs).  The library includes radix-2 routines (for lengths which are a
power of two) and mixed-radix routines (which work for any length).  For
efficiency there are separate versions of the routines for real data and
for complex data.  The mixed-radix routines are a reimplementation of the
FFTPACK library of Paul Swarztrauber.  Fortran code for FFTPACK is
available on Netlib (FFTPACK also includes some routines for sine and
cosine transforms but these are currently not available in GSL).  For
details and derivations of the underlying algorithms consult the
document <CITE>GSL FFT Algorithms</CITE> (see section <A HREF="gsl_manual.html#SEC250">References and Further Reading</A>)

</P>



<H2><A NAME="SEC243" HREF="gsl_manual.html#TOC243">Mathematical Definitions</A></H2>
<P>
<A NAME="IDX1295"></A>

</P>
<P>
Fast Fourier Transforms are efficient algorithms for
calculating the discrete fourier transform (DFT),

<SPAN class="ifinfo">


<PRE class="example">
x_j = \sum_{k=0}^{N-1} z_k \exp(-2\pi i j k / N) 
</PRE>

</SPAN>

<P>
The DFT usually arises as an approximation to the continuous fourier
transform when functions are sampled at discrete intervals in space or
time.  The naive evaluation of the discrete fourier transform is a
matrix-vector multiplication 
W\vec{z}. A general matrix-vector multiplication takes
O(N^2) operations for N data-points.  Fast fourier
transform algorithms use a divide-and-conquer strategy to factorize the
matrix W into smaller sub-matrices, corresponding to the integer
factors of the length N.  If N can be factorized into a
product of integers
f_1 f_2 ... f_n then the DFT can be computed in O(N \sum
f_i) operations.  For a radix-2 FFT this gives an operation count of
O(N \log_2 N).

</P>
<P>
All the FFT functions offer three types of transform: forwards, inverse
and backwards, based on the same mathematical definitions.  The
definition of the <I>forward fourier transform</I>,
x = FFT(z), is,

<SPAN class="ifinfo">


<PRE class="example">
x_j = \sum_{k=0}^{N-1} z_k \exp(-2\pi i j k / N) 
</PRE>

</SPAN>

<P>
and the definition of the <I>inverse fourier transform</I>,
x = IFFT(z), is,

<SPAN class="ifinfo">


<PRE class="example">
z_j = {1 \over N} \sum_{k=0}^{N-1} x_k \exp(2\pi i j k / N).
</PRE>

</SPAN>

<P>
The factor of 1/N makes this a true inverse.  For example, a call
to <CODE>gsl_fft_complex_forward</CODE> followed by a call to
<CODE>gsl_fft_complex_inverse</CODE> should return the original data (within
numerical errors).

</P>
<P>
In general there are two possible choices for the sign of the
exponential in the transform/ inverse-transform pair. GSL follows the
same convention as FFTPACK, using a negative exponential for the forward
transform.  The advantage of this convention is that the inverse
transform recreates the original function with simple fourier
synthesis.  Numerical Recipes uses the opposite convention, a positive
exponential in the forward transform.

</P>
<P>
The <I>backwards FFT</I> is simply our terminology for an unscaled
version of the inverse FFT,

<SPAN class="ifinfo">


<PRE class="example">
z^{backwards}_j = \sum_{k=0}^{N-1} x_k \exp(2\pi i j k / N).
</PRE>

</SPAN>

<P>
When the overall scale of the result is unimportant it is often
convenient to use the backwards FFT instead of the inverse to save
unnecessary divisions.

</P>


<H2><A NAME="SEC244" HREF="gsl_manual.html#TOC244">Overview of complex data FFTs</A></H2>
<P>
<A NAME="IDX1296"></A>

</P>
<P>
The inputs and outputs for the complex FFT routines are <I>packed
arrays</I> of floating point numbers.  In a packed array the real and
imaginary parts of each complex number are placed in alternate
neighboring elements.  For example, the following definition of a packed
array of length 6,

</P>

<PRE class="example">
double x[3*2];
gsl_complex_packed_array data = x;
</PRE>

<P>
can be used to hold an array of three complex numbers, <CODE>z[3]</CODE>, in
the following way,

</P>

<PRE class="example">
data[0] = Re(z[0])
data[1] = Im(z[0])
data[2] = Re(z[1])
data[3] = Im(z[1])
data[4] = Re(z[2])
data[5] = Im(z[2])
</PRE>

<P>
The array indices for the data have the same ordering as those
in the definition of the DFT--i.e. there are no index transformations
or permutations of the data.

</P>
<P>
A <I>stride</I> parameter allows the user to perform transforms on the
elements <CODE>z[stride*i]</CODE> instead of <CODE>z[i]</CODE>.  A stride greater
than 1 can be used to take an in-place FFT of the column of a matrix. A
stride of 1 accesses the array without any additional spacing between
elements.  

</P>
<P>
To perform an FFT on a vector argument, such as <CODE>gsl_complex_vector
* v</CODE>, use the following definitions (or their equivalents) when calling
the functions described in this chapter:

</P>

<PRE class="example">
gsl_complex_packed_array data = v-&#62;data;
size_t stride = v-&#62;stride;
size_t n = v-&#62;size;
</PRE>

<P>
For physical applications it is important to remember that the index
appearing in the DFT does not correspond directly to a physical
frequency.  If the time-step of the DFT is \Delta then the
frequency-domain includes both positive and negative frequencies,
ranging from -1/(2\Delta) through 0 to +1/(2\Delta).  The
positive frequencies are stored from the beginning of the array up to
the middle, and the negative frequencies are stored backwards from the
end of the array.

</P>
<P>
Here is a table which shows the layout of the array <VAR>data</VAR>, and the
correspondence between the time-domain data z, and the
frequency-domain data x.

</P>

<PRE class="example">
index    z               x = FFT(z)

0        z(t = 0)        x(f = 0)
1        z(t = 1)        x(f = 1/(N Delta))
2        z(t = 2)        x(f = 2/(N Delta))
.        ........        ..................
N/2      z(t = N/2)      x(f = +1/(2 Delta),
                               -1/(2 Delta))
.        ........        ..................
N-3      z(t = N-3)      x(f = -3/(N Delta))
N-2      z(t = N-2)      x(f = -2/(N Delta))
N-1      z(t = N-1)      x(f = -1/(N Delta))
</PRE>

<P>
When N is even the location N/2 contains the most positive
and negative frequencies (+1/(2 \Delta), -1/(2 \Delta))
which are equivalent.  If N is odd then general structure of the
table above still applies, but N/2 does not appear.

</P>



<H2><A NAME="SEC245" HREF="gsl_manual.html#TOC245">Radix-2 FFT routines for complex data</A></H2>
<P>
<A NAME="IDX1297"></A>
<A NAME="IDX1298"></A>

</P>
<P>
The radix-2 algorithms described in this section are simple and compact,
although not necessarily the most efficient.  They use the Cooley-Tukey
algorithm to compute in-place complex FFTs for lengths which are a power
of 2--no additional storage is required.  The corresponding
self-sorting mixed-radix routines offer better performance at the
expense of requiring additional working space.

</P>
<P>
All the functions described in this section are declared in the header file <TT>'gsl_fft_complex.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_fft_complex_radix2_forward</B> <I>(gsl_complex_packed_array <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1299"></A>

</P>
<P>
<DT><U>Function:</U> int <B>gsl_fft_complex_radix2_transform</B> <I>(gsl_complex_packed_array <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, gsl_fft_direction <VAR>sign</VAR>)</I>
<DD><A NAME="IDX1300"></A>

</P>
<P>
<DT><U>Function:</U> int <B>gsl_fft_complex_radix2_backward</B> <I>(gsl_complex_packed_array <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1301"></A>

</P>
<P>
<DT><U>Function:</U> int <B>gsl_fft_complex_radix2_inverse</B> <I>(gsl_complex_packed_array <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1302"></A>

</P>
<P>
These functions compute forward, backward and inverse FFTs of length
<VAR>n</VAR> with stride <VAR>stride</VAR>, on the packed complex array <VAR>data</VAR>
using an in-place radix-2 decimation-in-time algorithm.  The length of
the transform <VAR>n</VAR> is restricted to powers of two.  For the
<CODE>transform</CODE> version of the function the <VAR>sign</VAR> argument can be
either <CODE>forward</CODE> (-1) or <CODE>backward</CODE> (+1).

</P>
<P>
The functions return a value of <CODE>GSL_SUCCESS</CODE> if no errors were
detected, or <CODE>GSL_EDOM</CODE> if the length of the data <VAR>n</VAR> is not a
power of two.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_fft_complex_radix2_dif_forward</B> <I>(gsl_complex_packed_array <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1303"></A>

</P>
<P>
<DT><U>Function:</U> int <B>gsl_fft_complex_radix2_dif_transform</B> <I>(gsl_complex_packed_array <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, gsl_fft_direction <VAR>sign</VAR>)</I>
<DD><A NAME="IDX1304"></A>

</P>
<P>
<DT><U>Function:</U> int <B>gsl_fft_complex_radix2_dif_backward</B> <I>(gsl_complex_packed_array <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1305"></A>

</P>
<P>
<DT><U>Function:</U> int <B>gsl_fft_complex_radix2_dif_inverse</B> <I>(gsl_complex_packed_array <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1306"></A>

</P>
<P>
These are decimation-in-frequency versions of the radix-2 FFT functions.

</P>
</DL>

<P>
Here is an example program which computes the FFT of a short pulse in a
sample of length 128.  To make the resulting fourier transform real the
pulse is defined for equal positive and negative times (-10
... 10), where the negative times wrap around the end of the
array.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;math.h&#62;
#include &#60;gsl/gsl_errno.h&#62;
#include &#60;gsl/gsl_fft_complex.h&#62;

#define REAL(z,i) ((z)[2*(i)])
#define IMAG(z,i) ((z)[2*(i)+1])

int
main (void)
{
  int i; double data[2*128];

  for (i = 0; i &#60; 128; i++)
    {
       REAL(data,i) = 0.0; IMAG(data,i) = 0.0;
    }

  REAL(data,0) = 1.0;

  for (i = 1; i &#60;= 10; i++)
    {
       REAL(data,i) = REAL(data,128-i) = 1.0;
    }

  for (i = 0; i &#60; 128; i++)
    {
      printf ("%d %e %e\n", i, 
              REAL(data,i), IMAG(data,i));
    }
  printf ("\n");

  gsl_fft_complex_radix2_forward (data, 1, 128);

  for (i = 0; i &#60; 128; i++)
    {
      printf ("%d %e %e\n", i, 
              REAL(data,i)/sqrt(128), 
              IMAG(data,i)/sqrt(128));
    }

  return 0;
}
</PRE>

<P>
Note that we have assumed that the program is using the default error
handler (which calls <CODE>abort</CODE> for any errors).  If you are not using
a safe error handler you would need to check the return status of
<CODE>gsl_fft_complex_radix2_forward</CODE>.

</P>
<P>
The transformed data is rescaled by 1/\sqrt N so that it fits on
the same plot as the input.  Only the real part is shown, by the choice
of the input data the imaginary part is zero.  Allowing for the
wrap-around of negative times at t=128, and working in units of
k/N, the DFT approximates the continuum fourier transform, giving
a modulated sine function.

</P>
<P>
<BR><IMG SRC="fft-complex-radix2-t"><BR> 
<BR><IMG SRC="fft-complex-radix2-f"><BR>

<BLOCKQUOTE class="quotation">
<P>
A pulse and its discrete fourier transform, output from
the example program.
</BLOCKQUOTE>



<H2><A NAME="SEC246" HREF="gsl_manual.html#TOC246">Mixed-radix FFT routines for complex data</A></H2>
<P>
<A NAME="IDX1307"></A>
<A NAME="IDX1308"></A>

</P>
<P>
This section describes mixed-radix FFT algorithms for complex data.  The
mixed-radix functions work for FFTs of any length.  They are a
reimplementation of Paul Swarztrauber's Fortran FFTPACK library.
The theory is explained in the review article <CITE>Self-sorting
Mixed-radix FFTs</CITE> by Clive Temperton.  The routines here use the same
indexing scheme and basic algorithms as FFTPACK.

</P>
<P>
The mixed-radix algorithm is based on sub-transform modules--highly
optimized small length FFTs which are combined to create larger FFTs.
There are efficient modules for factors of 2, 3, 4, 5, 6 and 7.  The
modules for the composite factors of 4 and 6 are faster than combining
the modules for 2*2 and 2*3.

</P>
<P>
For factors which are not implemented as modules there is a fall-back to
a general length-n module which uses Singleton's method for
efficiently computing a DFT. This module is O(n^2), and slower
than a dedicated module would be but works for any length n.  Of
course, lengths which use the general length-n module will still
be factorized as much as possible.  For example, a length of 143 will be
factorized into 11*13.  Large prime factors are the worst case
scenario, e.g. as found in n=2*3*99991, and should be avoided
because their O(n^2) scaling will dominate the run-time (consult
the document <CITE>GSL FFT Algorithms</CITE> included in the GSL distribution
if you encounter this problem).

</P>
<P>
The mixed-radix initialization function <CODE>gsl_fft_complex_wavetable_alloc</CODE>
returns the list of factors chosen by the library for a given length
N.  It can be used to check how well the length has been
factorized, and estimate the run-time.  To a first approximation the
run-time scales as N \sum f_i, where the f_i are the
factors of N.  For programs under user control you may wish to
issue a warning that the transform will be slow when the length is
poorly factorized.  If you frequently encounter data lengths which
cannot be factorized using the existing small-prime modules consult
<CITE>GSL FFT Algorithms</CITE> for details on adding support for other
factors.

</P>

<P>
All the functions described in this section are declared in the header
file <TT>'gsl_fft_complex.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_fft_complex_wavetable * <B>gsl_fft_complex_wavetable_alloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1309"></A>
This function prepares a trigonometric lookup table for a complex FFT of
length <VAR>n</VAR>. The function returns a pointer to the newly allocated
<CODE>gsl_fft_complex_wavetable</CODE> if no errors were detected, and a null
pointer in the case of error.  The length <VAR>n</VAR> is factorized into a
product of subtransforms, and the factors and their trigonometric
coefficients are stored in the wavetable. The trigonometric coefficients
are computed using direct calls to <CODE>sin</CODE> and <CODE>cos</CODE>, for
accuracy.  Recursion relations could be used to compute the lookup table
faster, but if an application performs many FFTs of the same length then
this computation is a one-off overhead which does not affect the final
throughput.

</P>
<P>
The wavetable structure can be used repeatedly for any transform of the
same length.  The table is not modified by calls to any of the other FFT
functions.  The same wavetable can be used for both forward and backward
(or inverse) transforms of a given length.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_fft_complex_wavetable_free</B> <I>(gsl_fft_complex_wavetable * <VAR>wavetable</VAR>)</I>
<DD><A NAME="IDX1310"></A>
This function frees the memory associated with the wavetable
<VAR>wavetable</VAR>.  The wavetable can be freed if no further FFTs of the
same length will be needed.
</DL>
These functions operate on a <CODE>gsl_fft_complex_wavetable</CODE> structure
which contains internal parameters for the FFT.  It is not necessary to
set any of the components directly but it can sometimes be useful to
examine them.  For example, the chosen factorization of the FFT length
is given and can be used to provide an estimate of the run-time or
numerical error. The wavetable structure is declared in the header file
<TT>'gsl_fft_complex.h'</TT>.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_fft_complex_wavetable</B>
<DD><A NAME="IDX1311"></A>
This is a structure that holds the factorization and trigonometric
lookup tables for the mixed radix fft algorithm.  It has the following
components:

</P>
<DL COMPACT>

<DT><CODE>size_t n</CODE>
<DD>
This is the number of complex data points

<DT><CODE>size_t nf</CODE>
<DD>
This is the number of factors that the length <CODE>n</CODE> was decomposed into.

<DT><CODE>size_t factor[64]</CODE>
<DD>
This is the array of factors.  Only the first <CODE>nf</CODE> elements are
used. 

<DT><CODE>gsl_complex * trig</CODE>
<DD>
This is a pointer to a preallocated trigonometric lookup table of
<CODE>n</CODE> complex elements.

<DT><CODE>gsl_complex * twiddle[64]</CODE>
<DD>
This is an array of pointers into <CODE>trig</CODE>, giving the twiddle
factors for each pass.
</DL>
</DL>
<P>
The mixed radix algorithms require additional working space to hold
the intermediate steps of the transform.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_fft_complex_workspace * <B>gsl_fft_complex_workspace_alloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1312"></A>
This function allocates a workspace for a complex transform of length
<VAR>n</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_fft_complex_workspace_free</B> <I>(gsl_fft_complex_workspace * <VAR>workspace</VAR>)</I>
<DD><A NAME="IDX1313"></A>
This function frees the memory associated with the workspace
<VAR>workspace</VAR>. The workspace can be freed if no further FFTs of the
same length will be needed.
</DL>

</P>

<P>
The following functions compute the transform,

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_fft_complex_forward</B> <I>(gsl_complex_packed_array <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, const gsl_fft_complex_wavetable * <VAR>wavetable</VAR>, gsl_fft_complex_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX1314"></A>
<DT><U>Function:</U> int <B>gsl_fft_complex_transform</B> <I>(gsl_complex_packed_array <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, const gsl_fft_complex_wavetable * <VAR>wavetable</VAR>, gsl_fft_complex_workspace * <VAR>work</VAR>, gsl_fft_direction <VAR>sign</VAR>)</I>
<DD><A NAME="IDX1315"></A>
<DT><U>Function:</U> int <B>gsl_fft_complex_backward</B> <I>(gsl_complex_packed_array <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, const gsl_fft_complex_wavetable * <VAR>wavetable</VAR>, gsl_fft_complex_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX1316"></A>
<DT><U>Function:</U> int <B>gsl_fft_complex_inverse</B> <I>(gsl_complex_packed_array <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, const gsl_fft_complex_wavetable * <VAR>wavetable</VAR>, gsl_fft_complex_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX1317"></A>

</P>
<P>
These functions compute forward, backward and inverse FFTs of length
<VAR>n</VAR> with stride <VAR>stride</VAR>, on the packed complex array
<VAR>data</VAR>, using a mixed radix decimation-in-frequency algorithm.
There is no restriction on the length <VAR>n</VAR>.  Efficient modules are
provided for subtransforms of length 2, 3, 4, 5, 6 and 7.  Any remaining
factors are computed with a slow, O(n^2), general-n
module. The caller must supply a <VAR>wavetable</VAR> containing the
trigonometric lookup tables and a workspace <VAR>work</VAR>.  For the
<CODE>transform</CODE> version of the function the <VAR>sign</VAR> argument can be
either <CODE>forward</CODE> (-1) or <CODE>backward</CODE> (+1).

</P>
<P>
The functions return a value of <CODE>0</CODE> if no errors were detected. The
following <CODE>gsl_errno</CODE> conditions are defined for these functions:

</P>
<DL COMPACT>

<DT><CODE>GSL_EDOM</CODE>
<DD>
The length of the data <VAR>n</VAR> is not a positive integer (i.e. <VAR>n</VAR>
is zero).

<DT><CODE>GSL_EINVAL</CODE>
<DD>
The length of the data <VAR>n</VAR> and the length used to compute the given
<VAR>wavetable</VAR> do not match.
</DL>
</DL>

<P>
Here is an example program which computes the FFT of a short pulse in a
sample of length 630 (=2*3*3*5*7) using the mixed-radix
algorithm.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;math.h&#62;
#include &#60;gsl/gsl_errno.h&#62;
#include &#60;gsl/gsl_fft_complex.h&#62;

#define REAL(z,i) ((z)[2*(i)])
#define IMAG(z,i) ((z)[2*(i)+1])

int
main (void)
{
  int i;
  const int n = 630;
  double data[2*n];

  gsl_fft_complex_wavetable * wavetable;
  gsl_fft_complex_workspace * workspace;

  for (i = 0; i &#60; n; i++)
    {
      REAL(data,i) = 0.0;
      IMAG(data,i) = 0.0;
    }

  data[0] = 1.0;

  for (i = 1; i &#60;= 10; i++)
    {
      REAL(data,i) = REAL(data,n-i) = 1.0;
    }

  for (i = 0; i &#60; n; i++)
    {
      printf ("%d: %e %e\n", i, REAL(data,i), 
                                IMAG(data,i));
    }
  printf ("\n");

  wavetable = gsl_fft_complex_wavetable_alloc (n);
  workspace = gsl_fft_complex_workspace_alloc (n);

  for (i = 0; i &#60; wavetable-&#62;nf; i++)
    {
       printf ("# factor %d: %d\n", i, 
               wavetable-&#62;factor[i]);
    }

  gsl_fft_complex_forward (data, 1, n, 
                           wavetable, workspace);

  for (i = 0; i &#60; n; i++)
    {
      printf ("%d: %e %e\n", i, REAL(data,i), 
                                IMAG(data,i));
    }

  gsl_fft_complex_wavetable_free (wavetable);
  gsl_fft_complex_workspace_free (workspace);
  return 0;
}
</PRE>

<P>
Note that we have assumed that the program is using the default
<CODE>gsl</CODE> error handler (which calls <CODE>abort</CODE> for any errors).  If
you are not using a safe error handler you would need to check the
return status of all the <CODE>gsl</CODE> routines.

</P>


<H2><A NAME="SEC247" HREF="gsl_manual.html#TOC247">Overview of real data FFTs</A></H2>
<P>
<A NAME="IDX1318"></A>
The functions for real data are similar to those for complex data.
However, there is an important difference between forward and inverse
transforms.  The fourier transform of a real sequence is not real.  It is
a complex sequence with a special symmetry:

<SPAN class="ifinfo">


<PRE class="example">
z_k = z_{N-k}^*
</PRE>

</SPAN>

<P>
A sequence with this symmetry is called <I>conjugate-complex</I> or
<I>half-complex</I>.  This different structure requires different
storage layouts for the forward transform (from real to half-complex)
and inverse transform (from half-complex back to real).  As a
consequence the routines are divided into two sets: functions in
<CODE>gsl_fft_real</CODE> which operate on real sequences and functions in
<CODE>gsl_fft_halfcomplex</CODE> which operate on half-complex sequences.

</P>
<P>
Functions in <CODE>gsl_fft_real</CODE> compute the frequency coefficients of a
real sequence.  The half-complex coefficients c of a real sequence
x are given by fourier analysis,

<SPAN class="ifinfo">


<PRE class="example">
c_k = \sum_{j=0}^{N-1} x_k \exp(-2 \pi i j k /N)
</PRE>

</SPAN>

<P>
Functions in <CODE>gsl_fft_halfcomplex</CODE> compute inverse or backwards
transforms.  They reconstruct real sequences by fourier synthesis from
their half-complex frequency coefficients, c,

<SPAN class="ifinfo">


<PRE class="example">
x_j = {1 \over N} \sum_{k=0}^{N-1} c_k \exp(2 \pi i j k /N)
</PRE>

</SPAN>

<P>
The symmetry of the half-complex sequence implies that only half of the
complex numbers in the output need to be stored.  The remaining half can
be reconstructed using the half-complex symmetry condition. This works
for all lengths, even and odd--when the length is even the middle value
where k=N/2 is also real.  Thus only <VAR>N</VAR> real numbers are
required to store the half-complex sequence, and the transform of a real
sequence can be stored in the same size array as the original data.

</P>
<P>
The precise storage arrangements depend on the algorithm, and are
different for radix-2 and mixed-radix routines.  The radix-2 function
operates in-place, which constrains the locations where each element can
be stored.  The restriction forces real and imaginary parts to be stored
far apart.  The mixed-radix algorithm does not have this restriction, and
it stores the real and imaginary parts of a given term in neighboring
locations (which is desirable for better locality of memory accesses).

</P>


<H2><A NAME="SEC248" HREF="gsl_manual.html#TOC248">Radix-2 FFT routines for real data</A></H2>
<P>
<A NAME="IDX1319"></A>
<A NAME="IDX1320"></A>

</P>
<P>
This section describes radix-2 FFT algorithms for real data.  They use
the Cooley-Tukey algorithm to compute in-place FFTs for lengths which
are a power of 2. 

</P>
<P>
The radix-2 FFT functions for real data are declared in the header files
<TT>'gsl_fft_real.h'</TT> 

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_fft_real_radix2_transform</B> <I>(double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1321"></A>

</P>
<P>
This function computes an in-place radix-2 FFT of length <VAR>n</VAR> and
stride <VAR>stride</VAR> on the real array <VAR>data</VAR>.  The output is a
half-complex sequence, which is stored in-place.  The arrangement of the
half-complex terms uses the following scheme: for k &#60; N/2 the
real part of the k-th term is stored in location k, and
the corresponding imaginary part is stored in location N-k.  Terms
with k &#62; N/2 can be reconstructed using the symmetry 
z_k = z^*_{N-k}. 
The terms for k=0 and k=N/2 are both purely
real, and count as a special case.  Their real parts are stored in
locations 0 and N/2 respectively, while their imaginary
parts which are zero are not stored.

</P>
<P>
The following table shows the correspondence between the output
<VAR>data</VAR> and the equivalent results obtained by considering the input
data as a complex sequence with zero imaginary part,

</P>

<PRE class="example">
complex[0].real    =    data[0] 
complex[0].imag    =    0 
complex[1].real    =    data[1] 
complex[1].imag    =    data[N-1]
...............         ................
complex[k].real    =    data[k]
complex[k].imag    =    data[N-k] 
...............         ................
complex[N/2].real  =    data[N/2]
complex[N/2].real  =    0
...............         ................
complex[k'].real   =    data[k]        k' = N - k
complex[k'].imag   =   -data[N-k] 
...............         ................
complex[N-1].real  =    data[1]
complex[N-1].imag  =   -data[N-1]
</PRE>

</DL>
<P>
The radix-2 FFT functions for halfcomplex data are declared in the
header file <TT>'gsl_fft_halfcomplex.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_fft_halfcomplex_radix2_inverse</B> <I>(double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1322"></A>
<DT><U>Function:</U> int <B>gsl_fft_halfcomplex_radix2_backward</B> <I>(double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1323"></A>

</P>
<P>
These functions compute the inverse or backwards in-place radix-2 FFT of
length <VAR>n</VAR> and stride <VAR>stride</VAR> on the half-complex sequence
<VAR>data</VAR> stored according the output scheme used by
<CODE>gsl_fft_real_radix2</CODE>.  The result is a real array stored in natural
order.

</P>
</DL>



<H2><A NAME="SEC249" HREF="gsl_manual.html#TOC249">Mixed-radix FFT routines for real data</A></H2>
<P>
<A NAME="IDX1324"></A>
<A NAME="IDX1325"></A>

</P>
<P>
This section describes mixed-radix FFT algorithms for real data.  The
mixed-radix functions work for FFTs of any length.  They are a
reimplementation of the real-FFT routines in the Fortran FFTPACK library
by Paul Swarztrauber.  The theory behind the algorithm is explained in
the article <CITE>Fast Mixed-Radix Real Fourier Transforms</CITE> by Clive
Temperton.  The routines here use the same indexing scheme and basic
algorithms as FFTPACK.

</P>
<P>
The functions use the FFTPACK storage convention for half-complex
sequences.  In this convention the half-complex transform of a real
sequence is stored with frequencies in increasing order, starting at
zero, with the real and imaginary parts of each frequency in neighboring
locations.  When a value is known to be real the imaginary part is not
stored.  The imaginary part of the zero-frequency component is never
stored.  It is known to be zero (since the zero frequency component is
simply the sum of the input data (all real)).  For a sequence of even
length the imaginary part of the frequency n/2 is not stored
either, since the symmetry 
z_k = z_{N-k}^* implies that this is
purely real too.

</P>
<P>
The storage scheme is best shown by some examples.  The table below
shows the output for an odd-length sequence, n=5.  The two columns
give the correspondence between the 5 values in the half-complex
sequence returned by <CODE>gsl_fft_real_transform</CODE>, <VAR>halfcomplex</VAR>[] and the
values <VAR>complex</VAR>[] that would be returned if the same real input
sequence were passed to <CODE>gsl_fft_complex_backward</CODE> as a complex
sequence (with imaginary parts set to <CODE>0</CODE>),

</P>

<PRE class="example">
complex[0].real  =  halfcomplex[0] 
complex[0].imag  =  0
complex[1].real  =  halfcomplex[1] 
complex[1].imag  =  halfcomplex[2]
complex[2].real  =  halfcomplex[3]
complex[2].imag  =  halfcomplex[4]
complex[3].real  =  halfcomplex[3]
complex[3].imag  = -halfcomplex[4]
complex[4].real  =  halfcomplex[1]
complex[4].imag  = -halfcomplex[2]
</PRE>

<P>
The upper elements of the <VAR>complex</VAR> array, <CODE>complex[3]</CODE> and
<CODE>complex[4]</CODE> are filled in using the symmetry condition.  The
imaginary part of the zero-frequency term <CODE>complex[0].imag</CODE> is
known to be zero by the symmetry.

</P>
<P>
The next table shows the output for an even-length sequence, n=6
In the even case there are two values which are purely real,

</P>

<PRE class="example">
complex[0].real  =  halfcomplex[0]
complex[0].imag  =  0
complex[1].real  =  halfcomplex[1] 
complex[1].imag  =  halfcomplex[2] 
complex[2].real  =  halfcomplex[3] 
complex[2].imag  =  halfcomplex[4] 
complex[3].real  =  halfcomplex[5] 
complex[3].imag  =  0 
complex[4].real  =  halfcomplex[3] 
complex[4].imag  = -halfcomplex[4]
complex[5].real  =  halfcomplex[1] 
complex[5].imag  = -halfcomplex[2] 
</PRE>

<P>
The upper elements of the <VAR>complex</VAR> array, <CODE>complex[4]</CODE> and
<CODE>complex[5]</CODE> are filled in using the symmetry condition.  Both
<CODE>complex[0].imag</CODE> and <CODE>complex[3].imag</CODE> are known to be zero.

</P>
<P>
All these functions are declared in the header files
<TT>'gsl_fft_real.h'</TT> and <TT>'gsl_fft_halfcomplex.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_fft_real_wavetable * <B>gsl_fft_real_wavetable_alloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1326"></A>
<DT><U>Function:</U> gsl_fft_halfcomplex_wavetable * <B>gsl_fft_halfcomplex_wavetable_alloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1327"></A>
These functions prepare trigonometric lookup tables for an FFT of size
n real elements.  The functions return a pointer to the newly
allocated struct if no errors were detected, and a null pointer in the
case of error.  The length <VAR>n</VAR> is factorized into a product of
subtransforms, and the factors and their trigonometric coefficients are
stored in the wavetable. The trigonometric coefficients are computed
using direct calls to <CODE>sin</CODE> and <CODE>cos</CODE>, for accuracy.
Recursion relations could be used to compute the lookup table faster,
but if an application performs many FFTs of the same length then
computing the wavetable is a one-off overhead which does not affect the
final throughput.

</P>
<P>
The wavetable structure can be used repeatedly for any transform of the
same length.  The table is not modified by calls to any of the other FFT
functions.  The appropriate type of wavetable must be used for forward
real or inverse half-complex transforms.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_fft_real_wavetable_free</B> <I>(gsl_fft_real_wavetable * <VAR>wavetable</VAR>)</I>
<DD><A NAME="IDX1328"></A>
<DT><U>Function:</U> void <B>gsl_fft_halfcomplex_wavetable_free</B> <I>(gsl_fft_halfcomplex_wavetable * <VAR>wavetable</VAR>)</I>
<DD><A NAME="IDX1329"></A>
These functions free the memory associated with the wavetable
<VAR>wavetable</VAR>. The wavetable can be freed if no further FFTs of the
same length will be needed.
</DL>
The mixed radix algorithms require additional working space to hold
the intermediate steps of the transform,

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_fft_real_workspace * <B>gsl_fft_real_workspace_alloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1330"></A>
This function allocates a workspace for a real transform of length
<VAR>n</VAR>.  The same workspace can be used for both forward real and inverse
halfcomplex transforms.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_fft_real_workspace_free</B> <I>(gsl_fft_real_workspace * <VAR>workspace</VAR>)</I>
<DD><A NAME="IDX1331"></A>
This function frees the memory associated with the workspace
<VAR>workspace</VAR>. The workspace can be freed if no further FFTs of the
same length will be needed.
</DL>
The following functions compute the transforms of real and half-complex
data,

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_fft_real_transform</B> <I>(double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, const gsl_fft_real_wavetable * <VAR>wavetable</VAR>, gsl_fft_real_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX1332"></A>
<DT><U>Function:</U> int <B>gsl_fft_halfcomplex_transform</B> <I>(double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, const gsl_fft_halfcomplex_wavetable * <VAR>wavetable</VAR>, gsl_fft_real_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX1333"></A>
These functions compute the FFT of <VAR>data</VAR>, a real or half-complex
array of length <VAR>n</VAR>, using a mixed radix decimation-in-frequency
algorithm.  For <CODE>gsl_fft_real_transform</CODE> <VAR>data</VAR> is an array of
time-ordered real data.  For <CODE>gsl_fft_halfcomplex_transform</CODE>
<VAR>data</VAR> contains fourier coefficients in the half-complex ordering
described above.  There is no restriction on the length <VAR>n</VAR>.
Efficient modules are provided for subtransforms of length 2, 3, 4 and
5.  Any remaining factors are computed with a slow, O(n^2),
general-n module.  The caller must supply a <VAR>wavetable</VAR> containing
trigonometric lookup tables and a workspace <VAR>work</VAR>. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_fft_real_unpack</B> <I>(const double <VAR>real_coefficient</VAR>[], gsl_complex_packed_array <VAR>complex_coefficient</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1334"></A>

</P>
<P>
This function converts a single real array, <VAR>real_coefficient</VAR> into
an equivalent complex array, <VAR>complex_coefficient</VAR>, (with imaginary
part set to zero), suitable for <CODE>gsl_fft_complex</CODE> routines.  The
algorithm for the conversion is simply,

</P>

<PRE class="example">
for (i = 0; i &#60; n; i++)
  {
    complex_coefficient[i].real 
      = real_coefficient[i];
    complex_coefficient[i].imag 
      = 0.0;
  }
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_fft_halfcomplex_unpack</B> <I>(const double <VAR>halfcomplex_coefficient</VAR>[], gsl_complex_packed_array <VAR>complex_coefficient</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1335"></A>

</P>
<P>
This function converts <VAR>halfcomplex_coefficient</VAR>, an array of
half-complex coefficients as returned by <CODE>gsl_fft_real_transform</CODE>, into an
ordinary complex array, <VAR>complex_coefficient</VAR>.  It fills in the
complex array using the symmetry 
z_k = z_{N-k}^*
to reconstruct the redundant elements.  The algorithm for the conversion
is,

</P>

<PRE class="example">
complex_coefficient[0].real 
  = halfcomplex_coefficient[0];
complex_coefficient[0].imag 
  = 0.0;

for (i = 1; i &#60; n - i; i++)
  {
    double hc_real 
      = halfcomplex_coefficient[2 * i - 1];
    double hc_imag 
      = halfcomplex_coefficient[2 * i];
    complex_coefficient[i].real = hc_real;
    complex_coefficient[i].imag = hc_imag;
    complex_coefficient[n - i].real = hc_real;
    complex_coefficient[n - i].imag = -hc_imag;
  }

if (i == n - i)
  {
    complex_coefficient[i].real 
      = halfcomplex_coefficient[n - 1];
    complex_coefficient[i].imag 
      = 0.0;
  }
</PRE>

</DL>

<P>
Here is an example program using <CODE>gsl_fft_real_transform</CODE> and
<CODE>gsl_fft_halfcomplex_inverse</CODE>.  It generates a real signal in the
shape of a square pulse.  The pulse is fourier transformed to frequency
space, and all but the lowest ten frequency components are removed from
the array of fourier coefficients returned by
<CODE>gsl_fft_real_transform</CODE>.

</P>
<P>
The remaining fourier coefficients are transformed back to the
time-domain, to give a filtered version of the square pulse.  Since
fourier coefficients are stored using the half-complex symmetry both
positive and negative frequencies are removed and the final filtered
signal is also real.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;math.h&#62;
#include &#60;gsl/gsl_errno.h&#62;
#include &#60;gsl/gsl_fft_real.h&#62;
#include &#60;gsl/gsl_fft_halfcomplex.h&#62;

int
main (void)
{
  int i, n = 100;
  double data[n];

  gsl_fft_real_wavetable * real;
  gsl_fft_halfcomplex_wavetable * hc;
  gsl_fft_real_workspace * work;

  for (i = 0; i &#60; n; i++)
    {
      data[i] = 0.0;
    }

  for (i = n / 3; i &#60; 2 * n / 3; i++)
    {
      data[i] = 1.0;
    }

  for (i = 0; i &#60; n; i++)
    {
      printf ("%d: %e\n", i, data[i]);
    }
  printf ("\n");

  work = gsl_fft_real_workspace_alloc (n);
  real = gsl_fft_real_wavetable_alloc (n);

  gsl_fft_real_transform (data, 1, n, 
                          real, work);

  gsl_fft_real_wavetable_free (real);

  for (i = 11; i &#60; n; i++)
    {
      data[i] = 0;
    }

  hc = gsl_fft_halfcomplex_wavetable_alloc (n);

  gsl_fft_halfcomplex_inverse (data, 1, n, 
                               hc, work);
  gsl_fft_halfcomplex_wavetable_free (hc);

  for (i = 0; i &#60; n; i++)
    {
      printf ("%d: %e\n", i, data[i]);
    }

  gsl_fft_real_workspace_free (work);
  return 0;
}
</PRE>

<P>
<BR><IMG SRC="fft-real-mixedradix"><BR>

</P>
<P>
Low-pass filtered version of a real pulse, 
output from the example program.

</P>


<H2><A NAME="SEC250" HREF="gsl_manual.html#TOC250">References and Further Reading</A></H2>

<P>
A good starting point for learning more about the FFT is the review
article <CITE>Fast Fourier Transforms: A Tutorial Review and A State of
the Art</CITE> by Duhamel and Vetterli,

</P>

<UL class="itemize">
<LI>

P. Duhamel and M. Vetterli.
Fast fourier transforms: A tutorial review and a state of the art.
<CITE>Signal Processing</CITE>, 19:259--299, 1990.
</UL>

<P>
To find out about the algorithms used in the GSL routines you may want
to consult the document <CITE>GSL FFT Algorithms</CITE> (it is included
in GSL, as <TT>'doc/fftalgorithms.tex'</TT>).  This has general information
on FFTs and explicit derivations of the implementation for each
routine.  There are also references to the relevant literature.  For
convenience some of the more important references are reproduced below.

</P>
<P>
There are several introductory books on the FFT with example programs,
such as <CITE>The Fast Fourier Transform</CITE> by Brigham and <CITE>DFT/FFT
and Convolution Algorithms</CITE> by Burrus and Parks,

</P>

<UL class="itemize">
<LI>

E. Oran Brigham.
<CITE>The Fast Fourier Transform</CITE>.
Prentice Hall, 1974.

<LI>

C. S. Burrus and T. W. Parks.
<CITE>DFT/FFT and Convolution Algorithms</CITE>.
Wiley, 1984.
</UL>

<P>
Both these introductory books cover the radix-2 FFT in some detail.
The mixed-radix algorithm at the heart of the FFTPACK routines is
reviewed in Clive Temperton's paper,

</P>

<UL class="itemize">
<LI>

Clive Temperton.
Self-sorting mixed-radix fast fourier transforms.
<CITE>Journal of Computational Physics</CITE>, 52(1):1--23, 1983.
</UL>

<P>
The derivation of FFTs for real-valued data is explained in the
following two articles,

</P>

<UL class="itemize">
<LI>

Henrik V. Sorenson, Douglas L. Jones, Michael T. Heideman, and C. Sidney
Burrus.
Real-valued fast fourier transform algorithms.
<CITE>IEEE Transactions on Acoustics, Speech, and Signal Processing</CITE>,
ASSP-35(6):849--863, 1987.

<LI>

Clive Temperton.
Fast mixed-radix real fourier transforms.
<CITE>Journal of Computational Physics</CITE>, 52:340--350, 1983.
</UL>

<P>
In 1979 the IEEE published a compendium of carefully-reviewed Fortran
FFT programs in <CITE>Programs for Digital Signal Processing</CITE>.  It is a
useful reference for implementations of many different FFT
algorithms,

</P>

<UL class="itemize">
<LI>

Digital Signal Processing Committee and IEEE Acoustics, Speech, and Signal
Processing Committee, editors.
<CITE>Programs for Digital Signal Processing</CITE>.
IEEE Press, 1979.
</UL>

<P>
For large-scale FFT work we recommend the use of the dedicated FFTW library
by Frigo and Johnson.  The FFTW library is self-optimizing--it
automatically tunes itself for each hardware platform in order to
achieve maximum performance.  It is available under the GNU GPL.

</P>

<UL class="itemize">
<LI>

FFTW Website, <A HREF="http://www.fftw.org/">http://www.fftw.org/</A>
</UL>

<P>
The source code for FFTPACK is available from Netlib,

</P>

<UL class="itemize">
<LI>

FFTPACK, <A HREF="http://www.netlib.org/fftpack/">http://www.netlib.org/fftpack/</A>
</UL>



<H1><A NAME="SEC251" HREF="gsl_manual.html#TOC251">Numerical Integration</A></H1>
<P>
<A NAME="IDX1336"></A>
<A NAME="IDX1337"></A>
<A NAME="IDX1338"></A>
<A NAME="IDX1339"></A>

</P>
<P>
This chapter describes routines for performing numerical integration
(quadrature) of a function in one dimension.  There are routines for
adaptive and non-adaptive integration of general functions, with
specialised routines for specific cases.  These include integration over
infinite and semi-infinite ranges, singular integrals, including
logarithmic singularities, computation of Cauchy principal values and
oscillatory integrals.  The library reimplements the algorithms used in
QUADPACK, a numerical integration package written by Piessens,
Doncker-Kapenga, Uberhuber and Kahaner.  Fortran code for QUADPACK is
available on Netlib.

</P>
<P>
The functions described in this chapter are declared in the header file
<TT>'gsl_integration.h'</TT>.

</P>



<H2><A NAME="SEC252" HREF="gsl_manual.html#TOC252">Introduction</A></H2>

<P>
Each algorithm computes an approximation to a definite integral of the
form,

<SPAN class="ifinfo">


<PRE class="example">
I = \int_a^b f(x) w(x) dx
</PRE>

</SPAN>

<P>
where w(x) is a weight function (for general integrands w(x)=1).
The user provides absolute and relative error bounds 
(epsabs, epsrel) which specify the following accuracy requirement,

<SPAN class="ifinfo">


<PRE class="example">
|RESULT - I|  &#60;= max(epsabs, epsrel |I|)
</PRE>

</SPAN>

<P>
where 
RESULT is the numerical approximation obtained by the
algorithm.  The algorithms attempt to estimate the absolute error
ABSERR = |RESULT - I| in such a way that the following inequality
holds,

<SPAN class="ifinfo">


<PRE class="example">
|RESULT - I| &#60;= ABSERR &#60;= max(epsabs, epsrel |I|)
</PRE>

</SPAN>

<P>
The routines will fail to converge if the error bounds are too
stringent, but always return the best approximation obtained up to that
stage.

</P>
<P>
The algorithms in QUADPACK use a naming convention based on the
following letters,

</P>

<PRE class="display">
<CODE>Q</CODE> - quadrature routine

<CODE>N</CODE> - non-adaptive integrator
<CODE>A</CODE> - adaptive integrator

<CODE>G</CODE> - general integrand (user-defined)
<CODE>W</CODE> - weight function with integrand

<CODE>S</CODE> - singularities can be more readily integrated
<CODE>P</CODE> - points of special difficulty can be supplied
<CODE>I</CODE> - infinite range of integration
<CODE>O</CODE> - oscillatory weight function, cos or sin
<CODE>F</CODE> - Fourier integral
<CODE>C</CODE> - Cauchy principal value
</PRE>

<P>
The algorithms are built on pairs of quadrature rules, a higher order
rule and a lower order rule.  The higher order rule is used to compute
the best approximation to an integral over a small range.  The
difference between the results of the higher order rule and the lower
order rule gives an estimate of the error in the approximation.

</P>


<H3><A NAME="SEC253" HREF="gsl_manual.html#TOC253">Integrands without weight functions</A></H3>
<P>
<A NAME="IDX1340"></A>
The algorithms for general functions (without a weight function) are
based on Gauss-Kronrod rules. 

</P>
<P>
A Gauss-Kronrod rule begins with a classical Gaussian quadrature rule of
order m.  This is extended with additional points between each of
the abscissae to give a higher order Kronrod rule of order 2m+1.
The Kronrod rule is efficient because it reuses existing function
evaluations from the Gaussian rule.  

</P>
<P>
The higher order Kronrod rule is used as the best approximation to the
integral, and the difference between the two rules is used as an
estimate of the error in the approximation.

</P>


<H3><A NAME="SEC254" HREF="gsl_manual.html#TOC254">Integrands with weight functions</A></H3>
<P>
<A NAME="IDX1341"></A>
<A NAME="IDX1342"></A>
For integrands with weight functions the algorithms use Clenshaw-Curtis
quadrature rules.  

</P>
<P>
A Clenshaw-Curtis rule begins with an n-th order Chebyshev
polynomial approximation to the integrand.  This polynomial can be
integrated exactly to give an approximation to the integral of the
original function.  The Chebyshev expansion can be extended to higher
orders to improve the approximation and provide an estimate of the
error.

</P>


<H3><A NAME="SEC255" HREF="gsl_manual.html#TOC255">Integrands with singular weight functions</A></H3>

<P>
The presence of singularities (or other behavior) in the integrand can
cause slow convergence in the Chebyshev approximation.  The modified
Clenshaw-Curtis rules used in QUADPACK separate out several common
weight functions which cause slow convergence.  

</P>
<P>
These weight functions are integrated analytically against the Chebyshev
polynomials to precompute <I>modified Chebyshev moments</I>.  Combining
the moments with the Chebyshev approximation to the function gives the
desired integral.  The use of analytic integration for the singular part
of the function allows exact cancellations and substantially improves
the overall convergence behavior of the integration.

</P>



<H2><A NAME="SEC256" HREF="gsl_manual.html#TOC256">QNG non-adaptive Gauss-Kronrod integration</A></H2>

<P>
The QNG algorithm is a non-adaptive procedure which uses fixed
Gauss-Kronrod abscissae to sample the integrand at a maximum of 87
points.  It is provided for fast integration of smooth functions.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_integration_qng</B> <I>(const gsl_function * <VAR>f</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>epsabs</VAR>, double <VAR>epsrel</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>, size_t * <VAR>neval</VAR>)</I>
<DD><A NAME="IDX1343"></A>

</P>
<P>
This function applies the Gauss-Kronrod 10-point, 21-point, 43-point and
87-point integration rules in succession until an estimate of the
integral of f over (a,b) is achieved within the desired
absolute and relative error limits, <VAR>epsabs</VAR> and <VAR>epsrel</VAR>.  The
function returns the final approximation, <VAR>result</VAR>, an estimate of
the absolute error, <VAR>abserr</VAR> and the number of function evaluations
used, <VAR>neval</VAR>.  The Gauss-Kronrod rules are designed in such a way
that each rule uses all the results of its predecessors, in order to
minimize the total number of function evaluations.
</DL>

</P>



<H2><A NAME="SEC257" HREF="gsl_manual.html#TOC257">QAG adaptive integration</A></H2>

<P>
The QAG algorithm is a simple adaptive integration procedure.  The
integration region is divided into subintervals, and on each iteration
the subinterval with the largest estimated error is bisected.  This
reduces the overall error rapidly, as the subintervals become
concentrated around local difficulties in the integrand.  These
subintervals are managed by a <CODE>gsl_integration_workspace</CODE> struct,
which handles the memory for the subinterval ranges, results and error
estimates.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_integration_workspace * <B>gsl_integration_workspace_alloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1344"></A>
This function allocates a workspace sufficient to hold <VAR>n</VAR> double
precision intervals, their integration results and error estimates.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_integration_workspace_free</B> <I>(gsl_integration_workspace * <VAR>w</VAR>)</I>
<DD><A NAME="IDX1345"></A>
This function frees the memory associated with the workspace <VAR>w</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_integration_qag</B> <I>(const gsl_function * <VAR>f</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>epsabs</VAR>, double <VAR>epsrel</VAR>, size_t <VAR>limit</VAR>, int <VAR>key</VAR>, gsl_integration_workspace * <VAR>workspace</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX1346"></A>

</P>
<P>
This function applies an integration rule adaptively until an estimate
of the integral of f over (a,b) is achieved within the
desired absolute and relative error limits, <VAR>epsabs</VAR> and
<VAR>epsrel</VAR>.  The function returns the final approximation,
<VAR>result</VAR>, and an estimate of the absolute error, <VAR>abserr</VAR>.  The
integration rule is determined by the value of <VAR>key</VAR>, which should
be chosen from the following symbolic names,

</P>

<PRE class="example">
GSL_INTEG_GAUSS15  (key = 1)
GSL_INTEG_GAUSS21  (key = 2)
GSL_INTEG_GAUSS31  (key = 3)
GSL_INTEG_GAUSS41  (key = 4)
GSL_INTEG_GAUSS51  (key = 5)
GSL_INTEG_GAUSS61  (key = 6)
</PRE>

<P>
corresponding to the 15, 21, 31, 41, 51 and 61 point Gauss-Kronrod
rules.  The higher-order rules give better accuracy for smooth functions,
while lower-order rules save time when the function contains local
difficulties, such as discontinuities.

</P>
<P>
On each iteration the adaptive integration strategy bisects the interval
with the largest error estimate.  The subintervals and their results are
stored in the memory provided by <VAR>workspace</VAR>.  The maximum number of
subintervals is given by <VAR>limit</VAR>, which may not exceed the allocated
size of the workspace.
</DL>

</P>



<H2><A NAME="SEC258" HREF="gsl_manual.html#TOC258">QAGS adaptive integration with singularities</A></H2>

<P>
The presence of an integrable singularity in the integration region
causes an adaptive routine to concentrate new subintervals around the
singularity.  As the subintervals decrease in size the successive
approximations to the integral converge in a limiting fashion.  This
approach to the limit can be accelerated using an extrapolation
procedure.  The QAGS algorithm combines adaptive bisection with the Wynn
epsilon-algorithm to speed up the integration of many types of
integrable singularities.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_integration_qags</B> <I>(const gsl_function * <VAR>f</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>epsabs</VAR>, double <VAR>epsrel</VAR>, size_t <VAR>limit</VAR>, gsl_integration_workspace * <VAR>workspace</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX1347"></A>

</P>
<P>
This function applies the Gauss-Kronrod 21-point integration rule
adaptively until an estimate of the integral of f over
(a,b) is achieved within the desired absolute and relative error
limits, <VAR>epsabs</VAR> and <VAR>epsrel</VAR>.  The results are extrapolated
using the epsilon-algorithm, which accelerates the convergence of the
integral in the presence of discontinuities and integrable
singularities.  The function returns the final approximation from the
extrapolation, <VAR>result</VAR>, and an estimate of the absolute error,
<VAR>abserr</VAR>.  The subintervals and their results are stored in the
memory provided by <VAR>workspace</VAR>.  The maximum number of subintervals
is given by <VAR>limit</VAR>, which may not exceed the allocated size of the
workspace.

</P>
</DL>



<H2><A NAME="SEC259" HREF="gsl_manual.html#TOC259">QAGP adaptive integration with known singular points</A></H2>
<P>
<A NAME="IDX1348"></A>
<DL>
<DT><U>Function:</U> int <B>gsl_integration_qagp</B> <I>(const gsl_function * <VAR>f</VAR>, double * <VAR>pts</VAR>, size_t <VAR>npts</VAR>, double <VAR>epsabs</VAR>, double <VAR>epsrel</VAR>, size_t <VAR>limit</VAR>, gsl_integration_workspace * <VAR>workspace</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX1349"></A>

</P>
<P>
This function applies the adaptive integration algorithm QAGS taking
account of the user-supplied locations of singular points.  The array
<VAR>pts</VAR> of length <VAR>npts</VAR> should contain the endpoints of the
integration ranges defined by the integration region and locations of
the singularities.  For example, to integrate over the region
(a,b) with break-points at x_1, x_2, x_3 (where 
a &#60; x_1 &#60; x_2 &#60; x_3 &#60; b) the following <VAR>pts</VAR> array should be used

</P>

<PRE class="example">
pts[0] = a
pts[1] = x_1
pts[2] = x_2
pts[3] = x_3
pts[4] = b
</PRE>

<P>
with <VAR>npts</VAR> = 5.

</P>
<P>
If you know the locations of the singular points in the integration
region then this routine will be faster than <CODE>QAGS</CODE>.

</P>
</DL>



<H2><A NAME="SEC260" HREF="gsl_manual.html#TOC260">QAGI adaptive integration on infinite intervals</A></H2>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_integration_qagi</B> <I>(gsl_function * <VAR>f</VAR>, double <VAR>epsabs</VAR>, double <VAR>epsrel</VAR>, size_t <VAR>limit</VAR>, gsl_integration_workspace * <VAR>workspace</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX1350"></A>

</P>
<P>
This function computes the integral of the function <VAR>f</VAR> over the
infinite interval (-\infty,+\infty).  The integral is mapped onto the
semi-open interval (0,1] using the transformation x = (1-t)/t,

<SPAN class="ifinfo">


<PRE class="example">
\int_{-\infty}^{+\infty} dx f(x) = 
     \int_0^1 dt (f((1-t)/t) + f((-1+t)/t))/t^2.
</PRE>

</SPAN>

<P>
It is then integrated using the QAGS algorithm.  The normal 21-point
Gauss-Kronrod rule of QAGS is replaced by a 15-point rule, because the
transformation can generate an integrable singularity at the origin.  In
this case a lower-order rule is more efficient.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_integration_qagiu</B> <I>(gsl_function * <VAR>f</VAR>, double <VAR>a</VAR>, double <VAR>epsabs</VAR>, double <VAR>epsrel</VAR>, size_t <VAR>limit</VAR>, gsl_integration_workspace * <VAR>workspace</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX1351"></A>

</P>
<P>
This function computes the integral of the function <VAR>f</VAR> over the
semi-infinite interval (a,+\infty).  The integral is mapped onto the
semi-open interval (0,1] using the transformation x = a + (1-t)/t,

<SPAN class="ifinfo">


<PRE class="example">
\int_{a}^{+\infty} dx f(x) = 
     \int_0^1 dt f(a + (1-t)/t)/t^2
</PRE>

</SPAN>

<P>
and then integrated using the QAGS algorithm.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_integration_qagil</B> <I>(gsl_function * <VAR>f</VAR>, double <VAR>b</VAR>, double <VAR>epsabs</VAR>, double <VAR>epsrel</VAR>, size_t <VAR>limit</VAR>, gsl_integration_workspace * <VAR>workspace</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX1352"></A>
This function computes the integral of the function <VAR>f</VAR> over the
semi-infinite interval (-\infty,b).  The integral is mapped onto the
semi-open interval (0,1] using the transformation x = b - (1-t)/t,

<SPAN class="ifinfo">


<PRE class="example">
\int_{+\infty}^{b} dx f(x) = 
     \int_0^1 dt f(b - (1-t)/t)/t^2
</PRE>

</SPAN>

<P>
and then integrated using the QAGS algorithm.
</DL>

</P>


<H2><A NAME="SEC261" HREF="gsl_manual.html#TOC261">QAWC adaptive integration for Cauchy principal values</A></H2>
<P>
<A NAME="IDX1353"></A>
<DL>
<DT><U>Function:</U> int <B>gsl_integration_qawc</B> <I>(gsl_function * <VAR>f</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>, double <VAR>c</VAR>, double <VAR>epsabs</VAR>, double <VAR>epsrel</VAR>, size_t <VAR>limit</VAR>, gsl_integration_workspace * <VAR>workspace</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX1354"></A>

</P>
<P>
This function computes the Cauchy principal value of the integral of
f over (a,b), with a singularity at <VAR>c</VAR>,

<SPAN class="ifinfo">


<PRE class="example">
I = \int_a^b dx f(x) / (x - c)
</PRE>

</SPAN>

<P>
The adaptive bisection algorithm of QAG is used, with modifications to
ensure that subdivisions do not occur at the singular point x = c.
When a subinterval contains the point x = c or is close to
it then a special 25-point modified Clenshaw-Curtis rule is used to control
the singularity.  Further away from the
singularity the algorithm uses an ordinary 15-point Gauss-Kronrod
integration rule.

</P>
</DL>



<H2><A NAME="SEC262" HREF="gsl_manual.html#TOC262">QAWS adaptive integration for singular functions</A></H2>
<P>
<A NAME="IDX1355"></A>
The QAWS algorithm is designed for integrands with algebraic-logarithmic
singularities at the end-points of an integration region.  In order to
work efficiently the algorithm requires a precomputed table of
Chebyshev moments.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_integration_qaws_table * <B>gsl_integration_qaws_table_alloc</B> <I>(double <VAR>alpha</VAR>, double <VAR>beta</VAR>, int <VAR>mu</VAR>, int <VAR>nu</VAR>)</I>
<DD><A NAME="IDX1356"></A>

</P>
<P>
This function allocates space for a <CODE>gsl_integration_qaws_table</CODE>
struct and associated workspace describing a singular weight function
W(x) with the parameters (\alpha, \beta, \mu, \nu),

<SPAN class="ifinfo">


<PRE class="example">
W(x) = (x-a)^alpha (b-x)^beta log^mu (x-a) log^nu (b-x)
</PRE>

</SPAN>

<P>
where \alpha &#62; -1, \beta &#62; -1, and \mu = 0, 1,
\nu = 0, 1.  The weight function can take four different forms
depending on the values of \mu and \nu,

<SPAN class="ifinfo">


<PRE class="example">
W(x) = (x-a)^alpha (b-x)^beta                   (mu = 0, nu = 0)
W(x) = (x-a)^alpha (b-x)^beta log(x-a)          (mu = 1, nu = 0)
W(x) = (x-a)^alpha (b-x)^beta log(b-x)          (mu = 0, nu = 1)
W(x) = (x-a)^alpha (b-x)^beta log(x-a) log(b-x) (mu = 1, nu = 1)
</PRE>

</SPAN>

<P>
The singular points (a,b) do not have to be specified until the
integral is computed, where they are the endpoints of the integration
range.

</P>
<P>
The function returns a pointer to the newly allocated
<CODE>gsl_integration_qaws_table</CODE> if no errors were detected, and 0 in
the case of error.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_integration_qaws_table_set</B> <I>(gsl_integration_qaws_table * <VAR>t</VAR>, double <VAR>alpha</VAR>, double <VAR>beta</VAR>, int <VAR>mu</VAR>, int <VAR>nu</VAR>)</I>
<DD><A NAME="IDX1357"></A>
This function modifies the parameters (\alpha, \beta, \mu, \nu) of
an existing <CODE>gsl_integration_qaws_table</CODE> struct <VAR>t</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_integration_qaws_table_free</B> <I>(gsl_integration_qaws_table * <VAR>t</VAR>)</I>
<DD><A NAME="IDX1358"></A>
This function frees all the memory associated with the
<CODE>gsl_integration_qaws_table</CODE> struct <VAR>t</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_integration_qaws</B> <I>(gsl_function * <VAR>f</VAR>, const double <VAR>a</VAR>, const double <VAR>b</VAR>, gsl_integration_qaws_table * <VAR>t</VAR>, const double <VAR>epsabs</VAR>, const double <VAR>epsrel</VAR>, const size_t <VAR>limit</VAR>, gsl_integration_workspace * <VAR>workspace</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX1359"></A>

</P>
<P>
This function computes the integral of the function f(x) over the
interval (a,b) with the singular weight function
(x-a)^\alpha (b-x)^\beta \log^\mu (x-a) \log^\nu (b-x).  The parameters 
of the weight function (\alpha, \beta, \mu, \nu) are taken from the
table <VAR>t</VAR>.  The integral is,

<SPAN class="ifinfo">


<PRE class="example">
I = \int_a^b dx f(x) (x-a)^alpha (b-x)^beta log^mu (x-a) log^nu (b-x).
</PRE>

</SPAN>

<P>
The adaptive bisection algorithm of QAG is used.  When a subinterval
contains one of the endpoints then a special 25-point modified
Clenshaw-Curtis rule is used to control the singularities.  For
subintervals which do not include the endpoints an ordinary 15-point
Gauss-Kronrod integration rule is used.

</P>
</DL>



<H2><A NAME="SEC263" HREF="gsl_manual.html#TOC263">QAWO adaptive integration for oscillatory functions</A></H2>
<P>
<A NAME="IDX1360"></A>
The QAWO algorithm is designed for integrands with an oscillatory
factor, \sin(\omega x) or \cos(\omega x).  In order to
work efficiently the algorithm requires a table of Chebyshev moments
which must be pre-computed with calls to the functions below.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_integration_qawo_table * <B>gsl_integration_qawo_table_alloc</B> <I>(double <VAR>omega</VAR>, double <VAR>L</VAR>, enum gsl_integration_qawo_enum <VAR>sine</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1361"></A>

</P>
<P>
This function allocates space for a <CODE>gsl_integration_qawo_table</CODE>
struct and its associated workspace describing a sine or cosine weight
function W(x) with the parameters (\omega, L),

<SPAN class="ifinfo">


<PRE class="example">
W(x) = sin(omega x)
W(x) = cos(omega x)
</PRE>

</SPAN>

<P>
The parameter <VAR>L</VAR> must be the length of the interval over which the
function will be integrated L = b - a.  The choice of sine or
cosine is made with the parameter <VAR>sine</VAR> which should be chosen from
one of the two following symbolic values:

</P>

<PRE class="example">
GSL_INTEG_COSINE
GSL_INTEG_SINE
</PRE>

<P>
The <CODE>gsl_integration_qawo_table</CODE> is a table of the trigonometric
coefficients required in the integration process.  The parameter <VAR>n</VAR>
determines the number of levels of coefficients that are computed.  Each
level corresponds to one bisection of the interval L, so that
<VAR>n</VAR> levels are sufficient for subintervals down to the length
L/2^n.  The integration routine <CODE>gsl_integration_qawo</CODE>
returns the error <CODE>GSL_ETABLE</CODE> if the number of levels is
insufficient for the requested accuracy.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_integration_qawo_table_set</B> <I>(gsl_integration_qawo_table * <VAR>t</VAR>, double <VAR>omega</VAR>, double <VAR>L</VAR>, enum gsl_integration_qawo_enum <VAR>sine</VAR>)</I>
<DD><A NAME="IDX1362"></A>
This function changes the parameters <VAR>omega</VAR>, <VAR>L</VAR> and <VAR>sine</VAR>
of the existing workspace <VAR>t</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_integration_qawo_table_set_length</B> <I>(gsl_integration_qawo_table * <VAR>t</VAR>, double <VAR>L</VAR>)</I>
<DD><A NAME="IDX1363"></A>
This function allows the length parameter <VAR>L</VAR> of the workspace
<VAR>t</VAR> to be changed.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_integration_qawo_table_free</B> <I>(gsl_integration_qawo_table * <VAR>t</VAR>)</I>
<DD><A NAME="IDX1364"></A>
This function frees all the memory associated with the workspace <VAR>t</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_integration_qawo</B> <I>(gsl_function * <VAR>f</VAR>, const double <VAR>a</VAR>, const double <VAR>epsabs</VAR>, const double <VAR>epsrel</VAR>, const size_t <VAR>limit</VAR>, gsl_integration_workspace * <VAR>workspace</VAR>, gsl_integration_qawo_table * <VAR>wf</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX1365"></A>

</P>
<P>
This function uses an adaptive algorithm to compute the integral of
f over (a,b) with the weight function 
\sin(\omega x) or \cos(\omega x) defined 
by the table <VAR>wf</VAR>,

<SPAN class="ifinfo">


<PRE class="example">
I = \int_a^b dx f(x) sin(omega x)
I = \int_a^b dx f(x) cos(omega x)
</PRE>

</SPAN>

<P>
The results are extrapolated using the epsilon-algorithm to accelerate
the convergence of the integral.  The function returns the final
approximation from the extrapolation, <VAR>result</VAR>, and an estimate of
the absolute error, <VAR>abserr</VAR>.  The subintervals and their results are
stored in the memory provided by <VAR>workspace</VAR>.  The maximum number of
subintervals is given by <VAR>limit</VAR>, which may not exceed the allocated
size of the workspace.

</P>
<P>
Those subintervals with "large" widths d where d\omega &#62; 4 are
computed using a 25-point Clenshaw-Curtis integration rule, which handles the
oscillatory behavior.  Subintervals with a "small" widths where
d\omega &#60; 4 are computed using a 15-point Gauss-Kronrod integration.

</P>
</DL>



<H2><A NAME="SEC264" HREF="gsl_manual.html#TOC264">QAWF adaptive integration for Fourier integrals</A></H2>
<P>
<A NAME="IDX1366"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_integration_qawf</B> <I>(gsl_function * <VAR>f</VAR>, const double <VAR>a</VAR>, const double <VAR>epsabs</VAR>, const size_t <VAR>limit</VAR>, gsl_integration_workspace * <VAR>workspace</VAR>, gsl_integration_workspace * <VAR>cycle_workspace</VAR>, gsl_integration_qawo_table * <VAR>wf</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX1367"></A>

</P>
<P>
This function attempts to compute a Fourier integral of the function
<VAR>f</VAR> over the semi-infinite interval [a,+\infty).

<SPAN class="ifinfo">


<PRE class="example">
I = \int_a^{+\infty} dx f(x) sin(omega x)
I = \int_a^{+\infty} dx f(x) cos(omega x)
</PRE>

</SPAN>

<P>
The parameter \omega and choice of \sin or \cos is
taken from the table <VAR>wf</VAR> (the length <VAR>L</VAR> can take any value,
since it is overridden by this function to a value appropriate for the
fourier integration).  The integral is computed using the QAWO algorithm
over each of the subintervals,

<SPAN class="ifinfo">


<PRE class="example">
C_1 = [a, a + c]
C_2 = [a + c, a + 2 c]
... = ...
C_k = [a + (k-1) c, a + k c]
</PRE>

</SPAN>

<P>
where 
c = (2 floor(|\omega|) + 1) \pi/|\omega|.  The width c is
chosen to cover an odd number of periods so that the contributions from
the intervals alternate in sign and are monotonically decreasing when
<VAR>f</VAR> is positive and monotonically decreasing.  The sum of this
sequence of contributions is accelerated using the epsilon-algorithm.

</P>
<P>
This function works to an overall absolute tolerance of
<VAR>abserr</VAR>.  The following strategy is used: on each interval
C_k the algorithm tries to achieve the tolerance

<SPAN class="ifinfo">


<PRE class="example">
TOL_k = u_k abserr
</PRE>

</SPAN>

<P>
where 
u_k = (1 - p)p^{k-1} and p = 9/10.  
The sum of the geometric series of contributions from each interval
gives an overall tolerance of <VAR>abserr</VAR>.

</P>
<P>
If the integration of a subinterval leads to difficulties then the
accuracy requirement for subsequent intervals is relaxed,

<SPAN class="ifinfo">


<PRE class="example">
TOL_k = u_k max(abserr, max_{i&#60;k}{E_i})
</PRE>

</SPAN>

<P>
where E_k is the estimated error on the interval C_k.

</P>
<P>
The subintervals and their results are stored in the memory provided by
<VAR>workspace</VAR>.  The maximum number of subintervals is given by
<VAR>limit</VAR>, which may not exceed the allocated size of the workspace.
The integration over each subinterval uses the memory provided by
<VAR>cycle_workspace</VAR> as workspace for the QAWO algorithm.

</P>
</DL>



<H2><A NAME="SEC265" HREF="gsl_manual.html#TOC265">Error codes</A></H2>

<P>
In addition to the standard error codes for invalid arguments the
functions can return the following values,

</P>
<DL COMPACT>

<DT><CODE>GSL_EMAXITER</CODE>
<DD>
the maximum number of subdivisions was exceeded.
<DT><CODE>GSL_EROUND</CODE>
<DD>
cannot reach tolerance because of roundoff error,
or roundoff error was detected in the extrapolation table.
<DT><CODE>GSL_ESING</CODE>
<DD>
a non-integrable singularity or other bad integrand behavior was found
in the integration interval.
<DT><CODE>GSL_EDIVERGE</CODE>
<DD>
the integral is divergent, or too slowly convergent to be integrated
numerically.
</DL>



<H2><A NAME="SEC266" HREF="gsl_manual.html#TOC266">Examples</A></H2>

<P>
The integrator <CODE>QAGS</CODE> will handle a large class of definite
integrals.  For example, consider the following integral, which has a
algebraic-logarithmic singularity at the origin,

<SPAN class="ifinfo">


<PRE class="example">
\int_0^1 x^{-1/2} log(x) dx = -4
</PRE>

</SPAN>

<P>
The program below computes this integral to a relative accuracy bound of
<CODE>1e-7</CODE>.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;math.h&#62;
#include &#60;gsl/gsl_integration.h&#62;

double f (double x, void * params) {
  double alpha = *(double *) params;
  double f = log(alpha*x) / sqrt(x);
  return f;
}

int
main (void)
{
  gsl_integration_workspace * w 
    = gsl_integration_workspace_alloc (1000);
  
  double result, error;
  double expected = -4.0;
  double alpha = 1.0;

  gsl_function F;
  F.function = &#38;f;
  F.params = &#38;alpha;

  gsl_integration_qags (&#38;F, 0, 1, 0, 1e-7, 1000,
                        w, &#38;result, &#38;error); 

  printf ("result          = % .18f\n", result);
  printf ("exact result    = % .18f\n", expected);
  printf ("estimated error = % .18f\n", error);
  printf ("actual error    = % .18f\n", result - expected);
  printf ("intervals =  %d\n", w-&#62;size);

  return 0;
}
</PRE>

<P>
The results below show that the desired accuracy is achieved after 8
subdivisions. 

</P>

<PRE class="example">
$ ./a.out 
result          = -3.999999999999973799
exact result    = -4.000000000000000000
estimated error =  0.000000000000246025
actual error    =  0.000000000000026201
intervals =  8
</PRE>

<P>
In fact, the extrapolation procedure used by <CODE>QAGS</CODE> produces an
accuracy of almost twice as many digits.  The error estimate returned by
the extrapolation procedure is larger than the actual error, giving a
margin of safety of one order of magnitude.

</P>



<H2><A NAME="SEC267" HREF="gsl_manual.html#TOC267">References and Further Reading</A></H2>

<P>
The following book is the definitive reference for QUADPACK, and was
written by the original authors.  It provides descriptions of the
algorithms, program listings, test programs and examples.  It also
includes useful advice on numerical integration and many references to
the numerical integration literature used in developing QUADPACK.

</P>

<UL class="itemize">
<LI>

R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, D.K. Kahaner.
<CITE>QUADPACK A subroutine package for automatic integration</CITE>
Springer Verlag, 1983.
</UL>

<P>

</P>



<H1><A NAME="SEC268" HREF="gsl_manual.html#TOC268">Random Number Generation</A></H1>
<P>
<A NAME="IDX1368"></A>

</P>
<P>
The library provides a large collection of random number generators
which can be accessed through a uniform interface.  Environment
variables allow you to select different generators and seeds at runtime,
so that you can easily switch between generators without needing to
recompile your program.  Each instance of a generator keeps track of its
own state, allowing the generators to be used in multi-threaded
programs.  Additional functions are available for transforming uniform
random numbers into samples from continuous or discrete probability
distributions such as the Gaussian, log-normal or Poisson distributions.

</P>
<P>
These functions are declared in the header file <TT>'gsl_rng.h'</TT>.

</P>



<H2><A NAME="SEC269" HREF="gsl_manual.html#TOC269">General comments on random numbers</A></H2>

<P>
In 1988, Park and Miller wrote a paper entitled "Random number
generators: good ones are hard to find." [Commun. ACM, 31, 1192--1201].
Fortunately, some excellent random number generators are available,
though poor ones are still in common use.  You may be happy with the
system-supplied random number generator on your computer, but you should
be aware that as computers get faster, requirements on random number
generators increase.  Nowadays, a simulation that calls a random number
generator millions of times can often finish before you can make it down
the hall to the coffee machine and back.

</P>
<P>
A very nice review of random number generators was written by Pierre
L'Ecuyer, as Chapter 4 of the book: Handbook on Simulation, Jerry Banks,
ed. (Wiley, 1997).  The chapter is available in postscript from
L'Ecuyer's ftp site (see references).  Knuth's volume on Seminumerical
Algorithms (originally published in 1968) devotes 170 pages to random
number generators, and has recently been updated in its 3rd edition
(1997).
It is brilliant, a classic.  If you don't own it, you should stop reading
right now, run to the nearest bookstore, and buy it.

</P>
<P>
A good random number generator will satisfy both theoretical and
statistical properties.  Theoretical properties are often hard to obtain
(they require real math!), but one prefers a random number generator
with a long period, low serial correlation, and a tendency <EM>not</EM> to
"fall mainly on the planes."  Statistical tests are performed with
numerical simulations.  Generally, a random number generator is used to
estimate some quantity for which the theory of probability provides an
exact answer.  Comparison to this exact answer provides a measure of
"randomness".

</P>


<H2><A NAME="SEC270" HREF="gsl_manual.html#TOC270">The Random Number Generator Interface</A></H2>

<P>
It is important to remember that a random number generator is not a
"real" function like sine or cosine.  Unlike real functions, successive
calls to a random number generator yield different return values.  Of
course that is just what you want for a random number generator, but to
achieve this effect, the generator must keep track of some kind of
"state" variable.  Sometimes this state is just an integer (sometimes
just the value of the previously generated random number), but often it
is more complicated than that and may involve a whole array of numbers,
possibly with some indices thrown in.  To use the random number
generators, you do not need to know the details of what comprises the
state, and besides that varies from algorithm to algorithm.

</P>
<P>
The random number generator library uses two special structs,
<CODE>gsl_rng_type</CODE> which holds static information about each type of
generator and <CODE>gsl_rng</CODE> which describes an instance of a generator
created from a given <CODE>gsl_rng_type</CODE>.

</P>
<P>
The functions described in this section are declared in the header file
<TT>'gsl_rng.h'</TT>.

</P>


<H2><A NAME="SEC271" HREF="gsl_manual.html#TOC271">Random number generator initialization</A></H2>

<P>
<DL>
<DT><U>Function:</U> gsl_rng * <B>gsl_rng_alloc</B> <I>(const gsl_rng_type * <VAR>T</VAR>)</I>
<DD><A NAME="IDX1369"></A>
This function returns a pointer to a newly-created
instance of a random number generator of type <VAR>T</VAR>.
For example, the following code creates an instance of the Tausworthe
generator,

</P>

<PRE class="example">
gsl_rng * r = gsl_rng_alloc (gsl_rng_taus);
</PRE>

<P>
If there is insufficient memory to create the generator then the
function returns a null pointer and the error handler is invoked with an
error code of <CODE>GSL_ENOMEM</CODE>.

</P>
<P>
The generator is automatically initialized with the default seed,
<CODE>gsl_rng_default_seed</CODE>.  This is zero by default but can be changed
either directly or by using the environment variable <CODE>GSL_RNG_SEED</CODE>
(see section <A HREF="gsl_manual.html#SEC274">Random number environment variables</A>).

</P>
<P>
The details of the available generator types are
described later in this chapter.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_rng_set</B> <I>(const gsl_rng * <VAR>r</VAR>, unsigned long int <VAR>s</VAR>)</I>
<DD><A NAME="IDX1370"></A>
This function initializes (or `seeds') the random number generator.  If
the generator is seeded with the same value of <VAR>s</VAR> on two different
runs, the same stream of random numbers will be generated by successive
calls to the routines below.  If different values of <VAR>s</VAR> are
supplied, then the generated streams of random numbers should be
completely different.  If the seed <VAR>s</VAR> is zero then the standard seed
from the original implementation is used instead.  For example, the
original Fortran source code for the <CODE>ranlux</CODE> generator used a seed
of 314159265, and so choosing <VAR>s</VAR> equal to zero reproduces this when
using <CODE>gsl_rng_ranlux</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_rng_free</B> <I>(gsl_rng * <VAR>r</VAR>)</I>
<DD><A NAME="IDX1371"></A>
This function frees all the memory associated with the generator
<VAR>r</VAR>.
</DL>

</P>


<H2><A NAME="SEC272" HREF="gsl_manual.html#TOC272">Sampling from a random number generator</A></H2>

<P>
The following functions return uniformly distributed random numbers,
either as integers or double precision floating point numbers.  To obtain
non-uniform distributions see section <A HREF="gsl_manual.html#SEC292">Random Number Distributions</A>.

</P>
<P>
<DL>
<DT><U>Function:</U> unsigned long int <B>gsl_rng_get</B> <I>(const gsl_rng * <VAR>r</VAR>)</I>
<DD><A NAME="IDX1372"></A>
This function returns a random integer from the generator <VAR>r</VAR>.  The
minimum and maximum values depend on the algorithm used, but all
integers in the range [<VAR>min</VAR>,<VAR>max</VAR>] are equally likely.  The
values of <VAR>min</VAR> and <VAR>max</VAR> can determined using the auxiliary
functions <CODE>gsl_rng_max (r)</CODE> and <CODE>gsl_rng_min (r)</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_rng_uniform</B> <I>(const gsl_rng * <VAR>r</VAR>)</I>
<DD><A NAME="IDX1373"></A>
This function returns a double precision floating point number uniformly
distributed in the range [0,1).  The range includes 0.0 but excludes 1.0.
The value is typically obtained by dividing the result of
<CODE>gsl_rng_get(r)</CODE> by <CODE>gsl_rng_max(r) + 1.0</CODE> in double
precision.  Some generators compute this ratio internally so that they
can provide floating point numbers with more than 32 bits of randomness
(the maximum number of bits that can be portably represented in a single
<CODE>unsigned long int</CODE>).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_rng_uniform_pos</B> <I>(const gsl_rng * <VAR>r</VAR>)</I>
<DD><A NAME="IDX1374"></A>
This function returns a positive double precision floating point number
uniformly distributed in the range (0,1), excluding both 0.0 and 1.0.
The number is obtained by sampling the generator with the algorithm of
<CODE>gsl_rng_uniform</CODE> until a non-zero value is obtained.  You can use
this function if you need to avoid a singularity at 0.0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> unsigned long int <B>gsl_rng_uniform_int</B> <I>(const gsl_rng * <VAR>r</VAR>, unsigned long int <VAR>n</VAR>)</I>
<DD><A NAME="IDX1375"></A>
This function returns a random integer from 0 to <VAR>n</VAR>-1 inclusive.
All integers in the range [0,<VAR>n</VAR>-1] are equally likely, regardless
of the generator used.  An offset correction is applied so that zero is
always returned with the correct probability, for any minimum value of
the underlying generator.

</P>
<P>
If <VAR>n</VAR> is larger than the range of the generator then the function
calls the error handler with an error code of <CODE>GSL_EINVAL</CODE> and
returns zero.
</DL>

</P>


<H2><A NAME="SEC273" HREF="gsl_manual.html#TOC273">Auxiliary random number generator functions</A></H2>
<P>
The following functions provide information about an existing
generator.  You should use them in preference to hard-coding the generator
parameters into your own code.

</P>
<P>
<DL>
<DT><U>Function:</U> const char * <B>gsl_rng_name</B> <I>(const gsl_rng * <VAR>r</VAR>)</I>
<DD><A NAME="IDX1376"></A>
This function returns a pointer to the name of the generator.
For example,

</P>

<PRE class="example">
printf ("r is a '%s' generator\n", 
        gsl_rng_name (r));
</PRE>

<P>
would print something like <CODE>r is a 'taus' generator</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> unsigned long int <B>gsl_rng_max</B> <I>(const gsl_rng * <VAR>r</VAR>)</I>
<DD><A NAME="IDX1377"></A>
<CODE>gsl_rng_max</CODE> returns the largest value that <CODE>gsl_rng_get</CODE>
can return.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> unsigned long int <B>gsl_rng_min</B> <I>(const gsl_rng * <VAR>r</VAR>)</I>
<DD><A NAME="IDX1378"></A>
<CODE>gsl_rng_min</CODE> returns the smallest value that <CODE>gsl_rng_get</CODE>
can return.  Usually this value is zero.  There are some generators with
algorithms that cannot return zero, and for these generators the minimum
value is 1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void * <B>gsl_rng_state</B> <I>(const gsl_rng * <VAR>r</VAR>)</I>
<DD><A NAME="IDX1379"></A>
<DT><U>Function:</U> size_t <B>gsl_rng_size</B> <I>(const gsl_rng * <VAR>r</VAR>)</I>
<DD><A NAME="IDX1380"></A>
These functions return a pointer to the state of generator <VAR>r</VAR> and
its size.  You can use this information to access the state directly.  For
example, the following code will write the state of a generator to a
stream,

</P>

<PRE class="example">
void * state = gsl_rng_state (r);
size_t n = gsl_rng_size (r);
fwrite (state, n, 1, stream);
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> const gsl_rng_type ** <B>gsl_rng_types_setup</B> <I>(void)</I>
<DD><A NAME="IDX1381"></A>
This function returns a pointer to an array of all the available
generator types, terminated by a null pointer. The function should be
called once at the start of the program, if needed.  The following code
fragment shows how to iterate over the array of generator types to print
the names of the available algorithms,

</P>

<PRE class="example">
const gsl_rng_type **t, **t0;

t0 = gsl_rng_types_setup ();

printf ("Available generators:\n");

for (t = t0; *t != 0; t++)
  {
    printf ("%s\n", (*t)-&#62;name);
  }
</PRE>

</DL>



<H2><A NAME="SEC274" HREF="gsl_manual.html#TOC274">Random number environment variables</A></H2>

<P>
The library allows you to choose a default generator and seed from the
environment variables <CODE>GSL_RNG_TYPE</CODE> and <CODE>GSL_RNG_SEED</CODE> and
the function <CODE>gsl_rng_env_setup</CODE>.  This makes it easy try out
different generators and seeds without having to recompile your program.

</P>
<P>
<DL>
<DT><U>Function:</U> const gsl_rng_type * <B>gsl_rng_env_setup</B> <I>(void)</I>
<DD><A NAME="IDX1382"></A>
This function reads the environment variables <CODE>GSL_RNG_TYPE</CODE> and
<CODE>GSL_RNG_SEED</CODE> and uses their values to set the corresponding
library variables <CODE>gsl_rng_default</CODE> and
<CODE>gsl_rng_default_seed</CODE>.  These global variables are defined as
follows,

</P>

<PRE class="example">
extern const gsl_rng_type *gsl_rng_default
extern unsigned long int gsl_rng_default_seed
</PRE>

<P>
The environment variable <CODE>GSL_RNG_TYPE</CODE> should be the name of a
generator, such as <CODE>taus</CODE> or <CODE>mt19937</CODE>.  The environment
variable <CODE>GSL_RNG_SEED</CODE> should contain the desired seed value.  It
is converted to an <CODE>unsigned long int</CODE> using the C library function
<CODE>strtoul</CODE>.

</P>
<P>
If you don't specify a generator for <CODE>GSL_RNG_TYPE</CODE> then
<CODE>gsl_rng_mt19937</CODE> is used as the default.  The initial value of
<CODE>gsl_rng_default_seed</CODE> is zero.

</P>
</DL>
<P>
Here is a short program which shows how to create a global
generator using the environment variables <CODE>GSL_RNG_TYPE</CODE> and
<CODE>GSL_RNG_SEED</CODE>,

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_rng.h&#62;

gsl_rng * r;  /* global generator */

int
main (void)
{
  const gsl_rng_type * T;

  gsl_rng_env_setup();

  T = gsl_rng_default;
  r = gsl_rng_alloc (T);
  
  printf ("generator type: %s\n", gsl_rng_name (r));
  printf ("seed = %lu\n", gsl_rng_default_seed);
  printf ("first value = %lu\n", gsl_rng_get (r));
  return 0;
}
</PRE>

<P>
Running the program without any environment variables uses the initial
defaults, an <CODE>mt19937</CODE> generator with a seed of 0,

</P>

<PRE class="example">
$ ./a.out 
generator type: mt19937
seed = 0
first value = 4293858116
</PRE>

<P>
By setting the two variables on the command line we can
change the default generator and the seed,

</P>

<PRE class="example">
$ GSL_RNG_TYPE="taus" GSL_RNG_SEED=123 ./a.out 
GSL_RNG_TYPE=taus
GSL_RNG_SEED=123
generator type: taus
seed = 123
first value = 2720986350
</PRE>



<H2><A NAME="SEC275" HREF="gsl_manual.html#TOC275">Copying random number generator state</A></H2>

<P>
The above methods do not expose the random number `state' which changes
from call to call.  It is often useful to be able to save and restore
the state.  To permit these practices, a few somewhat more advanced
functions are supplied.  These include:

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_rng_memcpy</B> <I>(gsl_rng * <VAR>dest</VAR>, const gsl_rng * <VAR>src</VAR>)</I>
<DD><A NAME="IDX1383"></A>
This function copies the random number generator <VAR>src</VAR> into the
pre-existing generator <VAR>dest</VAR>, making <VAR>dest</VAR> into an exact copy
of <VAR>src</VAR>.  The two generators must be of the same type.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_rng * <B>gsl_rng_clone</B> <I>(const gsl_rng * <VAR>r</VAR>)</I>
<DD><A NAME="IDX1384"></A>
This function returns a pointer to a newly created generator which is an
exact copy of the generator <VAR>r</VAR>.
</DL>

</P>


<H2><A NAME="SEC276" HREF="gsl_manual.html#TOC276">Reading and writing random number generator state</A></H2>

<P>
The library provides functions for reading and writing the random
number state to a file as binary data or formatted text.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_rng_fwrite</B> <I>(FILE * <VAR>stream</VAR>, const gsl_rng * <VAR>r</VAR>)</I>
<DD><A NAME="IDX1385"></A>
This function writes the random number state of the random number
generator <VAR>r</VAR> to the stream <VAR>stream</VAR> in binary format.  The
return value is 0 for success and <CODE>GSL_EFAILED</CODE> if there was a
problem writing to the file.  Since the data is written in the native
binary format it may not be portable between different architectures.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_rng_fread</B> <I>(FILE * <VAR>stream</VAR>, gsl_rng * <VAR>r</VAR>)</I>
<DD><A NAME="IDX1386"></A>
This function reads the random number state into the random number
generator <VAR>r</VAR> from the open stream <VAR>stream</VAR> in binary format.
The random number generator <VAR>r</VAR> must be preinitialized with the
correct random number generator type since type information is not
saved.  The return value is 0 for success and <CODE>GSL_EFAILED</CODE> if
there was a problem reading from the file.  The data is assumed to
have been written in the native binary format on the same
architecture.
</DL>

</P>


<H2><A NAME="SEC277" HREF="gsl_manual.html#TOC277">Random number generator algorithms</A></H2>

<P>
The functions described above make no reference to the actual algorithm
used.  This is deliberate so that you can switch algorithms without
having to change any of your application source code.  The library
provides a large number of generators of different types, including
simulation quality generators, generators provided for compatibility
with other libraries and historical generators from the past.

</P>
<P>
The following generators are recommended for use in simulation.  They
have extremely long periods, low correlation and pass most statistical
tests.

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_mt19937</B>
<DD><A NAME="IDX1387"></A>
<A NAME="IDX1388"></A>
The MT19937 generator of Makoto Matsumoto and Takuji Nishimura is a
variant of the twisted generalized feedback shift-register algorithm,
and is known as the "Mersenne Twister" generator.  It has a Mersenne
prime period of 
2^19937 - 1 (about 
10^6000) and is
equi-distributed in 623 dimensions.  It has passed the DIEHARD
statistical tests.  It uses 624 words of state per generator and is
comparable in speed to the other generators.  The original generator used
a default seed of 4357 and choosing <VAR>s</VAR> equal to zero in
<CODE>gsl_rng_set</CODE> reproduces this.

</P>
<P>
For more information see,

<UL class="itemize">
<LI>

Makoto Matsumoto and Takuji Nishimura, "Mersenne Twister: A
623-dimensionally equidistributed uniform pseudorandom number
generator". <CITE>ACM Transactions on Modeling and Computer
Simulation</CITE>, Vol. 8, No. 1 (Jan. 1998), Pages 3--30
</UL>

<P>
The generator <CODE>gsl_rng_mt19937</CODE> uses the second revision of the
seeding procedure published by the two authors above in 2002.  The
original seeding procedures could cause spurious artifacts for some seed
values. They are still available through the alternative generators
<CODE>gsl_rng_mt19937_1999</CODE> and <CODE>gsl_rng_mt19937_1998</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_ranlxs0</B>
<DD><A NAME="IDX1389"></A>
<DT><U>Generator:</U> <B>gsl_rng_ranlxs1</B>
<DD><A NAME="IDX1390"></A>
<DT><U>Generator:</U> <B>gsl_rng_ranlxs2</B>
<DD><A NAME="IDX1391"></A>
<A NAME="IDX1392"></A>

</P>
<P>
The generator <CODE>ranlxs0</CODE> is a second-generation version of the
RANLUX algorithm of L&uuml;scher, which produces "luxury random
numbers".  This generator provides single precision output (24 bits) at
three luxury levels <CODE>ranlxs0</CODE>, <CODE>ranlxs1</CODE> and <CODE>ranlxs2</CODE>.
It uses double-precision floating point arithmetic internally and can be
significantly faster than the integer version of <CODE>ranlux</CODE>,
particularly on 64-bit architectures.  The period of the generator is
about 
10^171.  The algorithm has mathematically proven properties and
can provide truly decorrelated numbers at a known level of randomness.
The higher luxury levels provide increased decorrelation between samples
as an additional safety margin.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_ranlxd1</B>
<DD><A NAME="IDX1393"></A>
<DT><U>Generator:</U> <B>gsl_rng_ranlxd2</B>
<DD><A NAME="IDX1394"></A>
<A NAME="IDX1395"></A>

</P>
<P>
These generators produce double precision output (48 bits) from the
RANLXS generator.  The library provides two luxury levels
<CODE>ranlxd1</CODE> and <CODE>ranlxd2</CODE>.
</DL>

</P>

<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_ranlux</B>
<DD><A NAME="IDX1396"></A>
<DT><U>Generator:</U> <B>gsl_rng_ranlux389</B>
<DD><A NAME="IDX1397"></A>

</P>
<P>
<A NAME="IDX1398"></A>
The <CODE>ranlux</CODE> generator is an implementation of the original
algorithm developed by L&uuml;scher.  It uses a
lagged-fibonacci-with-skipping algorithm to produce "luxury random
numbers".  It is a 24-bit generator, originally designed for
single-precision IEEE floating point numbers.  This implementation is
based on integer arithmetic, while the second-generation versions
RANLXS and RANLXD described above provide floating-point
implementations which will be faster on many platforms.
The period of the generator is about 
10^171.  The algorithm has mathematically proven properties and
it can provide truly decorrelated numbers at a known level of
randomness.  The default level of decorrelation recommended by L&uuml;scher
is provided by <CODE>gsl_rng_ranlux</CODE>, while <CODE>gsl_rng_ranlux389</CODE>
gives the highest level of randomness, with all 24 bits decorrelated.
Both types of generator use 24 words of state per generator.

</P>
<P>
For more information see,

<UL class="itemize">
<LI>

M. L&uuml;scher, "A portable high-quality random number generator for
lattice field theory calculations", <CITE>Computer Physics
Communications</CITE>, 79 (1994) 100--110.
<LI>

F. James, "RANLUX: A Fortran implementation of the high-quality
pseudo-random number generator of L&uuml;scher", <CITE>Computer Physics
Communications</CITE>, 79 (1994) 111--114
</UL>

</DL>

<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_cmrg</B>
<DD><A NAME="IDX1399"></A>
<A NAME="IDX1400"></A>
This is a combined multiple recursive generator by L'Ecuyer. 
Its sequence is,

<SPAN class="ifinfo">


<PRE class="example">
z_n = (x_n - y_n) mod m_1
</PRE>

</SPAN>

<P>
where the two underlying generators x_n and y_n are,

<SPAN class="ifinfo">


<PRE class="example">
x_n = (a_1 x_{n-1} + a_2 x_{n-2} + a_3 x_{n-3}) mod m_1
y_n = (b_1 y_{n-1} + b_2 y_{n-2} + b_3 y_{n-3}) mod m_2
</PRE>

</SPAN>

<P>
with coefficients 
a_1 = 0, 
a_2 = 63308, 
a_3 = -183326,
b_1 = 86098, 
b_2 = 0,
b_3 = -539608,
and moduli 
m_1 = 2^31 - 1 = 2147483647
and 
m_2 = 2145483479.

</P>
<P>
The period of this generator is 
2^205 
(about 
10^61).  It uses
6 words of state per generator.  For more information see,

</P>

<UL class="itemize">
<LI>

P. L'Ecuyer, "Combined Multiple Recursive Random Number
Generators", <CITE>Operations Research</CITE>, 44, 5 (1996), 816--822.
</UL>

</DL>

<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_mrg</B>
<DD><A NAME="IDX1401"></A>
<A NAME="IDX1402"></A>
This is a fifth-order multiple recursive generator by L'Ecuyer, Blouin
and Coutre.  Its sequence is,

<SPAN class="ifinfo">


<PRE class="example">
x_n = (a_1 x_{n-1} + a_5 x_{n-5}) mod m
</PRE>

</SPAN>

<P>
with 
a_1 = 107374182, 
a_2 = a_3 = a_4 = 0, 
a_5 = 104480
and 
m = 2^31 - 1.

</P>
<P>
The period of this generator is about 
10^46.  It uses 5 words
of state per generator.  More information can be found in the following
paper,

<UL class="itemize">
<LI>

P. L'Ecuyer, F. Blouin, and R. Coutre, "A search for good multiple
recursive random number generators", <CITE>ACM Transactions on Modeling and
Computer Simulation</CITE> 3, 87--98 (1993).
</UL>

</DL>

<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_taus</B>
<DD><A NAME="IDX1403"></A>
<DT><U>Generator:</U> <B>gsl_rng_taus2</B>
<DD><A NAME="IDX1404"></A>
<A NAME="IDX1405"></A>
This is a maximally equidistributed combined Tausworthe generator by
L'Ecuyer.  The sequence is,

<SPAN class="ifinfo">


<PRE class="example">
x_n = (s1_n ^^ s2_n ^^ s3_n) 
</PRE>

</SPAN>

<P>
where,

<SPAN class="ifinfo">


<PRE class="example">
s1_{n+1} = (((s1_n&#38;4294967294)&#60;&#60;12)^^(((s1_n&#60;&#60;13)^^s1_n)&#62;&#62;19))
s2_{n+1} = (((s2_n&#38;4294967288)&#60;&#60; 4)^^(((s2_n&#60;&#60; 2)^^s2_n)&#62;&#62;25))
s3_{n+1} = (((s3_n&#38;4294967280)&#60;&#60;17)^^(((s3_n&#60;&#60; 3)^^s3_n)&#62;&#62;11))
</PRE>

</SPAN>

<P>
computed modulo 
2^32.  In the formulas above 
^^
denotes "exclusive-or".  Note that the algorithm relies on the properties
of 32-bit unsigned integers and has been implemented using a bitmask
of <CODE>0xFFFFFFFF</CODE> to make it work on 64 bit machines.

</P>
<P>
The period of this generator is 
2^88 (about
10^26).  It uses 3 words of state per generator.  For more
information see,

</P>

<UL class="itemize">
<LI>

P. L'Ecuyer, "Maximally Equidistributed Combined Tausworthe
Generators", <CITE>Mathematics of Computation</CITE>, 65, 213 (1996), 203--213.
</UL>

<P>
The generator <CODE>gsl_rng_taus2</CODE> uses the same algorithm as
<CODE>gsl_rng_taus</CODE> but with an improved seeding procedure described in
the paper,

</P>

<UL class="itemize">
<LI>

P. L'Ecuyer, "Tables of Maximally Equidistributed Combined LFSR
Generators", <CITE>Mathematics of Computation</CITE>, 68, 225 (1999), 261--269
</UL>

<P>
The generator <CODE>gsl_rng_taus2</CODE> should now be used in preference to
<CODE>gsl_rng_taus</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_gfsr4</B>
<DD><A NAME="IDX1406"></A>
<A NAME="IDX1407"></A>
The <CODE>gfsr4</CODE> generator is like a lagged-fibonacci generator, and 
produces each number as an <CODE>xor</CODE>'d sum of four previous values.

<SPAN class="ifinfo">


<PRE class="example">
r_n = r_{n-A} ^^ r_{n-B} ^^ r_{n-C} ^^ r_{n-D}
</PRE>

</SPAN>

<P>
Ziff (ref below) notes that "it is now widely known" that two-tap
registers (such as R250, which is described below)
have serious flaws, the most obvious one being the three-point
correlation that comes from the definition of the generator.  Nice
mathematical properties can be derived for GFSR's, and numerics bears
out the claim that 4-tap GFSR's with appropriately chosen offsets are as
random as can be measured, using the author's test.

</P>
<P>
This implementation uses the values suggested the example on p392 of
Ziff's article: A=471, B=1586, C=6988, D=9689.

</P>

<P>
If the offsets are appropriately chosen (such as the one ones in this
implementation), then the sequence is said to be maximal; that means
that the period is 2^D - 1, where D is the longest lag.
(It is one less than 2^D because it is not permitted to have all
zeros in the <CODE>ra[]</CODE> array.)  For this implementation with
D=9689 that works out to about 
10^2917.

</P>
<P>
Note that the implementation of this generator using a 32-bit
integer amounts to 32 parallel implementations of one-bit
generators.  One consequence of this is that the period of this
32-bit generator is the same as for the one-bit generator.
Moreover, this independence means that all 32-bit patterns are
equally likely, and in particular that 0 is an allowed random
value.  (We are grateful to Heiko Bauke for clarifying for us these
properties of GFSR random number generators.)

</P>
<P>
For more information see,

<UL class="itemize">
<LI>

Robert M. Ziff, "Four-tap shift-register-sequence random-number 
generators", <CITE>Computers in Physics</CITE>, 12(4), Jul/Aug
1998, pp 385--392.
</UL>

</DL>



<H2><A NAME="SEC278" HREF="gsl_manual.html#TOC278">Unix random number generators</A></H2>

<P>
The standard Unix random number generators <CODE>rand</CODE>, <CODE>random</CODE>
and <CODE>rand48</CODE> are provided as part of GSL. Although these
generators are widely available individually often they aren't all
available on the same platform.  This makes it difficult to write
portable code using them and so we have included the complete set of
Unix generators in GSL for convenience.  Note that these generators
don't produce high-quality randomness and aren't suitable for work
requiring accurate statistics.  However, if you won't be measuring
statistical quantities and just want to introduce some variation into
your program then these generators are quite acceptable.

</P>
<P>
<A NAME="IDX1408"></A>
<A NAME="IDX1409"></A>
<A NAME="IDX1410"></A>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_rand</B>
<DD><A NAME="IDX1411"></A>
<A NAME="IDX1412"></A>
This is the BSD <CODE>rand()</CODE> generator.  Its sequence is

<SPAN class="ifinfo">


<PRE class="example">
x_{n+1} = (a x_n + c) mod m
</PRE>

</SPAN>

<P>
with 
a = 1103515245, 
c = 12345 and 
m = 2^31.
The seed specifies the initial value, 
x_1.  The period of this
generator is 
2^31, and it uses 1 word of storage per
generator.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_random_bsd</B>
<DD><A NAME="IDX1413"></A>
<DT><U>Generator:</U> <B>gsl_rng_random_libc5</B>
<DD><A NAME="IDX1414"></A>
<DT><U>Generator:</U> <B>gsl_rng_random_glibc2</B>
<DD><A NAME="IDX1415"></A>
These generators implement the <CODE>random()</CODE> family of functions, a
set of linear feedback shift register generators originally used in BSD
Unix.  There are several versions of <CODE>random()</CODE> in use today: the
original BSD version (e.g. on SunOS4), a libc5 version (found on
older GNU/Linux systems) and a glibc2 version.  Each version uses a
different seeding procedure, and thus produces different sequences.

</P>
<P>
The original BSD routines accepted a variable length buffer for the
generator state, with longer buffers providing higher-quality
randomness.  The <CODE>random()</CODE> function implemented algorithms for
buffer lengths of 8, 32, 64, 128 and 256 bytes, and the algorithm with
the largest length that would fit into the user-supplied buffer was
used.  To support these algorithms additional generators are available
with the following names,

</P>

<PRE class="example">
gsl_rng_random8_bsd
gsl_rng_random32_bsd
gsl_rng_random64_bsd
gsl_rng_random128_bsd
gsl_rng_random256_bsd
</PRE>

<P>
where the numeric suffix indicates the buffer length.  The original BSD
<CODE>random</CODE> function used a 128-byte default buffer and so
<CODE>gsl_rng_random_bsd</CODE> has been made equivalent to
<CODE>gsl_rng_random128_bsd</CODE>.  Corresponding versions of the <CODE>libc5</CODE>
and <CODE>glibc2</CODE> generators are also available, with the names
<CODE>gsl_rng_random8_libc5</CODE>, <CODE>gsl_rng_random8_glibc2</CODE>, etc.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_rand48</B>
<DD><A NAME="IDX1416"></A>
<A NAME="IDX1417"></A>
This is the Unix <CODE>rand48</CODE> generator.  Its sequence is

<SPAN class="ifinfo">


<PRE class="example">
x_{n+1} = (a x_n + c) mod m
</PRE>

</SPAN>

<P>
defined on 48-bit unsigned integers with 
a = 25214903917, 
c = 11 and 
m = 2^48. 
The seed specifies the upper 32 bits of the initial value, x_1,
with the lower 16 bits set to <CODE>0x330E</CODE>.  The function
<CODE>gsl_rng_get</CODE> returns the upper 32 bits from each term of the
sequence.  This does not have a direct parallel in the original
<CODE>rand48</CODE> functions, but forcing the result to type <CODE>long int</CODE>
reproduces the output of <CODE>mrand48</CODE>.  The function
<CODE>gsl_rng_uniform</CODE> uses the full 48 bits of internal state to return
the double precision number x_n/m, which is equivalent to the
function <CODE>drand48</CODE>.  Note that some versions of the GNU C Library
contained a bug in <CODE>mrand48</CODE> function which caused it to produce
different results (only the lower 16-bits of the return value were set).
</DL>

</P>


<H2><A NAME="SEC279" HREF="gsl_manual.html#TOC279">Other random number generators</A></H2>

<P>
The generators in this section are provided for compatibility with
existing libraries.  If you are converting an existing program to use GSL
then you can select these generators to check your new implementation
against the original one, using the same random number generator.  After
verifying that your new program reproduces the original results you can
then switch to a higher-quality generator.

</P>
<P>
Note that most of the generators in this section are based on single
linear congruence relations, which are the least sophisticated type of
generator.  In particular, linear congruences have poor properties when
used with a non-prime modulus, as several of these routines do (e.g.
with a power of two modulus, 
2^31 or 
2^32).  This
leads to periodicity in the least significant bits of each number,
with only the higher bits having any randomness.  Thus if you want to
produce a random bitstream it is best to avoid using the least
significant bits.

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_ranf</B>
<DD><A NAME="IDX1418"></A>
<A NAME="IDX1419"></A>
<A NAME="IDX1420"></A>
This is the CRAY random number generator <CODE>RANF</CODE>.  Its sequence is

<SPAN class="ifinfo">


<PRE class="example">
x_{n+1} = (a x_n) mod m
</PRE>

</SPAN>

<P>
defined on 48-bit unsigned integers with a = 44485709377909 and
m = 2^48.  The seed specifies the lower
32 bits of the initial value, 
x_1, with the lowest bit set to
prevent the seed taking an even value.  The upper 16 bits of 
x_1
are set to 0. A consequence of this procedure is that the pairs of seeds
2 and 3, 4 and 5, etc produce the same sequences.

</P>
<P>
The generator compatible with the CRAY MATHLIB routine RANF. It
produces double precision floating point numbers which should be
identical to those from the original RANF.

</P>
<P>
There is a subtlety in the implementation of the seeding.  The initial
state is reversed through one step, by multiplying by the modular
inverse of a mod m.  This is done for compatibility with
the original CRAY implementation.

</P>
<P>
Note that you can only seed the generator with integers up to
2^32, while the original CRAY implementation uses
non-portable wide integers which can cover all 
2^48 states of the generator.

</P>
<P>
The function <CODE>gsl_rng_get</CODE> returns the upper 32 bits from each term
of the sequence.  The function <CODE>gsl_rng_uniform</CODE> uses the full 48
bits to return the double precision number x_n/m.

</P>
<P>
The period of this generator is 
2^46.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_ranmar</B>
<DD><A NAME="IDX1421"></A>
<A NAME="IDX1422"></A>
This is the RANMAR lagged-fibonacci generator of Marsaglia, Zaman and
Tsang.  It is a 24-bit generator, originally designed for
single-precision IEEE floating point numbers.  It was included in the
CERNLIB high-energy physics library.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_r250</B>
<DD><A NAME="IDX1423"></A>
<A NAME="IDX1424"></A>
<A NAME="IDX1425"></A>
This is the shift-register generator of Kirkpatrick and Stoll.  The
sequence is based on the recurrence

<SPAN class="ifinfo">


<PRE class="example">
x_n = x_{n-103} ^^ x_{n-250}
</PRE>

</SPAN>

<P>
where 
^^ denotes "exclusive-or", defined on
32-bit words.  The period of this generator is about 
2^250 and it
uses 250 words of state per generator.

</P>
<P>
For more information see,

<UL class="itemize">
<LI>

S. Kirkpatrick and E. Stoll, "A very fast shift-register sequence random
number generator", <CITE>Journal of Computational Physics</CITE>, 40, 517--526
(1981)
</UL>

</DL>

<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_tt800</B>
<DD><A NAME="IDX1426"></A>
<A NAME="IDX1427"></A>
This is an earlier version of the twisted generalized feedback
shift-register generator, and has been superseded by the development of
MT19937.  However, it is still an acceptable generator in its own
right.  It has a period of 
2^800 and uses 33 words of storage
per generator.

</P>
<P>
For more information see,

<UL class="itemize">
<LI>

Makoto Matsumoto and Yoshiharu Kurita, "Twisted GFSR Generators
II", <CITE>ACM Transactions on Modelling and Computer Simulation</CITE>,
Vol. 4, No. 3, 1994, pages 254--266.
</UL>

</DL>

<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_vax</B>
<DD><A NAME="IDX1428"></A>
<A NAME="IDX1429"></A>
This is the VAX generator <CODE>MTH$RANDOM</CODE>.  Its sequence is,

<SPAN class="ifinfo">


<PRE class="example">
x_{n+1} = (a x_n + c) mod m
</PRE>

</SPAN>

<P>
with 
a = 69069, c = 1 and 
m = 2^32.  The seed specifies the initial value, 
x_1.  The
period of this generator is 
2^32 and it uses 1 word of storage per
generator.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_transputer</B>
<DD><A NAME="IDX1430"></A>
This is the random number generator from the INMOS Transputer
Development system.  Its sequence is,

<SPAN class="ifinfo">


<PRE class="example">
x_{n+1} = (a x_n) mod m
</PRE>

</SPAN>

<P>
with a = 1664525 and 
m = 2^32.
The seed specifies the initial value, 
x_1.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_randu</B>
<DD><A NAME="IDX1431"></A>
<A NAME="IDX1432"></A>
This is the IBM <CODE>RANDU</CODE> generator.  Its sequence is

<SPAN class="ifinfo">


<PRE class="example">
x_{n+1} = (a x_n) mod m
</PRE>

</SPAN>

<P>
with a = 65539 and 
m = 2^31.  The
seed specifies the initial value, 
x_1.  The period of this
generator was only 
2^29.  It has become a textbook example of a
poor generator.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_minstd</B>
<DD><A NAME="IDX1433"></A>
<A NAME="IDX1434"></A>
This is Park and Miller's "minimal standard" MINSTD generator, a
simple linear congruence which takes care to avoid the major pitfalls of
such algorithms.  Its sequence is,

<SPAN class="ifinfo">


<PRE class="example">
x_{n+1} = (a x_n) mod m
</PRE>

</SPAN>

<P>
with a = 16807 and 
m = 2^31 - 1 = 2147483647. 
The seed specifies the initial value, 
x_1.  The period of this
generator is about 
2^31.

</P>
<P>
This generator is used in the IMSL Library (subroutine RNUN) and in
MATLAB (the RAND function).  It is also sometimes known by the acronym
"GGL" (I'm not sure what that stands for).

</P>
<P>
For more information see,

<UL class="itemize">
<LI>

Park and Miller, "Random Number Generators: Good ones are hard to find",
<CITE>Communications of the ACM</CITE>, October 1988, Volume 31, No 10, pages
1192--1201.
</UL>

</DL>

<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_uni</B>
<DD><A NAME="IDX1435"></A>
<DT><U>Generator:</U> <B>gsl_rng_uni32</B>
<DD><A NAME="IDX1436"></A>
This is a reimplementation of the 16-bit SLATEC random number generator
RUNIF. A generalization of the generator to 32 bits is provided by
<CODE>gsl_rng_uni32</CODE>.  The original source code is available from NETLIB.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_slatec</B>
<DD><A NAME="IDX1437"></A>
This is the SLATEC random number generator RAND. It is ancient.  The
original source code is available from NETLIB.
</DL>

</P>

<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_zuf</B>
<DD><A NAME="IDX1438"></A>
This is the ZUFALL lagged Fibonacci series generator of Peterson.  Its
sequence is,

<SPAN class="ifinfo">


<PRE class="example">
t = u_{n-273} + u_{n-607}
u_n  = t - floor(t)
</PRE>

</SPAN>

<P>
The original source code is available from NETLIB.  For more information
see,

<UL class="itemize">
<LI>

W. Petersen, "Lagged Fibonacci Random Number Generators for the NEC
SX-3", <CITE>International Journal of High Speed Computing</CITE> (1994).
</UL>

</DL>

<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_borosh13</B>
<DD><A NAME="IDX1439"></A>
This is the Borosh-Niederreiter random number generator. It is taken
from Knuth's <CITE>Seminumerical Algorithms</CITE>, 3rd Ed., pages
106--108. Its sequence is,

<SPAN class="ifinfo">


<PRE class="example">
x_{n+1} = (a x_n) mod m
</PRE>

</SPAN>

<P>
with a = 1812433253 and 
m = 2^32.
The seed specifies the initial value, 
x_1.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_coveyou</B>
<DD><A NAME="IDX1440"></A>
This is the Coveyou random number generator. It is taken from Knuth's
<CITE>Seminumerical Algorithms</CITE>, 3rd Ed., Section 3.2.2. Its sequence
is,

<SPAN class="ifinfo">


<PRE class="example">
x_{n+1} = (x_n (x_n + 1)) mod m
</PRE>

</SPAN>

<P>
with 
m = 2^32.
The seed specifies the initial value, 
x_1.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_fishman18</B>
<DD><A NAME="IDX1441"></A>
This is the Fishman, Moore III random number generator. It is taken from
Knuth's <CITE>Seminumerical Algorithms</CITE>, 3rd Ed., pages 106--108. Its
sequence is,

<SPAN class="ifinfo">


<PRE class="example">
x_{n+1} = (a x_n) mod m
</PRE>

</SPAN>

<P>
with a = 62089911 and 
m = 2^31 - 1.
The seed specifies the initial value, 
x_1.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_fishman20</B>
<DD><A NAME="IDX1442"></A>
This is the Fishman random number generator. It is taken from Knuth's
<CITE>Seminumerical Algorithms</CITE>, 3rd Ed., page 108. Its sequence is,

<SPAN class="ifinfo">


<PRE class="example">
x_{n+1} = (a x_n) mod m
</PRE>

</SPAN>

<P>
with a = 48271 and 
m = 2^31 - 1.
The seed specifies the initial value, 
x_1.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_fishman2x</B>
<DD><A NAME="IDX1443"></A>
This is the L'Ecuyer--Fishman random number generator. It is taken from
Knuth's <CITE>Seminumerical Algorithms</CITE>, 3rd Ed., page 108. Its sequence
is,

<SPAN class="ifinfo">


<PRE class="example">
z_{n+1} = (x_n - y_n) mod m
</PRE>

</SPAN>

<P>
with 
m = 2^31 - 1.
x_n and y_n are given by the <CODE>fishman20</CODE> 
and <CODE>lecuyer21</CODE> algorithms.
The seed specifies the initial value, 
x_1.

</P>
</DL>

<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_knuthran2</B>
<DD><A NAME="IDX1444"></A>
This is a second-order multiple recursive generator described by Knuth
in <CITE>Seminumerical Algorithms</CITE>, 3rd Ed., page 108.  Its sequence is,

<SPAN class="ifinfo">


<PRE class="example">
x_n = (a_1 x_{n-1} + a_2 x_{n-2}) mod m
</PRE>

</SPAN>

<P>
with 
a_1 = 271828183, 
a_2 = 314159269, 
and 
m = 2^31 - 1.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_knuthran</B>
<DD><A NAME="IDX1445"></A>
This is a second-order multiple recursive generator described by Knuth
in <CITE>Seminumerical Algorithms</CITE>, 3rd Ed., Section 3.6.  Knuth
provides its C code.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_lecuyer21</B>
<DD><A NAME="IDX1446"></A>
This is the L'Ecuyer random number generator. It is taken from Knuth's
<CITE>Seminumerical Algorithms</CITE>, 3rd Ed., page 106--108. Its sequence is,

<SPAN class="ifinfo">


<PRE class="example">
x_{n+1} = (a x_n) mod m
</PRE>

</SPAN>

<P>
with a = 40692 and 
m = 2^31 - 249.
The seed specifies the initial value, 
x_1.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_rng_waterman14</B>
<DD><A NAME="IDX1447"></A>
This is the Waterman random number generator. It is taken from Knuth's
<CITE>Seminumerical Algorithms</CITE>, 3rd Ed., page 106--108. Its sequence is,

<SPAN class="ifinfo">


<PRE class="example">
x_{n+1} = (a x_n) mod m
</PRE>

</SPAN>

<P>
with a = 1566083941 and 
m = 2^32.
The seed specifies the initial value, 
x_1.
</DL>

</P>



<H2><A NAME="SEC280" HREF="gsl_manual.html#TOC280">Performance</A></H2>

<P>
The following table shows the relative performance of a selection the
available random number generators.  The fastest simulation quality
generators are <CODE>taus</CODE>, <CODE>gfsr4</CODE> and <CODE>mt19937</CODE>.  The
generators which offer the best mathematically-proven quality are those
based on the RANLUX algorithm.

</P>


<PRE class="example">
1754 k ints/sec,    870 k doubles/sec, taus
1613 k ints/sec,    855 k doubles/sec, gfsr4
1370 k ints/sec,    769 k doubles/sec, mt19937
 565 k ints/sec,    571 k doubles/sec, ranlxs0
 400 k ints/sec,    405 k doubles/sec, ranlxs1
 490 k ints/sec,    389 k doubles/sec, mrg
 407 k ints/sec,    297 k doubles/sec, ranlux
 243 k ints/sec,    254 k doubles/sec, ranlxd1
 251 k ints/sec,    253 k doubles/sec, ranlxs2
 238 k ints/sec,    215 k doubles/sec, cmrg
 247 k ints/sec,    198 k doubles/sec, ranlux389
 141 k ints/sec,    140 k doubles/sec, ranlxd2

1852 k ints/sec,    935 k doubles/sec, ran3
 813 k ints/sec,    575 k doubles/sec, ran0
 787 k ints/sec,    476 k doubles/sec, ran1
 379 k ints/sec,    292 k doubles/sec, ran2
</PRE>



<H2><A NAME="SEC281" HREF="gsl_manual.html#TOC281">Examples</A></H2>

<P>
The following program demonstrates the use of a random number generator
to produce uniform random numbers in the range [0.0, 1.0),

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_rng.h&#62;

int
main (void)
{
  const gsl_rng_type * T;
  gsl_rng * r;

  int i, n = 10;

  gsl_rng_env_setup();

  T = gsl_rng_default;
  r = gsl_rng_alloc (T);

  for (i = 0; i &#60; n; i++) 
    {
      double u = gsl_rng_uniform (r);
      printf ("%.5f\n", u);
    }

  gsl_rng_free (r);

  return 0;
}
</PRE>

<P>
Here is the output of the program,

</P>

<PRE class="example">
$ ./a.out 
0.99974
0.16291
0.28262
0.94720
0.23166
0.48497
0.95748
0.74431
0.54004
0.73995
</PRE>

<P>
The numbers depend on the seed used by the generator.  The default seed
can be changed with the <CODE>GSL_RNG_SEED</CODE> environment variable to
produce a different stream of numbers.  The generator itself can be
changed using the environment variable <CODE>GSL_RNG_TYPE</CODE>.  Here is the
output of the program using a seed value of 123 and the
multiple-recursive generator <CODE>mrg</CODE>,

</P>

<PRE class="example">
$ GSL_RNG_SEED=123 GSL_RNG_TYPE=mrg ./a.out 
GSL_RNG_TYPE=mrg
GSL_RNG_SEED=123
0.33050
0.86631
0.32982
0.67620
0.53391
0.06457
0.16847
0.70229
0.04371
0.86374
</PRE>



<H2><A NAME="SEC282" HREF="gsl_manual.html#TOC282">References and Further Reading</A></H2>

<P>
The subject of random number generation and testing is reviewed
extensively in Knuth's <CITE>Seminumerical Algorithms</CITE>.

</P>

<UL class="itemize">
<LI>

Donald E. Knuth, <CITE>The Art of Computer Programming: Seminumerical
Algorithms</CITE> (Vol 2, 3rd Ed, 1997), Addison-Wesley, ISBN 0201896842.
</UL>

<P>
Further information is available in the review paper written by Pierre
L'Ecuyer,

</P>

<UL class="itemize">
P. L'Ecuyer, "Random Number Generation", Chapter 4 of the
Handbook on Simulation, Jerry Banks Ed., Wiley, 1998, 93--137.

<A HREF="http://www.iro.umontreal.ca/~lecuyer/papers.html">http://www.iro.umontreal.ca/~lecuyer/papers.html</A>
in the file <TT>'handsim.ps'</TT>.
</UL>

<P>
The source code for the DIEHARD random number generator tests is also
available online,

</P>

<UL class="itemize">
<LI>

<CITE>DIEHARD source code</CITE> G. Marsaglia,
<LI>

<A HREF="http://stat.fsu.edu/pub/diehard/">http://stat.fsu.edu/pub/diehard/</A>
</UL>

<P>
A comprehensive set of random number generator tests is available from
NIST,

</P>

<UL class="itemize">
<LI>

NIST Special Publication 800-22, "A Statistical Test Suite for the
Validation of Random Number Generators and Pseudo Random Number
Generators for Cryptographic Applications".
<LI>

<A HREF="http://csrc.nist.gov/rng/">http://csrc.nist.gov/rng/</A>
</UL>



<H2><A NAME="SEC283" HREF="gsl_manual.html#TOC283">Acknowledgements</A></H2>

<P>
Thanks to Makoto Matsumoto, Takuji Nishimura and Yoshiharu Kurita for
making the source code to their generators (MT19937, MM&#38;TN; TT800,
MM&#38;YK) available under the GNU General Public License.  Thanks to Martin
L&uuml;scher for providing notes and source code for the RANLXS and
RANLXD generators.

</P>



<H1><A NAME="SEC284" HREF="gsl_manual.html#TOC284">Quasi-Random Sequences</A></H1>
<P>
<A NAME="IDX1448"></A>
<A NAME="IDX1449"></A>
<A NAME="IDX1450"></A>
<A NAME="IDX1451"></A>
This chapter describes functions for generating quasi-random sequences
in arbitrary dimensions.  A quasi-random sequence progressively covers a
d-dimensional space with a set of points that are uniformly
distributed.  Quasi-random sequences are also known as low-discrepancy
sequences.  The quasi-random sequence generators use an interface that
is similar to the interface for random number generators, except that
seeding is not required--each generator produces a single sequence.

</P>
<P>
The functions described in this section are declared in the header file
<TT>'gsl_qrng.h'</TT>.

</P>



<H2><A NAME="SEC285" HREF="gsl_manual.html#TOC285">Quasi-random number generator initialization</A></H2>

<P>
<DL>
<DT><U>Function:</U> gsl_qrng * <B>gsl_qrng_alloc</B> <I>(const gsl_qrng_type * <VAR>T</VAR>, unsigned int <VAR>d</VAR>)</I>
<DD><A NAME="IDX1452"></A>
This function returns a pointer to a newly-created instance of a
quasi-random sequence generator of type <VAR>T</VAR> and dimension <VAR>d</VAR>.
If there is insufficient memory to create the generator then the
function returns a null pointer and the error handler is invoked with an
error code of <CODE>GSL_ENOMEM</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_qrng_free</B> <I>(gsl_qrng * <VAR>q</VAR>)</I>
<DD><A NAME="IDX1453"></A>
This function frees all the memory associated with the generator
<VAR>q</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_qrng_init</B> <I>(gsl_qrng * <VAR>q</VAR>)</I>
<DD><A NAME="IDX1454"></A>
This function reinitializes the generator <VAR>q</VAR> to its starting point.
Note that quasi-random sequences do not use a seed and always produce
the same set of values.
</DL>

</P>


<H2><A NAME="SEC286" HREF="gsl_manual.html#TOC286">Sampling from a quasi-random number generator</A></H2>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_qrng_get</B> <I>(const gsl_qrng * <VAR>q</VAR>, double <VAR>x</VAR>[])</I>
<DD><A NAME="IDX1455"></A>
This function stores the next point from the sequence generator <VAR>q</VAR>
in the array <VAR>x</VAR>.  The space available for <VAR>x</VAR> must match the
dimension of the generator.  The point <VAR>x</VAR> will lie in the range
0 &#60; x_i &#60; 1 for each x_i.
</DL>

</P>


<H2><A NAME="SEC287" HREF="gsl_manual.html#TOC287">Auxiliary quasi-random number generator functions</A></H2>

<P>
<DL>
<DT><U>Function:</U> const char * <B>gsl_qrng_name</B> <I>(const gsl_qrng * <VAR>q</VAR>)</I>
<DD><A NAME="IDX1456"></A>
This function returns a pointer to the name of the generator.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_qrng_size</B> <I>(const gsl_qrng * <VAR>q</VAR>)</I>
<DD><A NAME="IDX1457"></A>
<DT><U>Function:</U> void * <B>gsl_qrng_state</B> <I>(const gsl_qrng * <VAR>q</VAR>)</I>
<DD><A NAME="IDX1458"></A>
These functions return a pointer to the state of generator <VAR>r</VAR> and
its size.  You can use this information to access the state directly.  For
example, the following code will write the state of a generator to a
stream,

</P>

<PRE class="example">
void * state = gsl_qrng_state (q);
size_t n = gsl_qrng_size (q);
fwrite (state, n, 1, stream);
</PRE>

</DL>



<H2><A NAME="SEC288" HREF="gsl_manual.html#TOC288">Saving and resorting quasi-random number generator state</A></H2>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_qrng_memcpy</B> <I>(gsl_qrng * <VAR>dest</VAR>, const gsl_qrng * <VAR>src</VAR>)</I>
<DD><A NAME="IDX1459"></A>
This function copies the quasi-random sequence generator <VAR>src</VAR> into the
pre-existing generator <VAR>dest</VAR>, making <VAR>dest</VAR> into an exact copy
of <VAR>src</VAR>.  The two generators must be of the same type.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_qrng * <B>gsl_qrng_clone</B> <I>(const gsl_qrng * <VAR>q</VAR>)</I>
<DD><A NAME="IDX1460"></A>
This function returns a pointer to a newly created generator which is an
exact copy of the generator <VAR>q</VAR>.
</DL>

</P>


<H2><A NAME="SEC289" HREF="gsl_manual.html#TOC289">Quasi-random number generator algorithms</A></H2>

<P>
The following quasi-random sequence algorithms are available,

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_qrng_niederreiter_2</B>
<DD><A NAME="IDX1461"></A>
This generator uses the algorithm described in Bratley, Fox,
Niederreiter, <CITE>ACM Trans. Model. Comp. Sim.</CITE> 2, 195 (1992). It is
valid up to 12 dimensions.
</DL>

</P>
<P>
<DL>
<DT><U>Generator:</U> <B>gsl_qrng_sobol</B>
<DD><A NAME="IDX1462"></A>
This generator uses the Sobol sequence described in Antonov, Saleev,
<CITE>USSR Comput. Maths. Math. Phys.</CITE> 19, 252 (1980). It is valid up to
40 dimensions.
</DL>

</P>


<H2><A NAME="SEC290" HREF="gsl_manual.html#TOC290">Examples</A></H2>

<P>
The following program prints the first 1024 points of the 2-dimensional
Sobol sequence.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_qrng.h&#62;

int
main (void)
{
  int i;
  gsl_qrng * q = gsl_qrng_alloc (gsl_qrng_sobol, 2);

  for (i = 0; i &#60; 1024; i++)
    {
      double v[2];
      gsl_qrng_get (q, v);
      printf ("%.5f %.5f\n", v[0], v[1]);
    }

  gsl_qrng_free (q);
  return 0;
}
</PRE>

<P>
Here is the output from the program,

</P>

<PRE class="example">
$ ./a.out
0.50000 0.50000
0.75000 0.25000
0.25000 0.75000
0.37500 0.37500
0.87500 0.87500
0.62500 0.12500
0.12500 0.62500
....
</PRE>

<P>
It can be seen that successive points progressively fill-in the spaces
between previous points. 

</P>
<P>
The following plot shows the distribution in the x-y plane of the first
1024 points from the Sobol sequence,
<P>
<BR><IMG SRC="qrng"><BR>
<P>
Distribution of the first 1024 points 
from the quasi-random Sobol sequence

</P>


<H2><A NAME="SEC291" HREF="gsl_manual.html#TOC291">References</A></H2>

<P>
The implementations of the quasi-random sequence routines are based on
the algorithms described in the following paper,

</P>

<UL class="itemize">
P. Bratley and B.L. Fox and H. Niederreiter, "Algorithm 738: Programs
to Generate Niederreiter's Low-discrepancy Sequences", <CITE>ACM
Transactions on Mathematical Software</CITE>, Vol. 20, No. 4, December, 1994,
p. 494--495.
</UL>



<H1><A NAME="SEC292" HREF="gsl_manual.html#TOC292">Random Number Distributions</A></H1>
<P>
<A NAME="IDX1463"></A>
<A NAME="IDX1464"></A>
<A NAME="IDX1465"></A>
<A NAME="IDX1466"></A>
<A NAME="IDX1467"></A>
This chapter describes functions for generating random variates and
computing their probability distributions.  Samples from the
distributions described in this chapter can be obtained using any of the
random number generators in the library as an underlying source of
randomness.  

</P>
<P>
In the simplest cases a non-uniform distribution can be obtained
analytically from the uniform distribution of a random number generator
by applying an appropriate transformation.  This method uses one call to
the random number generator.  More complicated distributions are created
by the <I>acceptance-rejection</I> method, which compares the desired
distribution against a distribution which is similar and known
analytically.  This usually requires several samples from the generator.

</P>
<P>
The library also provides cumulative distribution functions and inverse
cumulative distribution functions, sometimes referred to as quantile
functions.  The cumulative distribution functions and their inverses are
computed separately for the upper and lower tails of the distribution,
allowing full accuracy to be retained for small results.

</P>
<P>
The functions for random variates and probability density functions
described in this section are declared in <TT>'gsl_randist.h'</TT>.  The
corresponding cumulative distribution functions are declared in
<TT>'gsl_cdf.h'</TT>.

</P>



<H2><A NAME="SEC293" HREF="gsl_manual.html#TOC293">Introduction</A></H2>

<P>
Continuous random number distributions are defined by a probability
density function, p(x), such that the probability of x
occurring in the infinitesimal range x to x+dx is 
p dx.

</P>
<P>
The cumulative distribution function for the lower tail P(x) is
defined by the integral,

<SPAN class="ifinfo">


<PRE class="example">
P(x) = \int_{-\infty}^{x} dx' p(x')
</PRE>

</SPAN>

<P>
and gives the probability of a variate taking a value less than x.

</P>
<P>
The cumulative distribution function for the upper tail Q(x) is
defined by the integral,

<SPAN class="ifinfo">


<PRE class="example">
Q(x) = \int_{x}^{+\infty} dx' p(x')
</PRE>

</SPAN>

<P>
and gives the probability of a variate taking a value greater than x.

</P>
<P>
The upper and lower cumulative distribution functions are related by
P(x) + Q(x) = 1 and satisfy 
0 &#60;= P(x) &#60;= 1, 
0 &#60;= Q(x) &#60;= 1.

</P>
<P>
The inverse cumulative distributions, 
x=P^{-1}(P) and 
x=Q^{-1}(Q) give the values of x
which correspond to a specific value of P or {Q}.  
They can be used to find confidence limits from probability values.

</P>


<H2><A NAME="SEC294" HREF="gsl_manual.html#TOC294">The Gaussian Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_gaussian</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1468"></A>
<A NAME="IDX1469"></A>
This function returns a Gaussian random variate, with mean zero and
standard deviation <VAR>sigma</VAR>.  The probability distribution for
Gaussian random variates is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = {1 \over \sqrt{2 \pi \sigma^2}} \exp (-x^2 / 2\sigma^2) dx
</PRE>

</SPAN>

<P>
for x in the range -\infty to +\infty.  Use the
transformation z = \mu + x on the numbers returned by
<CODE>gsl_ran_gaussian</CODE> to obtain a Gaussian distribution with mean
\mu.  This function uses the Box-Mueller algorithm which requires two
calls to the random number generator <VAR>r</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_gaussian_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1470"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for a Gaussian distribution with standard deviation <VAR>sigma</VAR>, using
the formula given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_gaussian_ratio_method</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1471"></A>
This function computes a Gaussian random variate using the
Kinderman-Monahan ratio method.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_ugaussian</B> <I>(const gsl_rng * <VAR>r</VAR>)</I>
<DD><A NAME="IDX1472"></A>
<DT><U>Function:</U> double <B>gsl_ran_ugaussian_pdf</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1473"></A>
<DT><U>Function:</U> double <B>gsl_ran_ugaussian_ratio_method</B> <I>(const gsl_rng * <VAR>r</VAR>)</I>
<DD><A NAME="IDX1474"></A>
These functions compute results for the unit Gaussian distribution.  They
are equivalent to the functions above with a standard deviation of one,
<VAR>sigma</VAR> = 1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_gaussian_P</B> <I>(double <VAR>x</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1475"></A>
<DT><U>Function:</U> double <B>gsl_cdf_gaussian_Q</B> <I>(double <VAR>x</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1476"></A>
<DT><U>Function:</U> double <B>gsl_cdf_gaussian_Pinv</B> <I>(double <VAR>P</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1477"></A>
<DT><U>Function:</U> double <B>gsl_cdf_gaussian_Qinv</B> <I>(double <VAR>Q</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1478"></A>
These functions compute the cumulative distribution functions
P(x), Q(x) and their inverses for the Gaussian
distribution with standard deviation <VAR>sigma</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_ugaussian_P</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1479"></A>
<DT><U>Function:</U> double <B>gsl_cdf_ugaussian_Q</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1480"></A>
<DT><U>Function:</U> double <B>gsl_cdf_ugaussian_Pinv</B> <I>(double <VAR>P</VAR>)</I>
<DD><A NAME="IDX1481"></A>
<DT><U>Function:</U> double <B>gsl_cdf_ugaussian_Qinv</B> <I>(double <VAR>Q</VAR>)</I>
<DD><A NAME="IDX1482"></A>
These functions compute the cumulative distribution functions
P(x), Q(x) and their inverses for the unit Gaussian
distribution.
</DL>

</P>


<H2><A NAME="SEC295" HREF="gsl_manual.html#TOC295">The Gaussian Tail Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_gaussian_tail</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>a</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1483"></A>
<A NAME="IDX1484"></A>
This function provides random variates from the upper tail of a Gaussian
distribution with standard deviation <VAR>sigma</VAR>.  The values returned
are larger than the lower limit <VAR>a</VAR>, which must be positive.  The
method is based on Marsaglia's famous rectangle-wedge-tail algorithm (Ann. 
Math. Stat. 32, 894--899 (1961)), with this aspect explained in Knuth, v2,
3rd ed, p139,586 (exercise 11).

</P>
<P>
The probability distribution for Gaussian tail random variates is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = {1 \over N(a;\sigma) \sqrt{2 \pi \sigma^2}} \exp (- x^2/(2 \sigma^2)) dx
</PRE>

</SPAN>

<P>
for x &#62; a where N(a;\sigma) is the normalization constant,

<SPAN class="ifinfo">


<PRE class="example">
N(a;\sigma) = (1/2) erfc(a / sqrt(2 sigma^2)).
</PRE>

</SPAN>

</DL>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_gaussian_tail_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1485"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for a Gaussian tail distribution with standard deviation <VAR>sigma</VAR> and
lower limit <VAR>a</VAR>, using the formula given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_ugaussian_tail</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1486"></A>
<DT><U>Function:</U> double <B>gsl_ran_ugaussian_tail_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1487"></A>
These functions compute results for the tail of a unit Gaussian
distribution.  They are equivalent to the functions above with a standard
deviation of one, <VAR>sigma</VAR> = 1.
</DL>

</P>



<H2><A NAME="SEC296" HREF="gsl_manual.html#TOC296">The Bivariate Gaussian Distribution</A></H2>

<P>
<DL>
<DT><U>Function:</U> void <B>gsl_ran_bivariate_gaussian</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>sigma_x</VAR>, double <VAR>sigma_y</VAR>, double <VAR>rho</VAR>, double * <VAR>x</VAR>, double * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1488"></A>
<A NAME="IDX1489"></A>
<A NAME="IDX1490"></A>
<A NAME="IDX1491"></A>
This function generates a pair of correlated Gaussian variates, with
mean zero, correlation coefficient <VAR>rho</VAR> and standard deviations
<VAR>sigma_x</VAR> and <VAR>sigma_y</VAR> in the x and y directions.
The probability distribution for bivariate Gaussian random variates is,

<SPAN class="ifinfo">


<PRE class="example">
p(x,y) dx dy = {1 \over 2 \pi \sigma_x \sigma_y \sqrt{1-\rho^2}} \exp (-(x^2/\sigma_x^2 + y^2/\sigma_y^2 - 2 \rho x y/(\sigma_x\sigma_y))/2(1-\rho^2)) dx dy
</PRE>

</SPAN>

<P>
for x,y in the range -\infty to +\infty.  The
correlation coefficient <VAR>rho</VAR> should lie between 1 and
-1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_bivariate_gaussian_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>, double <VAR>sigma_x</VAR>, double <VAR>sigma_y</VAR>, double <VAR>rho</VAR>)</I>
<DD><A NAME="IDX1492"></A>
This function computes the probability density p(x,y) at
(<VAR>x</VAR>,<VAR>y</VAR>) for a bivariate Gaussian distribution with standard
deviations <VAR>sigma_x</VAR>, <VAR>sigma_y</VAR> and correlation coefficient
<VAR>rho</VAR>, using the formula given above.
</DL>

</P>
<P>



<H2><A NAME="SEC297" HREF="gsl_manual.html#TOC297">The Exponential Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_exponential</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>mu</VAR>)</I>
<DD><A NAME="IDX1493"></A>
<A NAME="IDX1494"></A>
This function returns a random variate from the exponential distribution
with mean <VAR>mu</VAR>. The distribution is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = {1 \over \mu} \exp(-x/\mu) dx
</PRE>

</SPAN>

<P>
for 
x &#62;= 0. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_exponential_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>mu</VAR>)</I>
<DD><A NAME="IDX1495"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for an exponential distribution with mean <VAR>mu</VAR>, using the formula
given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_exponential_P</B> <I>(double <VAR>x</VAR>, double <VAR>mu</VAR>)</I>
<DD><A NAME="IDX1496"></A>
<DT><U>Function:</U> double <B>gsl_cdf_exponential_Q</B> <I>(double <VAR>x</VAR>, double <VAR>mu</VAR>)</I>
<DD><A NAME="IDX1497"></A>
<DT><U>Function:</U> double <B>gsl_cdf_exponential_Pinv</B> <I>(double <VAR>P</VAR>, double <VAR>mu</VAR>)</I>
<DD><A NAME="IDX1498"></A>
<DT><U>Function:</U> double <B>gsl_cdf_exponential_Qinv</B> <I>(double <VAR>Q</VAR>, double <VAR>mu</VAR>)</I>
<DD><A NAME="IDX1499"></A>
These functions compute the cumulative distribution functions
P(x), Q(x) and their inverses for the exponential
distribution with mean <VAR>mu</VAR>.
</DL>

</P>


<H2><A NAME="SEC298" HREF="gsl_manual.html#TOC298">The Laplace Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_laplace</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1500"></A>
<A NAME="IDX1501"></A>
<A NAME="IDX1502"></A>
This function returns a random variate from the Laplace distribution
with width <VAR>a</VAR>.  The distribution is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = {1 \over 2 a}  \exp(-|x/a|) dx
</PRE>

</SPAN>

<P>
for -\infty &#60; x &#60; \infty.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_laplace_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1503"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for a Laplace distribution with width <VAR>a</VAR>, using the formula
given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_laplace_P</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1504"></A>
<DT><U>Function:</U> double <B>gsl_cdf_laplace_Q</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1505"></A>
<DT><U>Function:</U> double <B>gsl_cdf_laplace_Pinv</B> <I>(double <VAR>P</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1506"></A>
<DT><U>Function:</U> double <B>gsl_cdf_laplace_Qinv</B> <I>(double <VAR>Q</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1507"></A>
These functions compute the cumulative distribution functions
P(x), Q(x) and their inverses for the Laplace
distribution with width <VAR>a</VAR>.
</DL>

</P>



<H2><A NAME="SEC299" HREF="gsl_manual.html#TOC299">The Exponential Power Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_exppow</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1508"></A>
<A NAME="IDX1509"></A>
This function returns a random variate from the exponential power distribution
with scale parameter <VAR>a</VAR> and exponent <VAR>b</VAR>.  The distribution is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = {1 \over 2 a \Gamma(1+1/b)} \exp(-|x/a|^b) dx
</PRE>

</SPAN>

<P>
for 
x &#62;= 0.  For b = 1 this reduces to the Laplace
distribution.  For b = 2 it has the same form as a gaussian
distribution, but with 
a = \sqrt{2} \sigma.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_exppow_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1510"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for an exponential power distribution with scale parameter <VAR>a</VAR>
and exponent <VAR>b</VAR>, using the formula given above.
</DL>

</P>
<P>



<H2><A NAME="SEC300" HREF="gsl_manual.html#TOC300">The Cauchy Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_cauchy</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1511"></A>
<A NAME="IDX1512"></A>
This function returns a random variate from the Cauchy distribution with
scale parameter <VAR>a</VAR>.  The probability distribution for Cauchy
random variates is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = {1 \over a\pi (1 + (x/a)^2) } dx
</PRE>

</SPAN>

<P>
for x in the range -\infty to +\infty.  The Cauchy
distribution is also known as the Lorentz distribution.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_cauchy_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1513"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for a Cauchy distribution with scale parameter <VAR>a</VAR>, using the formula
given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_cauchy_P</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1514"></A>
<DT><U>Function:</U> double <B>gsl_cdf_cauchy_Q</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1515"></A>
<DT><U>Function:</U> double <B>gsl_cdf_cauchy_Pinv</B> <I>(double <VAR>P</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1516"></A>
<DT><U>Function:</U> double <B>gsl_cdf_cauchy_Qinv</B> <I>(double <VAR>Q</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1517"></A>
These functions compute the cumulative distribution functions
P(x), Q(x) and their inverses for the Cauchy
distribution with scale parameter <VAR>a</VAR>.
</DL>

</P>



<H2><A NAME="SEC301" HREF="gsl_manual.html#TOC301">The Rayleigh Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_rayleigh</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1518"></A>
<A NAME="IDX1519"></A>
This function returns a random variate from the Rayleigh distribution with
scale parameter <VAR>sigma</VAR>.  The distribution is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = {x \over \sigma^2} \exp(- x^2/(2 \sigma^2)) dx
</PRE>

</SPAN>

<P>
for x &#62; 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_rayleigh_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1520"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for a Rayleigh distribution with scale parameter <VAR>sigma</VAR>, using the
formula given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_rayleigh_P</B> <I>(double <VAR>x</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1521"></A>
<DT><U>Function:</U> double <B>gsl_cdf_rayleigh_Q</B> <I>(double <VAR>x</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1522"></A>
<DT><U>Function:</U> double <B>gsl_cdf_rayleigh_Pinv</B> <I>(double <VAR>P</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1523"></A>
<DT><U>Function:</U> double <B>gsl_cdf_rayleigh_Qinv</B> <I>(double <VAR>Q</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1524"></A>
These functions compute the cumulative distribution functions
P(x), Q(x) and their inverses for the Rayleigh
distribution with scale parameter <VAR>sigma</VAR>.
</DL>

</P>



<H2><A NAME="SEC302" HREF="gsl_manual.html#TOC302">The Rayleigh Tail Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_rayleigh_tail</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>a</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1525"></A>
<A NAME="IDX1526"></A>
This function returns a random variate from the tail of the Rayleigh
distribution with scale parameter <VAR>sigma</VAR> and a lower limit of
<VAR>a</VAR>.  The distribution is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = {x \over \sigma^2} \exp ((a^2 - x^2) /(2 \sigma^2)) dx
</PRE>

</SPAN>

<P>
for x &#62; a.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_rayleigh_tail_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1527"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for a Rayleigh tail distribution with scale parameter <VAR>sigma</VAR> and
lower limit <VAR>a</VAR>, using the formula given above.
</DL>

</P>
<P>



<H2><A NAME="SEC303" HREF="gsl_manual.html#TOC303">The Landau Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_landau</B> <I>(const gsl_rng * <VAR>r</VAR>)</I>
<DD><A NAME="IDX1528"></A>
<A NAME="IDX1529"></A>
This function returns a random variate from the Landau distribution.  The
probability distribution for Landau random variates is defined
analytically by the complex integral,

<SPAN class="ifinfo">


<PRE class="example">
p(x) = (1/(2 \pi i)) \int_{c-i\infty}^{c+i\infty} ds exp(s log(s) + x s) 
</PRE>

</SPAN>

<P>
For numerical purposes it is more convenient to use the following
equivalent form of the integral,

<SPAN class="ifinfo">


<PRE class="example">
p(x) = (1/\pi) \int_0^\infty dt \exp(-t \log(t) - x t) \sin(\pi t).
</PRE>

</SPAN>

</DL>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_landau_pdf</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1530"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for the Landau distribution using an approximation to the formula given
above.
</DL>

</P>
<P>



<H2><A NAME="SEC304" HREF="gsl_manual.html#TOC304">The Levy alpha-Stable Distributions</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_levy</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>c</VAR>, double <VAR>alpha</VAR>)</I>
<DD><A NAME="IDX1531"></A>
<A NAME="IDX1532"></A>
This function returns a random variate from the Levy symmetric stable
distribution with scale <VAR>c</VAR> and exponent <VAR>alpha</VAR>.  The symmetric
stable probability distribution is defined by a fourier transform,

<SPAN class="ifinfo">


<PRE class="example">
p(x) = {1 \over 2 \pi} \int_{-\infty}^{+\infty} dt \exp(-it x - |c t|^alpha)
</PRE>

</SPAN>

<P>
There is no explicit solution for the form of p(x) and the
library does not define a corresponding <CODE>pdf</CODE> function.  For
\alpha = 1 the distribution reduces to the Cauchy distribution.  For
\alpha = 2 it is a Gaussian distribution with 
\sigma = \sqrt{2} c.  For \alpha &#60; 1 the tails of the
distribution become extremely wide.

</P>
<P>
The algorithm only works for 
0 &#60; alpha &#60;= 2.
</DL>

</P>
<P>



<H2><A NAME="SEC305" HREF="gsl_manual.html#TOC305">The Levy skew alpha-Stable Distribution</A></H2>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_levy_skew</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>c</VAR>, double <VAR>alpha</VAR>, double <VAR>beta</VAR>)</I>
<DD><A NAME="IDX1533"></A>
<A NAME="IDX1534"></A>
<A NAME="IDX1535"></A>
This function returns a random variate from the Levy skew stable
distribution with scale <VAR>c</VAR>, exponent <VAR>alpha</VAR> and skewness
parameter <VAR>beta</VAR>.  The skewness parameter must lie in the range
[-1,1].  The Levy skew stable probability distribution is defined
by a fourier transform,

<SPAN class="ifinfo">


<PRE class="example">
p(x) = {1 \over 2 \pi} \int_{-\infty}^{+\infty} dt \exp(-it x - |c t|^alpha (1-i beta sign(t) tan(pi alpha/2)))
</PRE>

</SPAN>

<P>
When \alpha = 1 the term \tan(\pi \alpha/2) is replaced by
-(2/\pi)\log|t|.  There is no explicit solution for the form of
p(x) and the library does not define a corresponding <CODE>pdf</CODE>
function.  For \alpha = 2 the distribution reduces to a Gaussian
distribution with 
\sigma = \sqrt{2} c and the skewness parameter has no effect.  
For \alpha &#60; 1 the tails of the distribution become extremely
wide.  The symmetric distribution corresponds to \beta =
0.

</P>
<P>
The algorithm only works for 
0 &#60; alpha &#60;= 2.
</DL>

</P>
<P>
The Levy alpha-stable distributions have the property that if N
alpha-stable variates are drawn from the distribution p(c, \alpha,
\beta) then the sum Y = X_1 + X_2 + \dots + X_N will also be
distributed as an alpha-stable variate,
p(N^(1/\alpha) c, \alpha, \beta).

</P>

<P>



<H2><A NAME="SEC306" HREF="gsl_manual.html#TOC306">The Gamma Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_gamma</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1536"></A>
<A NAME="IDX1537"></A>
This function returns a random variate from the gamma
distribution.  The distribution function is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = {1 \over \Gamma(a) b^a} x^{a-1} e^{-x/b} dx
</PRE>

</SPAN>

<P>
for x &#62; 0.

</P>
<P>
<A NAME="IDX1538"></A>
The gamma distribution with an integer parameter <VAR>a</VAR> is known as the Erlang distribution.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_gamma_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1539"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for a gamma distribution with parameters <VAR>a</VAR> and <VAR>b</VAR>, using the
formula given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_gamma_P</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1540"></A>
<DT><U>Function:</U> double <B>gsl_cdf_gamma_Q</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1541"></A>
<DT><U>Function:</U> double <B>gsl_cdf_gamma_Pinv</B> <I>(double <VAR>P</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1542"></A>
<DT><U>Function:</U> double <B>gsl_cdf_gamma_Qinv</B> <I>(double <VAR>Q</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1543"></A>
These functions compute the cumulative distribution functions
P(x), Q(x) and their inverses for the gamma
distribution with parameters <VAR>a</VAR> and <VAR>b</VAR>.
</DL>

</P>


<H2><A NAME="SEC307" HREF="gsl_manual.html#TOC307">The Flat (Uniform) Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_flat</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1544"></A>
<A NAME="IDX1545"></A>
<A NAME="IDX1546"></A>
This function returns a random variate from the flat (uniform)
distribution from <VAR>a</VAR> to <VAR>b</VAR>. The distribution is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = {1 \over (b-a)} dx
</PRE>

</SPAN>

<P>
if 
a &#60;= x &#60; b and 0 otherwise.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_flat_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1547"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for a uniform distribution from <VAR>a</VAR> to <VAR>b</VAR>, using the formula
given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_flat_P</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1548"></A>
<DT><U>Function:</U> double <B>gsl_cdf_flat_Q</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1549"></A>
<DT><U>Function:</U> double <B>gsl_cdf_flat_Pinv</B> <I>(double <VAR>P</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1550"></A>
<DT><U>Function:</U> double <B>gsl_cdf_flat_Qinv</B> <I>(double <VAR>Q</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1551"></A>
These functions compute the cumulative distribution functions
P(x), Q(x) and their inverses for a uniform distribution
from <VAR>a</VAR> to <VAR>b</VAR>.
</DL>

</P>



<H2><A NAME="SEC308" HREF="gsl_manual.html#TOC308">The Lognormal Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_lognormal</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>zeta</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1552"></A>
<A NAME="IDX1553"></A>
This function returns a random variate from the lognormal
distribution.  The distribution function is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = {1 \over x \sqrt{2 \pi \sigma^2} } \exp(-(\ln(x) - \zeta)^2/2 \sigma^2) dx
</PRE>

</SPAN>

<P>
for x &#62; 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_lognormal_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>zeta</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1554"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for a lognormal distribution with parameters <VAR>zeta</VAR> and <VAR>sigma</VAR>,
using the formula given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_lognormal_P</B> <I>(double <VAR>x</VAR>, double <VAR>zeta</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1555"></A>
<DT><U>Function:</U> double <B>gsl_cdf_lognormal_Q</B> <I>(double <VAR>x</VAR>, double <VAR>zeta</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1556"></A>
<DT><U>Function:</U> double <B>gsl_cdf_lognormal_Pinv</B> <I>(double <VAR>P</VAR>, double <VAR>zeta</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1557"></A>
<DT><U>Function:</U> double <B>gsl_cdf_lognormal_Qinv</B> <I>(double <VAR>Q</VAR>, double <VAR>zeta</VAR>, double <VAR>sigma</VAR>)</I>
<DD><A NAME="IDX1558"></A>
These functions compute the cumulative distribution functions
P(x), Q(x) and their inverses for the lognormal
distribution with parameters <VAR>zeta</VAR> and <VAR>sigma</VAR>.
</DL>

</P>



<H2><A NAME="SEC309" HREF="gsl_manual.html#TOC309">The Chi-squared Distribution</A></H2>
<P>
The chi-squared distribution arises in statistics.  If Y_i are
n independent gaussian random variates with unit variance then the
sum-of-squares,

<SPAN class="ifinfo">


<PRE class="example">
X_i = \sum_i Y_i^2
</PRE>

</SPAN>

<P>
has a chi-squared distribution with n degrees of freedom.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_chisq</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>nu</VAR>)</I>
<DD><A NAME="IDX1559"></A>
<A NAME="IDX1560"></A>
This function returns a random variate from the chi-squared distribution
with <VAR>nu</VAR> degrees of freedom. The distribution function is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = {1 \over 2 \Gamma(\nu/2) } (x/2)^{\nu/2 - 1} \exp(-x/2) dx
</PRE>

</SPAN>

<P>
for 
x &#62;= 0. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_chisq_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>nu</VAR>)</I>
<DD><A NAME="IDX1561"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for a chi-squared distribution with <VAR>nu</VAR> degrees of freedom, using
the formula given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_chisq_P</B> <I>(double <VAR>x</VAR>, double <VAR>nu</VAR>)</I>
<DD><A NAME="IDX1562"></A>
<DT><U>Function:</U> double <B>gsl_cdf_chisq_Q</B> <I>(double <VAR>x</VAR>, double <VAR>nu</VAR>)</I>
<DD><A NAME="IDX1563"></A>
<DT><U>Function:</U> double <B>gsl_cdf_chisq_Pinv</B> <I>(double <VAR>P</VAR>, double <VAR>nu</VAR>)</I>
<DD><A NAME="IDX1564"></A>
<DT><U>Function:</U> double <B>gsl_cdf_chisq_Qinv</B> <I>(double <VAR>Q</VAR>, double <VAR>nu</VAR>)</I>
<DD><A NAME="IDX1565"></A>
These functions compute the cumulative distribution functions
P(x), Q(x) and their inverses for the chi-squared
distribution with <VAR>nu</VAR> degrees of freedom.
</DL>

</P>



<H2><A NAME="SEC310" HREF="gsl_manual.html#TOC310">The F-distribution</A></H2>
<P>
The F-distribution arises in statistics.  If Y_1 and Y_2
are chi-squared deviates with \nu_1 and \nu_2 degrees of
freedom then the ratio,

<SPAN class="ifinfo">


<PRE class="example">
X = { (Y_1 / \nu_1) \over (Y_2 / \nu_2) }
</PRE>

</SPAN>

<P>
has an F-distribution F(x;\nu_1,\nu_2).

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_fdist</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>nu1</VAR>, double <VAR>nu2</VAR>)</I>
<DD><A NAME="IDX1566"></A>
<A NAME="IDX1567"></A>
This function returns a random variate from the F-distribution with degrees of freedom <VAR>nu1</VAR> and <VAR>nu2</VAR>. The distribution function is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = 
   { \Gamma((\nu_1 + \nu_2)/2)
        \over \Gamma(\nu_1/2) \Gamma(\nu_2/2) } 
   \nu_1^{\nu_1/2} \nu_2^{\nu_2/2} 
   x^{\nu_1/2 - 1} (\nu_2 + \nu_1 x)^{-\nu_1/2 -\nu_2/2}
</PRE>

</SPAN>

<P>
for 
x &#62;= 0. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_fdist_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>nu1</VAR>, double <VAR>nu2</VAR>)</I>
<DD><A NAME="IDX1568"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for an F-distribution with <VAR>nu1</VAR> and <VAR>nu2</VAR> degrees of freedom,
using the formula given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_fdist_P</B> <I>(double <VAR>x</VAR>, double <VAR>nu1</VAR>, double <VAR>nu2</VAR>)</I>
<DD><A NAME="IDX1569"></A>
<DT><U>Function:</U> double <B>gsl_cdf_fdist_Q</B> <I>(double <VAR>x</VAR>, double <VAR>nu1</VAR>, double <VAR>nu2</VAR>)</I>
<DD><A NAME="IDX1570"></A>
These functions compute the cumulative distribution functions
P(x) and Q(x) for the F-distribution with <VAR>nu1</VAR> and
<VAR>nu2</VAR> degrees of freedom.
</DL>

</P>


<H2><A NAME="SEC311" HREF="gsl_manual.html#TOC311">The t-distribution</A></H2>
<P>
The t-distribution arises in statistics.  If Y_1 has a normal
distribution and Y_2 has a chi-squared distribution with
\nu degrees of freedom then the ratio,

<SPAN class="ifinfo">


<PRE class="example">
X = { Y_1 \over \sqrt{Y_2 / \nu} }
</PRE>

</SPAN>

<P>
has a t-distribution t(x;\nu) with \nu degrees of freedom.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_tdist</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>nu</VAR>)</I>
<DD><A NAME="IDX1571"></A>
<A NAME="IDX1572"></A>
<A NAME="IDX1573"></A>
This function returns a random variate from the t-distribution.  The
distribution function is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = {\Gamma((\nu + 1)/2) \over \sqrt{\pi \nu} \Gamma(\nu/2)}
   (1 + x^2/\nu)^{-(\nu + 1)/2} dx
</PRE>

</SPAN>

<P>
for -\infty &#60; x &#60; +\infty.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_tdist_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>nu</VAR>)</I>
<DD><A NAME="IDX1574"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for a t-distribution with <VAR>nu</VAR> degrees of freedom, using the formula
given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_tdist_P</B> <I>(double <VAR>x</VAR>, double <VAR>nu</VAR>)</I>
<DD><A NAME="IDX1575"></A>
<DT><U>Function:</U> double <B>gsl_cdf_tdist_Q</B> <I>(double <VAR>x</VAR>, double <VAR>nu</VAR>)</I>
<DD><A NAME="IDX1576"></A>
<DT><U>Function:</U> double <B>gsl_cdf_tdist_Pinv</B> <I>(double <VAR>P</VAR>, double <VAR>nu</VAR>)</I>
<DD><A NAME="IDX1577"></A>
<DT><U>Function:</U> double <B>gsl_cdf_tdist_Qinv</B> <I>(double <VAR>Q</VAR>, double <VAR>nu</VAR>)</I>
<DD><A NAME="IDX1578"></A>
These functions compute the cumulative distribution functions
P(x), Q(x) and their inverses for the t-distribution
with <VAR>nu</VAR> degrees of freedom.
</DL>

</P>


<H2><A NAME="SEC312" HREF="gsl_manual.html#TOC312">The Beta Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_beta</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1579"></A>
<A NAME="IDX1580"></A>
This function returns a random variate from the beta
distribution.  The distribution function is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = {\Gamma(a+b) \over \Gamma(a) \Gamma(b)} x^{a-1} (1-x)^{b-1} dx
</PRE>

</SPAN>

<P>
for 
0 &#60;= x &#60;= 1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_beta_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1581"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for a beta distribution with parameters <VAR>a</VAR> and <VAR>b</VAR>, using the
formula given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_beta_P</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1582"></A>
<DT><U>Function:</U> double <B>gsl_cdf_beta_Q</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1583"></A>
These functions compute the cumulative distribution functions
P(x) and Q(x) for the beta distribution with
parameters <VAR>a</VAR> and <VAR>b</VAR>.
</DL>

</P>


<H2><A NAME="SEC313" HREF="gsl_manual.html#TOC313">The Logistic Distribution</A></H2>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_logistic</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1584"></A>
<A NAME="IDX1585"></A>
This function returns a random variate from the logistic
distribution.  The distribution function is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = { \exp(-x/a) \over a (1 + \exp(-x/a))^2 } dx
</PRE>

</SPAN>

<P>
for -\infty &#60; x &#60; +\infty.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_logistic_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1586"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for a logistic distribution with scale parameter <VAR>a</VAR>, using the
formula given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_logistic_P</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1587"></A>
<DT><U>Function:</U> double <B>gsl_cdf_logistic_Q</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1588"></A>
<DT><U>Function:</U> double <B>gsl_cdf_logistic_Pinv</B> <I>(double <VAR>P</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1589"></A>
<DT><U>Function:</U> double <B>gsl_cdf_logistic_Qinv</B> <I>(double <VAR>Q</VAR>, double <VAR>a</VAR>)</I>
<DD><A NAME="IDX1590"></A>
These functions compute the cumulative distribution functions
P(x), Q(x) and their inverses for the logistic
distribution with scale parameter <VAR>a</VAR>.
</DL>

</P>


<H2><A NAME="SEC314" HREF="gsl_manual.html#TOC314">The Pareto Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_pareto</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1591"></A>
<A NAME="IDX1592"></A>
This function returns a random variate from the Pareto distribution of
order <VAR>a</VAR>.  The distribution function is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = (a/b) / (x/b)^{a+1} dx
</PRE>

</SPAN>

<P>
for 
x &#62;= b.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_pareto_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1593"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for a Pareto distribution with exponent <VAR>a</VAR> and scale <VAR>b</VAR>, using
the formula given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_pareto_P</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1594"></A>
<DT><U>Function:</U> double <B>gsl_cdf_pareto_Q</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1595"></A>
<DT><U>Function:</U> double <B>gsl_cdf_pareto_Pinv</B> <I>(double <VAR>P</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1596"></A>
<DT><U>Function:</U> double <B>gsl_cdf_pareto_Qinv</B> <I>(double <VAR>Q</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1597"></A>
These functions compute the cumulative distribution functions
P(x), Q(x) and their inverses for the Pareto
distribution with exponent <VAR>a</VAR> and scale <VAR>b</VAR>.
</DL>

</P>


<H2><A NAME="SEC315" HREF="gsl_manual.html#TOC315">Spherical Vector Distributions</A></H2>

<P>
The spherical distributions generate random vectors, located on a
spherical surface.  They can be used as random directions, for example in
the steps of a random walk.

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_ran_dir_2d</B> <I>(const gsl_rng * <VAR>r</VAR>, double * <VAR>x</VAR>, double * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1598"></A>
<DT><U>Function:</U> void <B>gsl_ran_dir_2d_trig_method</B> <I>(const gsl_rng * <VAR>r</VAR>, double * <VAR>x</VAR>, double * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1599"></A>
<A NAME="IDX1600"></A>
<A NAME="IDX1601"></A>
<A NAME="IDX1602"></A>
This function returns a random direction vector v =
(<VAR>x</VAR>,<VAR>y</VAR>) in two dimensions.  The vector is normalized such that
|v|^2 = x^2 + y^2 = 1.  The obvious way to do this is to take a
uniform random number between 0 and 2\pi and let <VAR>x</VAR> and
<VAR>y</VAR> be the sine and cosine respectively.  Two trig functions would
have been expensive in the old days, but with modern hardware
implementations, this is sometimes the fastest way to go.  This is the
case for the Pentium (but not the case for the Sun Sparcstation).
One can avoid the trig evaluations by choosing <VAR>x</VAR> and
<VAR>y</VAR> in the interior of a unit circle (choose them at random from the
interior of the enclosing square, and then reject those that are outside
the unit circle), and then dividing by 
\sqrt{x^2 + y^2}.
A much cleverer approach, attributed to von Neumann (See Knuth, v2, 3rd
ed, p140, exercise 23), requires neither trig nor a square root.  In
this approach, <VAR>u</VAR> and <VAR>v</VAR> are chosen at random from the
interior of a unit circle, and then x=(u^2-v^2)/(u^2+v^2) and
y=2uv/(u^2+v^2).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_ran_dir_3d</B> <I>(const gsl_rng * <VAR>r</VAR>, double * <VAR>x</VAR>, double * <VAR>y</VAR>, double * <VAR>z</VAR>)</I>
<DD><A NAME="IDX1603"></A>
<A NAME="IDX1604"></A>
<A NAME="IDX1605"></A>
<A NAME="IDX1606"></A>
This function returns a random direction vector v =
(<VAR>x</VAR>,<VAR>y</VAR>,<VAR>z</VAR>) in three dimensions.  The vector is normalized
such that |v|^2 = x^2 + y^2 + z^2 = 1.  The method employed is
due to Robert E. Knop (CACM 13, 326 (1970)), and explained in Knuth, v2,
3rd ed, p136.  It uses the surprising fact that the distribution
projected along any axis is actually uniform (this is only true for 3
dimensions).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_ran_dir_nd</B> <I>(const gsl_rng * <VAR>r</VAR>, size_t <VAR>n</VAR>, double * <VAR>x</VAR>)</I>
<DD><A NAME="IDX1607"></A>
<A NAME="IDX1608"></A>
<A NAME="IDX1609"></A>
<A NAME="IDX1610"></A>

</P>
<P>
This function returns a random direction vector
v = (x_1,x_2,...,x_n) in <VAR>n</VAR> dimensions.  The vector is normalized
such that 
|v|^2 = x_1^2 + x_2^2 + ... + x_n^2 = 1.  The method
uses the fact that a multivariate gaussian distribution is spherically
symmetric.  Each component is generated to have a gaussian distribution,
and then the components are normalized.  The method is described by
Knuth, v2, 3rd ed, p135--136, and attributed to G. W. Brown, Modern
Mathematics for the Engineer (1956).
</DL>

</P>


<H2><A NAME="SEC316" HREF="gsl_manual.html#TOC316">The Weibull Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_weibull</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1611"></A>
<A NAME="IDX1612"></A>
This function returns a random variate from the Weibull distribution.  The
distribution function is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = {b \over a^b} x^{b-1}  \exp(-(x/a)^b) dx
</PRE>

</SPAN>

<P>
for 
x &#62;= 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_weibull_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1613"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for a Weibull distribution with scale <VAR>a</VAR> and exponent <VAR>b</VAR>,
using the formula given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_weibull_P</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1614"></A>
<DT><U>Function:</U> double <B>gsl_cdf_weibull_Q</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1615"></A>
<DT><U>Function:</U> double <B>gsl_cdf_weibull_Pinv</B> <I>(double <VAR>P</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1616"></A>
<DT><U>Function:</U> double <B>gsl_cdf_weibull_Qinv</B> <I>(double <VAR>Q</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1617"></A>
These functions compute the cumulative distribution functions
P(x), Q(x) and their inverses for the Weibull
distribution with scale <VAR>a</VAR> and exponent <VAR>b</VAR>.
</DL>

</P>



<H2><A NAME="SEC317" HREF="gsl_manual.html#TOC317">The Type-1 Gumbel Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_gumbel1</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1618"></A>
<A NAME="IDX1619"></A>
<A NAME="IDX1620"></A>
This function returns  a random variate from the Type-1 Gumbel
distribution.  The Type-1 Gumbel distribution function is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = a b \exp(-(b \exp(-ax) + ax)) dx
</PRE>

</SPAN>

<P>
for -\infty &#60; x &#60; \infty. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_gumbel1_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1621"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for a Type-1 Gumbel distribution with parameters <VAR>a</VAR> and <VAR>b</VAR>,
using the formula given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_gumbel1_P</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1622"></A>
<DT><U>Function:</U> double <B>gsl_cdf_gumbel1_Q</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1623"></A>
<DT><U>Function:</U> double <B>gsl_cdf_gumbel1_Pinv</B> <I>(double <VAR>P</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1624"></A>
<DT><U>Function:</U> double <B>gsl_cdf_gumbel1_Qinv</B> <I>(double <VAR>Q</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1625"></A>
These functions compute the cumulative distribution functions
P(x), Q(x) and their inverses for the Type-1 Gumbel
distribution with parameters <VAR>a</VAR> and <VAR>b</VAR>.
</DL>

</P>



<H2><A NAME="SEC318" HREF="gsl_manual.html#TOC318">The Type-2 Gumbel Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_gumbel2</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1626"></A>
<A NAME="IDX1627"></A>
<A NAME="IDX1628"></A>
This function returns a random variate from the Type-2 Gumbel
distribution.  The Type-2 Gumbel distribution function is,

<SPAN class="ifinfo">


<PRE class="example">
p(x) dx = a b x^{-a-1} \exp(-b x^{-a}) dx
</PRE>

</SPAN>

<P>
for 0 &#60; x &#60; \infty.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_gumbel2_pdf</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1629"></A>
This function computes the probability density p(x) at <VAR>x</VAR>
for a Type-2 Gumbel distribution with parameters <VAR>a</VAR> and <VAR>b</VAR>,
using the formula given above.
</DL>

</P>
<P>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cdf_gumbel2_P</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1630"></A>
<DT><U>Function:</U> double <B>gsl_cdf_gumbel2_Q</B> <I>(double <VAR>x</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1631"></A>
<DT><U>Function:</U> double <B>gsl_cdf_gumbel2_Pinv</B> <I>(double <VAR>P</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1632"></A>
<DT><U>Function:</U> double <B>gsl_cdf_gumbel2_Qinv</B> <I>(double <VAR>Q</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1633"></A>
These functions compute the cumulative distribution functions
P(x), Q(x) and their inverses for the Type-2 Gumbel
distribution with parameters <VAR>a</VAR> and <VAR>b</VAR>.
</DL>

</P>



<H2><A NAME="SEC319" HREF="gsl_manual.html#TOC319">The Dirichlet Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_ran_dirichlet</B> <I>(const gsl_rng * <VAR>r</VAR>, size_t <VAR>K</VAR>, const double <VAR>alpha</VAR>[], double <VAR>theta</VAR>[])</I>
<DD><A NAME="IDX1634"></A>
<A NAME="IDX1635"></A>
This function returns an array of <VAR>K</VAR> random variates from a Dirichlet
distribution of order <VAR>K</VAR>-1. The distribution function is

<SPAN class="ifinfo">


<PRE class="example">
p(\theta_1, ..., \theta_K) d\theta_1 ... d\theta_K = 
  (1/Z) \prod_{i=1}^K \theta_i^{\alpha_i - 1} \delta(1 -\sum_{i=1}^K \theta_i) d\theta_1 ... d\theta_K
</PRE>

</SPAN>

<P>
for 
theta_i &#62;= 0
and 
alpha_i &#62;= 0.  The delta function ensures that \sum \theta_i = 1.
The normalization factor Z is

<SPAN class="ifinfo">


<PRE class="example">
Z = {\prod_{i=1}^K \Gamma(\alpha_i)} / {\Gamma( \sum_{i=1}^K \alpha_i)}
</PRE>

</SPAN>

<P>
The random variates are generated by sampling <VAR>K</VAR> values 
from gamma distributions with parameters 
a=alpha_i, b=1, 
and renormalizing. 
See A.M. Law, W.D. Kelton, <CITE>Simulation Modeling and Analysis</CITE> (1991).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_dirichlet_pdf</B> <I>(size_t <VAR>K</VAR>, const double <VAR>alpha</VAR>[], const double <VAR>theta</VAR>[])</I>
<DD><A NAME="IDX1636"></A>
This function computes the probability density 
p(\theta_1, ... , \theta_K)
at <VAR>theta</VAR>[<VAR>K</VAR>] for a Dirichlet distribution with parameters 
<VAR>alpha</VAR>[<VAR>K</VAR>], using the formula given above.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_dirichlet_lnpdf</B> <I>(size_t <VAR>K</VAR>, const double <VAR>alpha</VAR>[], const double <VAR>theta</VAR>[])</I>
<DD><A NAME="IDX1637"></A>
This function computes the logarithm of the probability density 
p(\theta_1, ... , \theta_K)
for a Dirichlet distribution with parameters 
<VAR>alpha</VAR>[<VAR>K</VAR>].
</DL>

</P>


<H2><A NAME="SEC320" HREF="gsl_manual.html#TOC320">General Discrete Distributions</A></H2>

<P>
Given K discrete events with different probabilities P[k],
produce a random value k consistent with its probability.

</P>
<P>
The obvious way to do this is to preprocess the probability list by
generating a cumulative probability array with K+1 elements:

<SPAN class="ifinfo">


<PRE class="example">
  C[0] = 0 
C[k+1] = C[k]+P[k].
</PRE>

</SPAN>

<P>
Note that this construction produces C[K]=1.  Now choose a
uniform deviate u between 0 and 1, and find the value of k
such that 
C[k] &#60;= u &#60; C[k+1].  
Although this in principle requires of order \log K steps per
random number generation, they are fast steps, and if you use something
like \lfloor uK \rfloor as a starting point, you can often do
pretty well.

</P>
<P>
But faster methods have been devised.  Again, the idea is to preprocess
the probability list, and save the result in some form of lookup table;
then the individual calls for a random discrete event can go rapidly.
An approach invented by G. Marsaglia (Generating discrete random numbers
in a computer, Comm ACM 6, 37--38 (1963)) is very clever, and readers
interested in examples of good algorithm design are directed to this
short and well-written paper.  Unfortunately, for large K,
Marsaglia's lookup table can be quite large.  

</P>
<P>
A much better approach is due to Alastair J. Walker (An efficient method
for generating discrete random variables with general distributions, ACM
Trans on Mathematical Software 3, 253--256 (1977); see also Knuth, v2,
3rd ed, p120--121,139).  This requires two lookup tables, one floating
point and one integer, but both only of size K.  After
preprocessing, the random numbers are generated in O(1) time, even for
large K.  The preprocessing suggested by Walker requires
O(K^2) effort, but that is not actually necessary, and the
implementation provided here only takes O(K) effort.  In general,
more preprocessing leads to faster generation of the individual random
numbers, but a diminishing return is reached pretty early.  Knuth points
out that the optimal preprocessing is combinatorially difficult for
large K.

</P>
<P>
This method can be used to speed up some of the discrete random number
generators below, such as the binomial distribution.  To use it for
something like the Poisson Distribution, a modification would have to
be made, since it only takes a finite set of K outcomes.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_ran_discrete_t * <B>gsl_ran_discrete_preproc</B> <I>(size_t <VAR>K</VAR>, const double * <VAR>P</VAR>)</I>
<DD><A NAME="IDX1638"></A>
<A NAME="IDX1639"></A>
<A NAME="IDX1640"></A>
This function returns a pointer to a structure that contains the lookup
table for the discrete random number generator.  The array <VAR>P</VAR>[] contains
the probabilities of the discrete events; these array elements must all be 
positive, but they needn't add up to one (so you can think of them more
generally as "weights")---the preprocessor will normalize appropriately.
This return value is used
as an argument for the <CODE>gsl_ran_discrete</CODE> function below.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_ran_discrete</B> <I>(const gsl_rng * <VAR>r</VAR>, const gsl_ran_discrete_t * <VAR>g</VAR>)</I>
<DD><A NAME="IDX1641"></A>
<A NAME="IDX1642"></A>
After the preprocessor, above, has been called, you use this function to
get the discrete random numbers.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_discrete_pdf</B> <I>(size_t <VAR>k</VAR>, const gsl_ran_discrete_t * <VAR>g</VAR>)</I>
<DD><A NAME="IDX1643"></A>
<A NAME="IDX1644"></A>
Returns the probability P[k] of observing the variable <VAR>k</VAR>.
Since P[k] is not stored as part of the lookup table, it must be
recomputed; this computation takes O(K), so if <VAR>K</VAR> is large
and you care about the original array P[k] used to create the
lookup table, then you should just keep this original array P[k]
around.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_ran_discrete_free</B> <I>(gsl_ran_discrete_t * <VAR>g</VAR>)</I>
<DD><A NAME="IDX1645"></A>
<A NAME="IDX1646"></A>
De-allocates the lookup table pointed to by <VAR>g</VAR>.
</DL>

</P>


<H2><A NAME="SEC321" HREF="gsl_manual.html#TOC321">The Poisson Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> unsigned int <B>gsl_ran_poisson</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>mu</VAR>)</I>
<DD><A NAME="IDX1647"></A>
<A NAME="IDX1648"></A>
This function returns a random integer from the Poisson distribution
with mean <VAR>mu</VAR>.  The probability distribution for Poisson variates is,

<SPAN class="ifinfo">


<PRE class="example">
p(k) = {\mu^k \over k!} \exp(-\mu)
</PRE>

</SPAN>

<P>
for 
k &#62;= 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_poisson_pdf</B> <I>(unsigned int <VAR>k</VAR>, double <VAR>mu</VAR>)</I>
<DD><A NAME="IDX1649"></A>
This function computes the probability p(k) of obtaining  <VAR>k</VAR>
from a Poisson distribution with mean <VAR>mu</VAR>, using the formula
given above.
</DL>

</P>
<P>



<H2><A NAME="SEC322" HREF="gsl_manual.html#TOC322">The Bernoulli Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> unsigned int <B>gsl_ran_bernoulli</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>p</VAR>)</I>
<DD><A NAME="IDX1650"></A>
<A NAME="IDX1651"></A>
This function returns either 0 or 1, the result of a Bernoulli trial
with probability <VAR>p</VAR>.  The probability distribution for a Bernoulli
trial is,

<SPAN class="ifinfo">


<PRE class="example">
p(0) = 1 - p
p(1) = p
</PRE>

</SPAN>

</DL>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_bernoulli_pdf</B> <I>(unsigned int <VAR>k</VAR>, double <VAR>p</VAR>)</I>
<DD><A NAME="IDX1652"></A>
This function computes the probability p(k) of obtaining
<VAR>k</VAR> from a Bernoulli distribution with probability parameter
<VAR>p</VAR>, using the formula given above.
</DL>

</P>
<P>



<H2><A NAME="SEC323" HREF="gsl_manual.html#TOC323">The Binomial Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> unsigned int <B>gsl_ran_binomial</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>p</VAR>, unsigned int <VAR>n</VAR>)</I>
<DD><A NAME="IDX1653"></A>
<A NAME="IDX1654"></A>
This function returns a random integer from the binomial distribution,
the number of successes in <VAR>n</VAR> independent trials with probability
<VAR>p</VAR>.  The probability distribution for binomial variates is,

<SPAN class="ifinfo">


<PRE class="example">
p(k) = {n! \over k! (n-k)! } p^k (1-p)^{n-k}
</PRE>

</SPAN>

<P>
for 
0 &#60;= k &#60;= n.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_binomial_pdf</B> <I>(unsigned int <VAR>k</VAR>, double <VAR>p</VAR>, unsigned int <VAR>n</VAR>)</I>
<DD><A NAME="IDX1655"></A>
This function computes the probability p(k) of obtaining <VAR>k</VAR>
from a binomial distribution with parameters <VAR>p</VAR> and <VAR>n</VAR>, using
the formula given above.
</DL>

</P>
<P>



<H2><A NAME="SEC324" HREF="gsl_manual.html#TOC324">The Multinomial Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_ran_multinomial</B> <I>(const gsl_rng * <VAR>r</VAR>, size_t <VAR>K</VAR>, unsigned int <VAR>N</VAR>, const double <VAR>p</VAR>[], unsigned int <VAR>n</VAR>[])</I>
<DD><A NAME="IDX1656"></A>
<A NAME="IDX1657"></A>

</P>
<P>
This function returns an array of <VAR>K</VAR> random variates from a 
multinomial distribution. The distribution function is,

<SPAN class="ifinfo">


<PRE class="example">
P(n_1, n_2, ..., n_K) = 
  (N!/(n_1! n_2! ... n_K!)) p_1^n_1 p_2^n_2 ... p_K^n_K
</PRE>

</SPAN>

<P>
where 
(n_1, n_2, ..., n_K) 
are nonnegative integers with 
sum_{k=1}^K n_k = N,
and
(p_1, p_2, ..., p_K)
is a probability distribution with \sum p_i = 1.  
If the array <VAR>p</VAR>[<VAR>K</VAR>] is not normalized then its entries will be
treated as weights and normalized appropriately.

</P>
<P>
Random variates are generated using the conditional binomial method (see
C.S. David, <CITE>The computer generation of multinomial random
variates</CITE>, Comp. Stat. Data Anal. 16 (1993) 205--217 for details).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_multinomial_pdf</B> <I>(size_t <VAR>K</VAR>, const double <VAR>p</VAR>[], const unsigned int <VAR>n</VAR>[])</I>
<DD><A NAME="IDX1658"></A>
This function computes the probability 
P(n_1, n_2, ..., n_K)
of sampling <VAR>n</VAR>[<VAR>K</VAR>] from a multinomial distribution 
with parameters <VAR>p</VAR>[<VAR>K</VAR>], using the formula given above.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_multinomial_lnpdf</B> <I>(size_t <VAR>K</VAR>, const double <VAR>p</VAR>[], const unsigned int <VAR>n</VAR>[])</I>
<DD><A NAME="IDX1659"></A>
This function returns the logarithm of the probability for the
multinomial distribution 
P(n_1, n_2, ..., n_K) with parameters <VAR>p</VAR>[<VAR>K</VAR>].
</DL>

</P>



<H2><A NAME="SEC325" HREF="gsl_manual.html#TOC325">The Negative Binomial Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> unsigned int <B>gsl_ran_negative_binomial</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>p</VAR>, double <VAR>n</VAR>)</I>
<DD><A NAME="IDX1660"></A>
<A NAME="IDX1661"></A>
This function returns a random integer from the negative binomial
distribution, the number of failures occurring before <VAR>n</VAR> successes
in independent trials with probability <VAR>p</VAR> of success.  The
probability distribution for negative binomial variates is,

<SPAN class="ifinfo">


<PRE class="example">
p(k) = {\Gamma(n + k) \over \Gamma(k+1) \Gamma(n) } p^n (1-p)^k
</PRE>

</SPAN>

<P>
Note that n is not required to be an integer.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_negative_binomial_pdf</B> <I>(unsigned int <VAR>k</VAR>, double <VAR>p</VAR>, double <VAR>n</VAR>)</I>
<DD><A NAME="IDX1662"></A>
This function computes the probability p(k) of obtaining <VAR>k</VAR>
from a negative binomial distribution with parameters <VAR>p</VAR> and
<VAR>n</VAR>, using the formula given above.
</DL>

</P>
<P>



<H2><A NAME="SEC326" HREF="gsl_manual.html#TOC326">The Pascal Distribution</A></H2>

<P>
<DL>
<DT><U>Function:</U> unsigned int <B>gsl_ran_pascal</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>p</VAR>, unsigned int <VAR>n</VAR>)</I>
<DD><A NAME="IDX1663"></A>
This function returns a random integer from the Pascal distribution.  The
Pascal distribution is simply a negative binomial distribution with an
integer value of n.

<SPAN class="ifinfo">


<PRE class="example">
p(k) = {(n + k - 1)! \over k! (n - 1)! } p^n (1-p)^k
</PRE>

</SPAN>

<P>
for 
k &#62;= 0
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_pascal_pdf</B> <I>(unsigned int <VAR>k</VAR>, double <VAR>p</VAR>, unsigned int <VAR>n</VAR>)</I>
<DD><A NAME="IDX1664"></A>
This function computes the probability p(k) of obtaining <VAR>k</VAR>
from a Pascal distribution with parameters <VAR>p</VAR> and
<VAR>n</VAR>, using the formula given above.
</DL>

</P>
<P>



<H2><A NAME="SEC327" HREF="gsl_manual.html#TOC327">The Geometric Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> unsigned int <B>gsl_ran_geometric</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>p</VAR>)</I>
<DD><A NAME="IDX1665"></A>
<A NAME="IDX1666"></A>
This function returns a random integer from the geometric distribution,
the number of independent trials with probability <VAR>p</VAR> until the
first success.  The probability distribution for geometric variates
is,

<SPAN class="ifinfo">


<PRE class="example">
p(k) =  p (1-p)^(k-1)
</PRE>

</SPAN>

<P>
for 
k &#62;= 1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_geometric_pdf</B> <I>(unsigned int <VAR>k</VAR>, double <VAR>p</VAR>)</I>
<DD><A NAME="IDX1667"></A>
This function computes the probability p(k) of obtaining <VAR>k</VAR>
from a geometric distribution with probability parameter <VAR>p</VAR>, using
the formula given above.
</DL>

</P>
<P>



<H2><A NAME="SEC328" HREF="gsl_manual.html#TOC328">The Hypergeometric Distribution</A></H2>
<P>
<A NAME="IDX1668"></A>
<DL>
<DT><U>Function:</U> unsigned int <B>gsl_ran_hypergeometric</B> <I>(const gsl_rng * <VAR>r</VAR>, unsigned int <VAR>n1</VAR>, unsigned int <VAR>n2</VAR>, unsigned int <VAR>t</VAR>)</I>
<DD><A NAME="IDX1669"></A>
<A NAME="IDX1670"></A>
This function returns a random integer from the hypergeometric
distribution.  The probability distribution for hypergeometric
random variates is,

<SPAN class="ifinfo">


<PRE class="example">
p(k) =  C(n_1, k) C(n_2, t - k) / C(n_1 + n_2, t)
</PRE>

</SPAN>

<P>
where C(a,b) = a!/(b!(a-b)!) and 
t &#60;= n_1 + n_2.  The
domain of k is 
max(0,t-n_2), ..., min(t,n_1).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_hypergeometric_pdf</B> <I>(unsigned int <VAR>k</VAR>, unsigned int <VAR>n1</VAR>, unsigned int <VAR>n2</VAR>, unsigned int <VAR>t</VAR>)</I>
<DD><A NAME="IDX1671"></A>
This function computes the probability p(k) of obtaining <VAR>k</VAR>
from a hypergeometric distribution with parameters <VAR>n1</VAR>, <VAR>n2</VAR>,
<VAR>t</VAR>, using the formula given above.
</DL>

</P>
<P>



<H2><A NAME="SEC329" HREF="gsl_manual.html#TOC329">The Logarithmic Distribution</A></H2>
<P>
<DL>
<DT><U>Function:</U> unsigned int <B>gsl_ran_logarithmic</B> <I>(const gsl_rng * <VAR>r</VAR>, double <VAR>p</VAR>)</I>
<DD><A NAME="IDX1672"></A>
<A NAME="IDX1673"></A>
This function returns a random integer from the logarithmic
distribution.  The probability distribution for logarithmic random variates
is,

<SPAN class="ifinfo">


<PRE class="example">
p(k) = {-1 \over \log(1-p)} {(p^k \over k)}
</PRE>

</SPAN>

<P>
for 
k &#62;= 1.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_ran_logarithmic_pdf</B> <I>(unsigned int <VAR>k</VAR>, double <VAR>p</VAR>)</I>
<DD><A NAME="IDX1674"></A>
This function computes the probability p(k) of obtaining <VAR>k</VAR>
from a logarithmic distribution with probability parameter <VAR>p</VAR>,
using the formula given above.
</DL>

</P>
<P>



<H2><A NAME="SEC330" HREF="gsl_manual.html#TOC330">Shuffling and Sampling</A></H2>

<P>
The following functions allow the shuffling and sampling of a set of
objects.  The algorithms rely on a random number generator as a source of
randomness and a poor quality generator can lead to correlations in the
output.  In particular it is important to avoid generators with a short
period.  For more information see Knuth, v2, 3rd ed, Section 3.4.2,
"Random Sampling and Shuffling".

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_ran_shuffle</B> <I>(const gsl_rng * <VAR>r</VAR>, void * <VAR>base</VAR>, size_t <VAR>n</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX1675"></A>

</P>
<P>
This function randomly shuffles the order of <VAR>n</VAR> objects, each of
size <VAR>size</VAR>, stored in the array <VAR>base</VAR>[0..<VAR>n</VAR>-1].  The
output of the random number generator <VAR>r</VAR> is used to produce the
permutation.  The algorithm generates all possible n!
permutations with equal probability, assuming a perfect source of random
numbers.

</P>
<P>
The following code shows how to shuffle the numbers from 0 to 51,

</P>

<PRE class="example">
int a[52];

for (i = 0; i &#60; 52; i++)
  {
    a[i] = i;
  }

gsl_ran_shuffle (r, a, 52, sizeof (int));
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_ran_choose</B> <I>(const gsl_rng * <VAR>r</VAR>, void * <VAR>dest</VAR>, size_t <VAR>k</VAR>, void * <VAR>src</VAR>, size_t <VAR>n</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX1676"></A>
This function fills the array <VAR>dest</VAR>[k] with <VAR>k</VAR> objects taken
randomly from the <VAR>n</VAR> elements of the array
<VAR>src</VAR>[0..<VAR>n</VAR>-1].  The objects are each of size <VAR>size</VAR>.  The
output of the random number generator <VAR>r</VAR> is used to make the
selection.  The algorithm ensures all possible samples are equally
likely, assuming a perfect source of randomness.

</P>
<P>
The objects are sampled <EM>without</EM> replacement, thus each object can
only appear once in <VAR>dest</VAR>[k].  It is required that <VAR>k</VAR> be less
than or equal to <CODE>n</CODE>.  The objects in <VAR>dest</VAR> will be in the
same relative order as those in <VAR>src</VAR>.  You will need to call
<CODE>gsl_ran_shuffle(r, dest, n, size)</CODE> if you want to randomize the
order.

</P>
<P>
The following code shows how to select a random sample of three unique
numbers from the set 0 to 99,

</P>

<PRE class="example">
double a[3], b[100];

for (i = 0; i &#60; 100; i++)
  {
    b[i] = (double) i;
  }

gsl_ran_choose (r, a, 3, b, 100, sizeof (double));
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> void <B>gsl_ran_sample</B> <I>(const gsl_rng * <VAR>r</VAR>, void * <VAR>dest</VAR>, size_t <VAR>k</VAR>, void * <VAR>src</VAR>, size_t <VAR>n</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX1677"></A>
This function is like <CODE>gsl_ran_choose</CODE> but samples <VAR>k</VAR> items
from the original array of <VAR>n</VAR> items <VAR>src</VAR> with replacement, so
the same object can appear more than once in the output sequence
<VAR>dest</VAR>.  There is no requirement that <VAR>k</VAR> be less than <VAR>n</VAR>
in this case.
</DL>

</P>



<H2><A NAME="SEC331" HREF="gsl_manual.html#TOC331">Examples</A></H2>

<P>
The following program demonstrates the use of a random number generator
to produce variates from a distribution.  It prints 10 samples from the
Poisson distribution with a mean of 3.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_rng.h&#62;
#include &#60;gsl/gsl_randist.h&#62;

int
main (void)
{
  const gsl_rng_type * T;
  gsl_rng * r;

  int i, n = 10;
  double mu = 3.0;

  /* create a generator chosen by the 
     environment variable GSL_RNG_TYPE */

  gsl_rng_env_setup();

  T = gsl_rng_default;
  r = gsl_rng_alloc (T);

  /* print n random variates chosen from 
     the poisson distribution with mean 
     parameter mu */

  for (i = 0; i &#60; n; i++) 
    {
      unsigned int k = gsl_ran_poisson (r, mu);
      printf (" %u", k);
    }

  printf ("\n");
  return 0;
}
</PRE>

<P>
If the library and header files are installed under <TT>'/usr/local'</TT>
(the default location) then the program can be compiled with these
options,

</P>

<PRE class="example">
$ gcc -Wall demo.c -lgsl -lgslcblas -lm
</PRE>

<P>
Here is the output of the program,

</P>

<PRE class="example">
$ ./a.out 
 2 5 5 2 1 0 3 4 1 1
</PRE>

<P>
The variates depend on the seed used by the generator.  The seed for the
default generator type <CODE>gsl_rng_default</CODE> can be changed with the
<CODE>GSL_RNG_SEED</CODE> environment variable to produce a different stream
of variates,

</P>

<PRE class="example">
$ GSL_RNG_SEED=123 ./a.out 
GSL_RNG_SEED=123
 4 5 6 3 3 1 4 2 5 5
</PRE>

<P>
The following program generates a random walk in two dimensions.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_rng.h&#62;
#include &#60;gsl/gsl_randist.h&#62;

int
main (void)
{
  int i;
  double x = 0, y = 0, dx, dy;

  const gsl_rng_type * T;
  gsl_rng * r;

  gsl_rng_env_setup();
  T = gsl_rng_default;
  r = gsl_rng_alloc (T);

  printf ("%g %g\n", x, y);

  for (i = 0; i &#60; 10; i++)
    {
      gsl_ran_dir_2d (r, &#38;dx, &#38;dy);
      x += dx; y += dy; 
      printf ("%g %g\n", x, y);
    }
  return 0;
}
</PRE>

<P>
Here is the output from the program, three 10-step random walks from the origin,

</P>

<P>
The following program computes the upper and lower cumulative
distribution functions for the standard normal distribution at
x=2.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_cdf.h&#62;

int
main (void)
{
  double P, Q;
  double x = 2.0;

  P = gsl_cdf_ugaussian_P (x);
  printf ("prob(x &#60; %f) = %f\n", x, P);

  Q = gsl_cdf_ugaussian_Q (x);
  printf ("prob(x &#62; %f) = %f\n", x, Q);

  x = gsl_cdf_ugaussian_Pinv (P);
  printf ("Pinv(%f) = %f\n", P, x);

  x = gsl_cdf_ugaussian_Qinv (Q);
  printf ("Qinv(%f) = %f\n", Q, x);

  return 0;
}
</PRE>

<P>
Here is the output of the program,

</P>

<PRE class="example">
prob(x &#60; 2.000000) = 0.977250
prob(x &#62; 2.000000) = 0.022750
Pinv(0.977250) = 2.000000
Qinv(0.022750) = 2.000000
</PRE>



<H2><A NAME="SEC332" HREF="gsl_manual.html#TOC332">References and Further Reading</A></H2>

<P>
For an encyclopaedic coverage of the subject readers are advised to
consult the book <CITE>Non-Uniform Random Variate Generation</CITE> by Luc
Devroye.  It covers every imaginable distribution and provides hundreds
of algorithms.

</P>

<UL class="itemize">
<LI>

Luc Devroye, <CITE>Non-Uniform Random Variate Generation</CITE>,
Springer-Verlag, ISBN 0-387-96305-7.
</UL>

<P>
The subject of random variate generation is also reviewed by Knuth, who
describes algorithms for all the major distributions.

</P>

<UL class="itemize">
<LI>

Donald E. Knuth, <CITE>The Art of Computer Programming: Seminumerical
Algorithms</CITE> (Vol 2, 3rd Ed, 1997), Addison-Wesley, ISBN 0201896842.
</UL>

<P>
The Particle Data Group provides a short review of techniques for
generating distributions of random numbers in the "Monte Carlo"
section of its Annual Review of Particle Physics.

</P>

<UL class="itemize">
<LI>

<CITE>Review of Particle Properties</CITE>
R.M. Barnett et al., Physical Review D54, 1 (1996)
<A HREF="http://pdg.lbl.gov/">http://pdg.lbl.gov/</A>.
</UL>

<P>
The Review of Particle Physics is available online in postscript and pdf
format.

</P>
<P>
An overview of methods used to compute cumulative distribution functions
can be found in <CITE>Statistical Computing</CITE> by W.J. Kennedy and
J.E. Gentle. Another general reference is <CITE>Elements of Statistical
Computing</CITE> by R.A. Thisted.

</P>

<UL class="itemize">
<LI>

William E. Kennedy and James E. Gentle, <CITE>Statistical Computing</CITE> (1980),
Marcel Dekker, ISBN 0-8247-6898-1.
</UL>


<UL class="itemize">
<LI>

Ronald A. Thisted, <CITE>Elements of Statistical Computing</CITE> (1988), 
Chapman &#38; Hall, ISBN 0-412-01371-1.
</UL>

<P>
The cumulative distribution functions for the Gaussian distribution
are based on the following papers,

</P>

<UL class="itemize">
<LI>

<CITE>Rational Chebyshev Approximations Using Linear Equations</CITE>,
W.J. Cody, W. Fraser, J.F. Hart. Numerische Mathematik 12, 242--251 (1968).
</UL>


<UL class="itemize">
<LI>

<CITE>Rational Chebyshev Approximations for the Error Function</CITE>,
W.J. Cody. Mathematics of Computation 23, n107, 631--637 (July 1969).
</UL>



<H1><A NAME="SEC333" HREF="gsl_manual.html#TOC333">Statistics</A></H1>
<P>
<A NAME="IDX1678"></A>
<A NAME="IDX1679"></A>
<A NAME="IDX1680"></A>
<A NAME="IDX1681"></A>
<A NAME="IDX1682"></A>
<A NAME="IDX1683"></A>
<A NAME="IDX1684"></A>
<A NAME="IDX1685"></A>
<A NAME="IDX1686"></A>
<A NAME="IDX1687"></A>

</P>
<P>
This chapter describes the statistical functions in the library.  The
basic statistical functions include routines to compute the mean,
variance and standard deviation.  More advanced functions allow you to
calculate absolute deviations, skewness, and kurtosis as well as the
median and arbitrary percentiles.  The algorithms use recurrence
relations to compute average quantities in a stable way, without large
intermediate values that might overflow. 

</P>
<P>
The functions are available in versions for datasets in the standard
floating-point and integer types.  The versions for double precision
floating-point data have the prefix <CODE>gsl_stats</CODE> and are declared in
the header file <TT>'gsl_statistics_double.h'</TT>.  The versions for integer
data have the prefix <CODE>gsl_stats_int</CODE> and are declared in the header
file <TT>'gsl_statistics_int.h'</TT>. 

</P>



<H2><A NAME="SEC334" HREF="gsl_manual.html#TOC334">Mean, Standard Deviation and Variance</A></H2>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_mean</B> <I>(const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1688"></A>
This function returns the arithmetic mean of <VAR>data</VAR>, a dataset of
length <VAR>n</VAR> with stride <VAR>stride</VAR>.  The arithmetic mean, or
<I>sample mean</I>, is denoted by \Hat\mu and defined as,

<SPAN class="ifinfo">


<PRE class="example">
\Hat\mu = (1/N) \sum x_i
</PRE>

</SPAN>

<P>
where x_i are the elements of the dataset <VAR>data</VAR>.  For
samples drawn from a gaussian distribution the variance of
\Hat\mu is \sigma^2 / N.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_variance</B> <I>(const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1689"></A>
This function returns the estimated, or <I>sample</I>, variance of
<VAR>data</VAR>, a dataset of length <VAR>n</VAR> with stride <VAR>stride</VAR>.  The
estimated variance is denoted by \Hat\sigma^2 and is defined by,

<SPAN class="ifinfo">


<PRE class="example">
\Hat\sigma^2 = (1/(N-1)) \sum (x_i - \Hat\mu)^2
</PRE>

</SPAN>

<P>
where x_i are the elements of the dataset <VAR>data</VAR>.  Note that
the normalization factor of 1/(N-1) results from the derivation
of \Hat\sigma^2 as an unbiased estimator of the population
variance \sigma^2.  For samples drawn from a gaussian distribution
the variance of \Hat\sigma^2 itself is 2 \sigma^4 / N.

</P>
<P>
This function computes the mean via a call to <CODE>gsl_stats_mean</CODE>.  If
you have already computed the mean then you can pass it directly to
<CODE>gsl_stats_variance_m</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_variance_m</B> <I>(const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, double <VAR>mean</VAR>)</I>
<DD><A NAME="IDX1690"></A>
This function returns the sample variance of <VAR>data</VAR> relative to the
given value of <VAR>mean</VAR>.  The function is computed with \Hat\mu
replaced by the value of <VAR>mean</VAR> that you supply,

<SPAN class="ifinfo">


<PRE class="example">
\Hat\sigma^2 = (1/(N-1)) \sum (x_i - mean)^2
</PRE>

</SPAN>

</DL>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_sd</B> <I>(const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1691"></A>
<DT><U>Function:</U> double <B>gsl_stats_sd_m</B> <I>(const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, double <VAR>mean</VAR>)</I>
<DD><A NAME="IDX1692"></A>
The standard deviation is defined as the square root of the variance.
These functions return the square root of the corresponding variance
functions above.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_variance_with_fixed_mean</B> <I>(const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, double <VAR>mean</VAR>)</I>
<DD><A NAME="IDX1693"></A>
This function computes an unbiased estimate of the variance of
<VAR>data</VAR> when the population mean <VAR>mean</VAR> of the underlying
distribution is known <EM>a priori</EM>.  In this case the estimator for
the variance uses the factor 1/N and the sample mean
\Hat\mu is replaced by the known population mean \mu,

<SPAN class="ifinfo">


<PRE class="example">
\Hat\sigma^2 = (1/N) \sum (x_i - \mu)^2
</PRE>

</SPAN>

</DL>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_sd_with_fixed_mean</B> <I>(const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, double <VAR>mean</VAR>)</I>
<DD><A NAME="IDX1694"></A>
This function calculates the standard deviation of <VAR>data</VAR> for a
fixed population mean <VAR>mean</VAR>.  The result is the square root of the
corresponding variance function.
</DL>

</P>


<H2><A NAME="SEC335" HREF="gsl_manual.html#TOC335">Absolute deviation</A></H2>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_absdev</B> <I>(const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1695"></A>
This function computes the absolute deviation from the mean of
<VAR>data</VAR>, a dataset of length <VAR>n</VAR> with stride <VAR>stride</VAR>.  The
absolute deviation from the mean is defined as,

<SPAN class="ifinfo">


<PRE class="example">
absdev  = (1/N) \sum |x_i - \Hat\mu|
</PRE>

</SPAN>

<P>
where x_i are the elements of the dataset <VAR>data</VAR>.  The
absolute deviation from the mean provides a more robust measure of the
width of a distribution than the variance.  This function computes the
mean of <VAR>data</VAR> via a call to <CODE>gsl_stats_mean</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_absdev_m</B> <I>(const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, double <VAR>mean</VAR>)</I>
<DD><A NAME="IDX1696"></A>
This function computes the absolute deviation of the dataset <VAR>data</VAR>
relative to the given value of <VAR>mean</VAR>,

<SPAN class="ifinfo">


<PRE class="example">
absdev  = (1/N) \sum |x_i - mean|
</PRE>

</SPAN>

<P>
This function is useful if you have already computed the mean of
<VAR>data</VAR> (and want to avoid recomputing it), or wish to calculate the
absolute deviation relative to another value (such as zero, or the
median).
</DL>

</P>


<H2><A NAME="SEC336" HREF="gsl_manual.html#TOC336">Higher moments (skewness and kurtosis)</A></H2>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_skew</B> <I>(const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1697"></A>
This function computes the skewness of <VAR>data</VAR>, a dataset of length
<VAR>n</VAR> with stride <VAR>stride</VAR>.  The skewness is defined as,

<SPAN class="ifinfo">


<PRE class="example">
skew = (1/N) \sum ((x_i - \Hat\mu)/\Hat\sigma)^3
</PRE>

</SPAN>

<P>
where x_i are the elements of the dataset <VAR>data</VAR>.  The skewness
measures the asymmetry of the tails of a distribution.

</P>
<P>
The function computes the mean and estimated standard deviation of
<VAR>data</VAR> via calls to <CODE>gsl_stats_mean</CODE> and <CODE>gsl_stats_sd</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_skew_m_sd</B> <I>(const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, double <VAR>mean</VAR>, double <VAR>sd</VAR>)</I>
<DD><A NAME="IDX1698"></A>
This function computes the skewness of the dataset <VAR>data</VAR> using the
given values of the mean <VAR>mean</VAR> and standard deviation <VAR>sd</VAR>,

<SPAN class="ifinfo">


<PRE class="example">
skew = (1/N) \sum ((x_i - mean)/sd)^3
</PRE>

</SPAN>

<P>
These functions are useful if you have already computed the mean and
standard deviation of <VAR>data</VAR> and want to avoid recomputing them.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_kurtosis</B> <I>(const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1699"></A>
This function computes the kurtosis of <VAR>data</VAR>, a dataset of length
<VAR>n</VAR> with stride <VAR>stride</VAR>.  The kurtosis is defined as,

<SPAN class="ifinfo">


<PRE class="example">
kurtosis = ((1/N) \sum ((x_i - \Hat\mu)/\Hat\sigma)^4)  - 3
</PRE>

</SPAN>

<P>
The kurtosis measures how sharply peaked a distribution is, relative to
its width.  The kurtosis is normalized to zero for a gaussian
distribution.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_kurtosis_m_sd</B> <I>(const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, double <VAR>mean</VAR>, double <VAR>sd</VAR>)</I>
<DD><A NAME="IDX1700"></A>
This function computes the kurtosis of the dataset <VAR>data</VAR> using the
given values of the mean <VAR>mean</VAR> and standard deviation <VAR>sd</VAR>,

<SPAN class="ifinfo">


<PRE class="example">
kurtosis = ((1/N) \sum ((x_i - mean)/sd)^4) - 3
</PRE>

</SPAN>

<P>
This function is useful if you have already computed the mean and
standard deviation of <VAR>data</VAR> and want to avoid recomputing them.
</DL>

</P>


<H2><A NAME="SEC337" HREF="gsl_manual.html#TOC337">Autocorrelation</A></H2>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_lag1_autocorrelation</B> <I>(const double <VAR>data</VAR>[], const size_t <VAR>stride</VAR>, const size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1701"></A>
This function computes the lag-1 autocorrelation of the dataset <VAR>data</VAR>.

<SPAN class="ifinfo">


<PRE class="example">
a_1 = {\sum_{i = 1}^{n} (x_{i} - \Hat\mu) (x_{i-1} - \Hat\mu)
       \over
       \sum_{i = 1}^{n} (x_{i} - \Hat\mu) (x_{i} - \Hat\mu)}
</PRE>

</SPAN>

</DL>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_lag1_autocorrelation_m</B> <I>(const double <VAR>data</VAR>[], const size_t <VAR>stride</VAR>, const size_t <VAR>n</VAR>, const double <VAR>mean</VAR>)</I>
<DD><A NAME="IDX1702"></A>
This function computes the lag-1 autocorrelation of the dataset
<VAR>data</VAR> using the given value of the mean <VAR>mean</VAR>.

</P>
</DL>



<H2><A NAME="SEC338" HREF="gsl_manual.html#TOC338">Covariance</A></H2>
<P>
<A NAME="IDX1703"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_covariance</B> <I>(const double <VAR>data1</VAR>[], const size_t <VAR>stride1</VAR>, const double <VAR>data2</VAR>[], const size_t <VAR>stride2</VAR>, const size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1704"></A>
This function computes the covariance of the datasets <VAR>data1</VAR> and
<VAR>data2</VAR> which must both be of the same length <VAR>n</VAR>.

<SPAN class="ifinfo">


<PRE class="example">
covar = (1/(n - 1)) \sum_{i = 1}^{n} (x_i - \Hat x) (y_i - \Hat y)
</PRE>

</SPAN>

</DL>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_covariance_m</B> <I>(const double <VAR>data1</VAR>[], const size_t <VAR>stride1</VAR>, const double <VAR>data2</VAR>[], const size_t <VAR>n</VAR>, const double <VAR>mean1</VAR>, const double <VAR>mean2</VAR>)</I>
<DD><A NAME="IDX1705"></A>
This function computes the covariance of the datasets <VAR>data1</VAR> and
<VAR>data2</VAR> using the given values of the means, <VAR>mean1</VAR> and
<VAR>mean2</VAR>.  This is useful if you have already computed the means of
<VAR>data1</VAR> and <VAR>data2</VAR> and want to avoid recomputing them.
</DL>

</P>



<H2><A NAME="SEC339" HREF="gsl_manual.html#TOC339">Weighted Samples</A></H2>

<P>
The functions described in this section allow the computation of
statistics for weighted samples.  The functions accept an array of
samples, x_i, with associated weights, w_i.  Each sample
x_i is considered as having been drawn from a Gaussian
distribution with variance \sigma_i^2.  The sample weight
w_i is defined as the reciprocal of this variance, w_i =
1/\sigma_i^2.  Setting a weight to zero corresponds to removing a
sample from a dataset.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_wmean</B> <I>(const double <VAR>w</VAR>[], size_t <VAR>wstride</VAR>, const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1706"></A>
This function returns the weighted mean of the dataset <VAR>data</VAR> with
stride <VAR>stride</VAR> and length <VAR>n</VAR>, using the set of weights <VAR>w</VAR>
with stride <VAR>wstride</VAR> and length <VAR>n</VAR>.  The weighted mean is defined as,

<SPAN class="ifinfo">


<PRE class="example">
\Hat\mu = (\sum w_i x_i) / (\sum w_i)
</PRE>

</SPAN>

</DL>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_wvariance</B> <I>(const double <VAR>w</VAR>[], size_t <VAR>wstride</VAR>, const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1707"></A>
This function returns the estimated variance of the dataset <VAR>data</VAR>
with stride <VAR>stride</VAR> and length <VAR>n</VAR>, using the set of weights
<VAR>w</VAR> with stride <VAR>wstride</VAR> and length <VAR>n</VAR>.  The estimated
variance of a weighted dataset is defined as,

<SPAN class="ifinfo">


<PRE class="example">
\Hat\sigma^2 = ((\sum w_i)/((\sum w_i)^2 - \sum (w_i^2))) 
                \sum w_i (x_i - \Hat\mu)^2
</PRE>

</SPAN>

<P>
Note that this expression reduces to an unweighted variance with the
familiar 1/(N-1) factor when there are N equal non-zero
weights.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_wvariance_m</B> <I>(const double <VAR>w</VAR>[], size_t <VAR>wstride</VAR>, const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, double <VAR>wmean</VAR>)</I>
<DD><A NAME="IDX1708"></A>
This function returns the estimated variance of the weighted dataset
<VAR>data</VAR> using the given weighted mean <VAR>wmean</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_wsd</B> <I>(const double <VAR>w</VAR>[], size_t <VAR>wstride</VAR>, const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1709"></A>
The standard deviation is defined as the square root of the variance.
This function returns the square root of the corresponding variance
function <CODE>gsl_stats_wvariance</CODE> above.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_wsd_m</B> <I>(const double <VAR>w</VAR>[], size_t <VAR>wstride</VAR>, const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, double <VAR>wmean</VAR>)</I>
<DD><A NAME="IDX1710"></A>
This function returns the square root of the corresponding variance
function <CODE>gsl_stats_wvariance_m</CODE> above.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_wvariance_with_fixed_mean</B> <I>(const double <VAR>w</VAR>[], size_t <VAR>wstride</VAR>, const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, const double <VAR>mean</VAR>)</I>
<DD><A NAME="IDX1711"></A>
This function computes an unbiased estimate of the variance of weighted
dataset <VAR>data</VAR> when the population mean <VAR>mean</VAR> of the underlying
distribution is known <EM>a priori</EM>.  In this case the estimator for
the variance replaces the sample mean \Hat\mu by the known
population mean \mu,

<SPAN class="ifinfo">


<PRE class="example">
\Hat\sigma^2 = (\sum w_i (x_i - \mu)^2) / (\sum w_i)
</PRE>

</SPAN>

</DL>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_wsd_with_fixed_mean</B> <I>(const double <VAR>w</VAR>[], size_t <VAR>wstride</VAR>, const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, const double <VAR>mean</VAR>)</I>
<DD><A NAME="IDX1712"></A>
The standard deviation is defined as the square root of the variance.
This function returns the square root of the corresponding variance
function above.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_wabsdev</B> <I>(const double <VAR>w</VAR>[], size_t <VAR>wstride</VAR>, const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1713"></A>
This function computes the weighted absolute deviation from the weighted
mean of <VAR>data</VAR>.  The absolute deviation from the mean is defined as,

<SPAN class="ifinfo">


<PRE class="example">
absdev = (\sum w_i |x_i - \Hat\mu|) / (\sum w_i)
</PRE>

</SPAN>

</DL>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_wabsdev_m</B> <I>(const double <VAR>w</VAR>[], size_t <VAR>wstride</VAR>, const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, double <VAR>wmean</VAR>)</I>
<DD><A NAME="IDX1714"></A>
This function computes the absolute deviation of the weighted dataset
<VAR>data</VAR> about the given weighted mean <VAR>wmean</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_wskew</B> <I>(const double <VAR>w</VAR>[], size_t <VAR>wstride</VAR>, const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1715"></A>
This function computes the weighted skewness of the dataset <VAR>data</VAR>.

<SPAN class="ifinfo">


<PRE class="example">
skew = (\sum w_i ((x_i - xbar)/\sigma)^3) / (\sum w_i)
</PRE>

</SPAN>

</DL>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_wskew_m_sd</B> <I>(const double <VAR>w</VAR>[], size_t <VAR>wstride</VAR>, const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, double <VAR>wmean</VAR>, double <VAR>wsd</VAR>)</I>
<DD><A NAME="IDX1716"></A>
This function computes the weighted skewness of the dataset <VAR>data</VAR>
using the given values of the weighted mean and weighted standard
deviation, <VAR>wmean</VAR> and <VAR>wsd</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_wkurtosis</B> <I>(const double <VAR>w</VAR>[], size_t <VAR>wstride</VAR>, const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1717"></A>
This function computes the weighted kurtosis of the dataset <VAR>data</VAR>.

</P>

<SPAN class="ifinfo">


<PRE class="example">
kurtosis = ((\sum w_i ((x_i - xbar)/sigma)^4) / (\sum w_i)) - 3
</PRE>

</SPAN>

</DL>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_wkurtosis_m_sd</B> <I>(const double <VAR>w</VAR>[], size_t <VAR>wstride</VAR>, const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, double <VAR>wmean</VAR>, double <VAR>wsd</VAR>)</I>
<DD><A NAME="IDX1718"></A>
This function computes the weighted kurtosis of the dataset <VAR>data</VAR>
using the given values of the weighted mean and weighted standard
deviation, <VAR>wmean</VAR> and <VAR>wsd</VAR>.
</DL>

</P>


<H2><A NAME="SEC340" HREF="gsl_manual.html#TOC340">Maximum and Minimum values</A></H2>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_max</B> <I>(const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1719"></A>
This function returns the maximum value in <VAR>data</VAR>, a dataset of
length <VAR>n</VAR> with stride <VAR>stride</VAR>.  The maximum value is defined
as the value of the element x_i which satisfies 
x_i &#62;= x_j for all j.

</P>
<P>
If you want instead to find the element with the largest absolute
magnitude you will need to apply <CODE>fabs</CODE> or <CODE>abs</CODE> to your data
before calling this function.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_min</B> <I>(const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1720"></A>
This function returns the minimum value in <VAR>data</VAR>, a dataset of
length <VAR>n</VAR> with stride <VAR>stride</VAR>.  The minimum value is defined
as the value of the element x_i which satisfies 
x_i &#60;= x_j for all j.

</P>
<P>
If you want instead to find the element with the smallest absolute
magnitude you will need to apply <CODE>fabs</CODE> or <CODE>abs</CODE> to your data
before calling this function.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_stats_minmax</B> <I>(double * <VAR>min</VAR>, double * <VAR>max</VAR>, const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1721"></A>
This function finds both the minimum and maximum values <VAR>min</VAR>,
<VAR>max</VAR> in <VAR>data</VAR> in a single pass.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_stats_max_index</B> <I>(const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1722"></A>
This function returns the index of the maximum value in <VAR>data</VAR>, a
dataset of length <VAR>n</VAR> with stride <VAR>stride</VAR>.  The maximum value is
defined as the value of the element x_i which satisfies 
x_i &#62;= x_j for all j.  When there are several equal maximum
elements then the first one is chosen.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_stats_min_index</B> <I>(const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1723"></A>
This function returns the index of the minimum value in <VAR>data</VAR>, a
dataset of length <VAR>n</VAR> with stride <VAR>stride</VAR>.  The minimum value
is defined as the value of the element x_i which satisfies
x_i &#62;= x_j for all j.  When there are several equal
minimum elements then the first one is chosen.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_stats_minmax_index</B> <I>(size_t * <VAR>min_index</VAR>, size_t * <VAR>max_index</VAR>, const double <VAR>data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1724"></A>
This function returns the indexes <VAR>min_index</VAR>, <VAR>max_index</VAR> of
the minimum and maximum values in <VAR>data</VAR> in a single pass.
</DL>

</P>


<H2><A NAME="SEC341" HREF="gsl_manual.html#TOC341">Median and Percentiles</A></H2>

<P>
The median and percentile functions described in this section operate on
sorted data.  For convenience we use <I>quantiles</I>, measured on a scale
of 0 to 1, instead of percentiles (which use a scale of 0 to 100).

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_median_from_sorted_data</B> <I>(const double <VAR>sorted_data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1725"></A>
This function returns the median value of <VAR>sorted_data</VAR>, a dataset
of length <VAR>n</VAR> with stride <VAR>stride</VAR>.  The elements of the array
must be in ascending numerical order.  There are no checks to see
whether the data are sorted, so the function <CODE>gsl_sort</CODE> should
always be used first.

</P>
<P>
When the dataset has an odd number of elements the median is the value
of element (n-1)/2.  When the dataset has an even number of
elements the median is the mean of the two nearest middle values,
elements (n-1)/2 and n/2.  Since the algorithm for
computing the median involves interpolation this function always returns
a floating-point number, even for integer data types.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_stats_quantile_from_sorted_data</B> <I>(const double <VAR>sorted_data</VAR>[], size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, double <VAR>f</VAR>)</I>
<DD><A NAME="IDX1726"></A>
This function returns a quantile value of <VAR>sorted_data</VAR>, a
double-precision array of length <VAR>n</VAR> with stride <VAR>stride</VAR>.  The
elements of the array must be in ascending numerical order.  The
quantile is determined by the <VAR>f</VAR>, a fraction between 0 and 1.  For
example, to compute the value of the 75th percentile <VAR>f</VAR> should have
the value 0.75.

</P>
<P>
There are no checks to see whether the data are sorted, so the function
<CODE>gsl_sort</CODE> should always be used first.

</P>
<P>
The quantile is found by interpolation, using the formula

<SPAN class="ifinfo">


<PRE class="example">
quantile = (1 - \delta) x_i + \delta x_{i+1}
</PRE>

</SPAN>

<P>
where i is <CODE>floor</CODE>((n - 1)f) and \delta is
(n-1)f - i.

</P>
<P>
Thus the minimum value of the array (<CODE>data[0*stride]</CODE>) is given by
<VAR>f</VAR> equal to zero, the maximum value (<CODE>data[(n-1)*stride]</CODE>) is
given by <VAR>f</VAR> equal to one and the median value is given by <VAR>f</VAR>
equal to 0.5.  Since the algorithm for computing quantiles involves
interpolation this function always returns a floating-point number, even
for integer data types.
</DL>

</P>



<H2><A NAME="SEC342" HREF="gsl_manual.html#TOC342">Examples</A></H2>
<P>
Here is a basic example of how to use the statistical functions:

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_statistics.h&#62;

int
main(void)
{
  double data[5] = {17.2, 18.1, 16.5, 18.3, 12.6};
  double mean, variance, largest, smallest;

  mean     = gsl_stats_mean(data, 1, 5);
  variance = gsl_stats_variance(data, 1, 5);
  largest  = gsl_stats_max(data, 1, 5);
  smallest = gsl_stats_min(data, 1, 5);

  printf ("The dataset is %g, %g, %g, %g, %g\n",
         data[0], data[1], data[2], data[3], data[4]);

  printf ("The sample mean is %g\n", mean);
  printf ("The estimated variance is %g\n", variance);
  printf ("The largest value is %g\n", largest);
  printf ("The smallest value is %g\n", smallest);
  return 0;
}
</PRE>

<P>
The program should produce the following output,

</P>

<PRE class="example">
The dataset is 17.2, 18.1, 16.5, 18.3, 12.6
The sample mean is 16.54
The estimated variance is 4.2984
The largest value is 18.3
The smallest value is 12.6
</PRE>

<P>
Here is an example using sorted data,

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_sort.h&#62;
#include &#60;gsl/gsl_statistics.h&#62;

int
main(void)
{
  double data[5] = {17.2, 18.1, 16.5, 18.3, 12.6};
  double median, upperq, lowerq;

  printf ("Original dataset:  %g, %g, %g, %g, %g\n",
         data[0], data[1], data[2], data[3], data[4]);

  gsl_sort (data, 1, 5);

  printf ("Sorted dataset: %g, %g, %g, %g, %g\n",
         data[0], data[1], data[2], data[3], data[4]);

  median 
    = gsl_stats_median_from_sorted_data (data, 
                                         1, 5);

  upperq 
    = gsl_stats_quantile_from_sorted_data (data, 
                                           1, 5,
                                           0.75);
  lowerq 
    = gsl_stats_quantile_from_sorted_data (data, 
                                           1, 5,
                                           0.25);

  printf ("The median is %g\n", median);
  printf ("The upper quartile is %g\n", upperq);
  printf ("The lower quartile is %g\n", lowerq);
  return 0;
}
</PRE>

<P>
This program should produce the following output,

</P>

<PRE class="example">
Original dataset: 17.2, 18.1, 16.5, 18.3, 12.6
Sorted dataset: 12.6, 16.5, 17.2, 18.1, 18.3
The median is 17.2
The upper quartile is 18.1
The lower quartile is 16.5
</PRE>



<H2><A NAME="SEC343" HREF="gsl_manual.html#TOC343">References and Further Reading</A></H2>

<P>
The standard reference for almost any topic in statistics is the
multi-volume <CITE>Advanced Theory of Statistics</CITE> by Kendall and Stuart.

</P>

<UL class="itemize">
<LI>

Maurice Kendall, Alan Stuart, and J. Keith Ord.
<CITE>The Advanced Theory of Statistics</CITE> (multiple volumes)
reprinted as <CITE>Kendall's Advanced Theory of Statistics</CITE>.
Wiley, ISBN 047023380X.
</UL>

<P>
Many statistical concepts can be more easily understood by a Bayesian
approach.  The following book by Gelman, Carlin, Stern and Rubin gives a
comprehensive coverage of the subject.

</P>

<UL class="itemize">
<LI>

Andrew Gelman, John B. Carlin, Hal S. Stern, Donald B. Rubin.
<CITE>Bayesian Data Analysis</CITE>.
Chapman &#38; Hall, ISBN 0412039915.
</UL>

<P>
For physicists the Particle Data Group provides useful reviews of
Probability and Statistics in the "Mathematical Tools" section of its
Annual Review of Particle Physics. 

</P>

<UL class="itemize">
<LI>

<CITE>Review of Particle Properties</CITE>
R.M. Barnett et al., Physical Review D54, 1 (1996)
</UL>

<P>
The Review of Particle Physics is available online at
the website <A HREF="http://pdg.lbl.gov/">http://pdg.lbl.gov/</A>.

</P>



<H1><A NAME="SEC344" HREF="gsl_manual.html#TOC344">Histograms</A></H1>
<P>
<A NAME="IDX1727"></A>
<A NAME="IDX1728"></A>
This chapter describes functions for creating histograms.  Histograms
provide a convenient way of summarizing the distribution of a set of
data. A histogram consists of a set of <I>bins</I> which count the number
of events falling into a given range of a continuous variable x.
In GSL the bins of a histogram contain floating-point numbers, so they
can be used to record both integer and non-integer distributions.  The
bins can use arbitrary sets of ranges (uniformly spaced bins are the
default).  Both one and two-dimensional histograms are supported.

</P>
<P>
Once a histogram has been created it can also be converted into a
probability distribution function.  The library provides efficient
routines for selecting random samples from probability distributions.
This can be useful for generating simulations based on real data.

</P>
<P>
The functions are declared in the header files <TT>'gsl_histogram.h'</TT>
and <TT>'gsl_histogram2d.h'</TT>.

</P>



<H2><A NAME="SEC345" HREF="gsl_manual.html#TOC345">The histogram struct</A></H2>

<P>
A histogram is defined by the following struct,

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_histogram</B>
<DD><A NAME="IDX1729"></A>
<DL COMPACT>

<DT><CODE>size_t n</CODE>
<DD>
This is the number of histogram bins
<DT><CODE>double * range</CODE>
<DD>
The ranges of the bins are stored in an array of <VAR>n</VAR>+1 elements
pointed to by <VAR>range</VAR>.
<DT><CODE>double * bin</CODE>
<DD>
The counts for each bin are stored in an array of <VAR>n</VAR> elements
pointed to by <VAR>bin</VAR>.  The bins are floating-point numbers, so you can
increment them by non-integer values if necessary.
</DL>
</DL>
<P>
The range for <VAR>bin</VAR>[i] is given by <VAR>range</VAR>[i] to
<VAR>range</VAR>[i+1].  For n bins there are n+1 entries in the
array <VAR>range</VAR>.  Each bin is inclusive at the lower end and exclusive
at the upper end.  Mathematically this means that the bins are defined by
the following inequality,

<SPAN class="ifinfo">

<PRE class="display">
bin[i] corresponds to range[i] &#60;= x &#60; range[i+1]
</PRE>

</SPAN>

<P>
Here is a diagram of the correspondence between ranges and bins on the
number-line for x,

</P>

<PRE class="smallexample">

     [ bin[0] )[ bin[1] )[ bin[2] )[ bin[3] )[ bin[4] )
  ---|---------|---------|---------|---------|---------|---  x
   r[0]      r[1]      r[2]      r[3]      r[4]      r[5]

</PRE>

<P>
In this picture the values of the <VAR>range</VAR> array are denoted by
r.  On the left-hand side of each bin the square bracket
<SAMP>'['</SAMP> denotes an inclusive lower bound 
(
r &#60;= x), and the round parentheses <SAMP>')'</SAMP> on the right-hand
side denote an exclusive upper bound (x &#60; r).  Thus any samples
which fall on the upper end of the histogram are excluded.  If you want
to include this value for the last bin you will need to add an extra bin
to your histogram.

</P>
<P>
The <CODE>gsl_histogram</CODE> struct and its associated functions are defined
in the header file <TT>'gsl_histogram.h'</TT>.

</P>


<H2><A NAME="SEC346" HREF="gsl_manual.html#TOC346">Histogram allocation</A></H2>
<P>
The functions for allocating memory to a histogram follow the style of
<CODE>malloc</CODE> and <CODE>free</CODE>.  In addition they also perform their own
error checking.  If there is insufficient memory available to allocate a
histogram then the functions call the error handler (with an error
number of <CODE>GSL_ENOMEM</CODE>) in addition to returning a null pointer.
Thus if you use the library error handler to abort your program then it
isn't necessary to check every histogram <CODE>alloc</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_histogram * <B>gsl_histogram_alloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1730"></A>
This function allocates memory for a histogram with <VAR>n</VAR> bins, and
returns a pointer to a newly created <CODE>gsl_histogram</CODE> struct.  If
insufficient memory is available a null pointer is returned and the
error handler is invoked with an error code of <CODE>GSL_ENOMEM</CODE>. The
bins and ranges are not initialized, and should be prepared using one of
the range-setting functions below in order to make the histogram ready
for use.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_set_ranges</B> <I>(gsl_histogram * <VAR>h</VAR>, const double <VAR>range</VAR>[], size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX1731"></A>
This function sets the ranges of the existing histogram <VAR>h</VAR> using
the array <VAR>range</VAR> of size <VAR>size</VAR>.  The values of the histogram
bins are reset to zero.  The <CODE>range</CODE> array should contain the
desired bin limits.  The ranges can be arbitrary, subject to the
restriction that they are monotonically increasing.

</P>
<P>
The following example shows how to create a histogram with logarithmic
bins with ranges [1,10), [10,100) and [100,1000).

</P>

<PRE class="example">
gsl_histogram * h = gsl_histogram_alloc (3);

/* bin[0] covers the range 1 &#60;= x &#60; 10 */
/* bin[1] covers the range 10 &#60;= x &#60; 100 */
/* bin[2] covers the range 100 &#60;= x &#60; 1000 */

double range[4] = { 1.0, 10.0, 100.0, 1000.0 };

gsl_histogram_set_ranges (h, range, 4);
</PRE>

<P>
Note that the size of the <VAR>range</VAR> array should be defined to be one
element bigger than the number of bins.  The additional element is
required for the upper value of the final bin.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_set_ranges_uniform</B> <I>(gsl_histogram * <VAR>h</VAR>, double <VAR>xmin</VAR>, double <VAR>xmax</VAR>)</I>
<DD><A NAME="IDX1732"></A>
This function sets the ranges of the existing histogram <VAR>h</VAR> to cover
the range <VAR>xmin</VAR> to <VAR>xmax</VAR> uniformly.  The values of the
histogram bins are reset to zero.  The bin ranges are shown in the table
below,

<SPAN class="ifinfo">

<PRE class="display">
bin[0] corresponds to xmin &#60;= x &#60; xmin + d
bin[1] corresponds to xmin + d &#60;= x &#60; xmin + 2 d
......
bin[n-1] corresponds to xmin + (n-1)d &#60;= x &#60; xmax
</PRE>

</SPAN>

<P>
where d is the bin spacing, d = (xmax-xmin)/n.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_histogram_free</B> <I>(gsl_histogram * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1733"></A>
This function frees the histogram <VAR>h</VAR> and all of the memory
associated with it.
</DL>

</P>


<H2><A NAME="SEC347" HREF="gsl_manual.html#TOC347">Copying Histograms</A></H2>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_memcpy</B> <I>(gsl_histogram * <VAR>dest</VAR>, const gsl_histogram * <VAR>src</VAR>)</I>
<DD><A NAME="IDX1734"></A>
This function copies the histogram <VAR>src</VAR> into the pre-existing
histogram <VAR>dest</VAR>, making <VAR>dest</VAR> into an exact copy of <VAR>src</VAR>.
The two histograms must be of the same size.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_histogram * <B>gsl_histogram_clone</B> <I>(const gsl_histogram * <VAR>src</VAR>)</I>
<DD><A NAME="IDX1735"></A>
This function returns a pointer to a newly created histogram which is an
exact copy of the histogram <VAR>src</VAR>.
</DL>

</P>


<H2><A NAME="SEC348" HREF="gsl_manual.html#TOC348">Updating and accessing histogram elements</A></H2>

<P>
There are two ways to access histogram bins, either by specifying an
x coordinate or by using the bin-index directly.  The functions
for accessing the histogram through x coordinates use a binary
search to identify the bin which covers the appropriate range.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_increment</B> <I>(gsl_histogram * <VAR>h</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1736"></A>
This function updates the histogram <VAR>h</VAR> by adding one (1.0) to the
bin whose range contains the coordinate <VAR>x</VAR>. 

</P>
<P>
If <VAR>x</VAR> lies in the valid range of the histogram then the function
returns zero to indicate success.  If <VAR>x</VAR> is less than the lower
limit of the histogram then the function returns <CODE>GSL_EDOM</CODE>, and
none of bins are modified.  Similarly, if the value of <VAR>x</VAR> is greater
than or equal to the upper limit of the histogram then the function
returns <CODE>GSL_EDOM</CODE>, and none of the bins are modified.  The error
handler is not called, however, since it is often necessary to compute
histograms for a small range of a larger dataset, ignoring the values
outside the range of interest.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_accumulate</B> <I>(gsl_histogram * <VAR>h</VAR>, double <VAR>x</VAR>, double <VAR>weight</VAR>)</I>
<DD><A NAME="IDX1737"></A>
This function is similar to <CODE>gsl_histogram_increment</CODE> but increases
the value of the appropriate bin in the histogram <VAR>h</VAR> by the
floating-point number <VAR>weight</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram_get</B> <I>(const gsl_histogram * <VAR>h</VAR>, size_t <VAR>i</VAR>)</I>
<DD><A NAME="IDX1738"></A>
This function returns the contents of the <VAR>i</VAR>-th bin of the histogram
<VAR>h</VAR>.  If <VAR>i</VAR> lies outside the valid range of indices for the
histogram then the error handler is called with an error code of
<CODE>GSL_EDOM</CODE> and the function returns 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_get_range</B> <I>(const gsl_histogram * <VAR>h</VAR>, size_t <VAR>i</VAR>, double * <VAR>lower</VAR>, double * <VAR>upper</VAR>)</I>
<DD><A NAME="IDX1739"></A>
This function finds the upper and lower range limits of the <VAR>i</VAR>-th
bin of the histogram <VAR>h</VAR>.  If the index <VAR>i</VAR> is valid then the
corresponding range limits are stored in <VAR>lower</VAR> and <VAR>upper</VAR>.
The lower limit is inclusive (i.e. events with this coordinate are
included in the bin) and the upper limit is exclusive (i.e. events with
the coordinate of the upper limit are excluded and fall in the
neighboring higher bin, if it exists).  The function returns 0 to
indicate success.  If <VAR>i</VAR> lies outside the valid range of indices for
the histogram then the error handler is called and the function returns
an error code of <CODE>GSL_EDOM</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram_max</B> <I>(const gsl_histogram * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1740"></A>
<DT><U>Function:</U> double <B>gsl_histogram_min</B> <I>(const gsl_histogram * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1741"></A>
<DT><U>Function:</U> size_t <B>gsl_histogram_bins</B> <I>(const gsl_histogram * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1742"></A>
These functions return the maximum upper and minimum lower range limits
and the number of bins of the histogram <VAR>h</VAR>.  They provide a way of
determining these values without accessing the <CODE>gsl_histogram</CODE>
struct directly.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_histogram_reset</B> <I>(gsl_histogram * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1743"></A>
This function resets all the bins in the histogram <VAR>h</VAR> to zero.
</DL>

</P>


<H2><A NAME="SEC349" HREF="gsl_manual.html#TOC349">Searching histogram ranges</A></H2>

<P>
The following functions are used by the access and update routines to
locate the bin which corresponds to a given x coordinate.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_find</B> <I>(const gsl_histogram * <VAR>h</VAR>, double <VAR>x</VAR>, size_t * <VAR>i</VAR>)</I>
<DD><A NAME="IDX1744"></A>
This function finds and sets the index <VAR>i</VAR> to the bin number which
covers the coordinate <VAR>x</VAR> in the histogram <VAR>h</VAR>.  The bin is
located using a binary search. The search includes an optimization for
histograms with uniform range, and will return the correct bin
immediately in this case.  If <VAR>x</VAR> is found in the range of the
histogram then the function sets the index <VAR>i</VAR> and returns
<CODE>GSL_SUCCESS</CODE>.  If <VAR>x</VAR> lies outside the valid range of the
histogram then the function returns <CODE>GSL_EDOM</CODE> and the error
handler is invoked.
</DL>

</P>


<H2><A NAME="SEC350" HREF="gsl_manual.html#TOC350">Histogram Statistics</A></H2>
<P>
<A NAME="IDX1745"></A>
<A NAME="IDX1746"></A>
<A NAME="IDX1747"></A>
<A NAME="IDX1748"></A>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram_max_val</B> <I>(const gsl_histogram * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1749"></A>
This function returns the maximum value contained in the histogram bins.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_histogram_max_bin</B> <I>(const gsl_histogram * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1750"></A>
This function returns the index of the bin containing the maximum
value. In the case where several bins contain the same maximum value the
smallest index is returned.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram_min_val</B> <I>(const gsl_histogram * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1751"></A>
This function returns the minimum value contained in the histogram bins.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_histogram_min_bin</B> <I>(const gsl_histogram * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1752"></A>
This function returns the index of the bin containing the minimum
value. In the case where several bins contain the same maximum value the
smallest index is returned.
</DL>

</P>
<P>
<A NAME="IDX1753"></A>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram_mean</B> <I>(const gsl_histogram * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1754"></A>
This function returns the mean of the histogrammed variable, where the
histogram is regarded as a probability distribution. Negative bin values
are ignored for the purposes of this calculation.  The accuracy of the
result is limited by the bin width.
</DL>

</P>
<P>
<A NAME="IDX1755"></A>
<A NAME="IDX1756"></A>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram_sigma</B> <I>(const gsl_histogram * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1757"></A>
This function returns the standard deviation of the histogrammed
variable, where the histogram is regarded as a probability
distribution. Negative bin values are ignored for the purposes of this
calculation. The accuracy of the result is limited by the bin width.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram_sum</B> <I>(const gsl_histogram * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1758"></A>
This function returns the sum of all bin values. Negative bin values
are included in the sum.
</DL>

</P>


<H2><A NAME="SEC351" HREF="gsl_manual.html#TOC351">Histogram Operations</A></H2>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_equal_bins_p</B> <I>(const gsl_histogram * <VAR>h1</VAR>, const gsl_histogram * <VAR>h2</VAR>)</I>
<DD><A NAME="IDX1759"></A>
This function returns 1 if the all of the individual bin
ranges of the two histograms are identical, and 0
otherwise.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_add</B> <I>(gsl_histogram * <VAR>h1</VAR>, const gsl_histogram * <VAR>h2</VAR>)</I>
<DD><A NAME="IDX1760"></A>
This function adds the contents of the bins in histogram <VAR>h2</VAR> to the
corresponding bins of histogram <VAR>h1</VAR>,  i.e. h'_1(i) = h_1(i) +
h_2(i).  The two histograms must have identical bin ranges.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_sub</B> <I>(gsl_histogram * <VAR>h1</VAR>, const gsl_histogram * <VAR>h2</VAR>)</I>
<DD><A NAME="IDX1761"></A>
This function subtracts the contents of the bins in histogram <VAR>h2</VAR>
from the corresponding bins of histogram <VAR>h1</VAR>, i.e. h'_1(i) =
h_1(i) - h_2(i).  The two histograms must have identical bin ranges.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_mul</B> <I>(gsl_histogram * <VAR>h1</VAR>, const gsl_histogram * <VAR>h2</VAR>)</I>
<DD><A NAME="IDX1762"></A>
This function multiplies the contents of the bins of histogram <VAR>h1</VAR>
by the contents of the corresponding bins in histogram <VAR>h2</VAR>,
i.e. h'_1(i) = h_1(i) * h_2(i).  The two histograms must have
identical bin ranges.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_div</B> <I>(gsl_histogram * <VAR>h1</VAR>, const gsl_histogram * <VAR>h2</VAR>)</I>
<DD><A NAME="IDX1763"></A>
This function divides the contents of the bins of histogram <VAR>h1</VAR> by
the contents of the corresponding bins in histogram <VAR>h2</VAR>,
i.e. h'_1(i) = h_1(i) / h_2(i).  The two histograms must have
identical bin ranges.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_scale</B> <I>(gsl_histogram * <VAR>h</VAR>, double <VAR>scale</VAR>)</I>
<DD><A NAME="IDX1764"></A>
This function multiplies the contents of the bins of histogram <VAR>h</VAR>
by the constant <VAR>scale</VAR>, i.e. 
h'_1(i) = h_1(i) * scale.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_shift</B> <I>(gsl_histogram * <VAR>h</VAR>, double <VAR>offset</VAR>)</I>
<DD><A NAME="IDX1765"></A>
This function shifts the contents of the bins of histogram <VAR>h</VAR> by
the constant <VAR>offset</VAR>, i.e. 
h'_1(i) = h_1(i) + offset.
</DL>

</P>


<H2><A NAME="SEC352" HREF="gsl_manual.html#TOC352">Reading and writing histograms</A></H2>

<P>
The library provides functions for reading and writing histograms to a file
as binary data or formatted text.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_fwrite</B> <I>(FILE * <VAR>stream</VAR>, const gsl_histogram * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1766"></A>
This function writes the ranges and bins of the histogram <VAR>h</VAR> to the
stream <VAR>stream</VAR> in binary format.  The return value is 0 for success
and <CODE>GSL_EFAILED</CODE> if there was a problem writing to the file.  Since
the data is written in the native binary format it may not be portable
between different architectures.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_fread</B> <I>(FILE * <VAR>stream</VAR>, gsl_histogram * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1767"></A>
This function reads into the histogram <VAR>h</VAR> from the open stream
<VAR>stream</VAR> in binary format.  The histogram <VAR>h</VAR> must be
preallocated with the correct size since the function uses the number of
bins in <VAR>h</VAR> to determine how many bytes to read.  The return value is
0 for success and <CODE>GSL_EFAILED</CODE> if there was a problem reading from
the file.  The data is assumed to have been written in the native binary
format on the same architecture.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_fprintf</B> <I>(FILE * <VAR>stream</VAR>, const gsl_histogram * <VAR>h</VAR>, const char * <VAR>range_format</VAR>, const char * <VAR>bin_format</VAR>)</I>
<DD><A NAME="IDX1768"></A>
This function writes the ranges and bins of the histogram <VAR>h</VAR>
line-by-line to the stream <VAR>stream</VAR> using the format specifiers
<VAR>range_format</VAR> and <VAR>bin_format</VAR>.  These should be one of the
<CODE>%g</CODE>, <CODE>%e</CODE> or <CODE>%f</CODE> formats for floating point
numbers.  The function returns 0 for success and <CODE>GSL_EFAILED</CODE> if
there was a problem writing to the file.  The histogram output is
formatted in three columns, and the columns are separated by spaces,
like this,

</P>

<PRE class="example">
range[0] range[1] bin[0]
range[1] range[2] bin[1]
range[2] range[3] bin[2]
....
range[n-1] range[n] bin[n-1]
</PRE>

<P>
The values of the ranges are formatted using <VAR>range_format</VAR> and the
value of the bins are formatted using <VAR>bin_format</VAR>.  Each line
contains the lower and upper limit of the range of the bins and the
value of the bin itself.  Since the upper limit of one bin is the lower
limit of the next there is duplication of these values between lines but
this allows the histogram to be manipulated with line-oriented tools.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_fscanf</B> <I>(FILE * <VAR>stream</VAR>, gsl_histogram * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1769"></A>
This function reads formatted data from the stream <VAR>stream</VAR> into the
histogram <VAR>h</VAR>.  The data is assumed to be in the three-column format
used by <CODE>gsl_histogram_fprintf</CODE>.  The histogram <VAR>h</VAR> must be
preallocated with the correct length since the function uses the size of
<VAR>h</VAR> to determine how many numbers to read.  The function returns 0
for success and <CODE>GSL_EFAILED</CODE> if there was a problem reading from
the file.
</DL>

</P>


<H2><A NAME="SEC353" HREF="gsl_manual.html#TOC353">Resampling from histograms</A></H2>
<P>
<A NAME="IDX1770"></A>
<A NAME="IDX1771"></A>
<A NAME="IDX1772"></A>

</P>
<P>
A histogram made by counting events can be regarded as a measurement of
a probability distribution.  Allowing for statistical error, the height
of each bin represents the probability of an event where the value of
x falls in the range of that bin.  The probability distribution
function has the one-dimensional form p(x)dx where,

<SPAN class="ifinfo">


<PRE class="example">
p(x) = n_i/ (N w_i)
</PRE>

</SPAN>

<P>
In this equation n_i is the number of events in the bin which
contains x, w_i is the width of the bin and N is
the total number of events.  The distribution of events within each bin
is assumed to be uniform.

</P>


<H2><A NAME="SEC354" HREF="gsl_manual.html#TOC354">The histogram probability distribution struct</A></H2>
<P>
<A NAME="IDX1773"></A>
<A NAME="IDX1774"></A>
<A NAME="IDX1775"></A>
<A NAME="IDX1776"></A>
The probability distribution function for a histogram consists of a set
of <I>bins</I> which measure the probability of an event falling into a
given range of a continuous variable x. A probability
distribution function is defined by the following struct, which actually
stores the cumulative probability distribution function.  This is the
natural quantity for generating samples via the inverse transform
method, because there is a one-to-one mapping between the cumulative
probability distribution and the range [0,1].  It can be shown that by
taking a uniform random number in this range and finding its
corresponding coordinate in the cumulative probability distribution we
obtain samples with the desired probability distribution.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_histogram_pdf</B>
<DD><A NAME="IDX1777"></A>
<DL COMPACT>

<DT><CODE>size_t n</CODE>
<DD>
This is the number of bins used to approximate the probability
distribution function. 
<DT><CODE>double * range</CODE>
<DD>
The ranges of the bins are stored in an array of <VAR>n</VAR>+1 elements
pointed to by <VAR>range</VAR>.
<DT><CODE>double * sum</CODE>
<DD>
The cumulative probability for the bins is stored in an array of
<VAR>n</VAR> elements pointed to by <VAR>sum</VAR>.
</DL>
</DL>
<P>
The following functions allow you to create a <CODE>gsl_histogram_pdf</CODE>
struct which represents this probability distribution and generate
random samples from it.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_histogram_pdf * <B>gsl_histogram_pdf_alloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1778"></A>
This function allocates memory for a probability distribution with
<VAR>n</VAR> bins and returns a pointer to a newly initialized
<CODE>gsl_histogram_pdf</CODE> struct. If insufficient memory is available a
null pointer is returned and the error handler is invoked with an error
code of <CODE>GSL_ENOMEM</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram_pdf_init</B> <I>(gsl_histogram_pdf * <VAR>p</VAR>, const gsl_histogram * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1779"></A>
This function initializes the probability distribution <VAR>p</VAR> with
the contents of the histogram <VAR>h</VAR>. If any of the bins of <VAR>h</VAR> are
negative then the error handler is invoked with an error code of
<CODE>GSL_EDOM</CODE> because a probability distribution cannot contain
negative values.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_histogram_pdf_free</B> <I>(gsl_histogram_pdf * <VAR>p</VAR>)</I>
<DD><A NAME="IDX1780"></A>
This function frees the probability distribution function <VAR>p</VAR> and
all of the memory associated with it.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram_pdf_sample</B> <I>(const gsl_histogram_pdf * <VAR>p</VAR>, double <VAR>r</VAR>)</I>
<DD><A NAME="IDX1781"></A>
This function uses <VAR>r</VAR>, a uniform random number between zero and
one, to compute a single random sample from the probability distribution
<VAR>p</VAR>.  The algorithm used to compute the sample s is given by
the following formula,

<SPAN class="ifinfo">


<PRE class="example">
s = range[i] + delta * (range[i+1] - range[i])
</PRE>

</SPAN>

<P>
where i is the index which satisfies 
sum[i] &#60;=  r &#60; sum[i+1] and 
delta is 
(r - sum[i])/(sum[i+1] - sum[i]).
</DL>

</P>


<H2><A NAME="SEC355" HREF="gsl_manual.html#TOC355">Example programs for histograms</A></H2>

<P>
The following program shows how to make a simple histogram of a column
of numerical data supplied on <CODE>stdin</CODE>.  The program takes three
arguments, specifying the upper and lower bounds of the histogram and
the number of bins.  It then reads numbers from <CODE>stdin</CODE>, one line at
a time, and adds them to the histogram.  When there is no more data to
read it prints out the accumulated histogram using
<CODE>gsl_histogram_fprintf</CODE>.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;gsl/gsl_histogram.h&#62;

int
main (int argc, char **argv)
{
  double a, b;
  size_t n;

  if (argc != 4)
    {
      printf ("Usage: gsl-histogram xmin xmax n\n"
              "Computes a histogram of the data "
              "on stdin using n bins from xmin "
              "to xmax\n");
      exit (0);
    }

  a = atof (argv[1]);
  b = atof (argv[2]);
  n = atoi (argv[3]);

  {
    double x;
    gsl_histogram * h = gsl_histogram_alloc (n);
    gsl_histogram_set_ranges_uniform (h, a, b);

    while (fscanf (stdin, "%lg", &#38;x) == 1)
      {
        gsl_histogram_increment (h, x);
      }
    gsl_histogram_fprintf (stdout, h, "%g", "%g");
    gsl_histogram_free (h);
  }
  exit (0);
}
</PRE>

<P>
Here is an example of the program in use.  We generate 10000 random
samples from a Cauchy distribution with a width of 30 and histogram
them over the range -100 to 100, using 200 bins.

</P>

<PRE class="example">
$ gsl-randist 0 10000 cauchy 30 
   | gsl-histogram -100 100 200 &#62; histogram.dat
</PRE>

<P>
A plot of the resulting histogram shows the familiar shape of the
Cauchy distribution and the fluctuations caused by the finite sample
size.

</P>

<PRE class="example">
$ awk '{print $1, $3 ; print $2, $3}' histogram.dat 
   | graph -T X
</PRE>

<P>
<BR><IMG SRC="histogram"><BR>

</P>


<H2><A NAME="SEC356" HREF="gsl_manual.html#TOC356">Two dimensional histograms</A></H2>
<P>
<A NAME="IDX1782"></A>
<A NAME="IDX1783"></A>

</P>
<P>
A two dimensional histogram consists of a set of <I>bins</I> which count
the number of events falling in a given area of the (x,y)
plane.  The simplest way to use a two dimensional histogram is to record
two-dimensional position information, n(x,y).  Another possibility
is to form a <I>joint distribution</I> by recording related
variables.  For example a detector might record both the position of an
event (x) and the amount of energy it deposited E.  These
could be histogrammed as the joint distribution n(x,E).

</P>


<H2><A NAME="SEC357" HREF="gsl_manual.html#TOC357">The 2D histogram struct</A></H2>

<P>
Two dimensional histograms are defined by the following struct,

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_histogram2d</B>
<DD><A NAME="IDX1784"></A>
<DL COMPACT>

<DT><CODE>size_t nx, ny</CODE>
<DD>
This is the number of histogram bins in the x and y directions.
<DT><CODE>double * xrange</CODE>
<DD>
The ranges of the bins in the x-direction are stored in an array of
<VAR>nx</VAR> + 1 elements pointed to by <VAR>xrange</VAR>.
<DT><CODE>double * yrange</CODE>
<DD>
The ranges of the bins in the y-direction are stored in an array of
<VAR>ny</VAR> + 1 elements pointed to by <VAR>yrange</VAR>.
<DT><CODE>double * bin</CODE>
<DD>
The counts for each bin are stored in an array pointed to by <VAR>bin</VAR>.
The bins are floating-point numbers, so you can increment them by
non-integer values if necessary.  The array <VAR>bin</VAR> stores the two
dimensional array of bins in a single block of memory according to the
mapping <CODE>bin(i,j)</CODE> = <CODE>bin[i * ny + j]</CODE>.
</DL>
</DL>
<P>
The range for <CODE>bin(i,j)</CODE> is given by <CODE>xrange[i]</CODE> to
<CODE>xrange[i+1]</CODE> in the x-direction and <CODE>yrange[j]</CODE> to
<CODE>yrange[j+1]</CODE> in the y-direction.  Each bin is inclusive at the lower
end and exclusive at the upper end.  Mathematically this means that the
bins are defined by the following inequality,

<SPAN class="ifinfo">

<PRE class="display">
bin(i,j) corresponds to xrange[i] &#60;= x &#60; xrange[i+1]
                    and yrange[j] &#60;= y &#60; yrange[j+1]
</PRE>

</SPAN>

<P>
Note that any samples which fall on the upper sides of the histogram are
excluded.  If you want to include these values for the side bins you will
need to add an extra row or column to your histogram.

</P>
<P>
The <CODE>gsl_histogram2d</CODE> struct and its associated functions are
defined in the header file <TT>'gsl_histogram2d.h'</TT>.

</P>


<H2><A NAME="SEC358" HREF="gsl_manual.html#TOC358">2D Histogram allocation</A></H2>

<P>
The functions for allocating memory to a 2D histogram follow the style
of <CODE>malloc</CODE> and <CODE>free</CODE>.  In addition they also perform their
own error checking.  If there is insufficient memory available to
allocate a histogram then the functions call the error handler (with
an error number of <CODE>GSL_ENOMEM</CODE>) in addition to returning a null
pointer.  Thus if you use the library error handler to abort your program
then it isn't necessary to check every 2D histogram <CODE>alloc</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_histogram2d * <B>gsl_histogram2d_alloc</B> <I>(size_t <VAR>nx</VAR>, size_t <VAR>ny</VAR>)</I>
<DD><A NAME="IDX1785"></A>
This function allocates memory for a two-dimensional histogram with
<VAR>nx</VAR> bins in the x direction and <VAR>ny</VAR> bins in the y direction.
The function returns a pointer to a newly created <CODE>gsl_histogram2d</CODE>
struct. If insufficient memory is available a null pointer is returned
and the error handler is invoked with an error code of
<CODE>GSL_ENOMEM</CODE>. The bins and ranges must be initialized with one of
the functions below before the histogram is ready for use.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_set_ranges</B> <I>(gsl_histogram2d * <VAR>h</VAR>, const double <VAR>xrange</VAR>[], size_t <VAR>xsize</VAR>, const double <VAR>yrange</VAR>[], size_t <VAR>ysize</VAR>)</I>
<DD><A NAME="IDX1786"></A>
This function sets the ranges of the existing histogram <VAR>h</VAR> using
the arrays <VAR>xrange</VAR> and <VAR>yrange</VAR> of size <VAR>xsize</VAR> and
<VAR>ysize</VAR> respectively.  The values of the histogram bins are reset to
zero.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_set_ranges_uniform</B> <I>(gsl_histogram2d * <VAR>h</VAR>, double <VAR>xmin</VAR>, double <VAR>xmax</VAR>, double <VAR>ymin</VAR>, double <VAR>ymax</VAR>)</I>
<DD><A NAME="IDX1787"></A>
This function sets the ranges of the existing histogram <VAR>h</VAR> to cover
the ranges <VAR>xmin</VAR> to <VAR>xmax</VAR> and <VAR>ymin</VAR> to <VAR>ymax</VAR>
uniformly.  The values of the histogram bins are reset to zero.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_histogram2d_free</B> <I>(gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1788"></A>
This function frees the 2D histogram <VAR>h</VAR> and all of the memory
associated with it.
</DL>

</P>


<H2><A NAME="SEC359" HREF="gsl_manual.html#TOC359">Copying 2D Histograms</A></H2>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_memcpy</B> <I>(gsl_histogram2d * <VAR>dest</VAR>, const gsl_histogram2d * <VAR>src</VAR>)</I>
<DD><A NAME="IDX1789"></A>
This function copies the histogram <VAR>src</VAR> into the pre-existing
histogram <VAR>dest</VAR>, making <VAR>dest</VAR> into an exact copy of <VAR>src</VAR>.
The two histograms must be of the same size.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_histogram2d * <B>gsl_histogram2d_clone</B> <I>(const gsl_histogram2d * <VAR>src</VAR>)</I>
<DD><A NAME="IDX1790"></A>
This function returns a pointer to a newly created histogram which is an
exact copy of the histogram <VAR>src</VAR>.
</DL>

</P>


<H2><A NAME="SEC360" HREF="gsl_manual.html#TOC360">Updating and accessing 2D histogram elements</A></H2>

<P>
You can access the bins of a two-dimensional histogram either by
specifying a pair of (x,y) coordinates or by using the bin
indices (i,j) directly.  The functions for accessing the histogram
through (x,y) coordinates use binary searches in the x and y
directions to identify the bin which covers the appropriate range.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_increment</B> <I>(gsl_histogram2d * <VAR>h</VAR>, double <VAR>x</VAR>, double <VAR>y</VAR>)</I>
<DD><A NAME="IDX1791"></A>
This function updates the histogram <VAR>h</VAR> by adding one (1.0) to the
bin whose x and y ranges contain the coordinates (<VAR>x</VAR>,<VAR>y</VAR>).

</P>
<P>
If the point (x,y) lies inside the valid ranges of the
histogram then the function returns zero to indicate success.  If
(x,y) lies outside the limits of the histogram then the
function returns <CODE>GSL_EDOM</CODE>, and none of the bins are modified.  The
error handler is not called, since it is often necessary to compute
histograms for a small range of a larger dataset, ignoring any
coordinates outside the range of interest.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_accumulate</B> <I>(gsl_histogram2d * <VAR>h</VAR>, double <VAR>x</VAR>, double <VAR>y</VAR>, double <VAR>weight</VAR>)</I>
<DD><A NAME="IDX1792"></A>
This function is similar to <CODE>gsl_histogram2d_increment</CODE> but increases
the value of the appropriate bin in the histogram <VAR>h</VAR> by the
floating-point number <VAR>weight</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram2d_get</B> <I>(const gsl_histogram2d * <VAR>h</VAR>, size_t <VAR>i</VAR>, size_t <VAR>j</VAR>)</I>
<DD><A NAME="IDX1793"></A>
This function returns the contents of the (<VAR>i</VAR>,<VAR>j</VAR>)-th bin of the
histogram <VAR>h</VAR>.  If (<VAR>i</VAR>,<VAR>j</VAR>) lies outside the valid range of
indices for the histogram then the error handler is called with an error
code of <CODE>GSL_EDOM</CODE> and the function returns 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_get_xrange</B> <I>(const gsl_histogram2d * <VAR>h</VAR>, size_t <VAR>i</VAR>, double * <VAR>xlower</VAR>, double * <VAR>xupper</VAR>)</I>
<DD><A NAME="IDX1794"></A>
<DT><U>Function:</U> int <B>gsl_histogram2d_get_yrange</B> <I>(const gsl_histogram2d * <VAR>h</VAR>, size_t <VAR>j</VAR>, double * <VAR>ylower</VAR>, double * <VAR>yupper</VAR>)</I>
<DD><A NAME="IDX1795"></A>
These functions find the upper and lower range limits of the <VAR>i</VAR>-th
and <VAR>j</VAR>-th bins in the x and y directions of the histogram <VAR>h</VAR>.
The range limits are stored in <VAR>xlower</VAR> and <VAR>xupper</VAR> or
<VAR>ylower</VAR> and <VAR>yupper</VAR>.  The lower limits are inclusive
(i.e. events with these coordinates are included in the bin) and the
upper limits are exclusive (i.e. events with the value of the upper
limit are not included and fall in the neighboring higher bin, if it
exists).  The functions return 0 to indicate success.  If <VAR>i</VAR> or
<VAR>j</VAR> lies outside the valid range of indices for the histogram then
the error handler is called with an error code of <CODE>GSL_EDOM</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram2d_xmax</B> <I>(const gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1796"></A>
<DT><U>Function:</U> double <B>gsl_histogram2d_xmin</B> <I>(const gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1797"></A>
<DT><U>Function:</U> size_t <B>gsl_histogram2d_nx</B> <I>(const gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1798"></A>
<DT><U>Function:</U> double <B>gsl_histogram2d_ymax</B> <I>(const gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1799"></A>
<DT><U>Function:</U> double <B>gsl_histogram2d_ymin</B> <I>(const gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1800"></A>
<DT><U>Function:</U> size_t <B>gsl_histogram2d_ny</B> <I>(const gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1801"></A>
These functions return the maximum upper and minimum lower range limits
and the number of bins for the x and y directions of the histogram
<VAR>h</VAR>.  They provide a way of determining these values without
accessing the <CODE>gsl_histogram2d</CODE> struct directly.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_histogram2d_reset</B> <I>(gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1802"></A>
This function resets all the bins of the histogram <VAR>h</VAR> to zero.
</DL>

</P>


<H2><A NAME="SEC361" HREF="gsl_manual.html#TOC361">Searching 2D histogram ranges</A></H2>

<P>
The following functions are used by the access and update routines to
locate the bin which corresponds to a given (x,y) coordinate.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_find</B> <I>(const gsl_histogram2d * <VAR>h</VAR>, double <VAR>x</VAR>, double <VAR>y</VAR>, size_t * <VAR>i</VAR>, size_t * <VAR>j</VAR>)</I>
<DD><A NAME="IDX1803"></A>
This function finds and sets the indices <VAR>i</VAR> and <VAR>j</VAR> to the to
the bin which covers the coordinates (<VAR>x</VAR>,<VAR>y</VAR>). The bin is
located using a binary search.  The search includes an optimization for
histograms with uniform ranges, and will return the correct bin immediately
in this case. If (x,y) is found then the function sets the
indices (<VAR>i</VAR>,<VAR>j</VAR>) and returns <CODE>GSL_SUCCESS</CODE>.  If
(x,y) lies outside the valid range of the histogram then the
function returns <CODE>GSL_EDOM</CODE> and the error handler is invoked.
</DL>

</P>


<H2><A NAME="SEC362" HREF="gsl_manual.html#TOC362">2D Histogram Statistics</A></H2>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram2d_max_val</B> <I>(const gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1804"></A>
This function returns the maximum value contained in the histogram bins.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_histogram2d_max_bin</B> <I>(const gsl_histogram2d * <VAR>h</VAR>, size_t * <VAR>i</VAR>, size_t * <VAR>j</VAR>)</I>
<DD><A NAME="IDX1805"></A>
This function finds the indices of the bin containing the maximum value
in the histogram <VAR>h</VAR> and stores the result in (<VAR>i</VAR>,<VAR>j</VAR>). In
the case where several bins contain the same maximum value the first bin
found is returned.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram2d_min_val</B> <I>(const gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1806"></A>
This function returns the minimum value contained in the histogram bins.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_histogram2d_min_bin</B> <I>(const gsl_histogram2d * <VAR>h</VAR>, size_t * <VAR>i</VAR>, size_t * <VAR>j</VAR>)</I>
<DD><A NAME="IDX1807"></A>
This function finds the indices of the bin containing the minimum value
in the histogram <VAR>h</VAR> and stores the result in (<VAR>i</VAR>,<VAR>j</VAR>). In
the case where several bins contain the same maximum value the first bin
found is returned.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram2d_xmean</B> <I>(const gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1808"></A>
This function returns the mean of the histogrammed x variable, where the
histogram is regarded as a probability distribution. Negative bin values
are ignored for the purposes of this calculation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram2d_ymean</B> <I>(const gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1809"></A>
This function returns the mean of the histogrammed y variable, where the
histogram is regarded as a probability distribution. Negative bin values
are ignored for the purposes of this calculation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram2d_xsigma</B> <I>(const gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1810"></A>
This function returns the standard deviation of the histogrammed
x variable, where the histogram is regarded as a probability
distribution. Negative bin values are ignored for the purposes of this
calculation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram2d_ysigma</B> <I>(const gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1811"></A>
This function returns the standard deviation of the histogrammed
y variable, where the histogram is regarded as a probability
distribution. Negative bin values are ignored for the purposes of this
calculation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram2d_cov</B> <I>(const gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1812"></A>
This function returns the covariance of the histogrammed x and y
variables, where the histogram is regarded as a probability
distribution. Negative bin values are ignored for the purposes of this
calculation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_histogram2d_sum</B> <I>(const gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1813"></A>
This function returns the sum of all bin values. Negative bin values
are included in the sum.
</DL>

</P>


<H2><A NAME="SEC363" HREF="gsl_manual.html#TOC363">2D Histogram Operations</A></H2>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_equal_bins_p</B> <I>(const gsl_histogram2d * <VAR>h1</VAR>, const gsl_histogram2d * <VAR>h2</VAR>)</I>
<DD><A NAME="IDX1814"></A>
This function returns 1 if all the individual bin ranges of the two
histograms are identical, and 0 otherwise.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_add</B> <I>(gsl_histogram2d * <VAR>h1</VAR>, const gsl_histogram2d * <VAR>h2</VAR>)</I>
<DD><A NAME="IDX1815"></A>
This function adds the contents of the bins in histogram <VAR>h2</VAR> to the
corresponding bins of histogram <VAR>h1</VAR>,
i.e. h'_1(i,j) = h_1(i,j) + h_2(i,j).
The two histograms must have identical bin ranges.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_sub</B> <I>(gsl_histogram2d * <VAR>h1</VAR>, const gsl_histogram2d * <VAR>h2</VAR>)</I>
<DD><A NAME="IDX1816"></A>
This function subtracts the contents of the bins in histogram <VAR>h2</VAR> from the
corresponding bins of histogram <VAR>h1</VAR>,
i.e. h'_1(i,j) = h_1(i,j) - h_2(i,j).
The two histograms must have identical bin ranges.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_mul</B> <I>(gsl_histogram2d * <VAR>h1</VAR>, const gsl_histogram2d * <VAR>h2</VAR>)</I>
<DD><A NAME="IDX1817"></A>
This function multiplies the contents of the bins of histogram <VAR>h1</VAR>
by the contents of the corresponding bins in histogram <VAR>h2</VAR>,
i.e. h'_1(i,j) = h_1(i,j) * h_2(i,j).
The two histograms must have identical bin ranges.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_div</B> <I>(gsl_histogram2d * <VAR>h1</VAR>, const gsl_histogram2d * <VAR>h2</VAR>)</I>
<DD><A NAME="IDX1818"></A>
This function divides the contents of the bins of histogram <VAR>h1</VAR>
by the contents of the corresponding bins in histogram <VAR>h2</VAR>,
i.e. h'_1(i,j) = h_1(i,j) / h_2(i,j).
The two histograms must have identical bin ranges.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_scale</B> <I>(gsl_histogram2d * <VAR>h</VAR>, double <VAR>scale</VAR>)</I>
<DD><A NAME="IDX1819"></A>
This function multiplies the contents of the bins of histogram <VAR>h</VAR>
by the constant <VAR>scale</VAR>, i.e. 
h'_1(i,j) = h_1(i,j) scale.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_shift</B> <I>(gsl_histogram2d * <VAR>h</VAR>, double <VAR>offset</VAR>)</I>
<DD><A NAME="IDX1820"></A>
This function shifts the contents of the bins of histogram <VAR>h</VAR>
by the constant <VAR>offset</VAR>, i.e. 
h'_1(i,j) = h_1(i,j) + offset.
</DL>

</P>


<H2><A NAME="SEC364" HREF="gsl_manual.html#TOC364">Reading and writing 2D histograms</A></H2>

<P>
The library provides functions for reading and writing two dimensional
histograms to a file as binary data or formatted text.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_fwrite</B> <I>(FILE * <VAR>stream</VAR>, const gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1821"></A>
This function writes the ranges and bins of the histogram <VAR>h</VAR> to the
stream <VAR>stream</VAR> in binary format.  The return value is 0 for success
and <CODE>GSL_EFAILED</CODE> if there was a problem writing to the file.  Since
the data is written in the native binary format it may not be portable
between different architectures.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_fread</B> <I>(FILE * <VAR>stream</VAR>, gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1822"></A>
This function reads into the histogram <VAR>h</VAR> from the stream
<VAR>stream</VAR> in binary format.  The histogram <VAR>h</VAR> must be
preallocated with the correct size since the function uses the number of
x and y bins in <VAR>h</VAR> to determine how many bytes to read.  The return
value is 0 for success and <CODE>GSL_EFAILED</CODE> if there was a problem
reading from the file.  The data is assumed to have been written in the
native binary format on the same architecture.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_fprintf</B> <I>(FILE * <VAR>stream</VAR>, const gsl_histogram2d * <VAR>h</VAR>, const char * <VAR>range_format</VAR>, const char * <VAR>bin_format</VAR>)</I>
<DD><A NAME="IDX1823"></A>
This function writes the ranges and bins of the histogram <VAR>h</VAR>
line-by-line to the stream <VAR>stream</VAR> using the format specifiers
<VAR>range_format</VAR> and <VAR>bin_format</VAR>.  These should be one of the
<CODE>%g</CODE>, <CODE>%e</CODE> or <CODE>%f</CODE> formats for floating point
numbers.  The function returns 0 for success and <CODE>GSL_EFAILED</CODE> if
there was a problem writing to the file.  The histogram output is
formatted in five columns, and the columns are separated by spaces,
like this,

</P>

<PRE class="smallexample">
xrange[0] xrange[1] yrange[0] yrange[1] bin(0,0)
xrange[0] xrange[1] yrange[1] yrange[2] bin(0,1)
xrange[0] xrange[1] yrange[2] yrange[3] bin(0,2)
....
xrange[0] xrange[1] yrange[ny-1] yrange[ny] bin(0,ny-1)

xrange[1] xrange[2] yrange[0] yrange[1] bin(1,0)
xrange[1] xrange[2] yrange[1] yrange[2] bin(1,1)
xrange[1] xrange[2] yrange[1] yrange[2] bin(1,2)
....
xrange[1] xrange[2] yrange[ny-1] yrange[ny] bin(1,ny-1)

....

xrange[nx-1] xrange[nx] yrange[0] yrange[1] bin(nx-1,0)
xrange[nx-1] xrange[nx] yrange[1] yrange[2] bin(nx-1,1)
xrange[nx-1] xrange[nx] yrange[1] yrange[2] bin(nx-1,2)
....
xrange[nx-1] xrange[nx] yrange[ny-1] yrange[ny] bin(nx-1,ny-1)
</PRE>

<P>
Each line contains the lower and upper limits of the bin and the
contents of the bin.  Since the upper limits of the each bin are the
lower limits of the neighboring bins there is duplication of these
values but this allows the histogram to be manipulated with
line-oriented tools.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_fscanf</B> <I>(FILE * <VAR>stream</VAR>, gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1824"></A>
This function reads formatted data from the stream <VAR>stream</VAR> into the
histogram <VAR>h</VAR>.  The data is assumed to be in the five-column format
used by <CODE>gsl_histogram_fprintf</CODE>.  The histogram <VAR>h</VAR> must be
preallocated with the correct lengths since the function uses the sizes
of <VAR>h</VAR> to determine how many numbers to read.  The function returns 0
for success and <CODE>GSL_EFAILED</CODE> if there was a problem reading from
the file.
</DL>

</P>


<H2><A NAME="SEC365" HREF="gsl_manual.html#TOC365">Resampling from 2D histograms</A></H2>

<P>
As in the one-dimensional case, a two-dimensional histogram made by
counting events can be regarded as a measurement of a probability
distribution.  Allowing for statistical error, the height of each bin
represents the probability of an event where (x,y) falls in
the range of that bin.  For a two-dimensional histogram the probability
distribution takes the form p(x,y) dx dy where,

<SPAN class="ifinfo">


<PRE class="example">
p(x,y) = n_{ij}/ (N A_{ij})
</PRE>

</SPAN>

<P>
In this equation 
n_{ij} is the number of events in the bin which
contains (x,y), 
A_{ij} is the area of the bin and N is
the total number of events.  The distribution of events within each bin
is assumed to be uniform.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_histogram2d_pdf</B>
<DD><A NAME="IDX1825"></A>
<DL COMPACT>

<DT><CODE>size_t nx, ny</CODE>
<DD>
This is the number of histogram bins used to approximate the probability
distribution function in the x and y directions.
<DT><CODE>double * xrange</CODE>
<DD>
The ranges of the bins in the x-direction are stored in an array of
<VAR>nx</VAR> + 1 elements pointed to by <VAR>xrange</VAR>.
<DT><CODE>double * yrange</CODE>
<DD>
The ranges of the bins in the y-direction are stored in an array of
<VAR>ny</VAR> + 1 pointed to by <VAR>yrange</VAR>.
<DT><CODE>double * sum</CODE>
<DD>
The cumulative probability for the bins is stored in an array of
<VAR>nx</VAR>*<VAR>ny</VAR> elements pointed to by <VAR>sum</VAR>.
</DL>
</DL>
<P>
The following functions allow you to create a <CODE>gsl_histogram2d_pdf</CODE>
struct which represents a two dimensional probability distribution and
generate random samples from it.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_histogram2d_pdf * <B>gsl_histogram2d_pdf_alloc</B> <I>(size_t <VAR>nx</VAR>, size_t <VAR>ny</VAR>)</I>
<DD><A NAME="IDX1826"></A>
This function allocates memory for a two-dimensional probability
distribution of size <VAR>nx</VAR>-by-<VAR>ny</VAR> and returns a pointer to a
newly initialized <CODE>gsl_histogram2d_pdf</CODE> struct. If insufficient
memory is available a null pointer is returned and the error handler is
invoked with an error code of <CODE>GSL_ENOMEM</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_pdf_init</B> <I>(gsl_histogram2d_pdf * <VAR>p</VAR>, const gsl_histogram2d * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1827"></A>
This function initializes the two-dimensional probability distribution
calculated <VAR>p</VAR> from the histogram <VAR>h</VAR>.  If any of the bins of
<VAR>h</VAR> are negative then the error handler is invoked with an error
code of <CODE>GSL_EDOM</CODE> because a probability distribution cannot
contain negative values.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_histogram2d_pdf_free</B> <I>(gsl_histogram2d_pdf * <VAR>p</VAR>)</I>
<DD><A NAME="IDX1828"></A>
This function frees the two-dimensional probability distribution
function <VAR>p</VAR> and all of the memory associated with it.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_histogram2d_pdf_sample</B> <I>(const gsl_histogram2d_pdf * <VAR>p</VAR>, double <VAR>r1</VAR>, double <VAR>r2</VAR>, double * <VAR>x</VAR>, double * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1829"></A>
This function uses two uniform random numbers between zero and one,
<VAR>r1</VAR> and <VAR>r2</VAR>, to compute a single random sample from the
two-dimensional probability distribution <VAR>p</VAR>.
</DL>

</P>


<H2><A NAME="SEC366" HREF="gsl_manual.html#TOC366">Example programs for 2D histograms</A></H2>
<P>
This program demonstrates two features of two-dimensional histograms.
First a 10-by-10 two-dimensional histogram is created with x and y running
from 0 to 1.  Then a few sample points are added to the histogram, at
(0.3,0.3) with a height of 1, at (0.8,0.1) with a height of 5 and at
(0.7,0.9) with a height of 0.5.  This histogram with three events is
used to generate a random sample of 1000 simulated events, which are
printed out.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_rng.h&#62;
#include &#60;gsl/gsl_histogram2d.h&#62;

int
main (void)
{
  const gsl_rng_type * T;
  gsl_rng * r;

  gsl_histogram2d * h = gsl_histogram2d_alloc (10, 10);

  gsl_histogram2d_set_ranges_uniform (h, 
                                      0.0, 1.0,
                                      0.0, 1.0);

  gsl_histogram2d_accumulate (h, 0.3, 0.3, 1);
  gsl_histogram2d_accumulate (h, 0.8, 0.1, 5);
  gsl_histogram2d_accumulate (h, 0.7, 0.9, 0.5);

  gsl_rng_env_setup ();
  
  T = gsl_rng_default;
  r = gsl_rng_alloc (T);

  {
    int i;
    gsl_histogram2d_pdf * p 
      = gsl_histogram2d_pdf_alloc (h-&#62;nx, h-&#62;ny);
    
    gsl_histogram2d_pdf_init (p, h);

    for (i = 0; i &#60; 1000; i++) {
      double x, y;
      double u = gsl_rng_uniform (r);
      double v = gsl_rng_uniform (r);
       
      gsl_histogram2d_pdf_sample (p, u, v, &#38;x, &#38;y);
      
      printf ("%g %g\n", x, y);
    }
  }
  
 return 0;
}
</PRE>

<P>
The following plot shows the distribution of the simulated events.  Using
a higher resolution grid we can see the original underlying histogram
and also the statistical fluctuations caused by the events being
uniformly distributed over the area of the original bins.

</P>
<P>
<BR><IMG SRC="histogram2d"><BR>

</P>



<H1><A NAME="SEC367" HREF="gsl_manual.html#TOC367">N-tuples</A></H1>
<P>
<A NAME="IDX1830"></A>

</P>
<P>
This chapter describes functions for creating and manipulating
<I>ntuples</I>, sets of values associated with events.  The ntuples
are stored in files. Their values can be extracted in any combination
and <I>booked</I> in a histogram using a selection function.

</P>
<P>
The values to be stored are held in a user-defined data structure, and
an ntuple is created associating this data structure with a file.  The
values are then written to the file (normally inside a loop) using
the ntuple functions described below.

</P>
<P>
A histogram can be created from ntuple data by providing a selection
function and a value function.  The selection function specifies whether
an event should be included in the subset to be analyzed or not. The value
function computes the entry to be added to the histogram for each
event.

</P>
<P>
All the ntuple functions are defined in the header file
<TT>'gsl_ntuple.h'</TT>

</P>



<H2><A NAME="SEC368" HREF="gsl_manual.html#TOC368">The ntuple struct</A></H2>

<P>
Ntuples are manipulated using the <CODE>gsl_ntuple</CODE> struct. This struct
contains information on the file where the ntuple data is stored, a
pointer to the current ntuple data row and the size of the user-defined
ntuple data struct.

</P>

<PRE class="example">
typedef struct {
    FILE * file;
    void * ntuple_data;
    size_t size;
} gsl_ntuple;
</PRE>



<H2><A NAME="SEC369" HREF="gsl_manual.html#TOC369">Creating ntuples</A></H2>

<P>
<DL>
<DT><U>Function:</U> gsl_ntuple * <B>gsl_ntuple_create</B> <I>(char * <VAR>filename</VAR>, void * <VAR>ntuple_data</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX1831"></A>
This function creates a new write-only ntuple file <VAR>filename</VAR> for
ntuples of size <VAR>size</VAR> and returns a pointer to the newly created
ntuple struct.  Any existing file with the same name is truncated to
zero length and overwritten.  A pointer to memory for the current ntuple
row <VAR>ntuple_data</VAR> must be supplied--this is used to copy ntuples
in and out of the file.
</DL>

</P>


<H2><A NAME="SEC370" HREF="gsl_manual.html#TOC370">Opening an existing ntuple file</A></H2>

<P>
<DL>
<DT><U>Function:</U> gsl_ntuple * <B>gsl_ntuple_open</B> <I>(char * <VAR>filename</VAR>, void * <VAR>ntuple_data</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX1832"></A>
This function opens an existing ntuple file <VAR>filename</VAR> for reading
and returns a pointer to a corresponding ntuple struct. The ntuples in
the file must have size <VAR>size</VAR>.  A pointer to memory for the current
ntuple row <VAR>ntuple_data</VAR> must be supplied--this is used to copy
ntuples in and out of the file.
</DL>

</P>


<H2><A NAME="SEC371" HREF="gsl_manual.html#TOC371">Writing ntuples</A></H2>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_ntuple_write</B> <I>(gsl_ntuple * <VAR>ntuple</VAR>)</I>
<DD><A NAME="IDX1833"></A>
This function writes the current ntuple <VAR>ntuple-&#62;ntuple_data</VAR> of
size <VAR>ntuple-&#62;size</VAR> to the corresponding file.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_ntuple_bookdata</B> <I>(gsl_ntuple * <VAR>ntuple</VAR>)</I>
<DD><A NAME="IDX1834"></A>
This function is a synonym for <CODE>gsl_ntuple_write</CODE>.
</DL>

</P>


<H2><A NAME="SEC372" HREF="gsl_manual.html#TOC372">Reading ntuples</A></H2>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_ntuple_read</B> <I>(gsl_ntuple * <VAR>ntuple</VAR>)</I>
<DD><A NAME="IDX1835"></A>
This function reads the current row of the ntuple file for <VAR>ntuple</VAR>
and stores the values in <VAR>ntuple-&#62;data</VAR>.
</DL>

</P>


<H2><A NAME="SEC373" HREF="gsl_manual.html#TOC373">Closing an ntuple file</A></H2>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_ntuple_close</B> <I>(gsl_ntuple * <VAR>ntuple</VAR>)</I>
<DD><A NAME="IDX1836"></A>
This function closes the ntuple file <VAR>ntuple</VAR> and frees its
associated allocated memory.
</DL>

</P>


<H2><A NAME="SEC374" HREF="gsl_manual.html#TOC374">Histogramming ntuple values</A></H2>

<P>
Once an ntuple has been created its contents can be histogrammed in
various ways using the function <CODE>gsl_ntuple_project</CODE>.  Two
user-defined functions must be provided, a function to select events and
a function to compute scalar values. The selection function and the
value function both accept the ntuple row as a first argument and other
parameters as a second argument.

</P>
<P>
<A NAME="IDX1837"></A>
The <I>selection function</I> determines which ntuple rows are selected
for histogramming.  It is defined by the following struct,

<PRE class="smallexample">
typedef struct {
  int (* function) (void * ntuple_data, void * params);
  void * params;
} gsl_ntuple_select_fn;
</PRE>

<P>
The struct component <VAR>function</VAR> should return a non-zero value for
each ntuple row that is to be included in the histogram.

</P>
<P>
<A NAME="IDX1838"></A>
The <I>value function</I> computes scalar values for those ntuple rows
selected by the selection function,

<PRE class="smallexample">
typedef struct {
  double (* function) (void * ntuple_data, void * params);
  void * params;
} gsl_ntuple_value_fn;
</PRE>

<P>
In this case the struct component <VAR>function</VAR> should return the value
to be added to the histogram for the ntuple row.  

</P>
<P>
<A NAME="IDX1839"></A>
<A NAME="IDX1840"></A>
<DL>
<DT><U>Function:</U> int <B>gsl_ntuple_project</B> <I>(gsl_histogram * <VAR>h</VAR>, gsl_ntuple * <VAR>ntuple</VAR>, gsl_ntuple_value_fn * <VAR>value_func</VAR>, gsl_ntuple_select_fn * <VAR>select_func</VAR>)</I>
<DD><A NAME="IDX1841"></A>
This function updates the histogram <VAR>h</VAR> from the ntuple <VAR>ntuple</VAR>
using the functions <VAR>value_func</VAR> and <VAR>select_func</VAR>. For each
ntuple row where the selection function <VAR>select_func</VAR> is non-zero the
corresponding value of that row is computed using the function
<VAR>value_func</VAR> and added to the histogram.  Those ntuple rows where
<VAR>select_func</VAR> returns zero are ignored.  New entries are added to
the histogram, so subsequent calls can be used to accumulate further
data in the same histogram.
</DL>

</P>


<H2><A NAME="SEC375" HREF="gsl_manual.html#TOC375">Examples</A></H2>

<P>
The following example programs demonstrate the use of ntuples in
managing a large dataset.  The first program creates a set of 10,000
simulated "events", each with 3 associated values (x,y,z).  These
are generated from a gaussian distribution with unit variance, for
demonstration purposes, and written to the ntuple file <TT>'test.dat'</TT>.

</P>

<PRE class="example">
#include &#60;gsl/gsl_ntuple.h&#62;
#include &#60;gsl/gsl_rng.h&#62;
#include &#60;gsl/gsl_randist.h&#62;

struct data
{
  double x;
  double y;
  double z;
};

int
main (void)
{
  const gsl_rng_type * T;
  gsl_rng * r;

  struct data ntuple_row;
  int i;

  gsl_ntuple *ntuple 
    = gsl_ntuple_create ("test.dat", &#38;ntuple_row, 
                         sizeof (ntuple_row));

  gsl_rng_env_setup ();

  T = gsl_rng_default; 
  r = gsl_rng_alloc (T);

  for (i = 0; i &#60; 10000; i++)
    {
      ntuple_row.x = gsl_ran_ugaussian (r);
      ntuple_row.y = gsl_ran_ugaussian (r);
      ntuple_row.z = gsl_ran_ugaussian (r);
      
      gsl_ntuple_write (ntuple);
    }
  
  gsl_ntuple_close (ntuple);
  return 0;
}
</PRE>

<P>
The next program analyses the ntuple data in the file <TT>'test.dat'</TT>.
The analysis procedure is to compute the squared-magnitude of each
event, E^2=x^2+y^2+z^2, and select only those which exceed a
lower limit of 1.5.  The selected events are then histogrammed using
their E^2 values.

</P>

<PRE class="example">
#include &#60;math.h&#62;
#include &#60;gsl/gsl_ntuple.h&#62;
#include &#60;gsl/gsl_histogram.h&#62;

struct data
{
  double x;
  double y;
  double z;
};

int sel_func (void *ntuple_data, void *params);
double val_func (void *ntuple_data, void *params);

int
main (void)
{
  struct data ntuple_row;

  gsl_ntuple *ntuple 
    = gsl_ntuple_open ("test.dat", &#38;ntuple_row,
                       sizeof (ntuple_row));
  double lower = 1.5;

  gsl_ntuple_select_fn S;
  gsl_ntuple_value_fn V;

  gsl_histogram *h = gsl_histogram_alloc (100);
  gsl_histogram_set_ranges_uniform(h, 0.0, 10.0);

  S.function = &#38;sel_func;
  S.params = &#38;lower;

  V.function = &#38;val_func;
  V.params = 0;

  gsl_ntuple_project (h, ntuple, &#38;V, &#38;S);
  gsl_histogram_fprintf (stdout, h, "%f", "%f");
  gsl_histogram_free (h);
  gsl_ntuple_close (ntuple);

  return 0;
}

int
sel_func (void *ntuple_data, void *params)
{
  struct data * data = (struct data *) ntuple_data;  
  double x, y, z, E2, scale;
  scale = *(double *) params;
  
  x = data-&#62;x;
  y = data-&#62;y;
  z = data-&#62;z;

  E2 = x * x + y * y + z * z;

  return E2 &#62; scale;
}

double
val_func (void *ntuple_data, void *params)
{
  struct data * data = (struct data *) ntuple_data;  
  double x, y, z;

  x = data-&#62;x;
  y = data-&#62;y;
  z = data-&#62;z;

  return x * x + y * y + z * z;
}
</PRE>

<P>
The following plot shows the distribution of the selected events.
Note the cut-off at the lower bound.

</P>
<P>
<BR><IMG SRC="ntuple"><BR>

</P>


<H2><A NAME="SEC376" HREF="gsl_manual.html#TOC376">References and Further Reading</A></H2>
<P>
<A NAME="IDX1842"></A>
<A NAME="IDX1843"></A>

</P>
<P>
Further information on the use of ntuples can be found in the
documentation for the CERN packages PAW and HBOOK
(available online).

</P>



<H1><A NAME="SEC377" HREF="gsl_manual.html#TOC377">Monte Carlo Integration</A></H1>
<P>
<A NAME="IDX1844"></A>
<A NAME="IDX1845"></A>
This chapter describes routines for multidimensional Monte Carlo
integration.  These include the traditional Monte Carlo method and
adaptive algorithms such as VEGAS and MISER which use
importance sampling and stratified sampling techniques. Each algorithm
computes an estimate of a multidimensional definite integral of the
form,

<SPAN class="ifinfo">


<PRE class="example">
I = \int_xl^xu dx \int_yl^yu  dy ...  f(x, y, ...)
</PRE>

</SPAN>

<P>
over a hypercubic region ((x_l,x_u), (y_l,y_u), ...) using
a fixed number of function calls.  The routines also provide a
statistical estimate of the error on the result.  This error estimate
should be taken as a guide rather than as a strict error bound--random 
sampling of the region may not uncover all the important features
of the function, resulting in an underestimate of the error.

</P>
<P>
The functions are defined in separate header files for each routine,
<CODE>gsl_monte_plain.h</CODE>, <TT>'gsl_monte_miser.h'</TT> and
<TT>'gsl_monte_vegas.h'</TT>.

</P>



<H2><A NAME="SEC378" HREF="gsl_manual.html#TOC378">Interface</A></H2>
<P>
All of the Monte Carlo integration routines use the same general form of
interface.  There is an allocator to allocate memory for control
variables and workspace, a routine to initialize those control
variables, the integrator itself, and a function to free the space when
done.

</P>
<P>
Each integration function requires a random number generator to be
supplied, and returns an estimate of the integral and its standard
deviation.  The accuracy of the result is determined by the number of
function calls specified by the user.  If a known level of accuracy is
required this can be achieved by calling the integrator several times
and averaging the individual results until the desired accuracy is
obtained.  

</P>
<P>
Random sample points used within the Monte Carlo routines are always
chosen strictly within the integration region, so that endpoint
singularities are automatically avoided.

</P>
<P>
The function to be integrated has its own datatype, defined in the
header file <TT>'gsl_monte.h'</TT>.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_monte_function</B>
<DD><A NAME="IDX1846"></A>

</P>
<P>
This data type defines a general function with parameters for Monte
Carlo integration.

</P>
<DL COMPACT>

<DT><CODE>double (* f) (double * <VAR>x</VAR>, size_t <VAR>dim</VAR>, void * <VAR>params</VAR>)</CODE>
<DD>
this function should return the value
f(x,params) for the argument <VAR>x</VAR> and parameters <VAR>params</VAR>,
where <VAR>x</VAR> is an array of size <VAR>dim</VAR> giving the coordinates of
the point where the function is to be evaluated.

<DT><CODE>size_t dim</CODE>
<DD>
the number of dimensions for <VAR>x</VAR>.

<DT><CODE>void * params</CODE>
<DD>
a pointer to the parameters of the function.
</DL>
</DL>
<P>
Here is an example for a quadratic function in two dimensions,

<SPAN class="ifinfo">


<PRE class="example">
f(x,y) = a x^2 + b x y + c y^2
</PRE>

</SPAN>

<P>
with a = 3, b = 2, c = 1.  The following code
defines a <CODE>gsl_monte_function</CODE> <CODE>F</CODE> which you could pass to an
integrator:

</P>

<PRE class="example">
struct my_f_params { double a; double b; double c; };

double
my_f (double x[], size_t dim, void * p) {
   struct my_f_params * fp = (struct my_f_params *)p;

   if (dim != 2)
      {
        fprintf (stderr, "error: dim != 2");
        abort ();
      }

   return  fp-&#62;a * x[0] * x[0] 
             + fp-&#62;b * x[0] * x[1] 
               + fp-&#62;c * x[1] * x[1];
}

gsl_monte_function F;
struct my_f_params params = { 3.0, 2.0, 1.0 };

F.f = &#38;my_f;
F.dim = 2;
F.params = &#38;params;
</PRE>

<P>
The function f(x) can be evaluated using the following macro,

</P>

<PRE class="example">
#define GSL_MONTE_FN_EVAL(F,x) 
    (*((F)-&#62;f))(x,(F)-&#62;dim,(F)-&#62;params)
</PRE>



<H2><A NAME="SEC379" HREF="gsl_manual.html#TOC379">PLAIN Monte Carlo</A></H2>
<P>
<A NAME="IDX1847"></A>
The plain Monte Carlo algorithm samples points randomly from the
integration region to estimate the integral and its error.  Using this
algorithm the estimate of the integral E(f; N) for N
randomly distributed points x_i is given by,

<SPAN class="ifinfo">


<PRE class="example">
E(f; N) = =  V &#60;f&#62; = (V / N) \sum_i^N f(x_i)
</PRE>

</SPAN>

<P>
where V is the volume of the integration region.  The error on
this estimate \sigma(E;N) is calculated from the estimated
variance of the mean,

<SPAN class="ifinfo">


<PRE class="example">
\sigma^2 (E; N) = (V / N) \sum_i^N (f(x_i) -  &#60;f&#62;)^2.
</PRE>

</SPAN>

<P>
For large N this variance decreases asymptotically as
\Var(f)/N, where \Var(f) is the true variance of the
function over the integration region.  The error estimate itself should
decrease as 
\sigma(f)/\sqrt{N}.  The familiar law of errors
decreasing as 
1/\sqrt{N} applies--to reduce the error by a
factor of 10 requires a 100-fold increase in the number of sample
points.

</P>
<P>
The functions described in this section are declared in the header file
<TT>'gsl_monte_plain.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_monte_plain_state * <B>gsl_monte_plain_alloc</B> <I>(size_t <VAR>dim</VAR>)</I>
<DD><A NAME="IDX1848"></A>
This function allocates and initializes a workspace for Monte Carlo
integration in <VAR>dim</VAR> dimensions.  
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_monte_plain_init</B> <I>(gsl_monte_plain_state* <VAR>s</VAR>)</I>
<DD><A NAME="IDX1849"></A>
This function initializes a previously allocated integration state.
This allows an existing workspace to be reused for different
integrations.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_monte_plain_integrate</B> <I>(gsl_monte_function * <VAR>f</VAR>, double * <VAR>xl</VAR>, double * <VAR>xu</VAR>, size_t <VAR>dim</VAR>, size_t <VAR>calls</VAR>, gsl_rng * <VAR>r</VAR>, gsl_monte_plain_state * <VAR>s</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX1850"></A>
This routines uses the plain Monte Carlo algorithm to integrate the
function <VAR>f</VAR> over the <VAR>dim</VAR>-dimensional hypercubic region
defined by the lower and upper limits in the arrays <VAR>xl</VAR> and
<VAR>xu</VAR>, each of size <VAR>dim</VAR>.  The integration uses a fixed number
of function calls <VAR>calls</VAR>, and obtains random sampling points using
the random number generator <VAR>r</VAR>. A previously allocated workspace
<VAR>s</VAR> must be supplied.  The result of the integration is returned in
<VAR>result</VAR>, with an estimated absolute error <VAR>abserr</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_monte_plain_free</B> <I>(gsl_monte_plain_state * <VAR>s</VAR>)</I>
<DD><A NAME="IDX1851"></A>
This function frees the memory associated with the integrator state
<VAR>s</VAR>.
</DL>

</P>


<H2><A NAME="SEC380" HREF="gsl_manual.html#TOC380">MISER</A></H2>
<P>
<A NAME="IDX1852"></A>
<A NAME="IDX1853"></A>

</P>
<P>
The MISER algorithm of Press and Farrar is based on recursive
stratified sampling.  This technique aims to reduce the overall
integration error by concentrating integration points in the regions of
highest variance.

</P>
<P>
The idea of stratified sampling begins with the observation that for two
disjoint regions a and b with Monte Carlo estimates of the
integral E_a(f) and E_b(f) and variances
\sigma_a^2(f) and \sigma_b^2(f), the variance
\Var(f) of the combined estimate 
E(f) = (1/2) (E_a(f) + E_b(f)) 
is given by,

<SPAN class="ifinfo">


<PRE class="example">
\Var(f) = (\sigma_a^2(f) / 4 N_a) + (\sigma_b^2(f) / 4 N_b).
</PRE>

</SPAN>

<P>
It can be shown that this variance is minimized by distributing the
points such that,

<SPAN class="ifinfo">


<PRE class="example">
N_a / (N_a + N_b) = \sigma_a / (\sigma_a + \sigma_b).
</PRE>

</SPAN>

<P>
Hence the smallest error estimate is obtained by allocating sample
points in proportion to the standard deviation of the function in each
sub-region.

</P>
<P>
The MISER algorithm proceeds by bisecting the integration region
along one coordinate axis to give two sub-regions at each step.  The
direction is chosen by examining all d possible bisections and
selecting the one which will minimize the combined variance of the two
sub-regions.  The variance in the sub-regions is estimated by sampling
with a fraction of the total number of points available to the current
step.  The same procedure is then repeated recursively for each of the
two half-spaces from the best bisection. The remaining sample points are
allocated to the sub-regions using the formula for N_a and
N_b.  This recursive allocation of integration points continues
down to a user-specified depth where each sub-region is integrated using
a plain Monte Carlo estimate.  These individual values and their error
estimates are then combined upwards to give an overall result and an
estimate of its error.

</P>
<P>
The functions described in this section are declared in the header file
<TT>'gsl_monte_miser.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_monte_miser_state * <B>gsl_monte_miser_alloc</B> <I>(size_t <VAR>dim</VAR>)</I>
<DD><A NAME="IDX1854"></A>
This function allocates and initializes a workspace for Monte Carlo
integration in <VAR>dim</VAR> dimensions.  The workspace is used to maintain
the state of the integration.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_monte_miser_init</B> <I>(gsl_monte_miser_state* <VAR>s</VAR>)</I>
<DD><A NAME="IDX1855"></A>
This function initializes a previously allocated integration state.
This allows an existing workspace to be reused for different
integrations.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_monte_miser_integrate</B> <I>(gsl_monte_function * <VAR>f</VAR>, double * <VAR>xl</VAR>, double * <VAR>xu</VAR>, size_t <VAR>dim</VAR>, size_t <VAR>calls</VAR>, gsl_rng * <VAR>r</VAR>, gsl_monte_miser_state * <VAR>s</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX1856"></A>
This routines uses the MISER Monte Carlo algorithm to integrate the
function <VAR>f</VAR> over the <VAR>dim</VAR>-dimensional hypercubic region
defined by the lower and upper limits in the arrays <VAR>xl</VAR> and
<VAR>xu</VAR>, each of size <VAR>dim</VAR>.  The integration uses a fixed number
of function calls <VAR>calls</VAR>, and obtains random sampling points using
the random number generator <VAR>r</VAR>. A previously allocated workspace
<VAR>s</VAR> must be supplied.  The result of the integration is returned in
<VAR>result</VAR>, with an estimated absolute error <VAR>abserr</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_monte_miser_free</B> <I>(gsl_monte_miser_state * <VAR>s</VAR>)</I>
<DD><A NAME="IDX1857"></A>
This function frees the memory associated with the integrator state
<VAR>s</VAR>.
</DL>

</P>
<P>
The MISER algorithm has several configurable parameters. The
following variables can be accessed through the
<CODE>gsl_monte_miser_state</CODE> struct,

</P>
<P>
<DL>
<DT><U>Variable:</U> double <B>estimate_frac</B>
<DD><A NAME="IDX1858"></A>
This parameter specifies the fraction of the currently available number of
function calls which are allocated to estimating the variance at each
recursive step. The default value is 0.1.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> size_t <B>min_calls</B>
<DD><A NAME="IDX1859"></A>
This parameter specifies the minimum number of function calls required
for each estimate of the variance. If the number of function calls
allocated to the estimate using <VAR>estimate_frac</VAR> falls below
<VAR>min_calls</VAR> then <VAR>min_calls</VAR> are used instead.  This ensures
that each estimate maintains a reasonable level of accuracy.  The
default value of <VAR>min_calls</VAR> is <CODE>16 * dim</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> size_t <B>min_calls_per_bisection</B>
<DD><A NAME="IDX1860"></A>
This parameter specifies the minimum number of function calls required
to proceed with a bisection step.  When a recursive step has fewer calls
available than <VAR>min_calls_per_bisection</VAR> it performs a plain Monte
Carlo estimate of the current sub-region and terminates its branch of
the recursion.  The default value of this parameter is <CODE>32 *
min_calls</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> double <B>alpha</B>
<DD><A NAME="IDX1861"></A>
This parameter controls how the estimated variances for the two
sub-regions of a bisection are combined when allocating points.  With
recursive sampling the overall variance should scale better than
1/N, since the values from the sub-regions will be obtained using
a procedure which explicitly minimizes their variance.  To accommodate
this behavior the MISER algorithm allows the total variance to
depend on a scaling parameter \alpha,

<SPAN class="ifinfo">


<PRE class="example">
\Var(f) = {\sigma_a \over N_a^\alpha} + {\sigma_b \over N_b^\alpha}.
</PRE>

</SPAN>

<P>
The authors of the original paper describing MISER recommend the
value \alpha = 2 as a good choice, obtained from numerical
experiments, and this is used as the default value in this
implementation.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> double <B>dither</B>
<DD><A NAME="IDX1862"></A>
This parameter introduces a random fractional variation of size
<VAR>dither</VAR> into each bisection, which can be used to break the
symmetry of integrands which are concentrated near the exact center of
the hypercubic integration region.  The default value of dither is zero,
so no variation is introduced. If needed, a typical value of
<VAR>dither</VAR> is 0.1.
</DL>

</P>


<H2><A NAME="SEC381" HREF="gsl_manual.html#TOC381">VEGAS</A></H2>
<P>
<A NAME="IDX1863"></A>
<A NAME="IDX1864"></A>

</P>
<P>
The VEGAS algorithm of Lepage is based on importance sampling.  It
samples points from the probability distribution described by the
function |f|, so that the points are concentrated in the regions
that make the largest contribution to the integral.

</P>
<P>
In general, if the Monte Carlo integral of f is sampled with
points distributed according to a probability distribution described by
the function g, we obtain an estimate E_g(f; N),

<SPAN class="ifinfo">


<PRE class="example">
E_g(f; N) = E(f/g; N)
</PRE>

</SPAN>

<P>
with a corresponding variance,

<SPAN class="ifinfo">


<PRE class="example">
\Var_g(f; N) = \Var(f/g; N).
</PRE>

</SPAN>

<P>
If the probability distribution is chosen as g = |f|/I(|f|) then
it can be shown that the variance V_g(f; N) vanishes, and the
error in the estimate will be zero.  In practice it is not possible to
sample from the exact distribution g for an arbitrary function, so
importance sampling algorithms aim to produce efficient approximations
to the desired distribution.

</P>
<P>
The VEGAS algorithm approximates the exact distribution by making a
number of passes over the integration region while histogramming the
function f. Each histogram is used to define a sampling
distribution for the next pass.  Asymptotically this procedure converges
to the desired distribution. In order
to avoid the number of histogram bins growing like K^d the
probability distribution is approximated by a separable function:
g(x_1, x_2, ...) = g_1(x_1) g_2(x_2) ...  
so that the number of bins required is only Kd.     
This is equivalent to locating the peaks of the function from the
projections of the integrand onto the coordinate axes.  The efficiency
of VEGAS depends on the validity of this assumption.  It is most
efficient when the peaks of the integrand are well-localized.  If an
integrand can be rewritten in a form which is approximately separable
this will increase the efficiency of integration with VEGAS.

</P>
<P>
VEGAS incorporates a number of additional features, and combines both
stratified sampling and importance sampling.  The integration region is
divided into a number of "boxes", with each box getting a fixed
number of points (the goal is 2).  Each box can then have a fractional
number of bins, but if the ratio of bins-per-box is less than two, Vegas switches to a
kind variance reduction (rather than importance sampling).

</P>

<P>
<DL>
<DT><U>Function:</U> gsl_monte_vegas_state * <B>gsl_monte_vegas_alloc</B> <I>(size_t <VAR>dim</VAR>)</I>
<DD><A NAME="IDX1865"></A>
This function allocates and initializes a workspace for Monte Carlo
integration in <VAR>dim</VAR> dimensions.  The workspace is used to maintain
the state of the integration.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_monte_vegas_init</B> <I>(gsl_monte_vegas_state* <VAR>s</VAR>)</I>
<DD><A NAME="IDX1866"></A>
This function initializes a previously allocated integration state.
This allows an existing workspace to be reused for different
integrations.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_monte_vegas_integrate</B> <I>(gsl_monte_function * <VAR>f</VAR>, double * <VAR>xl</VAR>, double * <VAR>xu</VAR>, size_t <VAR>dim</VAR>, size_t <VAR>calls</VAR>, gsl_rng * <VAR>r</VAR>, gsl_monte_vegas_state * <VAR>s</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX1867"></A>
This routines uses the VEGAS Monte Carlo algorithm to integrate the
function <VAR>f</VAR> over the <VAR>dim</VAR>-dimensional hypercubic region
defined by the lower and upper limits in the arrays <VAR>xl</VAR> and
<VAR>xu</VAR>, each of size <VAR>dim</VAR>.  The integration uses a fixed number
of function calls <VAR>calls</VAR>, and obtains random sampling points using
the random number generator <VAR>r</VAR>. A previously allocated workspace
<VAR>s</VAR> must be supplied.  The result of the integration is returned in
<VAR>result</VAR>, with an estimated absolute error <VAR>abserr</VAR>.  The result
and its error estimate are based on a weighted average of independent
samples. The chi-squared per degree of freedom for the weighted average
is returned via the state struct component, <VAR>s-&#62;chisq</VAR>, and must be
consistent with 1 for the weighted average to be reliable.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_monte_vegas_free</B> <I>(gsl_monte_vegas_state * <VAR>s</VAR>)</I>
<DD><A NAME="IDX1868"></A>
This function frees the memory associated with the integrator state
<VAR>s</VAR>.
</DL>

</P>
<P>
The VEGAS algorithm computes a number of independent estimates of the
integral internally, according to the <CODE>iterations</CODE> parameter
described below, and returns their weighted average.  Random sampling of
the integrand can occasionally produce an estimate where the error is
zero, particularly if the function is constant in some regions. An
estimate with zero error causes the weighted average to break down and
must be handled separately. In the original Fortran implementations of
VEGAS the error estimate is made non-zero by substituting a small
value (typically <CODE>1e-30</CODE>).  The implementation in GSL differs from
this and avoids the use of an arbitrary constant--it either assigns
the value a weight which is the average weight of the preceding
estimates or discards it according to the following procedure,

</P>
<DL COMPACT>

<DT>current estimate has zero error, weighted average has finite error
<DD>
The current estimate is assigned a weight which is the average weight of
the preceding estimates.

<DT>current estimate has finite error, previous estimates had zero error
<DD>
The previous estimates are discarded and the weighted averaging
procedure begins with the current estimate.

<DT>current estimate has zero error, previous estimates had zero error
<DD>
The estimates are averaged using the arithmetic mean, but no error is computed.
</DL>

<P>
The VEGAS algorithm is highly configurable. The following variables
can be accessed through the <CODE>gsl_monte_vegas_state</CODE> struct,

</P>
<P>
<DL>
<DT><U>Variable:</U> double <B>result</B>
<DD><A NAME="IDX1869"></A>
<DT><U>Variable:</U> double <B>sigma</B>
<DD><A NAME="IDX1870"></A>
These parameters contain the raw value of the integral <VAR>result</VAR> and
its error <VAR>sigma</VAR> from the last iteration of the algorithm.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> double <B>chisq</B>
<DD><A NAME="IDX1871"></A>
This parameter gives the chi-squared per degree of freedom for the
weighted estimate of the integral.  The value of <VAR>chisq</VAR> should be
close to 1.  A value of <VAR>chisq</VAR> which differs significantly from 1
indicates that the values from different iterations are inconsistent.
In this case the weighted error will be under-estimated, and further
iterations of the algorithm are needed to obtain reliable results.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> double <B>alpha</B>
<DD><A NAME="IDX1872"></A>
The parameter <CODE>alpha</CODE> controls the stiffness of the rebinning
algorithm.  It is typically set between one and two. A value of zero
prevents rebinning of the grid.  The default value is 1.5.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> size_t <B>iterations</B>
<DD><A NAME="IDX1873"></A>
The number of iterations to perform for each call to the routine. The
default value is 5 iterations.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> int <B>stage</B>
<DD><A NAME="IDX1874"></A>
Setting this determines the <I>stage</I> of the calculation.  Normally,
<CODE>stage = 0</CODE> which begins with a new uniform grid and empty weighted
average.  Calling vegas with <CODE>stage = 1</CODE> retains the grid from the
previous run but discards the weighted average, so that one can "tune"
the grid using a relatively small number of points and then do a large
run with <CODE>stage = 1</CODE> on the optimized grid.  Setting <CODE>stage =
2</CODE> keeps the grid and the weighted average from the previous run, but
may increase (or decrease) the number of histogram bins in the grid
depending on the number of calls available.  Choosing <CODE>stage = 3</CODE>
enters at the main loop, so that nothing is changed, and is equivalent
to performing additional iterations in a previous call.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> int <B>mode</B>
<DD><A NAME="IDX1875"></A>
The possible choices are <CODE>GSL_VEGAS_MODE_IMPORTANCE</CODE>,
<CODE>GSL_VEGAS_MODE_STRATIFIED</CODE>, <CODE>GSL_VEGAS_MODE_IMPORTANCE_ONLY</CODE>.
This determines whether VEGAS will use importance sampling or
stratified sampling, or whether it can pick on its own.  In low
dimensions VEGAS uses strict stratified sampling (more precisely,
stratified sampling is chosen if there are fewer than 2 bins per box).
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> int <B>verbose</B>
<DD><A NAME="IDX1876"></A>
<DT><U>Variable:</U> FILE * <B>ostream</B>
<DD><A NAME="IDX1877"></A>
These parameters set the level of information printed by VEGAS. All
information is written to the stream <VAR>ostream</VAR>.  The default setting
of <VAR>verbose</VAR> is <CODE>-1</CODE>, which turns off all output.  A
<VAR>verbose</VAR> value of <CODE>0</CODE> prints summary information about the
weighted average and final result, while a value of <CODE>1</CODE> also
displays the grid coordinates.  A value of <CODE>2</CODE> prints information
from the rebinning procedure for each iteration.
</DL>

</P>


<H2><A NAME="SEC382" HREF="gsl_manual.html#TOC382">Examples</A></H2>

<P>
The example program below uses the Monte Carlo routines to estimate the
value of the following 3-dimensional integral from the theory of random
walks,

<SPAN class="ifinfo">


<PRE class="example">
I = \int_{-pi}^{+pi} {dk_x/(2 pi)} 
    \int_{-pi}^{+pi} {dk_y/(2 pi)} 
    \int_{-pi}^{+pi} {dk_z/(2 pi)} 
     1 / (1 - cos(k_x)cos(k_y)cos(k_z)).
</PRE>

</SPAN>

<P>
The analytic value of this integral can be shown to be I =
\Gamma(1/4)^4/(4 \pi^3) = 1.393203929685676859....  The integral gives
the mean time spent at the origin by a random walk on a body-centered
cubic lattice in three dimensions.

</P>
<P>
For simplicity we will compute the integral over the region
(0,0,0) to (\pi,\pi,\pi) and multiply by 8 to obtain the
full result.  The integral is slowly varying in the middle of the region
but has integrable singularities at the corners (0,0,0),
(0,\pi,\pi), (\pi,0,\pi) and (\pi,\pi,0).  The
Monte Carlo routines only select points which are strictly within the
integration region and so no special measures are needed to avoid these
singularities.

</P>

<PRE class="smallexample">
#include &#60;stdlib.h&#62;
#include &#60;gsl/gsl_math.h&#62;
#include &#60;gsl/gsl_monte.h&#62;
#include &#60;gsl/gsl_monte_plain.h&#62;
#include &#60;gsl/gsl_monte_miser.h&#62;
#include &#60;gsl/gsl_monte_vegas.h&#62;

/* Computation of the integral,

      I = int (dx dy dz)/(2pi)^3  1/(1-cos(x)cos(y)cos(z))

   over (-pi,-pi,-pi) to (+pi, +pi, +pi).  The exact answer
   is Gamma(1/4)^4/(4 pi^3).  This example is taken from
   C.Itzykson, J.M.Drouffe, "Statistical Field Theory -
   Volume 1", Section 1.1, p21, which cites the original
   paper M.L.Glasser, I.J.Zucker, Proc.Natl.Acad.Sci.USA 74
   1800 (1977) */

/* For simplicity we compute the integral over the region 
   (0,0,0) -&#62; (pi,pi,pi) and multiply by 8 */

double exact = 1.3932039296856768591842462603255;

double
g (double *k, size_t dim, void *params)
{
  double A = 1.0 / (M_PI * M_PI * M_PI);
  return A / (1.0 - cos (k[0]) * cos (k[1]) * cos (k[2]));
}

void
display_results (char *title, double result, double error)
{
  printf ("%s ==================\n", title);
  printf ("result = % .6f\n", result);
  printf ("sigma  = % .6f\n", error);
  printf ("exact  = % .6f\n", exact);
  printf ("error  = % .6f = %.1g sigma\n", result - exact,
          fabs (result - exact) / error);
}

int
main (void)
{
  double res, err;

  double xl[3] = { 0, 0, 0 };
  double xu[3] = { M_PI, M_PI, M_PI };

  const gsl_rng_type *T;
  gsl_rng *r;

  gsl_monte_function G = { &#38;g, 3, 0 };

  size_t calls = 500000;

  gsl_rng_env_setup ();

  T = gsl_rng_default;
  r = gsl_rng_alloc (T);

  {
    gsl_monte_plain_state *s = gsl_monte_plain_alloc (3);
    gsl_monte_plain_integrate (&#38;G, xl, xu, 3, calls, r, s, 
                               &#38;res, &#38;err);
    gsl_monte_plain_free (s);

    display_results ("plain", res, err);
  }

  {
    gsl_monte_miser_state *s = gsl_monte_miser_alloc (3);
    gsl_monte_miser_integrate (&#38;G, xl, xu, 3, calls, r, s,
                               &#38;res, &#38;err);
    gsl_monte_miser_free (s);

    display_results ("miser", res, err);
  }

  {
    gsl_monte_vegas_state *s = gsl_monte_vegas_alloc (3);

    gsl_monte_vegas_integrate (&#38;G, xl, xu, 3, 10000, r, s,
                               &#38;res, &#38;err);
    display_results ("vegas warm-up", res, err);

    printf ("converging...\n");

    do
      {
        gsl_monte_vegas_integrate (&#38;G, xl, xu, 3, calls/5, r, s,
                                   &#38;res, &#38;err);
        printf ("result = % .6f sigma = % .6f "
                "chisq/dof = %.1f\n", res, err, s-&#62;chisq);
      }
    while (fabs (s-&#62;chisq - 1.0) &#62; 0.5);

    display_results ("vegas final", res, err);

    gsl_monte_vegas_free (s);
  }
  return 0;
}
</PRE>

<P>
With 500,000 function calls the plain Monte Carlo algorithm achieves a
fractional error of 0.6%.  The estimated error <CODE>sigma</CODE> is
consistent with the actual error, and the computed result differs from
the true result by about one standard deviation,

</P>

<PRE class="example">
plain ==================
result =  1.385867
sigma  =  0.007938
exact  =  1.393204
error  = -0.007337 = 0.9 sigma
</PRE>

<P>
The MISER algorithm reduces the error by a factor of two, and also
correctly estimates the error,

</P>

<PRE class="example">
miser ==================
result =  1.390656
sigma  =  0.003743
exact  =  1.393204
error  = -0.002548 = 0.7 sigma
</PRE>

<P>
In the case of the VEGAS algorithm the program uses an initial
warm-up run of 10,000 function calls to prepare, or "warm up", the grid.
This is followed by a main run with five iterations of 100,000 function
calls. The chi-squared per degree of freedom for the five iterations are
checked for consistency with 1, and the run is repeated if the results
have not converged. In this case the estimates are consistent on the
first pass.

</P>

<PRE class="example">
vegas warm-up ==================
result =  1.386925
sigma  =  0.002651
exact  =  1.393204
error  = -0.006278 = 2 sigma
converging...
result =  1.392957 sigma =  0.000452 chisq/dof = 1.1
vegas final ==================
result =  1.392957
sigma  =  0.000452
exact  =  1.393204
error  = -0.000247 = 0.5 sigma
</PRE>

<P>
If the value of <CODE>chisq</CODE> had differed significantly from 1 it would
indicate inconsistent results, with a correspondingly underestimated
error.  The final estimate from VEGAS (using a similar number of
function calls) is significantly more accurate than the other two
algorithms.

</P>


<H2><A NAME="SEC383" HREF="gsl_manual.html#TOC383">References and Further Reading</A></H2>

<P>
The MISER algorithm is described in the following article by Press
and Farrar,

</P>

<UL class="itemize">
<LI>

W.H. Press, G.R. Farrar, <CITE>Recursive Stratified Sampling for
Multidimensional Monte Carlo Integration</CITE>,
Computers in Physics, v4 (1990), pp190--195.
</UL>

<P>
The VEGAS algorithm is described in the following papers,

</P>

<UL class="itemize">
<LI>

G.P. Lepage,
<CITE>A New Algorithm for Adaptive Multidimensional Integration</CITE>,
Journal of Computational Physics 27, 192--203, (1978)

<LI>

G.P. Lepage,
<CITE>VEGAS: An Adaptive Multi-dimensional Integration Program</CITE>,
Cornell preprint CLNS 80-447, March 1980
</UL>



<H1><A NAME="SEC384" HREF="gsl_manual.html#TOC384">Simulated Annealing</A></H1>
<P>
<A NAME="IDX1878"></A>
<A NAME="IDX1879"></A>
<A NAME="IDX1880"></A>
<A NAME="IDX1881"></A>
<A NAME="IDX1882"></A>
Stochastic search techniques are used when the structure of a space is
not well understood or is not smooth, so that techniques like Newton's
method (which requires calculating Jacobian derivative matrices) cannot
be used. In particular, these techniques are frequently used to solve
combinatorial optimization problems, such as the traveling salesman
problem.

</P>
<P>
The goal is to find a point in the space at which a real valued
<I>energy function</I> (or <I>cost function</I>) is minimized.  Simulated
annealing is a minimization technique which has given good results in
avoiding local minima; it is based on the idea of taking a random walk
through the space at successively lower temperatures, where the
probability of taking a step is given by a Boltzmann distribution.

</P>
<P>
The functions described in this chapter are declared in the header file
<TT>'gsl_siman.h'</TT>.

</P>



<H2><A NAME="SEC385" HREF="gsl_manual.html#TOC385">Simulated Annealing algorithm</A></H2>

<P>
The simulated annealing algorithm takes random walks through the problem
space, looking for points with low energies; in these random walks, the
probability of taking a step is determined by the Boltzmann distribution,

<SPAN class="ifinfo">


<PRE class="example">
p = e^{-(E_{i+1} - E_i)/(kT)}
</PRE>

</SPAN>

<P>
if 
E_{i+1} &#62; E_i, and 
p = 1 when 
E_{i+1} &#60;= E_i.

</P>
<P>
In other words, a step will occur if the new energy is lower.  If
the new energy is higher, the transition can still occur, and its
likelihood is proportional to the temperature T and inversely
proportional to the energy difference 
E_{i+1} - E_i.

</P>
<P>
The temperature T is initially set to a high value, and a random
walk is carried out at that temperature.  Then the temperature is
lowered very slightly according to a <I>cooling schedule</I>, for
example: 
T -&#62; T/mu_T
where \mu_T is slightly greater than 1. 
<A NAME="IDX1883"></A>
<A NAME="IDX1884"></A>

</P>
<P>
The slight probability of taking a step that gives higher energy is what
allows simulated annealing to frequently get out of local minima.

</P>


<H2><A NAME="SEC386" HREF="gsl_manual.html#TOC386">Simulated Annealing functions</A></H2>

<P>
<DL>
<DT><U>Function:</U> void <B>gsl_siman_solve</B> <I>(const gsl_rng * <VAR>r</VAR>, void * <VAR>x0_p</VAR>, gsl_siman_Efunc_t <VAR>Ef</VAR>, gsl_siman_step_t <VAR>take_step</VAR>, gsl_siman_metric_t <VAR>distance</VAR>, gsl_siman_print_t <VAR>print_position</VAR>, gsl_siman_copy_t <VAR>copyfunc</VAR>, gsl_siman_copy_construct_t <VAR>copy_constructor</VAR>, gsl_siman_destroy_t <VAR>destructor</VAR>, size_t <VAR>element_size</VAR>, gsl_siman_params_t <VAR>params</VAR>)</I>
<DD><A NAME="IDX1885"></A>

</P>
<P>
This function performs a simulated annealing search through a given
space.  The space is specified by providing the functions <VAR>Ef</VAR> and
<VAR>distance</VAR>.  The simulated annealing steps are generated using the
random number generator <VAR>r</VAR> and the function <VAR>take_step</VAR>.

</P>
<P>
The starting configuration of the system should be given by <VAR>x0_p</VAR>.
The routine offers two modes for updating configurations, a fixed-size
mode and a variable-size mode.  In the fixed-size mode the configuration
is stored as a single block of memory of size <VAR>element_size</VAR>.
Copies of this configuration are created, copied and destroyed
internally using the standard library functions <CODE>malloc</CODE>,
<CODE>memcpy</CODE> and <CODE>free</CODE>.  The function pointers <VAR>copyfunc</VAR>,
<VAR>copy_constructor</VAR> and <VAR>destructor</VAR> should be null pointers in
fixed-size mode.  In the variable-size mode the functions
<VAR>copyfunc</VAR>, <VAR>copy_constructor</VAR> and <VAR>destructor</VAR> are used to
create, copy and destroy configurations internally.  The variable
<VAR>element_size</VAR> should be zero in the variable-size mode.

</P>
<P>
The <VAR>params</VAR> structure (described below) controls the run by
providing the temperature schedule and other tunable parameters to the
algorithm.

</P>
<P>
On exit the best result achieved during the search is placed in
<CODE>*<VAR>x0_p</VAR></CODE>.  If the annealing process has been successful this
should be a good approximation to the optimal point in the space.

</P>
<P>
If the function pointer <VAR>print_position</VAR> is not null, a debugging
log will be printed to <CODE>stdout</CODE> with the following columns:

</P>

<PRE class="example">
number_of_iterations temperature x x-(*x0_p) Ef(x)
</PRE>

<P>
and the output of the function <VAR>print_position</VAR> itself.  If
<VAR>print_position</VAR> is null then no information is printed.
</DL>
The simulated annealing routines require several user-specified
functions to define the configuration space and energy function.  The
prototypes for these functions are given below.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_siman_Efunc_t</B>
<DD><A NAME="IDX1886"></A>
This function type should return the energy of a configuration <VAR>xp</VAR>.

</P>

<PRE class="example">
double (*gsl_siman_Efunc_t) (void *xp)
</PRE>

</DL>

<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_siman_step_t</B>
<DD><A NAME="IDX1887"></A>
This function type should modify the configuration <VAR>xp</VAR> using a random step
taken from the generator <VAR>r</VAR>, up to a maximum distance of
<VAR>step_size</VAR>.

</P>

<PRE class="example">
void (*gsl_siman_step_t) (const gsl_rng *r, void *xp, 
                          double step_size)
</PRE>

</DL>

<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_siman_metric_t</B>
<DD><A NAME="IDX1888"></A>
This function type should return the distance between two configurations
<VAR>xp</VAR> and <VAR>yp</VAR>.

</P>

<PRE class="example">
double (*gsl_siman_metric_t) (void *xp, void *yp)
</PRE>

</DL>

<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_siman_print_t</B>
<DD><A NAME="IDX1889"></A>
This function type should print the contents of the configuration <VAR>xp</VAR>.

</P>

<PRE class="example">
void (*gsl_siman_print_t) (void *xp)
</PRE>

</DL>

<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_siman_copy_t</B>
<DD><A NAME="IDX1890"></A>
This function type should copy the configuration <VAR>source</VAR> into <VAR>dest</VAR>.

</P>

<PRE class="example">
void (*gsl_siman_copy_t) (void *source, void *dest)
</PRE>

</DL>

<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_siman_copy_construct_t</B>
<DD><A NAME="IDX1891"></A>
This function type should create a new copy of the configuration <VAR>xp</VAR>.

</P>

<PRE class="example">
void * (*gsl_siman_copy_construct_t) (void *xp)
</PRE>

</DL>

<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_siman_destroy_t</B>
<DD><A NAME="IDX1892"></A>
This function type should destroy the configuration <VAR>xp</VAR>, freeing its
memory.

</P>

<PRE class="example">
void (*gsl_siman_destroy_t) (void *xp)
</PRE>

</DL>

<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_siman_params_t</B>
<DD><A NAME="IDX1893"></A>
These are the parameters that control a run of <CODE>gsl_siman_solve</CODE>.
This structure contains all the information needed to control the
search, beyond the energy function, the step function and the initial
guess.

</P>
<DL COMPACT>

<DT><CODE>int n_tries</CODE>
<DD>
The number of points to try for each step.

<DT><CODE>int iters_fixed_T</CODE>
<DD>
The number of iterations at each temperature.

<DT><CODE>double step_size</CODE>
<DD>
The maximum step size in the random walk.

<DT><CODE>double k, t_initial, mu_t, t_min</CODE>
<DD>
The parameters of the Boltzmann distribution and cooling schedule.
</DL>
</DL>



<H2><A NAME="SEC387" HREF="gsl_manual.html#TOC387">Examples</A></H2>

<P>
The simulated annealing package is clumsy, and it has to be because it
is written in C, for C callers, and tries to be polymorphic at the same
time.  But here we provide some examples which can be pasted into your
application with little change and should make things easier.

</P>



<H3><A NAME="SEC388" HREF="gsl_manual.html#TOC388">Trivial example</A></H3>

<P>
The first example, in one dimensional cartesian space, sets up an energy
function which is a damped sine wave; this has many local minima, but
only one global minimum, somewhere between 1.0 and 1.5.  The initial
guess given is 15.5, which is several local minima away from the global
minimum.

</P>

<PRE class="smallexample">
#include &#60;math.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;gsl/gsl_siman.h&#62;

/* set up parameters for this simulated annealing run */

/* how many points do we try before stepping */
#define N_TRIES 200             

/* how many iterations for each T? */
#define ITERS_FIXED_T 10        

/* max step size in random walk */
#define STEP_SIZE 10            

/* Boltzmann constant */
#define K 1.0                   

/* initial temperature */
#define T_INITIAL 0.002         

/* damping factor for temperature */
#define MU_T 1.005              
#define T_MIN 2.0e-6

gsl_siman_params_t params 
  = {N_TRIES, ITERS_FIXED_T, STEP_SIZE,
     K, T_INITIAL, MU_T, T_MIN};

/* now some functions to test in one dimension */
double E1(void *xp)
{
  double x = * ((double *) xp);

  return exp(-pow((x-1.0),2.0))*sin(8*x);
}

double M1(void *xp, void *yp)
{
  double x = *((double *) xp);
  double y = *((double *) yp);

  return fabs(x - y);
}

void S1(const gsl_rng * r, void *xp, double step_size)
{
  double old_x = *((double *) xp);
  double new_x;

  double u = gsl_rng_uniform(r);
  new_x = u * 2 * step_size - step_size + old_x;

  memcpy(xp, &#38;new_x, sizeof(new_x));
}

void P1(void *xp)
{
  printf ("%12g", *((double *) xp));
}

int
main(int argc, char *argv[])
{
  const gsl_rng_type * T;
  gsl_rng * r;

  double x_initial = 15.5;

  gsl_rng_env_setup();

  T = gsl_rng_default;
  r = gsl_rng_alloc(T);

  gsl_siman_solve(r, &#38;x_initial, E1, S1, M1, P1,
                  NULL, NULL, NULL, 
                  sizeof(double), params);
  return 0;
}
</PRE>

<P>
Here are a couple of plots that are generated by running
<CODE>siman_test</CODE> in the following way:

</P>

<PRE class="example">
$ ./siman_test | grep -v "^#" 
 | xyplot -xyil -y -0.88 -0.83 -d "x...y" 
 | xyps -d &#62; siman-test.eps
$ ./siman_test | grep -v "^#" 
 | xyplot -xyil -xl "generation" -yl "energy" -d "x..y"
 | xyps -d &#62; siman-energy.eps
</PRE>

<P>
<BR><IMG SRC="siman-test"><BR> 
<BR><IMG SRC="siman-energy"><BR>

</P>

<BLOCKQUOTE class="quotation">
<P>
Example of a simulated annealing run: at higher temperatures (early in
the plot) you see that the solution can fluctuate, but at lower
temperatures it converges.
</BLOCKQUOTE>



<H3><A NAME="SEC389" HREF="gsl_manual.html#TOC389">Traveling Salesman Problem</A></H3>
<P>
<A NAME="IDX1894"></A>
<A NAME="IDX1895"></A>

</P>
<P>
The TSP (<I>Traveling Salesman Problem</I>) is the classic combinatorial
optimization problem.  I have provided a very simple version of it,
based on the coordinates of twelve cities in the southwestern United
States.  This should maybe be called the <I>Flying Salesman Problem</I>,
since I am using the great-circle distance between cities, rather than
the driving distance.  Also: I assume the earth is a sphere, so I don't
use geoid distances.

</P>
<P>
The <CODE>gsl_siman_solve()</CODE> routine finds a route which is 3490.62
Kilometers long; this is confirmed by an exhaustive search of all
possible routes with the same initial city.

</P>
<P>
The full code can be found in <TT>'siman/siman_tsp.c'</TT>, but I include
here some plots generated in the following way:

</P>

<PRE class="smallexample">
$ ./siman_tsp &#62; tsp.output
$ grep -v "^#" tsp.output  
 | xyplot -xyil -d "x................y" 
    -lx "generation" -ly "distance" 
    -lt "TSP -- 12 southwest cities" 
 | xyps -d &#62; 12-cities.eps
$ grep initial_city_coord tsp.output 
 | awk '{print $2, $3, $4, $5}' 
 | xyplot -xyil -lb0 -cs 0.8 
    -lx "longitude (- means west)" -ly "latitude" 
    -lt "TSP -- initial-order" 
 | xyps -d &#62; initial-route.eps
$ grep final_city_coord tsp.output 
 | awk '{print $2, $3, $4, $5}' 
 | xyplot -xyil -lb0 -cs 0.8
    -lx "longitude (- means west)" -ly "latitude" 
    -lt "TSP -- final-order" 
 | xyps -d &#62; final-route.eps
</PRE>

<P>
This is the output showing the initial order of the cities; longitude is
negative, since it is west and I want the plot to look like a map.

</P>

<PRE class="smallexample">
# initial coordinates of cities (longitude and latitude)
###initial_city_coord: -105.95 35.68 Santa Fe
###initial_city_coord: -112.07 33.54 Phoenix
###initial_city_coord: -106.62 35.12 Albuquerque
###initial_city_coord: -103.2 34.41 Clovis
###initial_city_coord: -107.87 37.29 Durango
###initial_city_coord: -96.77 32.79 Dallas
###initial_city_coord: -105.92 35.77 Tesuque
###initial_city_coord: -107.84 35.15 Grants
###initial_city_coord: -106.28 35.89 Los Alamos
###initial_city_coord: -106.76 32.34 Las Cruces
###initial_city_coord: -108.58 37.35 Cortez
###initial_city_coord: -108.74 35.52 Gallup
###initial_city_coord: -105.95 35.68 Santa Fe
</PRE>

<P>
The optimal route turns out to be:

</P>

<PRE class="smallexample">
# final coordinates of cities (longitude and latitude)
###final_city_coord: -105.95 35.68 Santa Fe
###final_city_coord: -106.28 35.89 Los Alamos
###final_city_coord: -106.62 35.12 Albuquerque
###final_city_coord: -107.84 35.15 Grants
###final_city_coord: -107.87 37.29 Durango
###final_city_coord: -108.58 37.35 Cortez
###final_city_coord: -108.74 35.52 Gallup
###final_city_coord: -112.07 33.54 Phoenix
###final_city_coord: -106.76 32.34 Las Cruces
###final_city_coord: -96.77 32.79 Dallas
###final_city_coord: -103.2 34.41 Clovis
###final_city_coord: -105.92 35.77 Tesuque
###final_city_coord: -105.95 35.68 Santa Fe
</PRE>

<P>
<BR><IMG SRC="initial-route"><BR> 
<BR><IMG SRC="final-route"><BR>

</P>

<BLOCKQUOTE class="quotation">
<P>
Initial and final (optimal) route for the 12 southwestern cities Flying
Salesman Problem.
</BLOCKQUOTE>

<P>
Here's a plot of the cost function (energy) versus generation (point in
the calculation at which a new temperature is set) for this problem:

</P>
<P>
<BR><IMG SRC="12-cities"><BR>

</P>

<BLOCKQUOTE class="quotation">
<P>
Example of a simulated annealing run for the 12 southwestern cities
Flying Salesman Problem.
</BLOCKQUOTE>



<H2><A NAME="SEC390" HREF="gsl_manual.html#TOC390">References and Further Reading</A></H2>

<P>
Further information is available in the following book,

</P>

<UL class="itemize">
<LI>

<CITE>Modern Heuristic Techniques for Combinatorial Problems</CITE>, Colin R. Reeves
(ed.), McGraw-Hill, 1995 (ISBN 0-07-709239-2).
</UL>



<H1><A NAME="SEC391" HREF="gsl_manual.html#TOC391">Ordinary Differential Equations</A></H1>
<P>
<A NAME="IDX1896"></A>
<A NAME="IDX1897"></A>
<A NAME="IDX1898"></A>
<A NAME="IDX1899"></A>
This chapter describes functions for solving ordinary differential
equation (ODE) initial value problems.  The library provides a variety
of low-level methods, such as Runge-Kutta and Bulirsch-Stoer routines,
and higher-level components for adaptive step-size control.  The
components can be combined by the user to achieve the desired solution,
with full access to any intermediate steps.

</P>
<P>
These functions are declared in the header file <TT>'gsl_odeiv.h'</TT>.

</P>



<H2><A NAME="SEC392" HREF="gsl_manual.html#TOC392">Defining the ODE System</A></H2>

<P>
The routines solve the general n-dimensional first-order system,

<SPAN class="ifinfo">


<PRE class="example">
dy_i(t)/dt = f_i(t, y_1(t), ..., y_n(t))
</PRE>

</SPAN>

<P>
for i = 1, \dots, n.  The stepping functions rely on the vector
of derivatives f_i and the Jacobian matrix, 
J_{ij} = df_i(t,y(t)) / dy_j. 
A system of equations is defined using the <CODE>gsl_odeiv_system</CODE>
datatype.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_odeiv_system</B>
<DD><A NAME="IDX1900"></A>
This data type defines a general ODE system with arbitrary parameters.

</P>
<DL COMPACT>

<DT><CODE>int (* function) (double t, const double y[], double dydt[], void * params)</CODE>
<DD>
This function should store the vector elements
f_i(t,y,params) in the array <VAR>dydt</VAR>,
for arguments (<VAR>t</VAR>,<VAR>y</VAR>) and parameters <VAR>params</VAR>.
The function should return <CODE>GSL_SUCCESS</CODE> if the calculation 
was completed successfully. Any other return value indicates
an error.

<DT><CODE>int (* jacobian) (double t, const double y[], double * dfdy, double dfdt[], void * params);</CODE>
<DD>
This function should store the vector of derivative elements 
df_i(t,y,params)/dt in the array <VAR>dfdt</VAR> and the 
Jacobian matrix 
J_{ij} in the array
<VAR>dfdy</VAR>, regarded as a row-ordered matrix <CODE>J(i,j) = dfdy[i * dimension + j]</CODE>
where <CODE>dimension</CODE> is the dimension of the system.
The function should return <CODE>GSL_SUCCESS</CODE> if the calculation 
was completed successfully.  Any other return value indicates
an error.

Some of the simpler solver algorithms do not make use of the Jacobian
matrix, so it is not always strictly necessary to provide it (the
<CODE>jacobian</CODE> element of the struct can be replaced by a null pointer
for those algorithms).  However, it is useful to provide the Jacobian to allow
the solver algorithms to be interchanged--the best algorithms make use
of the Jacobian.

<DT><CODE>size_t dimension;</CODE>
<DD>
This is the dimension of the system of equations.

<DT><CODE>void * params</CODE>
<DD>
This is a pointer to the arbitrary parameters of the system.
</DL>
</DL>



<H2><A NAME="SEC393" HREF="gsl_manual.html#TOC393">Stepping Functions</A></H2>

<P>
The lowest level components are the <I>stepping functions</I> which
advance a solution from time t to t+h for a fixed
step-size h and estimate the resulting local error.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_odeiv_step * <B>gsl_odeiv_step_alloc</B> <I>(const gsl_odeiv_step_type * <VAR>T</VAR>, size_t <VAR>dim</VAR>)</I>
<DD><A NAME="IDX1901"></A>
This function returns a pointer to a newly allocated instance of a
stepping function of type <VAR>T</VAR> for a system of <VAR>dim</VAR> dimensions.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_odeiv_step_reset</B> <I>(gsl_odeiv_step * <VAR>s</VAR>)</I>
<DD><A NAME="IDX1902"></A>
This function resets the stepping function <VAR>s</VAR>.  It should be used
whenever the next use of <VAR>s</VAR> will not be a continuation of a
previous step.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_odeiv_step_free</B> <I>(gsl_odeiv_step * <VAR>s</VAR>)</I>
<DD><A NAME="IDX1903"></A>
This function frees all the memory associated with the stepping function
<VAR>s</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> const char * <B>gsl_odeiv_step_name</B> <I>(const gsl_odeiv_step * <VAR>s</VAR>)</I>
<DD><A NAME="IDX1904"></A>
This function returns a pointer to the name of the stepping function.
For example,

</P>

<PRE class="example">
printf ("step method is '%s'\n",
         gsl_odeiv_step_name (s));
</PRE>

<P>
would print something like <CODE>step method is 'rk4'</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> unsigned int <B>gsl_odeiv_step_order</B> <I>(const gsl_odeiv_step * <VAR>s</VAR>)</I>
<DD><A NAME="IDX1905"></A>
This function returns the order of the stepping function on the previous
step.  This order can vary if the stepping function itself is adaptive.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_odeiv_step_apply</B> <I>(gsl_odeiv_step * <VAR>s</VAR>, double <VAR>t</VAR>, double <VAR>h</VAR>, double <VAR>y</VAR>[], double <VAR>yerr</VAR>[], const double <VAR>dydt_in</VAR>[], double <VAR>dydt_out</VAR>[], const gsl_odeiv_system * <VAR>dydt</VAR>)</I>
<DD><A NAME="IDX1906"></A>
This function applies the stepping function <VAR>s</VAR> to the system of
equations defined by <VAR>dydt</VAR>, using the step size <VAR>h</VAR> to advance
the system from time <VAR>t</VAR> and state <VAR>y</VAR> to time <VAR>t</VAR>+<VAR>h</VAR>.
The new state of the system is stored in <VAR>y</VAR> on output, with an
estimate of the absolute error in each component stored in <VAR>yerr</VAR>.
If the argument <VAR>dydt_in</VAR> is not null it should point an array
containing the derivatives for the system at time <VAR>t</VAR> on input. This
is optional as the derivatives will be computed internally if they are
not provided, but allows the reuse of existing derivative information.
On output the new derivatives of the system at time <VAR>t</VAR>+<VAR>h</VAR> will
be stored in <VAR>dydt_out</VAR> if it is not null.

</P>
<P>
If the user-supplied functions defined in the system <VAR>dydt</VAR> return a
status other than <CODE>GSL_SUCCESS</CODE> the step will be aborted.  In this
case, the elements of <VAR>y</VAR> will be restored to their pre-step values
and the error code from the user-supplied function will be returned.  To
distinguish between error codes from the user-supplied functions and
those from <CODE>gsl_odeiv_step_apply</CODE> itself, any user-defined return
values should be distinct from the standard GSL error codes.
</DL>

</P>
<P>
The following algorithms are available,

</P>
<P>
<DL>
<DT><U>Step Type:</U> <B>gsl_odeiv_step_rk2</B>
<DD><A NAME="IDX1907"></A>
<A NAME="IDX1908"></A>
<A NAME="IDX1909"></A>
Embedded Runge-Kutta (2, 3) method.
</DL>

</P>
<P>
<DL>
<DT><U>Step Type:</U> <B>gsl_odeiv_step_rk4</B>
<DD><A NAME="IDX1910"></A>
<A NAME="IDX1911"></A>
4th order (classical) Runge-Kutta.
</DL>

</P>
<P>
<DL>
<DT><U>Step Type:</U> <B>gsl_odeiv_step_rkf45</B>
<DD><A NAME="IDX1912"></A>
<A NAME="IDX1913"></A>
<A NAME="IDX1914"></A>
Embedded Runge-Kutta-Fehlberg (4, 5) method.  This method is a good
general-purpose integrator.
</DL>

</P>
<P>
<DL>
<DT><U>Step Type:</U> <B>gsl_odeiv_step_rkck</B>
<DD><A NAME="IDX1915"></A>
<A NAME="IDX1916"></A>
<A NAME="IDX1917"></A>
Embedded Runge-Kutta Cash-Karp (4, 5) method.
</DL>

</P>
<P>
<DL>
<DT><U>Step Type:</U> <B>gsl_odeiv_step_rk8pd</B>
<DD><A NAME="IDX1918"></A>
<A NAME="IDX1919"></A>
<A NAME="IDX1920"></A>
Embedded Runge-Kutta Prince-Dormand (8,9) method.
</DL>

</P>
<P>
<DL>
<DT><U>Step Type:</U> <B>gsl_odeiv_step_rk2imp</B>
<DD><A NAME="IDX1921"></A>
Implicit 2nd order Runge-Kutta at Gaussian points.
</DL>

</P>
<P>
<DL>
<DT><U>Step Type:</U> <B>gsl_odeiv_step_rk4imp</B>
<DD><A NAME="IDX1922"></A>
Implicit 4th order Runge-Kutta at Gaussian points.
</DL>

</P>
<P>
<DL>
<DT><U>Step Type:</U> <B>gsl_odeiv_step_bsimp</B>
<DD><A NAME="IDX1923"></A>
<A NAME="IDX1924"></A>
<A NAME="IDX1925"></A>
<A NAME="IDX1926"></A>
Implicit Bulirsch-Stoer method of Bader and Deuflhard.  This algorithm
requires the Jacobian.
</DL>

</P>
<P>
<DL>
<DT><U>Step Type:</U> <B>gsl_odeiv_step_gear1</B>
<DD><A NAME="IDX1927"></A>
<A NAME="IDX1928"></A>
M=1 implicit Gear method.
</DL>

</P>
<P>
<DL>
<DT><U>Step Type:</U> <B>gsl_odeiv_step_gear2</B>
<DD><A NAME="IDX1929"></A>
M=2 implicit Gear method.
</DL>

</P>


<H2><A NAME="SEC394" HREF="gsl_manual.html#TOC394">Adaptive Step-size Control</A></H2>
<P>
<A NAME="IDX1930"></A>

</P>
<P>
The control function examines the proposed change to the solution
produced by a stepping function and attempts to determine the optimal
step-size for a user-specified level of error.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_odeiv_control * <B>gsl_odeiv_control_standard_new</B> <I>(double <VAR>eps_abs</VAR>, double <VAR>eps_rel</VAR>, double <VAR>a_y</VAR>, double <VAR>a_dydt</VAR>)</I>
<DD><A NAME="IDX1931"></A>
The standard control object is a four parameter heuristic based on
absolute and relative errors <VAR>eps_abs</VAR> and <VAR>eps_rel</VAR>, and
scaling factors <VAR>a_y</VAR> and <VAR>a_dydt</VAR> for the system state
y(t) and derivatives y'(t) respectively.

</P>
<P>
The step-size adjustment procedure for this method begins by computing
the desired error level D_i for each component,

<SPAN class="ifinfo">


<PRE class="example">
D_i = eps_abs + eps_rel * (a_y |y_i| + a_dydt h |y'_i|)
</PRE>

</SPAN>

<P>
and comparing it with the observed error E_i = |yerr_i|.  If the
observed error <VAR>E</VAR> exceeds the desired error level <VAR>D</VAR> by more
than 10% for any component then the method reduces the step-size by an
appropriate factor,

<SPAN class="ifinfo">


<PRE class="example">
h_new = h_old * S * (E/D)^(-1/q)
</PRE>

</SPAN>

<P>
where q is the consistency order of the method (e.g. q=4 for
4(5) embedded RK), and S is a safety factor of 0.9. The ratio
E/D is taken to be the maximum of the ratios
E_i/D_i. 

</P>
<P>
If the observed error E is less than 50% of the desired error
level <VAR>D</VAR> for the maximum ratio E_i/D_i then the algorithm
takes the opportunity to increase the step-size to bring the error in
line with the desired level,

<SPAN class="ifinfo">


<PRE class="example">
h_new = h_old * S * (E/D)^(-1/(q+1))
</PRE>

</SPAN>

<P>
This encompasses all the standard error scaling methods. To avoid
uncontrolled changes in the stepsize, the overall scaling factor is
limited to the range 1/5 to 5.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_odeiv_control * <B>gsl_odeiv_control_y_new</B> <I>(double <VAR>eps_abs</VAR>, double <VAR>eps_rel</VAR>)</I>
<DD><A NAME="IDX1932"></A>
This function creates a new control object which will keep the local
error on each step within an absolute error of <VAR>eps_abs</VAR> and
relative error of <VAR>eps_rel</VAR> with respect to the solution y_i(t).
This is equivalent to the standard control object with <VAR>a_y</VAR>=1 and
<VAR>a_dydt</VAR>=0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_odeiv_control * <B>gsl_odeiv_control_yp_new</B> <I>(double <VAR>eps_abs</VAR>, double <VAR>eps_rel</VAR>)</I>
<DD><A NAME="IDX1933"></A>
This function creates a new control object which will keep the local
error on each step within an absolute error of <VAR>eps_abs</VAR> and
relative error of <VAR>eps_rel</VAR> with respect to the derivatives of the
solution y'_i(t).  This is equivalent to the standard control
object with <VAR>a_y</VAR>=0 and <VAR>a_dydt</VAR>=1.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> gsl_odeiv_control * <B>gsl_odeiv_control_scaled_new</B> <I>(double <VAR>eps_abs</VAR>, double <VAR>eps_rel</VAR>, double <VAR>a_y</VAR>, double <VAR>a_dydt</VAR>, const double <VAR>scale_abs</VAR>[], size_t <VAR>dim</VAR>)</I>
<DD><A NAME="IDX1934"></A>
This function creates a new control object which uses the same algorithm
as <CODE>gsl_odeiv_control_standard_new</CODE> but with an absolute error
which is scaled for each component by the array <VAR>scale_abs</VAR>.
The formula for D_i for this control object is,

<SPAN class="ifinfo">


<PRE class="example">
D_i = eps_abs * s_i + eps_rel * (a_y |y_i| + a_dydt h |y'_i|)
</PRE>

</SPAN>

<P>
where s_i is the i-th component of the array <VAR>scale_abs</VAR>.
The same error control heuristic is used by the Matlab ODE suite. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_odeiv_control * <B>gsl_odeiv_control_alloc</B> <I>(const gsl_odeiv_control_type * <VAR>T</VAR>)</I>
<DD><A NAME="IDX1935"></A>
This function returns a pointer to a newly allocated instance of a
control function of type <VAR>T</VAR>.  This function is only needed for
defining new types of control functions.  For most purposes the standard
control functions described above should be sufficient. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_odeiv_control_init</B> <I>(gsl_odeiv_control * <VAR>c</VAR>, double <VAR>eps_abs</VAR>, double <VAR>eps_rel</VAR>, double <VAR>a_y</VAR>, double <VAR>a_dydt</VAR>)</I>
<DD><A NAME="IDX1936"></A>
This function initializes the control function <VAR>c</VAR> with the
parameters <VAR>eps_abs</VAR> (absolute error), <VAR>eps_rel</VAR> (relative
error), <VAR>a_y</VAR> (scaling factor for y) and <VAR>a_dydt</VAR> (scaling
factor for derivatives).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_odeiv_control_free</B> <I>(gsl_odeiv_control * <VAR>c</VAR>)</I>
<DD><A NAME="IDX1937"></A>
This function frees all the memory associated with the control function
<VAR>c</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_odeiv_control_hadjust</B> <I>(gsl_odeiv_control * <VAR>c</VAR>, gsl_odeiv_step * <VAR>s</VAR>, const double <VAR>y0</VAR>[], const double <VAR>yerr</VAR>[], const double <VAR>dydt</VAR>[], double * <VAR>h</VAR>)</I>
<DD><A NAME="IDX1938"></A>
This function adjusts the step-size <VAR>h</VAR> using the control function
<VAR>c</VAR>, and the current values of <VAR>y</VAR>, <VAR>yerr</VAR> and <VAR>dydt</VAR>.
The stepping function <VAR>step</VAR> is also needed to determine the order
of the method.  If the error in the y-values <VAR>yerr</VAR> is found to be
too large then the step-size <VAR>h</VAR> is reduced and the function returns
<CODE>GSL_ODEIV_HADJ_DEC</CODE>.  If the error is sufficiently small then
<VAR>h</VAR> may be increased and <CODE>GSL_ODEIV_HADJ_INC</CODE> is returned.  The
function returns <CODE>GSL_ODEIV_HADJ_NIL</CODE> if the step-size is
unchanged.  The goal of the function is to estimate the largest
step-size which satisfies the user-specified accuracy requirements for
the current point.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> const char * <B>gsl_odeiv_control_name</B> <I>(const gsl_odeiv_control * <VAR>c</VAR>)</I>
<DD><A NAME="IDX1939"></A>
This function returns a pointer to the name of the control function.
For example,

</P>

<PRE class="example">
printf ("control method is '%s'\n", 
        gsl_odeiv_control_name (c));
</PRE>

<P>
would print something like <CODE>control method is 'standard'</CODE>
</DL>

</P>



<H2><A NAME="SEC395" HREF="gsl_manual.html#TOC395">Evolution</A></H2>

<P>
The highest level of the system is the evolution function which combines
the results of a stepping function and control function to reliably
advance the solution forward over an interval (t_0, t_1).  If the
control function signals that the step-size should be decreased the
evolution function backs out of the current step and tries the proposed
smaller step-size.  This process is continued until an acceptable
step-size is found.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_odeiv_evolve * <B>gsl_odeiv_evolve_alloc</B> <I>(size_t <VAR>dim</VAR>)</I>
<DD><A NAME="IDX1940"></A>
This function returns a pointer to a newly allocated instance of an
evolution function for a system of <VAR>dim</VAR> dimensions.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_odeiv_evolve_apply</B> <I>(gsl_odeiv_evolve * <VAR>e</VAR>, gsl_odeiv_control * <VAR>con</VAR>, gsl_odeiv_step * <VAR>step</VAR>, const gsl_odeiv_system * <VAR>dydt</VAR>, double * <VAR>t</VAR>, double <VAR>t1</VAR>, double * <VAR>h</VAR>, double <VAR>y</VAR>[])</I>
<DD><A NAME="IDX1941"></A>
This function advances the system (<VAR>e</VAR>, <VAR>dydt</VAR>) from time
<VAR>t</VAR> and position <VAR>y</VAR> using the stepping function <VAR>step</VAR>.
The new time and position are stored in <VAR>t</VAR> and <VAR>y</VAR> on output.
The initial step-size is taken as <VAR>h</VAR>, but this will be modified
using the control function <VAR>c</VAR> to achieve the appropriate error
bound if necessary.  The routine may make several calls to <VAR>step</VAR> in
order to determine the optimum step-size. If the step-size has been
changed the value of <VAR>h</VAR> will be modified on output.  The maximum
time <VAR>t1</VAR> is guaranteed not to be exceeded by the time-step.  On the
final time-step the value of <VAR>t</VAR> will be set to <VAR>t1</VAR> exactly.

</P>
<P>
If the user-supplied functions defined in the system <VAR>dydt</VAR> return a
status other than <CODE>GSL_SUCCESS</CODE> the step will be aborted.  In this
case,  <VAR>t</VAR> and <VAR>y</VAR> will be restored to their pre-step values
and the error code from the user-supplied function will be returned.  To
distinguish between error codes from the user-supplied functions and
those from <CODE>gsl_odeiv_evolve_apply</CODE> itself, any user-defined return
values should be distinct from the standard GSL error codes.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_odeiv_evolve_reset</B> <I>(gsl_odeiv_evolve * <VAR>e</VAR>)</I>
<DD><A NAME="IDX1942"></A>
This function resets the evolution function <VAR>e</VAR>.  It should be used
whenever the next use of <VAR>e</VAR> will not be a continuation of a
previous step.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_odeiv_evolve_free</B> <I>(gsl_odeiv_evolve * <VAR>e</VAR>)</I>
<DD><A NAME="IDX1943"></A>
This function frees all the memory associated with the evolution function
<VAR>e</VAR>.
</DL>

</P>


<H2><A NAME="SEC396" HREF="gsl_manual.html#TOC396">Examples</A></H2>
<P>
<A NAME="IDX1944"></A>
The following program solves the second-order nonlinear Van der Pol
oscillator equation,

<SPAN class="ifinfo">


<PRE class="example">
x"(t) + \mu x'(t) (x(t)^2 - 1) + x(t) = 0
</PRE>

</SPAN>

<P>
This can be converted into a first order system suitable for use with
the routines described in this chapter by introducing a separate
variable for the velocity, y = x'(t),

<SPAN class="ifinfo">


<PRE class="example">
x' = y
y' = -x + \mu y (1-x^2)
</PRE>

</SPAN>

<P>
The program begins by defining functions for these derivatives and
their Jacobian,

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_errno.h&#62;
#include &#60;gsl/gsl_matrix.h&#62;
#include &#60;gsl/gsl_odeiv.h&#62;

int
func (double t, const double y[], double f[],
      void *params)
{
  double mu = *(double *)params;
  f[0] = y[1];
  f[1] = -y[0] - mu*y[1]*(y[0]*y[0] - 1);
  return GSL_SUCCESS;
}

int
jac (double t, const double y[], double *dfdy, 
     double dfdt[], void *params)
{
  double mu = *(double *)params;
  gsl_matrix_view dfdy_mat 
    = gsl_matrix_view_array (dfdy, 2, 2);
  gsl_matrix * m = &#38;dfdy_mat.matrix; 
  gsl_matrix_set (m, 0, 0, 0.0);
  gsl_matrix_set (m, 0, 1, 1.0);
  gsl_matrix_set (m, 1, 0, -2.0*mu*y[0]*y[1] - 1.0);
  gsl_matrix_set (m, 1, 1, -mu*(y[0]*y[0] - 1.0));
  dfdt[0] = 0.0;
  dfdt[1] = 0.0;
  return GSL_SUCCESS;
}

int
main (void)
{
  const gsl_odeiv_step_type * T 
    = gsl_odeiv_step_rk8pd;

  gsl_odeiv_step * s 
    = gsl_odeiv_step_alloc (T, 2);
  gsl_odeiv_control * c 
    = gsl_odeiv_control_y_new (1e-6, 0.0);
  gsl_odeiv_evolve * e 
    = gsl_odeiv_evolve_alloc (2);

  double mu = 10;
  gsl_odeiv_system sys = {func, jac, 2, &#38;mu};

  double t = 0.0, t1 = 100.0;
  double h = 1e-6;
  double y[2] = { 1.0, 0.0 };

  while (t &#60; t1)
    {
      int status = gsl_odeiv_evolve_apply (e, c, s,
                                           &#38;sys, 
                                           &#38;t, t1,
                                           &#38;h, y);

      if (status != GSL_SUCCESS)
          break;

      printf ("%.5e %.5e %.5e\n", t, y[0], y[1]);
    }

  gsl_odeiv_evolve_free (e);
  gsl_odeiv_control_free (c);
  gsl_odeiv_step_free (s);
  return 0;
}
</PRE>

<P>
The main loop of the program evolves the solution from (y, y') =
(1, 0) at t=0 to t=100.  The step-size h is
automatically adjusted by the controller to maintain an absolute
accuracy of 
10^{-6} in the function values <VAR>y</VAR>.

</P>
<P>
<BR><IMG SRC="vdp"><BR>
Numerical solution of the Van der Pol oscillator equation 
using Prince-Dormand 8th order Runge-Kutta.

</P>
<P>
To obtain the values at regular intervals, rather than the variable
spacings chosen by the control function, the main loop can be modified
to advance the solution from one point to the next.  For example, the
following main loop prints the solution at the fixed points t = 0,
1, 2, \dots, 100,

</P>

<PRE class="example">
  for (i = 1; i &#60;= 100; i++)
    {
      double ti = i * t1 / 100.0;

      while (t &#60; ti)
        {
          gsl_odeiv_evolve_apply (e, c, s, 
                                  &#38;sys, 
                                  &#38;t, ti, &#38;h,
                                  y);
        }
 
      printf ("%.5e %.5e %.5e\n", t, y[0], y[1]);
    }
</PRE>

<P>
It is also possible to work with a non-adaptive integrator, using only
the stepping function itself.  The following program uses the <CODE>rk4</CODE>
fourth-order Runge-Kutta stepping function with a fixed stepsize of
0.01,

</P>

<PRE class="example">
int
main (void)
{
  const gsl_odeiv_step_type * T 
    = gsl_odeiv_step_rk4;

  gsl_odeiv_step * s 
    = gsl_odeiv_step_alloc (T, 2);

  double mu = 10;
  gsl_odeiv_system sys = {func, jac, 2, &#38;mu};

  double t = 0.0, t1 = 100.0;
  double h = 1e-2;
  double y[2] = { 1.0, 0.0 }, y_err[2];
  double dydt_in[2], dydt_out[2];

  /* initialise dydt_in from system parameters */
  GSL_ODEIV_FN_EVAL(&#38;sys, t, y, dydt_in);

  while (t &#60; t1)
    {
      int status = gsl_odeiv_step_apply (s, t, h, 
                                         y, y_err, 
                                         dydt_in, 
                                         dydt_out, 
                                         &#38;sys);

      if (status != GSL_SUCCESS)
          break;

      dydt_in[0] = dydt_out[0];
      dydt_in[1] = dydt_out[1];

      t += h;

      printf ("%.5e %.5e %.5e\n", t, y[0], y[1]);
    }

  gsl_odeiv_step_free (s);
  return 0;
}
</PRE>

<P>
The derivatives must be initialized for the starting point t=0
before the first step is taken.  Subsequent steps use the output
derivatives <VAR>dydt_out</VAR> as inputs to the next step by copying their
values into <VAR>dydt_in</VAR>.

</P>


<H2><A NAME="SEC397" HREF="gsl_manual.html#TOC397">References and Further Reading</A></H2>

<P>
Many of the basic Runge-Kutta formulas can be found in the Handbook of
Mathematical Functions,

</P>

<UL class="itemize">
<LI>

Abramowitz &#38; Stegun (eds.), <CITE>Handbook of Mathematical Functions</CITE>,
Section 25.5.
</UL>

<P>
The implicit Bulirsch-Stoer algorithm <CODE>bsimp</CODE> is described in the
following paper,

</P>

<UL class="itemize">
<LI>

G. Bader and P. Deuflhard, "A Semi-Implicit Mid-Point Rule for Stiff
Systems of Ordinary Differential Equations.", Numer. Math. 41, 373--398,
1983.
</UL>



<H1><A NAME="SEC398" HREF="gsl_manual.html#TOC398">Interpolation</A></H1>
<P>
<A NAME="IDX1945"></A>
<A NAME="IDX1946"></A>

</P>
<P>
This chapter describes functions for performing interpolation.  The
library provides a variety of interpolation methods, including Cubic
splines and Akima splines.  The interpolation types are interchangeable,
allowing different methods to be used without recompiling.
Interpolations can be defined for both normal and periodic boundary
conditions.  Additional functions are available for computing
derivatives and integrals of interpolating functions.

</P>
<P>
The functions described in this section are declared in the header files
<TT>'gsl_interp.h'</TT> and <TT>'gsl_spline.h'</TT>.

</P>



<H2><A NAME="SEC399" HREF="gsl_manual.html#TOC399">Introduction</A></H2>

<P>
Given a set of data points (x_1, y_1) \dots (x_n, y_n) the
routines described in this section compute a continuous interpolating
function y(x) such that y(x_i) = y_i.  The interpolation
is piecewise smooth, and its behavior at the end-points is determined by
the type of interpolation used.

</P>


<H2><A NAME="SEC400" HREF="gsl_manual.html#TOC400">Interpolation Functions</A></H2>

<P>
The interpolation function for a given dataset is stored in a
<CODE>gsl_interp</CODE> object.  These are created by the following functions.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_interp * <B>gsl_interp_alloc</B> <I>(const gsl_interp_type * <VAR>T</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX1947"></A>
This function returns a pointer to a newly allocated interpolation
object of type <VAR>T</VAR> for <VAR>size</VAR> data-points.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_interp_init</B> <I>(gsl_interp * <VAR>interp</VAR>, const double <VAR>xa</VAR>[], const double <VAR>ya</VAR>[], size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX1948"></A>
This function initializes the interpolation object <VAR>interp</VAR> for the
data (<VAR>xa</VAR>,<VAR>ya</VAR>) where <VAR>xa</VAR> and <VAR>ya</VAR> are arrays of size
<VAR>size</VAR>.  The interpolation object (<CODE>gsl_interp</CODE>) does not save
the data arrays <VAR>xa</VAR> and <VAR>ya</VAR> and only stores the static state
computed from the data.  The <VAR>xa</VAR> data array is always assumed to be
strictly ordered; the behavior for other arrangements is not defined.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_interp_free</B> <I>(gsl_interp * <VAR>interp</VAR>)</I>
<DD><A NAME="IDX1949"></A>
This function frees the interpolation object <VAR>interp</VAR>.
</DL>

</P>


<H2><A NAME="SEC401" HREF="gsl_manual.html#TOC401">Interpolation Types</A></H2>

<P>
The interpolation library provides five interpolation types:

</P>
<P>
<DL>
<DT><U>Interpolation Type:</U> <B>gsl_interp_linear</B>
<DD><A NAME="IDX1950"></A>
<A NAME="IDX1951"></A>
Linear interpolation.  This interpolation method does not require any
additional memory.
</DL>

</P>
<P>
<DL>
<DT><U>Interpolation Type:</U> <B>gsl_interp_polynomial</B>
<DD><A NAME="IDX1952"></A>
<A NAME="IDX1953"></A>
Polynomial interpolation.  This method should only be used for
interpolating small numbers of points because polynomial interpolation
introduces large oscillations, even for well-behaved datasets.  The
number of terms in the interpolating polynomial is equal to the number
of points.
</DL>

</P>
<P>
<DL>
<DT><U>Interpolation Type:</U> <B>gsl_interp_cspline</B>
<DD><A NAME="IDX1954"></A>
<A NAME="IDX1955"></A>
Cubic spline with natural boundary conditions.
</DL>

</P>
<P>
<DL>
<DT><U>Interpolation Type:</U> <B>gsl_interp_cspline_periodic</B>
<DD><A NAME="IDX1956"></A>
Cubic spline with periodic boundary conditions
</DL>

</P>
<P>
<DL>
<DT><U>Interpolation Type:</U> <B>gsl_interp_akima</B>
<DD><A NAME="IDX1957"></A>
<A NAME="IDX1958"></A>
Non-rounded Akima spline with natural boundary conditions.  This method
uses the non-rounded corner algorithm of Wodicka.
</DL>

</P>
<P>
<DL>
<DT><U>Interpolation Type:</U> <B>gsl_interp_akima_periodic</B>
<DD><A NAME="IDX1959"></A>
Non-rounded Akima spline with periodic boundary conditions.  This method
uses the non-rounded corner algorithm of Wodicka.
</DL>

</P>
<P>
The following related functions are available:

</P>
<P>
<DL>
<DT><U>Function:</U> const char * <B>gsl_interp_name</B> <I>(const gsl_interp * <VAR>interp</VAR>)</I>
<DD><A NAME="IDX1960"></A>
This function returns the name of the interpolation type used by <VAR>interp</VAR>.
For example,

</P>

<PRE class="example">
printf ("interp uses '%s' interpolation.\n", 
        gsl_interp_name (interp));
</PRE>

<P>
would print something like,

</P>

<PRE class="example">
interp uses 'cspline' interpolation.
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> unsigned int <B>gsl_interp_min_size</B> <I>(const gsl_interp * <VAR>interp</VAR>)</I>
<DD><A NAME="IDX1961"></A>
This function returns the minimum number of points required by the
interpolation type of <VAR>interp</VAR>.  For example, Akima spline interpolation
requires a minimum of 5 points.
</DL>

</P>


<H2><A NAME="SEC402" HREF="gsl_manual.html#TOC402">Index Look-up and Acceleration</A></H2>

<P>
The state of searches can be stored in a <CODE>gsl_interp_accel</CODE> object,
which is a kind of iterator for interpolation lookups.  It caches the
previous value of an index lookup.  When the subsequent interpolation
point falls in the same interval its index value can be returned
immediately.

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_interp_bsearch</B> <I>(const double <VAR>x_array</VAR>[], double <VAR>x</VAR>, size_t <VAR>index_lo</VAR>, size_t <VAR>index_hi</VAR>)</I>
<DD><A NAME="IDX1962"></A>
This function returns the index i of the array <VAR>x_array</VAR> such
that <CODE>x_array[i] &#60;= x &#60; x_array[i+1]</CODE>.  The index is searched for
in the range [<VAR>index_lo</VAR>,<VAR>index_hi</VAR>].
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_interp_accel * <B>gsl_interp_accel_alloc</B> <I>(void)</I>
<DD><A NAME="IDX1963"></A>
This function returns a pointer to an accelerator object, which is a
kind of iterator for interpolation lookups.  It tracks the state of
lookups, thus allowing for application of various acceleration
strategies.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>gsl_interp_accel_find</B> <I>(gsl_interp_accel * <VAR>a</VAR>, const double <VAR>x_array</VAR>[], size_t <VAR>size</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1964"></A>
This function performs a lookup action on the data array <VAR>x_array</VAR>
of size <VAR>size</VAR>, using the given accelerator <VAR>a</VAR>.  This is how
lookups are performed during evaluation of an interpolation.  The
function returns an index i such that <CODE>x_array[i] &#60;= x &#60;
x_array[i+1]</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_interp_accel_free</B> <I>(gsl_interp_accel* <VAR>acc</VAR>)</I>
<DD><A NAME="IDX1965"></A>
This function frees the accelerator object <VAR>acc</VAR>.
</DL>

</P>


<H2><A NAME="SEC403" HREF="gsl_manual.html#TOC403">Evaluation of Interpolating Functions</A></H2>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_interp_eval</B> <I>(const gsl_interp * <VAR>interp</VAR>, const double <VAR>xa</VAR>[], const double <VAR>ya</VAR>[], double <VAR>x</VAR>, gsl_interp_accel * <VAR>acc</VAR>)</I>
<DD><A NAME="IDX1966"></A>
<DT><U>Function:</U> int <B>gsl_interp_eval_e</B> <I>(const gsl_interp * <VAR>interp</VAR>, const double <VAR>xa</VAR>[], const double <VAR>ya</VAR>[], double <VAR>x</VAR>, gsl_interp_accel * <VAR>acc</VAR>, double * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1967"></A>
These functions return the interpolated value of <VAR>y</VAR> for a given
point <VAR>x</VAR>, using the interpolation object <VAR>interp</VAR>, data arrays
<VAR>xa</VAR> and <VAR>ya</VAR> and the accelerator <VAR>acc</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_interp_eval_deriv</B> <I>(const gsl_interp * <VAR>interp</VAR>, const double <VAR>xa</VAR>[], const double <VAR>ya</VAR>[], double <VAR>x</VAR>, gsl_interp_accel * <VAR>acc</VAR>)</I>
<DD><A NAME="IDX1968"></A>
<DT><U>Function:</U> int <B>gsl_interp_eval_deriv_e</B> <I>(const gsl_interp * <VAR>interp</VAR>, const double <VAR>xa</VAR>[], const double <VAR>ya</VAR>[], double <VAR>x</VAR>, gsl_interp_accel * <VAR>acc</VAR>, double * <VAR>d</VAR>)</I>
<DD><A NAME="IDX1969"></A>
These functions return the derivative <VAR>d</VAR> of an interpolated
function for a given point <VAR>x</VAR>, using the interpolation object
<VAR>interp</VAR>, data arrays <VAR>xa</VAR> and <VAR>ya</VAR> and the accelerator
<VAR>acc</VAR>. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_interp_eval_deriv2</B> <I>(const gsl_interp * <VAR>interp</VAR>, const double <VAR>xa</VAR>[], const double <VAR>ya</VAR>[], double <VAR>x</VAR>, gsl_interp_accel * <VAR>acc</VAR>)</I>
<DD><A NAME="IDX1970"></A>
<DT><U>Function:</U> int <B>gsl_interp_eval_deriv2_e</B> <I>(const gsl_interp * <VAR>interp</VAR>, const double <VAR>xa</VAR>[], const double <VAR>ya</VAR>[], double <VAR>x</VAR>, gsl_interp_accel * <VAR>acc</VAR>, double * <VAR>d2</VAR>)</I>
<DD><A NAME="IDX1971"></A>
These functions return the second derivative <VAR>d2</VAR> of an interpolated
function for a given point <VAR>x</VAR>, using the interpolation object
<VAR>interp</VAR>, data arrays <VAR>xa</VAR> and <VAR>ya</VAR> and the accelerator
<VAR>acc</VAR>. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_interp_eval_integ</B> <I>(const gsl_interp * <VAR>interp</VAR>, const double <VAR>xa</VAR>[], const double <VAR>ya</VAR>[], double <VAR>a</VAR>, double <VAR>b</VAR>, gsl_interp_accel * <VAR>acc</VAR>)</I>
<DD><A NAME="IDX1972"></A>
<DT><U>Function:</U> int <B>gsl_interp_eval_integ_e</B> <I>(const gsl_interp * <VAR>interp</VAR>, const double <VAR>xa</VAR>[], const double <VAR>ya</VAR>[], double <VAR>a</VAR>, double <VAR>b</VAR>, gsl_interp_accel * <VAR>acc</VAR>, double * <VAR>result</VAR>)</I>
<DD><A NAME="IDX1973"></A>
These functions return the numerical integral <VAR>result</VAR> of an
interpolated function over the range [<VAR>a</VAR>, <VAR>b</VAR>], using the
interpolation object <VAR>interp</VAR>, data arrays <VAR>xa</VAR> and <VAR>ya</VAR> and
the accelerator <VAR>acc</VAR>.
</DL>

</P>


<H2><A NAME="SEC404" HREF="gsl_manual.html#TOC404">Higher-level Interface</A></H2>

<P>
The functions described in the previous sections required the user to
supply pointers to the x and y arrays on each call.  The
following functions are equivalent to the corresponding
<CODE>gsl_interp</CODE> functions but maintain a copy of this data in the
<CODE>gsl_spline</CODE> object.  This removes the need to pass both <VAR>xa</VAR>
and <VAR>ya</VAR> as arguments on each evaluation. These functions are
defined in the header file <TT>'gsl_spline.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_spline * <B>gsl_spline_alloc</B> <I>(const gsl_interp_type * <VAR>T</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX1974"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_spline_init</B> <I>(gsl_spline * <VAR>spline</VAR>, const double <VAR>xa</VAR>[], const double <VAR>ya</VAR>[], size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX1975"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_spline_free</B> <I>(gsl_spline * <VAR>spline</VAR>)</I>
<DD><A NAME="IDX1976"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_spline_eval</B> <I>(const gsl_spline * <VAR>spline</VAR>, double <VAR>x</VAR>, gsl_interp_accel * <VAR>acc</VAR>)</I>
<DD><A NAME="IDX1977"></A>
<DT><U>Function:</U> int <B>gsl_spline_eval_e</B> <I>(const gsl_spline * <VAR>spline</VAR>, double <VAR>x</VAR>, gsl_interp_accel * <VAR>acc</VAR>, double * <VAR>y</VAR>)</I>
<DD><A NAME="IDX1978"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_spline_eval_deriv</B> <I>(const gsl_spline * <VAR>spline</VAR>, double <VAR>x</VAR>, gsl_interp_accel * <VAR>acc</VAR>)</I>
<DD><A NAME="IDX1979"></A>
<DT><U>Function:</U> int <B>gsl_spline_eval_deriv_e</B> <I>(const gsl_spline * <VAR>spline</VAR>, double <VAR>x</VAR>, gsl_interp_accel * <VAR>acc</VAR>, double * <VAR>d</VAR>)</I>
<DD><A NAME="IDX1980"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_spline_eval_deriv2</B> <I>(const gsl_spline * <VAR>spline</VAR>, double <VAR>x</VAR>, gsl_interp_accel * <VAR>acc</VAR>)</I>
<DD><A NAME="IDX1981"></A>
<DT><U>Function:</U> int <B>gsl_spline_eval_deriv2_e</B> <I>(const gsl_spline * <VAR>spline</VAR>, double <VAR>x</VAR>, gsl_interp_accel * <VAR>acc</VAR>, double * <VAR>d2</VAR>)</I>
<DD><A NAME="IDX1982"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_spline_eval_integ</B> <I>(const gsl_spline * <VAR>spline</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>, gsl_interp_accel * <VAR>acc</VAR>)</I>
<DD><A NAME="IDX1983"></A>
<DT><U>Function:</U> int <B>gsl_spline_eval_integ_e</B> <I>(const gsl_spline * <VAR>spline</VAR>, double <VAR>a</VAR>, double <VAR>b</VAR>, gsl_interp_accel * <VAR>acc</VAR>, double * <VAR>result</VAR>)</I>
<DD><A NAME="IDX1984"></A>
</DL>

</P>


<H2><A NAME="SEC405" HREF="gsl_manual.html#TOC405">Examples</A></H2>

<P>
The following program demonstrates the use of the interpolation and
spline functions.  It computes a cubic spline interpolation of the
10-point dataset (x_i, y_i) where x_i = i + \sin(i)/2 and
y_i = i + \cos(i^2) for i = 0 \dots 9.

</P>

<PRE class="example">
#include &#60;stdlib.h&#62;
#include &#60;stdio.h&#62;
#include &#60;math.h&#62;
#include &#60;gsl/gsl_errno.h&#62;
#include &#60;gsl/gsl_spline.h&#62;

int
main (void)
{
  int i;
  double xi, yi, x[10], y[10];

  printf ("#m=0,S=2\n");

  for (i = 0; i &#60; 10; i++)
    {
      x[i] = i + 0.5 * sin (i);
      y[i] = i + cos (i * i);
      printf ("%g %g\n", x[i], y[i]);
    }

  printf ("#m=1,S=0\n");

  {
    gsl_interp_accel *acc 
      = gsl_interp_accel_alloc ();
    gsl_spline *spline 
      = gsl_spline_alloc (gsl_interp_cspline, 10);

    gsl_spline_init (spline, x, y, 10);

    for (xi = x[0]; xi &#60; x[9]; xi += 0.01)
      {
        yi = gsl_spline_eval (spline, xi, acc);
        printf ("%g %g\n", xi, yi);
      }
    gsl_spline_free (spline);
    gsl_interp_accel_free (acc);
  }
  return 0;
}
</PRE>

<P>
The output is designed to be used with the GNU plotutils
<CODE>graph</CODE> program,

</P>

<PRE class="example">
$ ./a.out &#62; interp.dat
$ graph -T ps &#60; interp.dat &#62; interp.ps
</PRE>

<P>
<BR><IMG SRC="interp2"><BR>
The result shows a smooth interpolation of the original points.  The
interpolation method can changed simply by varying the first argument of
<CODE>gsl_spline_alloc</CODE>.

</P>



<H2><A NAME="SEC406" HREF="gsl_manual.html#TOC406">References and Further Reading</A></H2>

<P>
Descriptions of the interpolation algorithms and further references can
be found in the following book,

</P>

<UL class="itemize">
<LI>C.W. Ueberhuber,

<CITE>Numerical Computation (Volume 1), Chapter 9 "Interpolation"</CITE>,
Springer (1997), ISBN 3-540-62058-3.
</UL>

<P>

</P>


<H1><A NAME="SEC407" HREF="gsl_manual.html#TOC407">Numerical Differentiation</A></H1>
<P>
<A NAME="IDX1985"></A>
<A NAME="IDX1986"></A>
<A NAME="IDX1987"></A>
<A NAME="IDX1988"></A>
<A NAME="IDX1989"></A>

</P>
<P>
The functions described in this chapter compute numerical derivatives by
finite differencing.  An adaptive algorithm is used to find the best
choice of finite difference and to estimate the error in the derivative.
These functions are declared in the header file <TT>'gsl_deriv.h'</TT>.

</P>



<H2><A NAME="SEC408" HREF="gsl_manual.html#TOC408">Functions</A></H2>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_deriv_central</B> <I>(const gsl_function * <VAR>f</VAR>, double <VAR>x</VAR>, double <VAR>h</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX1990"></A>
This function computes the numerical derivative of the function <VAR>f</VAR>
at the point <VAR>x</VAR> using an adaptive central difference algorithm with
a step-size of <VAR>h</VAR>.   The derivative is returned in <VAR>result</VAR> and an
estimate of its absolute error is returned in <VAR>abserr</VAR>.

</P>
<P>
The initial value of <VAR>h</VAR> is used to estimate an optimal step-size,
based on the scaling of the truncation error and round-off error in the
derivative calculation.  The derivative is computed using a 5-point rule
for equally spaced abscissae at x-h, x-h/2, x,
x+h/2, x, with an error estimate taken from the difference
between the 5-point rule and the corresponding 3-point rule x-h,
x, x+h.  Note that the value of the function at x
does not contribute to the derivative calculation, so only 4-points are
actually used.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_deriv_forward</B> <I>(const gsl_function * <VAR>f</VAR>, double <VAR>x</VAR>, double <VAR>h</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX1991"></A>
This function computes the numerical derivative of the function <VAR>f</VAR>
at the point <VAR>x</VAR> using an adaptive forward difference algorithm with
a step-size of <VAR>h</VAR>. The function is evaluated only at points greater
than <VAR>x</VAR>, and never at <VAR>x</VAR> itself.  The derivative is returned in
<VAR>result</VAR> and an estimate of its absolute error is returned in
<VAR>abserr</VAR>.  This function should be used if f(x) has a
discontinuity at <VAR>x</VAR>, or is undefined for values less than <VAR>x</VAR>.

</P>
<P>
The initial value of <VAR>h</VAR> is used to estimate an optimal step-size,
based on the scaling of the truncation error and round-off error in the
derivative calculation.  The derivative at x is computed using an
"open" 4-point rule for equally spaced abscissae at x+h/4,
x+h/2, x+3h/4, x+h, with an error estimate taken
from the difference between the 4-point rule and the corresponding
2-point rule x+h/2, x+h. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_deriv_backward</B> <I>(const gsl_function * <VAR>f</VAR>, double <VAR>x</VAR>, double <VAR>h</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX1992"></A>
This function computes the numerical derivative of the function <VAR>f</VAR>
at the point <VAR>x</VAR> using an adaptive backward difference algorithm
with a step-size of <VAR>h</VAR>. The function is evaluated only at points
less than <VAR>x</VAR>, and never at <VAR>x</VAR> itself.  The derivative is
returned in <VAR>result</VAR> and an estimate of its absolute error is
returned in <VAR>abserr</VAR>.  This function should be used if f(x)
has a discontinuity at <VAR>x</VAR>, or is undefined for values greater than
<VAR>x</VAR>.

</P>
<P>
This function is equivalent to calling <CODE>gsl_deriv_forward</CODE> with a
negative step-size.
</DL>

</P>


<H2><A NAME="SEC409" HREF="gsl_manual.html#TOC409">Examples</A></H2>

<P>
The following code estimates the derivative of the function 
f(x) = x^{3/2} 
at x=2 and at x=0.  The function f(x) is
undefined for x&#60;0 so the derivative at x=0 is computed
using <CODE>gsl_deriv_forward</CODE>.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_math.h&#62;
#include &#60;gsl/gsl_deriv.h&#62;

double f (double x, void * params)
{
  return pow (x, 1.5);
}

int
main (void)
{
  gsl_function F;
  double result, abserr;

  F.function = &#38;f;
  F.params = 0;

  printf ("f(x) = x^(3/2)\n");

  gsl_deriv_central (&#38;F, 2.0, 1e-8, &#38;result, &#38;abserr);
  printf ("x = 2.0\n");
  printf ("f'(x) = %.10f +/- %.10f\n", result, abserr);
  printf ("exact = %.10f\n\n", 1.5 * sqrt(2.0));

  gsl_deriv_forward (&#38;F, 0.0, 1e-8, &#38;result, &#38;abserr);
  printf ("x = 0.0\n");
  printf ("f'(x) = %.10f +/- %.10f\n", result, abserr);
  printf ("exact = %.10f\n", 0.0);

  return 0;
}
</PRE>

<P>
Here is the output of the program,

</P>

<PRE class="example">
$ ./a.out
f(x) = x^(3/2)
x = 2.0
f'(x) = 2.1213203120 +/- 0.0000004064
exact = 2.1213203436

x = 0.0
f'(x) = 0.0000000160 +/- 0.0000000339
exact = 0.0000000000
</PRE>



<H2><A NAME="SEC410" HREF="gsl_manual.html#TOC410">References and Further Reading</A></H2>

<P>
The algorithms used by these functions are described in the following sources:

</P>

<UL class="itemize">
<LI>

Abramowitz and Stegun, <CITE>Handbook of Mathematical Functions</CITE>,
Section 25.3.4, and Table 25.5 (Coefficients for Differentiation).

<LI>

S.D. Conte and Carl de Boor, <CITE>Elementary Numerical Analysis: An
Algorithmic Approach</CITE>, McGraw-Hill, 1972.
</UL>



<H1><A NAME="SEC411" HREF="gsl_manual.html#TOC411">Chebyshev Approximations</A></H1>
<P>
<A NAME="IDX1993"></A>
<A NAME="IDX1994"></A>
<A NAME="IDX1995"></A>

</P>
<P>
This chapter describes routines for computing Chebyshev approximations
to univariate functions.  A Chebyshev approximation is a truncation of
the series f(x) = \sum c_n T_n(x), where the Chebyshev
polynomials T_n(x) = \cos(n \arccos x) provide an orthogonal
basis of polynomials on the interval [-1,1] with the weight
function 
1 / \sqrt{1-x^2}.  The first few Chebyshev polynomials are,
T_0(x) = 1, T_1(x) = x, T_2(x) = 2 x^2 - 1.
For further information see Abramowitz &#38; Stegun, Chapter 22. 

</P>
<P>
The functions described in this chapter are declared in the header file
<TT>'gsl_chebyshev.h'</TT>.

</P>



<H2><A NAME="SEC412" HREF="gsl_manual.html#TOC412">Definitions</A></H2>

<P>
A Chebyshev series  is stored using the following structure,

</P>

<PRE class="example">
typedef struct
{
  double * c;   /* coefficients  c[0] .. c[order] */
  int order;    /* order of expansion             */
  double a;     /* lower interval point           */
  double b;     /* upper interval point           */
} gsl_cheb_struct
</PRE>

<P>
The approximation is made over the range [a,b] using
<VAR>order</VAR>+1 terms, including the coefficient c[0].  The series
is computed using the following convention,

<SPAN class="ifinfo">


<PRE class="example">
f(x) = (c_0 / 2) + \sum_{n=1} c_n T_n(x)
</PRE>

</SPAN>

<P>
which is needed when accessing the coefficients directly.

</P>


<H2><A NAME="SEC413" HREF="gsl_manual.html#TOC413">Creation and Calculation of Chebyshev Series</A></H2>

<P>
<DL>
<DT><U>Function:</U> gsl_cheb_series * <B>gsl_cheb_alloc</B> <I>(const size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX1996"></A>
This function allocates space for a Chebyshev series of order <VAR>n</VAR>
and returns a pointer to a new <CODE>gsl_cheb_series</CODE> struct.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_cheb_free</B> <I>(gsl_cheb_series * <VAR>cs</VAR>)</I>
<DD><A NAME="IDX1997"></A>
This function frees a previously allocated Chebyshev series <VAR>cs</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_cheb_init</B> <I>(gsl_cheb_series * <VAR>cs</VAR>, const gsl_function * <VAR>f</VAR>, const double <VAR>a</VAR>, const double <VAR>b</VAR>)</I>
<DD><A NAME="IDX1998"></A>
This function computes the Chebyshev approximation <VAR>cs</VAR> for the
function <VAR>f</VAR> over the range (a,b) to the previously specified
order.  The computation of the Chebyshev approximation is an
O(n^2) process, and requires n function evaluations.
</DL>

</P>


<H2><A NAME="SEC414" HREF="gsl_manual.html#TOC414">Chebyshev Series Evaluation</A></H2>

<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cheb_eval</B> <I>(const gsl_cheb_series * <VAR>cs</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1999"></A>
This function evaluates the Chebyshev series <VAR>cs</VAR> at a given point <VAR>x</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_cheb_eval_err</B> <I>(const gsl_cheb_series * <VAR>cs</VAR>, const double <VAR>x</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX2000"></A>
This function computes the Chebyshev series <VAR>cs</VAR> at a given point
<VAR>x</VAR>, estimating both the series <VAR>result</VAR> and its absolute error
<VAR>abserr</VAR>.  The error estimate is made from the first neglected term
in the series.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_cheb_eval_n</B> <I>(const gsl_cheb_series * <VAR>cs</VAR>, size_t <VAR>order</VAR>, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2001"></A>
This function evaluates the Chebyshev series <VAR>cs</VAR> at a given point
<VAR>n</VAR>, to (at most) the given order <VAR>order</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_cheb_eval_n_err</B> <I>(const gsl_cheb_series * <VAR>cs</VAR>, const size_t <VAR>order</VAR>, const double <VAR>x</VAR>, double * <VAR>result</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX2002"></A>
This function evaluates a Chebyshev series <VAR>cs</VAR> at a given point
<VAR>x</VAR>, estimating both the series <VAR>result</VAR> and its absolute error
<VAR>abserr</VAR>, to (at most) the given order <VAR>order</VAR>.  The error
estimate is made from the first neglected term in the series.
</DL>

</P>



<H2><A NAME="SEC415" HREF="gsl_manual.html#TOC415">Derivatives and Integrals</A></H2>

<P>
The following functions allow a Chebyshev series to be differentiated or
integrated, producing a new Chebyshev series.  Note that the error
estimate produced by evaluating the derivative series will be
underestimated due to the contribution of higher order terms being
neglected.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_cheb_calc_deriv</B> <I>(gsl_cheb_series * <VAR>deriv</VAR>, const gsl_cheb_series * <VAR>cs</VAR>)</I>
<DD><A NAME="IDX2003"></A>
This function computes the derivative of the series <VAR>cs</VAR>, storing
the derivative coefficients in the previously allocated <VAR>deriv</VAR>.
The two series <VAR>cs</VAR> and <VAR>deriv</VAR> must have been allocated with
the same order.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_cheb_calc_integ</B> <I>(gsl_cheb_series * <VAR>integ</VAR>, const gsl_cheb_series * <VAR>cs</VAR>)</I>
<DD><A NAME="IDX2004"></A>
This function computes the integral of the series <VAR>cs</VAR>, storing the
integral coefficients in the previously allocated <VAR>integ</VAR>.  The two
series <VAR>cs</VAR> and <VAR>integ</VAR> must have been allocated with the same
order.  The lower limit of the integration is taken to be the left hand
end of the range <VAR>a</VAR>.
</DL>

</P>


<H2><A NAME="SEC416" HREF="gsl_manual.html#TOC416">Examples</A></H2>

<P>
The following example program computes Chebyshev approximations to a
step function.  This is an extremely difficult approximation to make,
due to the discontinuity, and was chosen as an example where
approximation error is visible.  For smooth functions the Chebyshev
approximation converges extremely rapidly and errors would not be
visible.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_math.h&#62;
#include &#60;gsl/gsl_chebyshev.h&#62;

double
f (double x, void *p)
{
  if (x &#60; 0.5)
    return 0.25;
  else
    return 0.75;
}

int
main (void)
{
  int i, n = 10000; 

  gsl_cheb_series *cs = gsl_cheb_alloc (40);

  gsl_function F;

  F.function = f;
  F.params = 0;

  gsl_cheb_init (cs, &#38;F, 0.0, 1.0);

  for (i = 0; i &#60; n; i++)
    {
      double x = i / (double)n;
      double r10 = gsl_cheb_eval_n (cs, 10, x);
      double r40 = gsl_cheb_eval (cs, x);
      printf ("%g %g %g %g\n", 
              x, GSL_FN_EVAL (&#38;F, x), r10, r40);
    }

  gsl_cheb_free (cs);

  return 0;
}
</PRE>

<P>
The output from the program gives the original function, 10-th order
approximation and 40-th order approximation, all sampled at intervals of
0.001 in x.

</P>
<P>
<BR><IMG SRC="cheb"><BR>

</P>


<H2><A NAME="SEC417" HREF="gsl_manual.html#TOC417">References and Further Reading</A></H2>

<P>
The following paper describes the use of Chebyshev series,

</P>

<UL class="itemize">
<LI>

R. Broucke, "Ten Subroutines for the Manipulation of Chebyshev Series
[C1] (Algorithm 446)". <CITE>Communications of the ACM</CITE> 16(4), 254--256
(1973)
</UL>



<H1><A NAME="SEC418" HREF="gsl_manual.html#TOC418">Series Acceleration</A></H1>
<P>
<A NAME="IDX2005"></A>
<A NAME="IDX2006"></A>
<A NAME="IDX2007"></A>
<A NAME="IDX2008"></A>
<A NAME="IDX2009"></A>
<A NAME="IDX2010"></A>

</P>
<P>
The functions described in this chapter accelerate the convergence of a
series using the Levin u-transform.  This method takes a small number of
terms from the start of a series and uses a systematic approximation to
compute an extrapolated value and an estimate of its error.  The
u-transform works for both convergent and divergent series, including
asymptotic series.

</P>
<P>
These functions are declared in the header file <TT>'gsl_sum.h'</TT>.

</P>



<H2><A NAME="SEC419" HREF="gsl_manual.html#TOC419">Acceleration functions</A></H2>

<P>
The following functions compute the full Levin u-transform of a series
with its error estimate.  The error estimate is computed by propagating
rounding errors from each term through to the final extrapolation. 

</P>
<P>
These functions are intended for summing analytic series where each term
is known to high accuracy, and the rounding errors are assumed to
originate from finite precision. They are taken to be relative errors of
order <CODE>GSL_DBL_EPSILON</CODE> for each term.

</P>
<P>
The calculation of the error in the extrapolated value is an
O(N^2) process, which is expensive in time and memory.  A faster
but less reliable method which estimates the error from the convergence
of the extrapolated value is described in the next section.  For the
method described here a full table of intermediate values and
derivatives through to O(N) must be computed and stored, but this
does give a reliable error estimate.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_sum_levin_u_workspace * <B>gsl_sum_levin_u_alloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX2011"></A>
This function allocates a workspace for a Levin u-transform of <VAR>n</VAR>
terms.  The size of the workspace is O(2n^2 + 3n).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sum_levin_u_free</B> <I>(gsl_sum_levin_u_workspace * <VAR>w</VAR>)</I>
<DD><A NAME="IDX2012"></A>
This function frees the memory associated with the workspace <VAR>w</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sum_levin_u_accel</B> <I>(const double * <VAR>array</VAR>, size_t <VAR>array_size</VAR>, gsl_sum_levin_u_workspace * <VAR>w</VAR>, double * <VAR>sum_accel</VAR>, double * <VAR>abserr</VAR>)</I>
<DD><A NAME="IDX2013"></A>
This function takes the terms of a series in <VAR>array</VAR> of size
<VAR>array_size</VAR> and computes the extrapolated limit of the series using
a Levin u-transform.  Additional working space must be provided in
<VAR>w</VAR>.  The extrapolated sum is stored in <VAR>sum_accel</VAR>, with an
estimate of the absolute error stored in <VAR>abserr</VAR>.  The actual
term-by-term sum is returned in <CODE>w-&#62;sum_plain</CODE>. The algorithm
calculates the truncation error (the difference between two successive
extrapolations) and round-off error (propagated from the individual
terms) to choose an optimal number of terms for the extrapolation.
</DL>

</P>



<H2><A NAME="SEC420" HREF="gsl_manual.html#TOC420">Acceleration functions without error estimation</A></H2>

<P>
The functions described in this section compute the Levin u-transform of
series and attempt to estimate the error from the "truncation error" in
the extrapolation, the difference between the final two approximations.
Using this method avoids the need to compute an intermediate table of
derivatives because the error is estimated from the behavior of the
extrapolated value itself. Consequently this algorithm is an O(N)
process and only requires O(N) terms of storage.  If the series
converges sufficiently fast then this procedure can be acceptable.  It
is appropriate to use this method when there is a need to compute many
extrapolations of series with similar convergence properties at high-speed.
For example, when numerically integrating a function defined by a
parameterized series where the parameter varies only slightly. A
reliable error estimate should be computed first using the full
algorithm described above in order to verify the consistency of the
results.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_sum_levin_utrunc_workspace * <B>gsl_sum_levin_utrunc_alloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX2014"></A>
This function allocates a workspace for a Levin u-transform of <VAR>n</VAR>
terms, without error estimation.  The size of the workspace is
O(3n).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sum_levin_utrunc_free</B> <I>(gsl_sum_levin_utrunc_workspace * <VAR>w</VAR>)</I>
<DD><A NAME="IDX2015"></A>
This function frees the memory associated with the workspace <VAR>w</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_sum_levin_utrunc_accel</B> <I>(const double * <VAR>array</VAR>, size_t <VAR>array_size</VAR>, gsl_sum_levin_utrunc_workspace * <VAR>w</VAR>, double * <VAR>sum_accel</VAR>, double * <VAR>abserr_trunc</VAR>)</I>
<DD><A NAME="IDX2016"></A>
This function takes the terms of a series in <VAR>array</VAR> of size
<VAR>array_size</VAR> and computes the extrapolated limit of the series using
a Levin u-transform.  Additional working space must be provided in
<VAR>w</VAR>.  The extrapolated sum is stored in <VAR>sum_accel</VAR>.  The actual
term-by-term sum is returned in <CODE>w-&#62;sum_plain</CODE>. The algorithm
terminates when the difference between two successive extrapolations
reaches a minimum or is sufficiently small. The difference between these
two values is used as estimate of the error and is stored in
<VAR>abserr_trunc</VAR>.  To improve the reliability of the algorithm the
extrapolated values are replaced by moving averages when calculating the
truncation error, smoothing out any fluctuations.
</DL>

</P>



<H2><A NAME="SEC421" HREF="gsl_manual.html#TOC421">Examples</A></H2>

<P>
The following code calculates an estimate of \zeta(2) = \pi^2 / 6
using the series,

<SPAN class="ifinfo">


<PRE class="example">
\zeta(2) = 1 + 1/2^2 + 1/3^2 + 1/4^2 + ...
</PRE>

</SPAN>

<P>
After <VAR>N</VAR> terms the error in the sum is O(1/N), making direct
summation of the series converge slowly.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_math.h&#62;
#include &#60;gsl/gsl_sum.h&#62;

#define N 20

int
main (void)
{
  double t[N];
  double sum_accel, err;
  double sum = 0;
  int n;
  
  gsl_sum_levin_u_workspace * w 
    = gsl_sum_levin_u_alloc (N);

  const double zeta_2 = M_PI * M_PI / 6.0;
  
  /* terms for zeta(2) = \sum_{n=1}^{\infty} 1/n^2 */

  for (n = 0; n &#60; N; n++)
    {
      double np1 = n + 1.0;
      t[n] = 1.0 / (np1 * np1);
      sum += t[n];
    }
  
  gsl_sum_levin_u_accel (t, N, w, &#38;sum_accel, &#38;err);

  printf ("term-by-term sum = % .16f using %d terms\n", 
          sum, N);

  printf ("term-by-term sum = % .16f using %d terms\n", 
          w-&#62;sum_plain, w-&#62;terms_used);

  printf ("exact value      = % .16f\n", zeta_2);
  printf ("accelerated sum  = % .16f using %d terms\n", 
          sum_accel, w-&#62;terms_used);

  printf ("estimated error  = % .16f\n", err);
  printf ("actual error     = % .16f\n", 
          sum_accel - zeta_2);

  gsl_sum_levin_u_free (w);
  return 0;
}
</PRE>

<P>
The output below shows that the Levin u-transform is able to obtain an 
estimate of the sum to 1 part in 
10^10 using the first eleven terms of the series.  The
error estimate returned by the function is also accurate, giving
the correct number of significant digits. 

</P>

<PRE class="example">
$ ./a.out 
term-by-term sum =  1.5961632439130233 using 20 terms
term-by-term sum =  1.5759958390005426 using 13 terms
exact value      =  1.6449340668482264
accelerated sum  =  1.6449340668166479 using 13 terms
estimated error  =  0.0000000000508580
actual error     = -0.0000000000315785
</PRE>

<P>
Note that a direct summation of this series would require 
10^10 terms to achieve the same precision as the accelerated 
sum does in 13 terms.

</P>


<H2><A NAME="SEC422" HREF="gsl_manual.html#TOC422">References and Further Reading</A></H2>

<P>
The algorithms used by these functions are described in the following papers,

</P>

<UL class="itemize">
<LI>

T. Fessler, W.F. Ford, D.A. Smith,
HURRY: An acceleration algorithm for scalar sequences and series
<CITE>ACM Transactions on Mathematical Software</CITE>, 9(3):346--354, 1983.
and Algorithm 602 9(3):355--357, 1983.
</UL>

<P>
The theory of the u-transform was presented by Levin,

</P>

<UL class="itemize">
<LI>

D. Levin,
Development of Non-Linear Transformations for Improving Convergence of
Sequences, <CITE>Intern. J. Computer Math.</CITE> B3:371--388, 1973.
</UL>

<P>
A review paper on the Levin Transform is available online,

<UL class="itemize">
<LI>

Herbert H. H. Homeier, Scalar Levin-Type Sequence Transformations,
<A HREF="http://arxiv.org/abs/math/0005209">http://arxiv.org/abs/math/0005209</A>.
</UL>



<H1><A NAME="SEC423" HREF="gsl_manual.html#TOC423">Wavelet Transforms</A></H1>
<P>
<A NAME="IDX2017"></A>
<A NAME="IDX2018"></A>
<A NAME="IDX2019"></A>

</P>
<P>
This chapter describes functions for performing Discrete Wavelet
Transforms (DWTs).  The library includes wavelets for real data in both
one and two dimensions.  The wavelet functions are declared in the header
files <TT>'gsl_wavelet.h'</TT> and <TT>'gsl_wavelet2d.h'</TT>.

</P>



<H2><A NAME="SEC424" HREF="gsl_manual.html#TOC424">Definitions</A></H2>
<P>
<A NAME="IDX2020"></A>

</P>
<P>
The continuous wavelet transform and its inverse are defined by
the relations,

<SPAN class="ifinfo">


<PRE class="example">
w(s,\tau) = \int f(t) * \psi^*_{s,\tau}(t) dt
</PRE>

</SPAN>

<P>
and,

<SPAN class="ifinfo">


<PRE class="example">
f(t) = \int \int_{-\infty}^\infty w(s, \tau) * \psi_{s,\tau}(t) d\tau ds
</PRE>

</SPAN>

<P>
where the basis functions 
\psi_{s,\tau} are obtained by scaling
and translation from a single function, referred to as the <I>mother
wavelet</I>.

</P>
<P>
The discrete version of the wavelet transform acts on equally-spaced
samples, with fixed scaling and translation steps (s,
\tau).  The frequency and time axes are sampled <I>dyadically</I>
on scales of 2^j through a level parameter j.
The resulting family of functions 
{\psi_{j,n}}
constitutes an orthonormal
basis for square-integrable signals.  

</P>
<P>
The discrete wavelet transform is an O(N) algorithm, and is also
referred to as the <I>fast wavelet transform</I>.

</P>


<H2><A NAME="SEC425" HREF="gsl_manual.html#TOC425">Initialization</A></H2>
<P>
<A NAME="IDX2021"></A>

</P>
<P>
The <CODE>gsl_wavelet</CODE> structure contains the filter coefficients
defining the wavelet and any associated offset parameters.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_wavelet * <B>gsl_wavelet_alloc</B> <I>(const gsl_wavelet_type * <VAR>T</VAR>, size_t <VAR>k</VAR>)</I>
<DD><A NAME="IDX2022"></A>
This function allocates and initializes a wavelet object of type
<VAR>T</VAR>.  The parameter <VAR>k</VAR> selects the specific member of the
wavelet family.  A null pointer is returned if insufficient memory is
available or if a unsupported member is selected.
</DL>

</P>
<P>
The following wavelet types are implemented:

</P>
<P>
<DL>
<DT><U>Wavelet:</U> <B>gsl_wavelet_daubechies</B>
<DD><A NAME="IDX2023"></A>
<DT><U>Wavelet:</U> <B>gsl_wavelet_daubechies_centered</B>
<DD><A NAME="IDX2024"></A>
<A NAME="IDX2025"></A>
<A NAME="IDX2026"></A>
The is the Daubechies wavelet family of maximum phase with k/2
vanishing moments.  The implemented wavelets are 
k=4, 6, ..., 20, with <VAR>k</VAR> even.
</DL>

</P>
<P>
<DL>
<DT><U>Wavelet:</U> <B>gsl_wavelet_haar</B>
<DD><A NAME="IDX2027"></A>
<DT><U>Wavelet:</U> <B>gsl_wavelet_haar_centered</B>
<DD><A NAME="IDX2028"></A>
<A NAME="IDX2029"></A>
This is the Haar wavelet.  The only valid choice of k for the
Haar wavelet is k=2.
</DL>

</P>
<P>
<DL>
<DT><U>Wavelet:</U> <B>gsl_wavelet_bspline</B>
<DD><A NAME="IDX2030"></A>
<DT><U>Wavelet:</U> <B>gsl_wavelet_bspline_centered</B>
<DD><A NAME="IDX2031"></A>
<A NAME="IDX2032"></A>
<A NAME="IDX2033"></A>
This is the biorthogonal B-spline wavelet family of order (i,j).  
The implemented values of k = 100*i + j are 103, 105, 202, 204,
206, 208, 301, 303, 305 307, 309.
</DL>

</P>
<P>
The centered forms of the wavelets align the coefficients of the various
sub-bands on edges.  Thus the resulting visualization of the
coefficients of the wavelet transform in the phase plane is easier to
understand.

</P>
<P>
<DL>
<DT><U>Function:</U> const char * <B>gsl_wavelet_name</B> <I>(const gsl_wavelet * <VAR>w</VAR>)</I>
<DD><A NAME="IDX2034"></A>
This function returns a pointer to the name of the wavelet family for
<VAR>w</VAR>.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> void <B>gsl_wavelet_free</B> <I>(gsl_wavelet * <VAR>w</VAR>)</I>
<DD><A NAME="IDX2035"></A>
This function frees the wavelet object <VAR>w</VAR>.
</DL>

</P>
<P>
The <CODE>gsl_wavelet_workspace</CODE> structure contains scratch space of the
same size as the input data and is used to hold intermediate results
during the transform.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_wavelet_workspace * <B>gsl_wavelet_workspace_alloc</B> <I>(size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX2036"></A>
This function allocates a workspace for the discrete wavelet transform.
To perform a one-dimensional transform on <VAR>n</VAR> elements, a workspace
of size <VAR>n</VAR> must be provided.  For two-dimensional transforms of
<VAR>n</VAR>-by-<VAR>n</VAR> matrices it is sufficient to allocate a workspace of
size <VAR>n</VAR>, since the transform operates on individual rows and
columns.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_wavelet_workspace_free</B> <I>(gsl_wavelet_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2037"></A>
This function frees the allocated workspace <VAR>work</VAR>.
</DL>

</P>


<H2><A NAME="SEC426" HREF="gsl_manual.html#TOC426">Transform Functions</A></H2>

<P>
This sections describes the actual functions performing the discrete
wavelet transform.  Note that the transforms use periodic boundary
conditions.  If the signal is not periodic in the sample length then
spurious coefficients will appear at the beginning and end of each level
of the transform.

</P>



<H3><A NAME="SEC427" HREF="gsl_manual.html#TOC427">Wavelet transforms in one dimension</A></H3>
<P>
<A NAME="IDX2038"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_wavelet_transform</B> <I>(const gsl_wavelet * <VAR>w</VAR>, double * <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, gsl_wavelet_direction <VAR>dir</VAR>, gsl_wavelet_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2039"></A>
<DT><U>Function:</U> int <B>gsl_wavelet_transform_forward</B> <I>(const gsl_wavelet * <VAR>w</VAR>, double * <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, gsl_wavelet_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2040"></A>
<DT><U>Function:</U> int <B>gsl_wavelet_transform_inverse</B> <I>(const gsl_wavelet * <VAR>w</VAR>, double * <VAR>data</VAR>, size_t <VAR>stride</VAR>, size_t <VAR>n</VAR>, gsl_wavelet_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2041"></A>

</P>
<P>
These functions compute in-place forward and inverse discrete wavelet
transforms of length <VAR>n</VAR> with stride <VAR>stride</VAR> on the array
<VAR>data</VAR>. The length of the transform <VAR>n</VAR> is restricted to powers
of two.  For the <CODE>transform</CODE> version of the function the argument
<VAR>dir</VAR> can be either <CODE>forward</CODE> (+1) or <CODE>backward</CODE>
(-1).  A workspace <VAR>work</VAR> of length <VAR>n</VAR> must be provided.

</P>
<P>
For the forward transform, the elements of the original array are 
replaced by the discrete wavelet
transform 
f_i -&#62; w_{j,k} 
in a packed triangular storage layout, 
where <VAR>j</VAR> is the index of the level 
j = 0 ... J-1
and
<VAR>k</VAR> is the index of the coefficient within each level,
k = 0 ... (2^j)-1.  
The total number of levels is J = \log_2(n).  The output data
has the following form,

<SPAN class="ifinfo">


<PRE class="example">
(s_{-1,0}, d_{0,0}, d_{1,0}, d_{1,1}, d_{2,0}, ..., 
  d_{j,k}, ..., d_{J-1,2^{J-1}-1}) 
</PRE>

</SPAN>

<P>
where the first element is the smoothing coefficient s_{-1,0},
followed by the detail coefficients d_{j,k} for each level
j.  The backward transform inverts these coefficients to obtain 
the original data.

</P>
<P>
These functions return a status of <CODE>GSL_SUCCESS</CODE> upon successful
completion.  <CODE>GSL_EINVAL</CODE> is returned if <VAR>n</VAR> is not an integer
power of 2 or if insufficient workspace is provided.
</DL>

</P>


<H3><A NAME="SEC428" HREF="gsl_manual.html#TOC428">Wavelet transforms in two dimension</A></H3>
<P>
<A NAME="IDX2042"></A>

</P>
<P>
The library provides functions to perform two-dimensional discrete
wavelet transforms on square matrices.  The matrix dimensions must be an
integer power of two.  There are two possible orderings of the rows and
columns in the two-dimensional wavelet transform, referred to as the
"standard" and "non-standard" forms.

</P>
<P>
The "standard" transform performs a complete discrete wavelet
transform on the rows of the matrix, followed by a separate complete
discrete wavelet transform on the columns of the resulting
row-transformed matrix.  This procedure uses the same ordering as a
two-dimensional fourier transform.

</P>
<P>
The "non-standard" transform is performed in interleaved passes on the
rows and columns of the matrix for each level of the transform.  The
first level of the transform is applied to the matrix rows, and then to
the matrix columns.  This procedure is then repeated across the rows and
columns of the data for the subsequent levels of the transform, until
the full discrete wavelet transform is complete.  The non-standard form
of the discrete wavelet transform is typically used in image analysis.

</P>
<P>
The functions described in this section are declared in the header file
<TT>'gsl_wavelet2d.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_wavelet2d_transform</B> <I>(const gsl_wavelet * <VAR>w</VAR>, double * <VAR>data</VAR>, size_t <VAR>tda</VAR>, size_t <VAR>size1</VAR>, size_t <VAR>size2</VAR>, gsl_wavelet_direction <VAR>dir</VAR>, gsl_wavelet_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2043"></A>
<DT><U>Function:</U> int <B>gsl_wavelet2d_transform_forward</B> <I>(const gsl_wavelet * <VAR>w</VAR>, double * <VAR>data</VAR>, size_t <VAR>tda</VAR>, size_t <VAR>size1</VAR>, size_t <VAR>size2</VAR>, gsl_wavelet_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2044"></A>
<DT><U>Function:</U> int <B>gsl_wavelet2d_transform_inverse</B> <I>(const gsl_wavelet * <VAR>w</VAR>, double * <VAR>data</VAR>, size_t <VAR>tda</VAR>, size_t <VAR>size1</VAR>, size_t <VAR>size2</VAR>, gsl_wavelet_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2045"></A>

</P>
<P>
These functions compute two-dimensional in-place forward and inverse
discrete wavelet transforms in standard and non-standard forms on the
array <VAR>data</VAR> stored in row-major form with dimensions <VAR>size1</VAR>
and <VAR>size2</VAR> and physical row length <VAR>tda</VAR>.  The dimensions must
be equal (square matrix) and are restricted to powers of two.  For the
<CODE>transform</CODE> version of the function the argument <VAR>dir</VAR> can be
either <CODE>forward</CODE> (+1) or <CODE>backward</CODE> (-1).  A
workspace <VAR>work</VAR> of the appropriate size must be provided.  On exit,
the appropriate elements of the array <VAR>data</VAR> are replaced by their
two-dimensional wavelet transform.

</P>
<P>
The functions return a status of <CODE>GSL_SUCCESS</CODE> upon successful
completion.  <CODE>GSL_EINVAL</CODE> is returned if <VAR>size1</VAR> and
<VAR>size2</VAR> are not equal and integer powers of 2, or if insufficient
workspace is provided.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_wavelet2d_transform_matrix</B> <I>(const gsl_wavelet * <VAR>w</VAR>, gsl_matrix * <VAR>m</VAR>, gsl_wavelet_direction <VAR>dir</VAR>, gsl_wavelet_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2046"></A>
<DT><U>Function:</U> int <B>gsl_wavelet2d_transform_matrix_forward</B> <I>(const gsl_wavelet * <VAR>w</VAR>, gsl_matrix * <VAR>m</VAR>, gsl_wavelet_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2047"></A>
<DT><U>Function:</U> int <B>gsl_wavelet2d_transform_matrix_inverse</B> <I>(const gsl_wavelet * <VAR>w</VAR>, gsl_matrix * <VAR>m</VAR>, gsl_wavelet_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2048"></A>
These functions compute the two-dimensional in-place wavelet transform
on a matrix <VAR>a</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_wavelet2d_nstransform</B> <I>(const gsl_wavelet * <VAR>w</VAR>, double * <VAR>data</VAR>, size_t <VAR>tda</VAR>, size_t <VAR>size1</VAR>, size_t <VAR>size2</VAR>, gsl_wavelet_direction <VAR>dir</VAR>, gsl_wavelet_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2049"></A>
<DT><U>Function:</U> int <B>gsl_wavelet2d_nstransform_forward</B> <I>(const gsl_wavelet * <VAR>w</VAR>, double * <VAR>data</VAR>, size_t <VAR>tda</VAR>, size_t <VAR>size1</VAR>, size_t <VAR>size2</VAR>, gsl_wavelet_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2050"></A>
<DT><U>Function:</U> int <B>gsl_wavelet2d_nstransform_inverse</B> <I>(const gsl_wavelet * <VAR>w</VAR>, double * <VAR>data</VAR>, size_t <VAR>tda</VAR>, size_t <VAR>size1</VAR>, size_t <VAR>size2</VAR>, gsl_wavelet_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2051"></A>
These functions compute the two-dimensional wavelet transform in
non-standard form.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_wavelet2d_nstransform_matrix</B> <I>(const gsl_wavelet * <VAR>w</VAR>, gsl_matrix * <VAR>m</VAR>, gsl_wavelet_direction <VAR>dir</VAR>, gsl_wavelet_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2052"></A>
<DT><U>Function:</U> int <B>gsl_wavelet2d_nstransform_matrix_forward</B> <I>(const gsl_wavelet * <VAR>w</VAR>, gsl_matrix * <VAR>m</VAR>, gsl_wavelet_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2053"></A>
<DT><U>Function:</U> int <B>gsl_wavelet2d_nstransform_matrix_inverse</B> <I>(const gsl_wavelet * <VAR>w</VAR>, gsl_matrix * <VAR>m</VAR>, gsl_wavelet_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2054"></A>
These functions compute the non-standard form of the two-dimensional
in-place wavelet transform on a matrix <VAR>a</VAR>.
</DL>

</P>


<H2><A NAME="SEC429" HREF="gsl_manual.html#TOC429">Examples</A></H2>

<P>
The following program demonstrates the use of the one-dimensional
wavelet transform functions.  It computes an approximation to an input
signal (of length 256) using the 20 largest components of the wavelet
transform, while setting the others to zero.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;math.h&#62;
#include &#60;gsl/gsl_sort.h&#62;
#include &#60;gsl/gsl_wavelet.h&#62;

int
main (int argc, char **argv)
{
  int i, n = 256, nc = 20;
  double *data = malloc (n * sizeof (double));
  double *abscoeff = malloc (n * sizeof (double));
  size_t *p = malloc (n * sizeof (size_t));

  gsl_wavelet *w;
  gsl_wavelet_workspace *work;

  w = gsl_wavelet_alloc (gsl_wavelet_daubechies, 4);
  work = gsl_wavelet_workspace_alloc (n);

  FILE *f = fopen (argv[1], "r");
  for (i = 0; i &#60; n; i++)
    {
      fscanf (f, "%lg", &#38;data[i]);
    }
  fclose (f);

  gsl_wavelet_transform_forward (w, data, 1, n, work);

  for (i = 0; i &#60; n; i++)
    {
      abscoeff[i] = fabs (data[i]);
    }
  
  gsl_sort_index (p, abscoeff, 1, n);
  
  for (i = 0; (i + nc) &#60; n; i++)
    data[p[i]] = 0;
  
  gsl_wavelet_transform_inverse (w, data, 1, n, work);
  
  for (i = 0; i &#60; n; i++)
    {
      printf ("%g\n", data[i]);
    }
}
</PRE>

<P>
The output can be used with the GNU plotutils <CODE>graph</CODE> program,

</P>

<PRE class="example">
$ ./a.out ecg.dat &#62; dwt.dat
$ graph -T ps -x 0 256 32 -h 0.3 -a dwt.dat &#62; dwt.ps
</PRE>

<P>
The graphs below show an original and compressed version of a sample ECG
recording from the MIT-BIH Arrhythmia Database, part of the PhysioNet
archive of public-domain of medical datasets.

</P>
<P>
<BR><IMG SRC="dwt-orig"><BR> 
<BR><IMG SRC="dwt-samp"><BR> 

<BLOCKQUOTE class="quotation">
<P>
Original (upper) and wavelet-compressed (lower) ECG signals, using the
20 largest components of the Daubechies(4) discrete wavelet transform.
</BLOCKQUOTE>



<H2><A NAME="SEC430" HREF="gsl_manual.html#TOC430">References and Further Reading</A></H2>

<P>
The mathematical background to wavelet transforms is covered in the
original lectures by Daubechies,

</P>

<UL class="itemize">
<LI>

Ingrid Daubechies.
Ten Lectures on Wavelets.
<CITE>CBMS-NSF Regional Conference Series in Applied Mathematics</CITE> (1992), 
SIAM, ISBN 0898712742.
</UL>

<P>
An easy to read introduction to the subject with an emphasis on the
application of the wavelet transform in various branches of science is,

</P>

<UL class="itemize">
<LI>

Paul S. Addison. <CITE>The Illustrated Wavelet Transform Handbook</CITE>.
Institute of Physics Publishing (2002), ISBN 0750306920.
</UL>

<P>
For extensive coverage of signal analysis by wavelets, wavelet packets
and local cosine bases see,

</P>

<UL class="itemize">
<LI>

S. G. Mallat.  <CITE>A wavelet tour of signal processing</CITE> (Second
edition). Academic Press (1999), ISBN 012466606X.
</UL>

<P>
The concept of multiresolution analysis underlying the wavelet transform
is described in,

</P>

<UL class="itemize">
<LI>

S. G. Mallat.
Multiresolution Approximations and Wavelet Orthonormal Bases of L^2(R).
<CITE>Transactions of the American Mathematical Society</CITE>, 315(1), 1989, 69--87.
</UL>


<UL class="itemize">
<LI>

S. G. Mallat.
A Theory for Multiresolution Signal Decomposition--The Wavelet Representation.
<CITE>IEEE Transactions on Pattern Analysis and Machine Intelligence</CITE>, 11, 1989,
674--693. 
</UL>

<P>
The coefficients for the individual wavelet families implemented by the
library can be found in the following papers,

</P>

<UL class="itemize">
<LI>

I. Daubechies.
Orthonormal Bases of Compactly Supported Wavelets.
<CITE>Communications on Pure and Applied Mathematics</CITE>, 41 (1988) 909--996.
</UL>


<UL class="itemize">
<LI>

A. Cohen, I. Daubechies, and J.-C. Feauveau.
Biorthogonal Bases of Compactly Supported Wavelets.
<CITE>Communications on Pure and Applied Mathematics</CITE>, 45 (1992)
485--560.
</UL>

<P>
The PhysioNet archive of physiological datasets can be found online at
<A HREF="http://www.physionet.org/">http://www.physionet.org/</A> and is described in the following
paper,

</P>

<UL class="itemize">
<LI>

Goldberger et al.  
PhysioBank, PhysioToolkit, and PhysioNet: Components
of a New Research Resource for Complex Physiologic
Signals. 
<CITE>Circulation</CITE> 101(23):e215-e220 2000.
</UL>



<H1><A NAME="SEC431" HREF="gsl_manual.html#TOC431">Discrete Hankel Transforms</A></H1>
<P>
<A NAME="IDX2055"></A>
<A NAME="IDX2056"></A>
<A NAME="IDX2057"></A>
This chapter describes functions for performing Discrete Hankel
Transforms (DHTs).  The functions are declared in the header file
<TT>'gsl_dht.h'</TT>.

</P>



<H2><A NAME="SEC432" HREF="gsl_manual.html#TOC432">Definitions</A></H2>

<P>
The discrete Hankel transform acts on a vector of sampled data, where
the samples are assumed to have been taken at points related to the
zeroes of a Bessel function of fixed order; compare this to the case of
the discrete Fourier transform, where samples are taken at points
related to the zeroes of the sine or cosine function.

</P>
<P>
Specifically, let f(t) be a function on the unit interval.
Then the finite \nu-Hankel transform of f(t) is defined
to be the set of numbers g_m given by,
so that,
Suppose that f is band-limited in the sense that
g_m=0 for m &#62; M. Then we have the following
fundamental sampling theorem.
It is this discrete expression which defines the discrete Hankel
transform. The kernel in the summation above defines the matrix of the
\nu-Hankel transform of size M-1.  The coefficients of
this matrix, being dependent on \nu and M, must be
precomputed and stored; the <CODE>gsl_dht</CODE> object encapsulates this
data.  The allocation function <CODE>gsl_dht_alloc</CODE> returns a
<CODE>gsl_dht</CODE> object which must be properly initialized with
<CODE>gsl_dht_init</CODE> before it can be used to perform transforms on data
sample vectors, for fixed \nu and M, using the
<CODE>gsl_dht_apply</CODE> function. The implementation allows a scaling of
the fundamental interval, for convenience, so that one can assume the
function is defined on the interval [0,X], rather than the unit
interval.

</P>
<P>
Notice that by assumption f(t) vanishes at the endpoints
of the interval, consistent with the inversion formula
and the sampling formula given above. Therefore, this transform
corresponds to an orthogonal expansion in eigenfunctions
of the Dirichlet problem for the Bessel differential equation.

</P>



<H2><A NAME="SEC433" HREF="gsl_manual.html#TOC433">Functions</A></H2>

<P>
<DL>
<DT><U>Function:</U> gsl_dht * <B>gsl_dht_alloc</B> <I>(size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX2058"></A>
This function allocates a Discrete Hankel transform object of size
<VAR>size</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_dht_init</B> <I>(gsl_dht * <VAR>t</VAR>, double <VAR>nu</VAR>, double <VAR>xmax</VAR>)</I>
<DD><A NAME="IDX2059"></A>
This function initializes the transform <VAR>t</VAR> for the given values of
<VAR>nu</VAR> and <VAR>x</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_dht * <B>gsl_dht_new</B> <I>(size_t <VAR>size</VAR>, double <VAR>nu</VAR>, double <VAR>xmax</VAR>)</I>
<DD><A NAME="IDX2060"></A>
This function allocates a Discrete Hankel transform object of size
<VAR>size</VAR> and initializes it for the given values of <VAR>nu</VAR> and
<VAR>x</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_dht_free</B> <I>(gsl_dht * <VAR>t</VAR>)</I>
<DD><A NAME="IDX2061"></A>
This function frees the transform <VAR>t</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_dht_apply</B> <I>(const gsl_dht * <VAR>t</VAR>, double * <VAR>f_in</VAR>, double * <VAR>f_out</VAR>)</I>
<DD><A NAME="IDX2062"></A>
This function applies the transform <VAR>t</VAR> to the array <VAR>f_in</VAR>
whose size is equal to the size of the transform.  The result is stored
in the array <VAR>f_out</VAR> which must be of the same length.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_dht_x_sample</B> <I>(const gsl_dht * <VAR>t</VAR>, int <VAR>n</VAR>)</I>
<DD><A NAME="IDX2063"></A>
This function returns the value of the <VAR>n</VAR>-th sample point in the unit interval,
(j_{\nu,n+1}/j_{\nu,M}) X. These are the
points where the function f(t) is assumed to be sampled.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_dht_k_sample</B> <I>(const gsl_dht * <VAR>t</VAR>, int <VAR>n</VAR>)</I>
<DD><A NAME="IDX2064"></A>
This function returns the value of the <VAR>n</VAR>-th sample point in "k-space",
j_{\nu,n+1}/X.
</DL>

</P>


<H2><A NAME="SEC434" HREF="gsl_manual.html#TOC434">References and Further Reading</A></H2>

<P>
The algorithms used by these functions are described in the following papers,

</P>

<UL class="itemize">
<LI>

H. Fisk Johnson, Comp. Phys. Comm. 43, 181 (1987).
</UL>


<UL class="itemize">
<LI>

D. Lemoine, J. Chem. Phys. 101, 3936 (1994).
</UL>



<H1><A NAME="SEC435" HREF="gsl_manual.html#TOC435">One dimensional Root-Finding</A></H1>
<P>
<A NAME="IDX2065"></A>
<A NAME="IDX2066"></A>
<A NAME="IDX2067"></A>
<A NAME="IDX2068"></A>
<A NAME="IDX2069"></A>
<A NAME="IDX2070"></A>
<A NAME="IDX2071"></A>

</P>
<P>
This chapter describes routines for finding roots of arbitrary
one-dimensional functions.  The library provides low level components
for a variety of iterative solvers and convergence tests.  These can be
combined by the user to achieve the desired solution, with full access
to the intermediate steps of the iteration.  Each class of methods uses
the same framework, so that you can switch between solvers at runtime
without needing to recompile your program.  Each instance of a solver
keeps track of its own state, allowing the solvers to be used in
multi-threaded programs.

</P>
<P>
The header file <TT>'gsl_roots.h'</TT> contains prototypes for the root
finding functions and related declarations.

</P>



<H2><A NAME="SEC436" HREF="gsl_manual.html#TOC436">Overview</A></H2>
<P>
<A NAME="IDX2072"></A>

</P>
<P>
One-dimensional root finding algorithms can be divided into two classes,
<I>root bracketing</I> and <I>root polishing</I>.  Algorithms which proceed
by bracketing a root are guaranteed to converge.  Bracketing algorithms
begin with a bounded region known to contain a root.  The size of this
bounded region is reduced, iteratively, until it encloses the root to a
desired tolerance.  This provides a rigorous error estimate for the
location of the root.

</P>
<P>
The technique of <I>root polishing</I> attempts to improve an initial
guess to the root.  These algorithms converge only if started "close
enough" to a root, and sacrifice a rigorous error bound for speed.  By
approximating the behavior of a function in the vicinity of a root they
attempt to find a higher order improvement of an initial guess.  When the
behavior of the function is compatible with the algorithm and a good
initial guess is available a polishing algorithm can provide rapid
convergence.

</P>
<P>
In GSL both types of algorithm are available in similar frameworks.  The
user provides a high-level driver for the algorithms, and the library
provides the individual functions necessary for each of the steps.
There are three main phases of the iteration.  The steps are,

</P>

<UL class="itemize">
<LI>

initialize solver state, <VAR>s</VAR>, for algorithm <VAR>T</VAR>

<LI>

update <VAR>s</VAR> using the iteration <VAR>T</VAR>

<LI>

test <VAR>s</VAR> for convergence, and repeat iteration if necessary
</UL>

<P>
The state for bracketing solvers is held in a <CODE>gsl_root_fsolver</CODE>
struct.  The updating procedure uses only function evaluations (not
derivatives).  The state for root polishing solvers is held in a
<CODE>gsl_root_fdfsolver</CODE> struct.  The updates require both the function
and its derivative (hence the name <CODE>fdf</CODE>) to be supplied by the
user.

</P>


<H2><A NAME="SEC437" HREF="gsl_manual.html#TOC437">Caveats</A></H2>
<P>
<A NAME="IDX2073"></A>

</P>
<P>
Note that root finding functions can only search for one root at a time.
When there are several roots in the search area, the first root to be
found will be returned; however it is difficult to predict which of the
roots this will be. <EM>In most cases, no error will be reported if
you try to find a root in an area where there is more than one.</EM>

</P>
<P>
Care must be taken when a function may have a multiple root (such as 
f(x) = (x-x_0)^2 or 
f(x) = (x-x_0)^3).  
It is not possible to use root-bracketing algorithms on
even-multiplicity roots.  For these algorithms the initial interval must
contain a zero-crossing, where the function is negative at one end of
the interval and positive at the other end.  Roots with even-multiplicity
do not cross zero, but only touch it instantaneously.  Algorithms based
on root bracketing will still work for odd-multiplicity roots
(e.g. cubic, quintic, ...). 
Root polishing algorithms generally work with higher multiplicity roots,
but at a reduced rate of convergence.  In these cases the <I>Steffenson
algorithm</I> can be used to accelerate the convergence of multiple roots.

</P>
<P>
While it is not absolutely required that f have a root within the
search region, numerical root finding functions should not be used
haphazardly to check for the <EM>existence</EM> of roots.  There are better
ways to do this.  Because it is easy to create situations where numerical
root finders can fail, it is a bad idea to throw a root finder at a
function you do not know much about.  In general it is best to examine
the function visually by plotting before searching for a root.

</P>


<H2><A NAME="SEC438" HREF="gsl_manual.html#TOC438">Initializing the Solver</A></H2>

<P>
<DL>
<DT><U>Function:</U> gsl_root_fsolver * <B>gsl_root_fsolver_alloc</B> <I>(const gsl_root_fsolver_type * <VAR>T</VAR>)</I>
<DD><A NAME="IDX2074"></A>
This function returns a pointer to a newly allocated instance of a
solver of type <VAR>T</VAR>.  For example, the following code creates an
instance of a bisection solver,

</P>

<PRE class="example">
const gsl_root_fsolver_type * T 
  = gsl_root_fsolver_bisection;
gsl_root_fsolver * s 
  = gsl_root_fsolver_alloc (T);
</PRE>

<P>
If there is insufficient memory to create the solver then the function
returns a null pointer and the error handler is invoked with an error
code of <CODE>GSL_ENOMEM</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_root_fdfsolver * <B>gsl_root_fdfsolver_alloc</B> <I>(const gsl_root_fdfsolver_type * <VAR>T</VAR>)</I>
<DD><A NAME="IDX2075"></A>
This function returns a pointer to a newly allocated instance of a
derivative-based solver of type <VAR>T</VAR>.  For example, the following
code creates an instance of a Newton-Raphson solver,

</P>

<PRE class="example">
const gsl_root_fdfsolver_type * T 
  = gsl_root_fdfsolver_newton;
gsl_root_fdfsolver * s 
  = gsl_root_fdfsolver_alloc (T);
</PRE>

<P>
If there is insufficient memory to create the solver then the function
returns a null pointer and the error handler is invoked with an error
code of <CODE>GSL_ENOMEM</CODE>.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_root_fsolver_set</B> <I>(gsl_root_fsolver * <VAR>s</VAR>, gsl_function * <VAR>f</VAR>, double <VAR>x_lower</VAR>, double <VAR>x_upper</VAR>)</I>
<DD><A NAME="IDX2076"></A>
This function initializes, or reinitializes, an existing solver <VAR>s</VAR>
to use the function <VAR>f</VAR> and the initial search interval
[<VAR>x_lower</VAR>, <VAR>x_upper</VAR>].
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_root_fdfsolver_set</B> <I>(gsl_root_fdfsolver * <VAR>s</VAR>, gsl_function_fdf * <VAR>fdf</VAR>, double <VAR>root</VAR>)</I>
<DD><A NAME="IDX2077"></A>
This function initializes, or reinitializes, an existing solver <VAR>s</VAR>
to use the function and derivative <VAR>fdf</VAR> and the initial guess
<VAR>root</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_root_fsolver_free</B> <I>(gsl_root_fsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2078"></A>
<DT><U>Function:</U> void <B>gsl_root_fdfsolver_free</B> <I>(gsl_root_fdfsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2079"></A>
These functions free all the memory associated with the solver <VAR>s</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> const char * <B>gsl_root_fsolver_name</B> <I>(const gsl_root_fsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2080"></A>
<DT><U>Function:</U> const char * <B>gsl_root_fdfsolver_name</B> <I>(const gsl_root_fdfsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2081"></A>
These functions return a pointer to the name of the solver.  For example,

</P>

<PRE class="example">
printf ("s is a '%s' solver\n",
        gsl_root_fsolver_name (s));
</PRE>

<P>
would print something like <CODE>s is a 'bisection' solver</CODE>.
</DL>

</P>


<H2><A NAME="SEC439" HREF="gsl_manual.html#TOC439">Providing the function to solve</A></H2>
<P>
<A NAME="IDX2082"></A>

</P>
<P>
You must provide a continuous function of one variable for the root
finders to operate on, and, sometimes, its first derivative.  In order
to allow for general parameters the functions are defined by the
following data types:

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_function</B>
<DD><A NAME="IDX2083"></A>
This data type defines a general function with parameters. 

</P>
<DL COMPACT>

<DT><CODE>double (* function) (double <VAR>x</VAR>, void * <VAR>params</VAR>)</CODE>
<DD>
this function should return the value
f(x,params) for argument <VAR>x</VAR> and parameters <VAR>params</VAR>

<DT><CODE>void * params</CODE>
<DD>
a pointer to the parameters of the function
</DL>
</DL>

<P>
Here is an example for the general quadratic function,

<SPAN class="ifinfo">


<PRE class="example">
f(x) = a x^2 + b x + c
</PRE>

</SPAN>

<P>
with a = 3, b = 2, c = 1.  The following code
defines a <CODE>gsl_function</CODE> <CODE>F</CODE> which you could pass to a root
finder:

</P>

<PRE class="example">
struct my_f_params { double a; double b; double c; };

double
my_f (double x, void * p) {
   struct my_f_params * params 
     = (struct my_f_params *)p;
   double a = (params-&#62;a);
   double b = (params-&#62;b);
   double c = (params-&#62;c);

   return  (a * x + b) * x + c;
}

gsl_function F;
struct my_f_params params = { 3.0, 2.0, 1.0 };

F.function = &#38;my_f;
F.params = &#38;params;
</PRE>

<P>
The function f(x) can be evaluated using the following macro,

</P>

<PRE class="example">
#define GSL_FN_EVAL(F,x) 
    (*((F)-&#62;function))(x,(F)-&#62;params)
</PRE>

<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_function_fdf</B>
<DD><A NAME="IDX2084"></A>
This data type defines a general function with parameters and its first
derivative.

</P>
<DL COMPACT>

<DT><CODE>double (* f) (double <VAR>x</VAR>, void * <VAR>params</VAR>)</CODE>
<DD>
this function should return the value of
f(x,params) for argument <VAR>x</VAR> and parameters <VAR>params</VAR>

<DT><CODE>double (* df) (double <VAR>x</VAR>, void * <VAR>params</VAR>)</CODE>
<DD>
this function should return the value of the derivative of <VAR>f</VAR> with
respect to <VAR>x</VAR>,
f'(x,params), for argument <VAR>x</VAR> and parameters <VAR>params</VAR>

<DT><CODE>void (* fdf) (double <VAR>x</VAR>, void * <VAR>params</VAR>, double * <VAR>f</VAR>, double * <VAR>d</VAR>f)</CODE>
<DD>
this function should set the values of the function <VAR>f</VAR> to 
f(x,params)
and its derivative <VAR>df</VAR> to
f'(x,params) 
for argument <VAR>x</VAR> and parameters <VAR>params</VAR>.  This function
provides an optimization of the separate functions for f(x) and
f'(x)---it is always faster to compute the function and its
derivative at the same time.

<DT><CODE>void * params</CODE>
<DD>
a pointer to the parameters of the function
</DL>
</DL>

<P>
Here is an example where 
f(x) = 2\exp(2x):

</P>

<PRE class="example">
double
my_f (double x, void * params)
{
   return exp (2 * x);
}

double
my_df (double x, void * params)
{
   return 2 * exp (2 * x);
}

void
my_fdf (double x, void * params, 
        double * f, double * df)
{
   double t = exp (2 * x);

   *f = t;
   *df = 2 * t;   /* uses existing value */
}

gsl_function_fdf FDF;

FDF.f = &#38;my_f;
FDF.df = &#38;my_df;
FDF.fdf = &#38;my_fdf;
FDF.params = 0;
</PRE>

<P>
The function f(x) can be evaluated using the following macro,

</P>

<PRE class="example">
#define GSL_FN_FDF_EVAL_F(FDF,x) 
     (*((FDF)-&#62;f))(x,(FDF)-&#62;params)
</PRE>

<P>
The derivative f'(x) can be evaluated using the following macro,

</P>

<PRE class="example">
#define GSL_FN_FDF_EVAL_DF(FDF,x) 
     (*((FDF)-&#62;df))(x,(FDF)-&#62;params)
</PRE>

<P>
and both the function y = f(x) and its derivative dy = f'(x)
can be evaluated at the same time using the following macro,

</P>

<PRE class="example">
#define GSL_FN_FDF_EVAL_F_DF(FDF,x,y,dy) 
     (*((FDF)-&#62;fdf))(x,(FDF)-&#62;params,(y),(dy))
</PRE>

<P>
The macro stores f(x) in its <VAR>y</VAR> argument and f'(x) in
its <VAR>dy</VAR> argument--both of these should be pointers to
<CODE>double</CODE>.

</P>


<H2><A NAME="SEC440" HREF="gsl_manual.html#TOC440">Search Bounds and Guesses</A></H2>
<P>
<A NAME="IDX2085"></A>
<A NAME="IDX2086"></A>

</P>
<P>
You provide either search bounds or an initial guess; this section
explains how search bounds and guesses work and how function arguments
control them.

</P>
<P>
A guess is simply an x value which is iterated until it is within
the desired precision of a root.  It takes the form of a <CODE>double</CODE>.

</P>
<P>
Search bounds are the endpoints of a interval which is iterated until
the length of the interval is smaller than the requested precision.  The
interval is defined by two values, the lower limit and the upper limit.
Whether the endpoints are intended to be included in the interval or not
depends on the context in which the interval is used.

</P>


<H2><A NAME="SEC441" HREF="gsl_manual.html#TOC441">Iteration</A></H2>

<P>
The following functions drive the iteration of each algorithm.  Each
function performs one iteration to update the state of any solver of the
corresponding type.  The same functions work for all solvers so that
different methods can be substituted at runtime without modifications to
the code.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_root_fsolver_iterate</B> <I>(gsl_root_fsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2087"></A>
<DT><U>Function:</U> int <B>gsl_root_fdfsolver_iterate</B> <I>(gsl_root_fdfsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2088"></A>
These functions perform a single iteration of the solver <VAR>s</VAR>.  If the
iteration encounters an unexpected problem then an error code will be
returned,

</P>
<DL COMPACT>

<DT><CODE>GSL_EBADFUNC</CODE>
<DD>
the iteration encountered a singular point where the function or its
derivative evaluated to <CODE>Inf</CODE> or <CODE>NaN</CODE>.

<DT><CODE>GSL_EZERODIV</CODE>
<DD>
the derivative of the function vanished at the iteration point,
preventing the algorithm from continuing without a division by zero.
</DL>
</DL>

<P>
The solver maintains a current best estimate of the root at all
times.  The bracketing solvers also keep track of the current best
interval bounding the root.  This information can be accessed with the
following auxiliary functions,

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_root_fsolver_root</B> <I>(const gsl_root_fsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2089"></A>
<DT><U>Function:</U> double <B>gsl_root_fdfsolver_root</B> <I>(const gsl_root_fdfsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2090"></A>
These functions return the current estimate of the root for the solver <VAR>s</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_root_fsolver_x_lower</B> <I>(const gsl_root_fsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2091"></A>
<DT><U>Function:</U> double <B>gsl_root_fsolver_x_upper</B> <I>(const gsl_root_fsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2092"></A>
These functions return the current bracketing interval for the solver <VAR>s</VAR>.
</DL>

</P>


<H2><A NAME="SEC442" HREF="gsl_manual.html#TOC442">Search Stopping Parameters</A></H2>
<P>
<A NAME="IDX2093"></A>

</P>
<P>
A root finding procedure should stop when one of the following conditions is
true:

</P>

<UL class="itemize">
<LI>

A root has been found to within the user-specified precision.

<LI>

A user-specified maximum number of iterations has been reached.

<LI>

An error has occurred.
</UL>

<P>
The handling of these conditions is under user control.  The functions
below allow the user to test the precision of the current result in
several standard ways.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_root_test_interval</B> <I>(double <VAR>x_lower</VAR>, double <VAR>x_upper</VAR>, double <VAR>epsabs</VAR>, double <VAR>epsrel</VAR>)</I>
<DD><A NAME="IDX2094"></A>
This function tests for the convergence of the interval [<VAR>x_lower</VAR>,
<VAR>x_upper</VAR>] with absolute error <VAR>epsabs</VAR> and relative error
<VAR>epsrel</VAR>.  The test returns <CODE>GSL_SUCCESS</CODE> if the following
condition is achieved,

<SPAN class="ifinfo">


<PRE class="example">
|a - b| &#60; epsabs + epsrel min(|a|,|b|) 
</PRE>

</SPAN>

<P>
when the interval x = [a,b] does not include the origin.  If the
interval includes the origin then \min(|a|,|b|) is replaced by
zero (which is the minimum value of |x| over the interval).  This
ensures that the relative error is accurately estimated for roots close
to the origin.

</P>
<P>
This condition on the interval also implies that any estimate of the
root r in the interval satisfies the same condition with respect
to the true root r^*,

<SPAN class="ifinfo">


<PRE class="example">
|r - r^*| &#60; epsabs + epsrel r^*
</PRE>

</SPAN>

<P>
assuming that the true root r^* is contained within the interval.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_root_test_delta</B> <I>(double <VAR>x1</VAR>, double <VAR>x0</VAR>, double <VAR>epsabs</VAR>, double <VAR>epsrel</VAR>)</I>
<DD><A NAME="IDX2095"></A>

</P>
<P>
This function tests for the convergence of the sequence ..., <VAR>x0</VAR>,
<VAR>x1</VAR> with absolute error <VAR>epsabs</VAR> and relative error
<VAR>epsrel</VAR>.  The test returns <CODE>GSL_SUCCESS</CODE> if the following
condition is achieved,

<SPAN class="ifinfo">


<PRE class="example">
|x_1 - x_0| &#60; epsabs + epsrel |x_1|
</PRE>

</SPAN>

<P>
and returns <CODE>GSL_CONTINUE</CODE> otherwise.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_root_test_residual</B> <I>(double <VAR>f</VAR>, double <VAR>epsabs</VAR>)</I>
<DD><A NAME="IDX2096"></A>
This function tests the residual value <VAR>f</VAR> against the absolute
error bound <VAR>epsabs</VAR>.  The test returns <CODE>GSL_SUCCESS</CODE> if the
following condition is achieved,

<SPAN class="ifinfo">


<PRE class="example">
|f| &#60; epsabs
</PRE>

</SPAN>

<P>
and returns <CODE>GSL_CONTINUE</CODE> otherwise.  This criterion is suitable
for situations where the precise location of the root, x, is
unimportant provided a value can be found where the residual,
|f(x)|, is small enough.
</DL>

</P>



<H2><A NAME="SEC443" HREF="gsl_manual.html#TOC443">Root Bracketing Algorithms</A></H2>

<P>
The root bracketing algorithms described in this section require an
initial interval which is guaranteed to contain a root--if a
and b are the endpoints of the interval then f(a) must
differ in sign from f(b).  This ensures that the function crosses
zero at least once in the interval.  If a valid initial interval is used
then these algorithm cannot fail, provided the function is well-behaved.

</P>
<P>
Note that a bracketing algorithm cannot find roots of even degree, since
these do not cross the x-axis.

</P>
<P>
<DL>
<DT><U>Solver:</U> <B>gsl_root_fsolver_bisection</B>
<DD><A NAME="IDX2097"></A>

</P>
<P>
<A NAME="IDX2098"></A>
<A NAME="IDX2099"></A>

</P>
<P>
The <I>bisection algorithm</I> is the simplest method of bracketing the
roots of a function.   It is the slowest algorithm provided by
the library, with linear convergence.

</P>
<P>
On each iteration, the interval is bisected and the value of the
function at the midpoint is calculated.  The sign of this value is used
to determine which half of the interval does not contain a root.  That
half is discarded to give a new, smaller interval containing the
root.  This procedure can be continued indefinitely until the interval is
sufficiently small.

</P>
<P>
At any time the current estimate of the root is taken as the midpoint of
the interval.

</P>

</DL>

<P>
<DL>
<DT><U>Solver:</U> <B>gsl_root_fsolver_falsepos</B>
<DD><A NAME="IDX2100"></A>
<A NAME="IDX2101"></A>
<A NAME="IDX2102"></A>

</P>
<P>
The <I>false position algorithm</I> is a method of finding roots based on
linear interpolation.  Its convergence is linear, but it is usually
faster than bisection.

</P>
<P>
On each iteration a line is drawn between the endpoints (a,f(a))
and (b,f(b)) and the point where this line crosses the
x-axis taken as a "midpoint".  The value of the function at
this point is calculated and its sign is used to determine which side of
the interval does not contain a root.  That side is discarded to give a
new, smaller interval containing the root.  This procedure can be
continued indefinitely until the interval is sufficiently small.

</P>
<P>
The best estimate of the root is taken from the linear interpolation of
the interval on the current iteration.

</P>
</DL>

<P>
<DL>
<DT><U>Solver:</U> <B>gsl_root_fsolver_brent</B>
<DD><A NAME="IDX2103"></A>
<A NAME="IDX2104"></A>
<A NAME="IDX2105"></A>

</P>
<P>
The <I>Brent-Dekker method</I> (referred to here as <I>Brent's method</I>)
combines an interpolation strategy with the bisection algorithm.  This
produces a fast algorithm which is still robust.

</P>
<P>
On each iteration Brent's method approximates the function using an
interpolating curve.  On the first iteration this is a linear
interpolation of the two endpoints.  For subsequent iterations the
algorithm uses an inverse quadratic fit to the last three points, for
higher accuracy.  The intercept of the interpolating curve with the
x-axis is taken as a guess for the root.  If it lies within the
bounds of the current interval then the interpolating point is accepted,
and used to generate a smaller interval.  If the interpolating point is
not accepted then the algorithm falls back to an ordinary bisection
step.

</P>
<P>
The best estimate of the root is taken from the most recent
interpolation or bisection.
</DL>

</P>



<H2><A NAME="SEC444" HREF="gsl_manual.html#TOC444">Root Finding Algorithms using Derivatives</A></H2>

<P>
The root polishing algorithms described in this section require an
initial guess for the location of the root.  There is no absolute
guarantee of convergence--the function must be suitable for this
technique and the initial guess must be sufficiently close to the root
for it to work.  When these conditions are satisfied then convergence is
quadratic.

</P>
<P>
These algorithms make use of both the function and its derivative. 

</P>
<P>
<DL>
<DT><U>Derivative Solver:</U> <B>gsl_root_fdfsolver_newton</B>
<DD><A NAME="IDX2106"></A>
<A NAME="IDX2107"></A>
<A NAME="IDX2108"></A>

</P>
<P>
Newton's Method is the standard root-polishing algorithm.  The algorithm
begins with an initial guess for the location of the root.  On each
iteration, a line tangent to the function f is drawn at that
position.  The point where this line crosses the x-axis becomes
the new guess.  The iteration is defined by the following sequence,

<SPAN class="ifinfo">


<PRE class="example">
x_{i+1} = x_i - f(x_i)/f'(x_i)
</PRE>

</SPAN>

<P>
Newton's method converges quadratically for single roots, and linearly
for multiple roots.

</P>

</DL>

<P>
<DL>
<DT><U>Derivative Solver:</U> <B>gsl_root_fdfsolver_secant</B>
<DD><A NAME="IDX2109"></A>
<A NAME="IDX2110"></A>
<A NAME="IDX2111"></A>

</P>
<P>
The <I>secant method</I> is a simplified version of Newton's method which does
not require the computation of the derivative on every step.

</P>
<P>
On its first iteration the algorithm begins with Newton's method, using
the derivative to compute a first step,

<SPAN class="ifinfo">


<PRE class="example">
x_1 = x_0 - f(x_0)/f'(x_0)
</PRE>

</SPAN>

<P>
Subsequent iterations avoid the evaluation of the derivative by
replacing it with a numerical estimate, the slope of the line through
the previous two points,

<SPAN class="ifinfo">


<PRE class="example">
x_{i+1} = x_i f(x_i) / f'_{est} where
 f'_{est} = (f(x_i) - f(x_{i-1})/(x_i - x_{i-1})
</PRE>

</SPAN>

<P>
When the derivative does not change significantly in the vicinity of the
root the secant method gives a useful saving.  Asymptotically the secant
method is faster than Newton's method whenever the cost of evaluating
the derivative is more than 0.44 times the cost of evaluating the
function itself.  As with all methods of computing a numerical
derivative the estimate can suffer from cancellation errors if the
separation of the points becomes too small.

</P>
<P>
On single roots, the method has a convergence of order (1 + \sqrt
5)/2 (approximately 1.62).  It converges linearly for multiple
roots.  

</P>
</DL>

<P>
<DL>
<DT><U>Derivative Solver:</U> <B>gsl_root_fdfsolver_steffenson</B>
<DD><A NAME="IDX2112"></A>
<A NAME="IDX2113"></A>
<A NAME="IDX2114"></A>

</P>
<P>
The <I>Steffenson Method</I> provides the fastest convergence of all the
routines.  It combines the basic Newton algorithm with an Aitken
"delta-squared" acceleration.  If the Newton iterates are x_i
then the acceleration procedure generates a new sequence R_i,

<SPAN class="ifinfo">


<PRE class="example">
R_i = x_i - (x_{i+1} - x_i)^2 / (x_{i+2} - 2 x_{i+1} + x_{i})
</PRE>

</SPAN>

<P>
which converges faster than the original sequence under reasonable
conditions.  The new sequence requires three terms before it can produce
its first value so the method returns accelerated values on the second
and subsequent iterations.  On the first iteration it returns the
ordinary Newton estimate.  The Newton iterate is also returned if the
denominator of the acceleration term ever becomes zero.

</P>
<P>
As with all acceleration procedures this method can become unstable if
the function is not well-behaved. 
</DL>

</P>


<H2><A NAME="SEC445" HREF="gsl_manual.html#TOC445">Examples</A></H2>

<P>
For any root finding algorithm we need to prepare the function to be
solved.  For this example we will use the general quadratic equation
described earlier.  We first need a header file (<TT>'demo_fn.h'</TT>) to
define the function parameters,

</P>

<PRE class="example">
struct quadratic_params
  {
    double a, b, c;
  };

double quadratic (double x, void *params);
double quadratic_deriv (double x, void *params);
void quadratic_fdf (double x, void *params, 
                    double *y, double *dy);
</PRE>

<P>
We place the function definitions in a separate file (<TT>'demo_fn.c'</TT>),

</P>

<PRE class="example">
double
quadratic (double x, void *params)
{
  struct quadratic_params *p 
    = (struct quadratic_params *) params;

  double a = p-&#62;a;
  double b = p-&#62;b;
  double c = p-&#62;c;

  return (a * x + b) * x + c;
}

double
quadratic_deriv (double x, void *params)
{
  struct quadratic_params *p 
    = (struct quadratic_params *) params;

  double a = p-&#62;a;
  double b = p-&#62;b;
  double c = p-&#62;c;

  return 2.0 * a * x + b;
}

void
quadratic_fdf (double x, void *params, 
               double *y, double *dy)
{
  struct quadratic_params *p 
    = (struct quadratic_params *) params;

  double a = p-&#62;a;
  double b = p-&#62;b;
  double c = p-&#62;c;

  *y = (a * x + b) * x + c;
  *dy = 2.0 * a * x + b;
}
</PRE>

<P>
The first program uses the function solver <CODE>gsl_root_fsolver_brent</CODE>
for Brent's method and the general quadratic defined above to solve the
following equation,

<SPAN class="ifinfo">


<PRE class="example">
x^2 - 5 = 0
</PRE>

</SPAN>

<P>
with solution x = \sqrt 5 = 2.236068...

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_errno.h&#62;
#include &#60;gsl/gsl_math.h&#62;
#include &#60;gsl/gsl_roots.h&#62;

#include "demo_fn.h"
#include "demo_fn.c"

int
main (void)
{
  int status;
  int iter = 0, max_iter = 100;
  const gsl_root_fsolver_type *T;
  gsl_root_fsolver *s;
  double r = 0, r_expected = sqrt (5.0);
  double x_lo = 0.0, x_hi = 5.0;
  gsl_function F;
  struct quadratic_params params = {1.0, 0.0, -5.0};

  F.function = &#38;quadratic;
  F.params = &#38;params;

  T = gsl_root_fsolver_brent;
  s = gsl_root_fsolver_alloc (T);
  gsl_root_fsolver_set (s, &#38;F, x_lo, x_hi);

  printf ("using %s method\n", 
          gsl_root_fsolver_name (s));

  printf ("%5s [%9s, %9s] %9s %10s %9s\n",
          "iter", "lower", "upper", "root", 
          "err", "err(est)");

  do
    {
      iter++;
      status = gsl_root_fsolver_iterate (s);
      r = gsl_root_fsolver_root (s);
      x_lo = gsl_root_fsolver_x_lower (s);
      x_hi = gsl_root_fsolver_x_upper (s);
      status = gsl_root_test_interval (x_lo, x_hi,
                                       0, 0.001);

      if (status == GSL_SUCCESS)
        printf ("Converged:\n");

      printf ("%5d [%.7f, %.7f] %.7f %+.7f %.7f\n",
              iter, x_lo, x_hi,
              r, r - r_expected, 
              x_hi - x_lo);
    }
  while (status == GSL_CONTINUE &#38;&#38; iter &#60; max_iter);
  return status;
}
</PRE>

<P>
Here are the results of the iterations,

</P>

<PRE class="smallexample">
$ ./a.out 
using brent method
 iter [    lower,     upper]      root        err  err(est)
    1 [1.0000000, 5.0000000] 1.0000000 -1.2360680 4.0000000
    2 [1.0000000, 3.0000000] 3.0000000 +0.7639320 2.0000000
    3 [2.0000000, 3.0000000] 2.0000000 -0.2360680 1.0000000
    4 [2.2000000, 3.0000000] 2.2000000 -0.0360680 0.8000000
    5 [2.2000000, 2.2366300] 2.2366300 +0.0005621 0.0366300
Converged:                            
    6 [2.2360634, 2.2366300] 2.2360634 -0.0000046 0.0005666
</PRE>

<P>
If the program is modified to use the bisection solver instead of
Brent's method, by changing <CODE>gsl_root_fsolver_brent</CODE> to
<CODE>gsl_root_fsolver_bisection</CODE> the slower convergence of the
Bisection method can be observed,

</P>

<PRE class="smallexample">
$ ./a.out 
using bisection method
 iter [    lower,     upper]      root        err  err(est)
    1 [0.0000000, 2.5000000] 1.2500000 -0.9860680 2.5000000
    2 [1.2500000, 2.5000000] 1.8750000 -0.3610680 1.2500000
    3 [1.8750000, 2.5000000] 2.1875000 -0.0485680 0.6250000
    4 [2.1875000, 2.5000000] 2.3437500 +0.1076820 0.3125000
    5 [2.1875000, 2.3437500] 2.2656250 +0.0295570 0.1562500
    6 [2.1875000, 2.2656250] 2.2265625 -0.0095055 0.0781250
    7 [2.2265625, 2.2656250] 2.2460938 +0.0100258 0.0390625
    8 [2.2265625, 2.2460938] 2.2363281 +0.0002601 0.0195312
    9 [2.2265625, 2.2363281] 2.2314453 -0.0046227 0.0097656
   10 [2.2314453, 2.2363281] 2.2338867 -0.0021813 0.0048828
   11 [2.2338867, 2.2363281] 2.2351074 -0.0009606 0.0024414
Converged:                            
   12 [2.2351074, 2.2363281] 2.2357178 -0.0003502 0.0012207
</PRE>

<P>
The next program solves the same function using a derivative solver
instead.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_errno.h&#62;
#include &#60;gsl/gsl_math.h&#62;
#include &#60;gsl/gsl_roots.h&#62;

#include "demo_fn.h"
#include "demo_fn.c"

int
main (void)
{
  int status;
  int iter = 0, max_iter = 100;
  const gsl_root_fdfsolver_type *T;
  gsl_root_fdfsolver *s;
  double x0, x = 5.0, r_expected = sqrt (5.0);
  gsl_function_fdf FDF;
  struct quadratic_params params = {1.0, 0.0, -5.0};

  FDF.f = &#38;quadratic;
  FDF.df = &#38;quadratic_deriv;
  FDF.fdf = &#38;quadratic_fdf;
  FDF.params = &#38;params;

  T = gsl_root_fdfsolver_newton;
  s = gsl_root_fdfsolver_alloc (T);
  gsl_root_fdfsolver_set (s, &#38;FDF, x);

  printf ("using %s method\n", 
          gsl_root_fdfsolver_name (s));

  printf ("%-5s %10s %10s %10s\n",
          "iter", "root", "err", "err(est)");
  do
    {
      iter++;
      status = gsl_root_fdfsolver_iterate (s);
      x0 = x;
      x = gsl_root_fdfsolver_root (s);
      status = gsl_root_test_delta (x, x0, 0, 1e-3);

      if (status == GSL_SUCCESS)
        printf ("Converged:\n");

      printf ("%5d %10.7f %+10.7f %10.7f\n",
              iter, x, x - r_expected, x - x0);
    }
  while (status == GSL_CONTINUE &#38;&#38; iter &#60; max_iter);
  return status;
}
</PRE>

<P>
Here are the results for Newton's method,

</P>

<PRE class="example">
$ ./a.out 
using newton method
iter        root        err   err(est)
    1  3.0000000 +0.7639320 -2.0000000
    2  2.3333333 +0.0972654 -0.6666667
    3  2.2380952 +0.0020273 -0.0952381
Converged:      
    4  2.2360689 +0.0000009 -0.0020263
</PRE>

<P>
Note that the error can be estimated more accurately by taking the
difference between the current iterate and next iterate rather than the
previous iterate.  The other derivative solvers can be investigated by
changing <CODE>gsl_root_fdfsolver_newton</CODE> to
<CODE>gsl_root_fdfsolver_secant</CODE> or
<CODE>gsl_root_fdfsolver_steffenson</CODE>.

</P>


<H2><A NAME="SEC446" HREF="gsl_manual.html#TOC446">References and Further Reading</A></H2>

<P>
For information on the Brent-Dekker algorithm see the following two
papers,

</P>

<UL class="itemize">
<LI>

R. P. Brent, "An algorithm with guaranteed convergence for finding a
zero of a function", <CITE>Computer Journal</CITE>, 14 (1971) 422--425

<LI>

J. C. P. Bus and T. J. Dekker, "Two Efficient Algorithms with Guaranteed
Convergence for Finding a Zero of a Function", <CITE>ACM Transactions of
Mathematical Software</CITE>, Vol. 1 No. 4 (1975) 330--345
</UL>



<H1><A NAME="SEC447" HREF="gsl_manual.html#TOC447">One dimensional Minimization</A></H1>
<P>
<A NAME="IDX2115"></A>
<A NAME="IDX2116"></A>
<A NAME="IDX2117"></A>
<A NAME="IDX2118"></A>
<A NAME="IDX2119"></A>

</P>
<P>
This chapter describes routines for finding minima of arbitrary
one-dimensional functions.  The library provides low level components
for a variety of iterative minimizers and convergence tests.  These can be
combined by the user to achieve the desired solution, with full access
to the intermediate steps of the algorithms.  Each class of methods uses
the same framework, so that you can switch between minimizers at runtime
without needing to recompile your program.  Each instance of a minimizer
keeps track of its own state, allowing the minimizers to be used in
multi-threaded programs.

</P>
<P>
The header file <TT>'gsl_min.h'</TT> contains prototypes for the
minimization functions and related declarations.  To use the minimization
algorithms to find the maximum of a function simply invert its sign.

</P>



<H2><A NAME="SEC448" HREF="gsl_manual.html#TOC448">Overview</A></H2>
<P>
<A NAME="IDX2120"></A>

</P>
<P>
The minimization algorithms begin with a bounded region known to contain
a minimum.  The region is described by a lower bound a and an
upper bound b, with an estimate of the location of the minimum
x.

</P>
<P>
<BR><IMG SRC="min-interval"><BR>
The value of the function at x must be less than the value of the
function at the ends of the interval,

<SPAN class="ifinfo">


<PRE class="example">
f(a) &#62; f(x) &#60; f(b)
</PRE>

</SPAN>

<P>
This condition guarantees that a minimum is contained somewhere within
the interval.  On each iteration a new point x' is selected using
one of the available algorithms.  If the new point is a better estimate
of the minimum, i.e. where f(x') &#60; f(x), then the current
estimate of the minimum x is updated.  The new point also allows
the size of the bounded interval to be reduced, by choosing the most
compact set of points which satisfies the constraint f(a) &#62; f(x) &#60;
f(b).  The interval is reduced until it encloses the true minimum to a
desired tolerance.  This provides a best estimate of the location of the
minimum and a rigorous error estimate.

</P>
<P>
Several bracketing algorithms are available within a single framework.
The user provides a high-level driver for the algorithm, and the
library provides the individual functions necessary for each of the
steps.  There are three main phases of the iteration.  The steps are,

</P>

<UL class="itemize">
<LI>

initialize minimizer state, <VAR>s</VAR>, for algorithm <VAR>T</VAR>

<LI>

update <VAR>s</VAR> using the iteration <VAR>T</VAR>

<LI>

test <VAR>s</VAR> for convergence, and repeat iteration if necessary
</UL>

<P>
The state for the minimizers is held in a <CODE>gsl_min_fminimizer</CODE>
struct.  The updating procedure uses only function evaluations (not
derivatives).

</P>


<H2><A NAME="SEC449" HREF="gsl_manual.html#TOC449">Caveats</A></H2>
<P>
<A NAME="IDX2121"></A>

</P>
<P>
Note that minimization functions can only search for one minimum at a
time.  When there are several minima in the search area, the first
minimum to be found will be returned; however it is difficult to predict
which of the minima this will be. <EM>In most cases, no error will be
reported if you try to find a minimum in an area where there is more
than one.</EM>

</P>
<P>
With all minimization algorithms it can be difficult to determine the
location of the minimum to full numerical precision.  The behavior of the
function in the region of the minimum x^* can be approximated by
a Taylor expansion,

<SPAN class="ifinfo">


<PRE class="example">
y = f(x^*) + (1/2) f"(x^*) (x - x^*)^2
</PRE>

</SPAN>

<P>
and the second term of this expansion can be lost when added to the
first term at finite precision.  This magnifies the error in locating
x^*, making it proportional to \sqrt \epsilon (where
\epsilon is the relative accuracy of the floating point numbers).
For functions with higher order minima, such as x^4, the
magnification of the error is correspondingly worse.  The best that can
be achieved is to converge to the limit of numerical accuracy in the
function values, rather than the location of the minimum itself.

</P>


<H2><A NAME="SEC450" HREF="gsl_manual.html#TOC450">Initializing the Minimizer</A></H2>

<P>
<DL>
<DT><U>Function:</U> gsl_min_fminimizer * <B>gsl_min_fminimizer_alloc</B> <I>(const gsl_min_fminimizer_type * <VAR>T</VAR>)</I>
<DD><A NAME="IDX2122"></A>
This function returns a pointer to a newly allocated instance of a
minimizer of type <VAR>T</VAR>.  For example, the following code
creates an instance of a golden section minimizer,

</P>

<PRE class="example">
const gsl_min_fminimizer_type * T 
  = gsl_min_fminimizer_goldensection;
gsl_min_fminimizer * s 
  = gsl_min_fminimizer_alloc (T);
</PRE>

<P>
If there is insufficient memory to create the minimizer then the function
returns a null pointer and the error handler is invoked with an error
code of <CODE>GSL_ENOMEM</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_min_fminimizer_set</B> <I>(gsl_min_fminimizer * <VAR>s</VAR>, gsl_function * <VAR>f</VAR>, double <VAR>x_minimum</VAR>, double <VAR>x_lower</VAR>, double <VAR>x_upper</VAR>)</I>
<DD><A NAME="IDX2123"></A>
This function sets, or resets, an existing minimizer <VAR>s</VAR> to use the
function <VAR>f</VAR> and the initial search interval [<VAR>x_lower</VAR>,
<VAR>x_upper</VAR>], with a guess for the location of the minimum
<VAR>x_minimum</VAR>.

</P>
<P>
If the interval given does not contain a minimum, then the function
returns an error code of <CODE>GSL_EINVAL</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_min_fminimizer_set_with_values</B> <I>(gsl_min_fminimizer * <VAR>s</VAR>, gsl_function * <VAR>f</VAR>, double <VAR>x_minimum</VAR>, double <VAR>f_minimum</VAR>, double <VAR>x_lower</VAR>, double <VAR>f_lower</VAR>, double <VAR>x_upper</VAR>, double <VAR>f_upper</VAR>)</I>
<DD><A NAME="IDX2124"></A>
This function is equivalent to <CODE>gsl_min_fminimizer_set</CODE> but uses
the values <VAR>f_minimum</VAR>, <VAR>f_lower</VAR> and <VAR>f_upper</VAR> instead of
computing <CODE>f(x_minimum)</CODE>, <CODE>f(x_lower)</CODE> and <CODE>f(x_upper)</CODE>.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> void <B>gsl_min_fminimizer_free</B> <I>(gsl_min_fminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2125"></A>
This function frees all the memory associated with the minimizer
<VAR>s</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> const char * <B>gsl_min_fminimizer_name</B> <I>(const gsl_min_fminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2126"></A>
This function returns a pointer to the name of the minimizer.  For example,

</P>

<PRE class="example">
printf ("s is a '%s' minimizer\n",
        gsl_min_fminimizer_name (s));
</PRE>

<P>
would print something like <CODE>s is a 'brent' minimizer</CODE>.
</DL>

</P>


<H2><A NAME="SEC451" HREF="gsl_manual.html#TOC451">Providing the function to minimize</A></H2>
<P>
<A NAME="IDX2127"></A>

</P>
<P>
You must provide a continuous function of one variable for the
minimizers to operate on.  In order to allow for general parameters the
functions are defined by a <CODE>gsl_function</CODE> data type
(see section <A HREF="gsl_manual.html#SEC439">Providing the function to solve</A>).

</P>


<H2><A NAME="SEC452" HREF="gsl_manual.html#TOC452">Iteration</A></H2>

<P>
The following functions drive the iteration of each algorithm.  Each
function performs one iteration to update the state of any minimizer of the
corresponding type.  The same functions work for all minimizers so that
different methods can be substituted at runtime without modifications to
the code.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_min_fminimizer_iterate</B> <I>(gsl_min_fminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2128"></A>
This function performs a single iteration of the minimizer <VAR>s</VAR>.  If the
iteration encounters an unexpected problem then an error code will be
returned,

</P>
<DL COMPACT>

<DT><CODE>GSL_EBADFUNC</CODE>
<DD>
the iteration encountered a singular point where the function evaluated
to <CODE>Inf</CODE> or <CODE>NaN</CODE>.

<DT><CODE>GSL_FAILURE</CODE>
<DD>
the algorithm could not improve the current best approximation or
bounding interval.
</DL>
</DL>

<P>
The minimizer maintains a current best estimate of the position of the
minimum at all times, and the current interval bounding the minimum.
This information can be accessed with the following auxiliary functions,

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_min_fminimizer_x_minimum</B> <I>(const gsl_min_fminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2129"></A>
This function returns the current estimate of the position of the
minimum for the minimizer <VAR>s</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_min_fminimizer_x_upper</B> <I>(const gsl_min_fminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2130"></A>
<DT><U>Function:</U> double <B>gsl_min_fminimizer_x_lower</B> <I>(const gsl_min_fminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2131"></A>
These functions return the current upper and lower bound of the interval
for the minimizer <VAR>s</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gsl_min_fminimizer_f_minimum</B> <I>(const gsl_min_fminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2132"></A>
<DT><U>Function:</U> double <B>gsl_min_fminimizer_f_upper</B> <I>(const gsl_min_fminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2133"></A>
<DT><U>Function:</U> double <B>gsl_min_fminimizer_f_lower</B> <I>(const gsl_min_fminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2134"></A>
These functions return the value of the function at the current estimate
of the minimum and at the upper and lower bounds of the interval for the
minimizer <VAR>s</VAR>.
</DL>

</P>


<H2><A NAME="SEC453" HREF="gsl_manual.html#TOC453">Stopping Parameters</A></H2>
<P>
<A NAME="IDX2135"></A>

</P>
<P>
A minimization procedure should stop when one of the following
conditions is true:

</P>

<UL class="itemize">
<LI>

A minimum has been found to within the user-specified precision.

<LI>

A user-specified maximum number of iterations has been reached.

<LI>

An error has occurred.
</UL>

<P>
The handling of these conditions is under user control.  The function
below allows the user to test the precision of the current result.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_min_test_interval</B> <I>(double <VAR>x_lower</VAR>, double <VAR>x_upper</VAR>, double <VAR>epsabs</VAR>, double <VAR>epsrel</VAR>)</I>
<DD><A NAME="IDX2136"></A>
This function tests for the convergence of the interval [<VAR>x_lower</VAR>,
<VAR>x_upper</VAR>] with absolute error <VAR>epsabs</VAR> and relative error
<VAR>epsrel</VAR>.  The test returns <CODE>GSL_SUCCESS</CODE> if the following
condition is achieved,

<SPAN class="ifinfo">


<PRE class="example">
|a - b| &#60; epsabs + epsrel min(|a|,|b|) 
</PRE>

</SPAN>

<P>
when the interval x = [a,b] does not include the origin.  If the
interval includes the origin then \min(|a|,|b|) is replaced by
zero (which is the minimum value of |x| over the interval).  This
ensures that the relative error is accurately estimated for minima close
to the origin.

</P>
<P>
This condition on the interval also implies that any estimate of the
minimum x_m in the interval satisfies the same condition with respect
to the true minimum x_m^*,

<SPAN class="ifinfo">


<PRE class="example">
|x_m - x_m^*| &#60; epsabs + epsrel x_m^*
</PRE>

</SPAN>

<P>
assuming that the true minimum x_m^* is contained within the interval.
</DL>

</P>



<H2><A NAME="SEC454" HREF="gsl_manual.html#TOC454">Minimization Algorithms</A></H2>

<P>
The minimization algorithms described in this section require an initial
interval which is guaranteed to contain a minimum--if a and
b are the endpoints of the interval and x is an estimate
of the minimum then f(a) &#62; f(x) &#60; f(b).  This ensures that the
function has at least one minimum somewhere in the interval.  If a valid
initial interval is used then these algorithm cannot fail, provided the
function is well-behaved.

</P>
<P>
<DL>
<DT><U>Minimizer:</U> <B>gsl_min_fminimizer_goldensection</B>
<DD><A NAME="IDX2137"></A>

</P>
<P>
<A NAME="IDX2138"></A>
<A NAME="IDX2139"></A>

</P>
<P>
The <I>golden section algorithm</I> is the simplest method of bracketing
the minimum of a function.  It is the slowest algorithm provided by the
library, with linear convergence.

</P>
<P>
On each iteration, the algorithm first compares the subintervals from
the endpoints to the current minimum.  The larger subinterval is divided
in a golden section (using the famous ratio (3-\sqrt 5)/2 =
0.3189660...) and the value of the function at this new point is
calculated.  The new value is used with the constraint f(a') &#62;
f(x') &#60; f(b') to a select new interval containing the minimum, by
discarding the least useful point.  This procedure can be continued
indefinitely until the interval is sufficiently small.  Choosing the
golden section as the bisection ratio can be shown to provide the
fastest convergence for this type of algorithm.

</P>
</DL>

<P>
<DL>
<DT><U>Minimizer:</U> <B>gsl_min_fminimizer_brent</B>
<DD><A NAME="IDX2140"></A>
<A NAME="IDX2141"></A>
<A NAME="IDX2142"></A>

</P>
<P>
The <I>Brent minimization algorithm</I> combines a parabolic
interpolation with the golden section algorithm.  This produces a fast
algorithm which is still robust.

</P>
<P>
The outline of the algorithm can be summarized as follows: on each
iteration Brent's method approximates the function using an
interpolating parabola through three existing points.  The minimum of the
parabola is taken as a guess for the minimum.  If it lies within the
bounds of the current interval then the interpolating point is accepted,
and used to generate a smaller interval.  If the interpolating point is
not accepted then the algorithm falls back to an ordinary golden section
step.  The full details of Brent's method include some additional checks
to improve convergence.
</DL>

</P>



<H2><A NAME="SEC455" HREF="gsl_manual.html#TOC455">Examples</A></H2>

<P>
The following program uses the Brent algorithm to find the minimum of
the function f(x) = \cos(x) + 1, which occurs at x = \pi.
The starting interval is (0,6), with an initial guess for the
minimum of 2.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_errno.h&#62;
#include &#60;gsl/gsl_math.h&#62;
#include &#60;gsl/gsl_min.h&#62;

double fn1 (double x, void * params)
{
  return cos(x) + 1.0;
}

int
main (void)
{
  int status;
  int iter = 0, max_iter = 100;
  const gsl_min_fminimizer_type *T;
  gsl_min_fminimizer *s;
  double m = 2.0, m_expected = M_PI;
  double a = 0.0, b = 6.0;
  gsl_function F;

  F.function = &#38;fn1;
  F.params = 0;

  T = gsl_min_fminimizer_brent;
  s = gsl_min_fminimizer_alloc (T);
  gsl_min_fminimizer_set (s, &#38;F, m, a, b);

  printf ("using %s method\n",
          gsl_min_fminimizer_name (s));

  printf ("%5s [%9s, %9s] %9s %10s %9s\n",
          "iter", "lower", "upper", "min",
          "err", "err(est)");

  printf ("%5d [%.7f, %.7f] %.7f %+.7f %.7f\n",
          iter, a, b,
          m, m - m_expected, b - a);

  do
    {
      iter++;
      status = gsl_min_fminimizer_iterate (s);

      m = gsl_min_fminimizer_x_minimum (s);
      a = gsl_min_fminimizer_x_lower (s);
      b = gsl_min_fminimizer_x_upper (s);

      status 
        = gsl_min_test_interval (a, b, 0.001, 0.0);

      if (status == GSL_SUCCESS)
        printf ("Converged:\n");

      printf ("%5d [%.7f, %.7f] "
              "%.7f %.7f %+.7f %.7f\n",
              iter, a, b,
              m, m_expected, m - m_expected, b - a);
    }
  while (status == GSL_CONTINUE &#38;&#38; iter &#60; max_iter);

  return status;
}
</PRE>

<P>
Here are the results of the minimization procedure.

</P>

<PRE class="smallexample">
$ ./a.out 
    0 [0.0000000, 6.0000000] 2.0000000 -1.1415927 6.0000000
    1 [2.0000000, 6.0000000] 3.2758640 +0.1342713 4.0000000
    2 [2.0000000, 3.2831929] 3.2758640 +0.1342713 1.2831929
    3 [2.8689068, 3.2831929] 3.2758640 +0.1342713 0.4142862
    4 [2.8689068, 3.2831929] 3.2758640 +0.1342713 0.4142862
    5 [2.8689068, 3.2758640] 3.1460585 +0.0044658 0.4069572
    6 [3.1346075, 3.2758640] 3.1460585 +0.0044658 0.1412565
    7 [3.1346075, 3.1874620] 3.1460585 +0.0044658 0.0528545
    8 [3.1346075, 3.1460585] 3.1460585 +0.0044658 0.0114510
    9 [3.1346075, 3.1460585] 3.1424060 +0.0008133 0.0114510
   10 [3.1346075, 3.1424060] 3.1415885 -0.0000041 0.0077985
Converged:                            
   11 [3.1415885, 3.1424060] 3.1415927 -0.0000000 0.0008175
</PRE>



<H2><A NAME="SEC456" HREF="gsl_manual.html#TOC456">References and Further Reading</A></H2>

<P>
Further information on Brent's algorithm is available in the following
book,

</P>

<UL class="itemize">
<LI>

Richard Brent, <CITE>Algorithms for minimization without derivatives</CITE>,
Prentice-Hall (1973), republished by Dover in paperback (2002), ISBN
0-486-41998-3.
</UL>



<H1><A NAME="SEC457" HREF="gsl_manual.html#TOC457">Multidimensional Root-Finding</A></H1>
<P>
<A NAME="IDX2143"></A>
<A NAME="IDX2144"></A>
<A NAME="IDX2145"></A>

</P>
<P>
This chapter describes functions for multidimensional root-finding
(solving nonlinear systems with n equations in n
unknowns).  The library provides low level components for a variety of
iterative solvers and convergence tests.  These can be combined by the
user to achieve the desired solution, with full access to the
intermediate steps of the iteration.  Each class of methods uses the
same framework, so that you can switch between solvers at runtime
without needing to recompile your program.  Each instance of a solver
keeps track of its own state, allowing the solvers to be used in
multi-threaded programs.  The solvers are based on the original Fortran
library MINPACK.

</P>
<P>
The header file <TT>'gsl_multiroots.h'</TT> contains prototypes for the
multidimensional root finding functions and related declarations.

</P>



<H2><A NAME="SEC458" HREF="gsl_manual.html#TOC458">Overview</A></H2>
<P>
<A NAME="IDX2146"></A>

</P>
<P>
The problem of multidimensional root finding requires the simultaneous
solution of n equations, f_i, in n variables,
x_i,

<SPAN class="ifinfo">


<PRE class="example">
f_i (x_1, ..., x_n) = 0    for i = 1 ... n.
</PRE>

</SPAN>

<P>
In general there are no bracketing methods available for n
dimensional systems, and no way of knowing whether any solutions
exist.  All algorithms proceed from an initial guess using a variant of
the Newton iteration,

<SPAN class="ifinfo">


<PRE class="example">
x -&#62; x' = x - J^{-1} f(x)
</PRE>

</SPAN>

<P>
where x, f are vector quantities and J is the
Jacobian matrix 
J_{ij} = d f_i / d x_j.
Additional strategies can be used to enlarge the region of
convergence.  These include requiring a decrease in the norm |f| on
each step proposed by Newton's method, or taking steepest-descent steps in
the direction of the negative gradient of |f|.

</P>
<P>
Several root-finding algorithms are available within a single framework.
The user provides a high-level driver for the algorithms, and the
library provides the individual functions necessary for each of the
steps.  There are three main phases of the iteration.  The steps are,

</P>

<UL class="itemize">
<LI>

initialize solver state, <VAR>s</VAR>, for algorithm <VAR>T</VAR>

<LI>

update <VAR>s</VAR> using the iteration <VAR>T</VAR>

<LI>

test <VAR>s</VAR> for convergence, and repeat iteration if necessary
</UL>

<P>
The evaluation of the Jacobian matrix can be problematic, either because
programming the derivatives is intractable or because computation of the
n^2 terms of the matrix becomes too expensive.  For these reasons
the algorithms provided by the library are divided into two classes according
to whether the derivatives are available or not.

</P>
<P>
The state for solvers with an analytic Jacobian matrix is held in a
<CODE>gsl_multiroot_fdfsolver</CODE> struct.  The updating procedure requires
both the function and its derivatives to be supplied by the user.

</P>
<P>
The state for solvers which do not use an analytic Jacobian matrix is
held in a <CODE>gsl_multiroot_fsolver</CODE> struct.  The updating procedure
uses only function evaluations (not derivatives).  The algorithms
estimate the matrix J or 
J^{-1} by approximate methods.

</P>


<H2><A NAME="SEC459" HREF="gsl_manual.html#TOC459">Initializing the Solver</A></H2>

<P>
The following functions initialize a multidimensional solver, either
with or without derivatives.  The solver itself depends only on the
dimension of the problem and the algorithm and can be reused for
different problems.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_multiroot_fsolver * <B>gsl_multiroot_fsolver_alloc</B> <I>(const gsl_multiroot_fsolver_type * <VAR>T</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX2147"></A>
This function returns a pointer to a newly allocated instance of a
solver of type <VAR>T</VAR> for a system of <VAR>n</VAR> dimensions.
For example, the following code creates an instance of a hybrid solver, 
to solve a 3-dimensional system of equations.

</P>

<PRE class="example">
const gsl_multiroot_fsolver_type * T 
    = gsl_multiroot_fsolver_hybrid;
gsl_multiroot_fsolver * s 
    = gsl_multiroot_fsolver_alloc (T, 3);
</PRE>

<P>
If there is insufficient memory to create the solver then the function
returns a null pointer and the error handler is invoked with an error
code of <CODE>GSL_ENOMEM</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_multiroot_fdfsolver * <B>gsl_multiroot_fdfsolver_alloc</B> <I>(const gsl_multiroot_fdfsolver_type * <VAR>T</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX2148"></A>
This function returns a pointer to a newly allocated instance of a
derivative solver of type <VAR>T</VAR> for a system of <VAR>n</VAR> dimensions.
For example, the following code creates an instance of a Newton-Raphson solver,
for a 2-dimensional system of equations.

</P>

<PRE class="example">
const gsl_multiroot_fdfsolver_type * T 
    = gsl_multiroot_fdfsolver_newton;
gsl_multiroot_fdfsolver * s = 
    gsl_multiroot_fdfsolver_alloc (T, 2);
</PRE>

<P>
If there is insufficient memory to create the solver then the function
returns a null pointer and the error handler is invoked with an error
code of <CODE>GSL_ENOMEM</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_multiroot_fsolver_set</B> <I>(gsl_multiroot_fsolver * <VAR>s</VAR>, gsl_multiroot_function * <VAR>f</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX2149"></A>
This function sets, or resets, an existing solver <VAR>s</VAR> to use the
function <VAR>f</VAR> and the initial guess <VAR>x</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_multiroot_fdfsolver_set</B> <I>(gsl_multiroot_fdfsolver * <VAR>s</VAR>, gsl_multiroot_function_fdf * <VAR>fdf</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX2150"></A>
This function sets, or resets, an existing solver <VAR>s</VAR> to use the
function and derivative <VAR>fdf</VAR> and the initial guess <VAR>x</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_multiroot_fsolver_free</B> <I>(gsl_multiroot_fsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2151"></A>
<DT><U>Function:</U> void <B>gsl_multiroot_fdfsolver_free</B> <I>(gsl_multiroot_fdfsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2152"></A>
These functions free all the memory associated with the solver <VAR>s</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> const char * <B>gsl_multiroot_fsolver_name</B> <I>(const gsl_multiroot_fsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2153"></A>
<DT><U>Function:</U> const char * <B>gsl_multiroot_fdfsolver_name</B> <I>(const gsl_multiroot_fdfsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2154"></A>
These functions return a pointer to the name of the solver.  For example,

</P>

<PRE class="example">
printf ("s is a '%s' solver\n", 
        gsl_multiroot_fdfsolver_name (s));
</PRE>

<P>
would print something like <CODE>s is a 'newton' solver</CODE>.
</DL>

</P>


<H2><A NAME="SEC460" HREF="gsl_manual.html#TOC460">Providing the function to solve</A></H2>
<P>
<A NAME="IDX2155"></A>

</P>
<P>
You must provide n functions of n variables for the root
finders to operate on.  In order to allow for general parameters the
functions are defined by the following data types:

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_multiroot_function</B>
<DD><A NAME="IDX2156"></A>
This data type defines a general system of functions with parameters.

</P>
<DL COMPACT>

<DT><CODE>int (* f) (const gsl_vector * <VAR>x</VAR>, void * <VAR>params</VAR>, gsl_vector * <VAR>f</VAR>)</CODE>
<DD>
this function should store the vector result
f(x,params) in <VAR>f</VAR> for argument <VAR>x</VAR> and parameters <VAR>params</VAR>,
returning an appropriate error code if the function cannot be computed.

<DT><CODE>size_t n</CODE>
<DD>
the dimension of the system, i.e. the number of components of the
vectors <VAR>x</VAR> and <VAR>f</VAR>.

<DT><CODE>void * params</CODE>
<DD>
a pointer to the parameters of the function.
</DL>
</DL>

<P>
Here is an example using Powell's test function,

<SPAN class="ifinfo">


<PRE class="example">
f_1(x) = A x_0 x_1 - 1,
f_2(x) = exp(-x_0) + exp(-x_1) - (1 + 1/A)
</PRE>

</SPAN>

<P>
with A = 10^4.  The following code defines a
<CODE>gsl_multiroot_function</CODE> system <CODE>F</CODE> which you could pass to a
solver:

</P>

<PRE class="example">
struct powell_params { double A; };

int
powell (gsl_vector * x, void * p, gsl_vector * f) {
   struct powell_params * params 
     = *(struct powell_params *)p;
   const double A = (params-&#62;A);
   const double x0 = gsl_vector_get(x,0);
   const double x1 = gsl_vector_get(x,1);

   gsl_vector_set (f, 0, A * x0 * x1 - 1);
   gsl_vector_set (f, 1, (exp(-x0) + exp(-x1) 
                          - (1.0 + 1.0/A)));
   return GSL_SUCCESS
}

gsl_multiroot_function F;
struct powell_params params = { 10000.0 };

F.f = &#38;powell;
F.n = 2;
F.params = &#38;params;
</PRE>

<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_multiroot_function_fdf</B>
<DD><A NAME="IDX2157"></A>
This data type defines a general system of functions with parameters and
the corresponding Jacobian matrix of derivatives,

</P>
<DL COMPACT>

<DT><CODE>int (* f) (const gsl_vector * <VAR>x</VAR>, void * <VAR>params</VAR>, gsl_vector * <VAR>f</VAR>)</CODE>
<DD>
this function should store the vector result
f(x,params) in <VAR>f</VAR> for argument <VAR>x</VAR> and parameters <VAR>params</VAR>,
returning an appropriate error code if the function cannot be computed.

<DT><CODE>int (* df) (const gsl_vector * <VAR>x</VAR>, void * <VAR>params</VAR>, gsl_matrix * <VAR>J</VAR>)</CODE>
<DD>
this function should store the <VAR>n</VAR>-by-<VAR>n</VAR> matrix result
J_ij = d f_i(x,params) / d x_j in <VAR>J</VAR> for argument <VAR>x</VAR> 
and parameters <VAR>params</VAR>, returning an appropriate error code if the
function cannot be computed.

<DT><CODE>int (* fdf) (const gsl_vector * <VAR>x</VAR>, void * <VAR>params</VAR>, gsl_vector * <VAR>f</VAR>, gsl_matrix * <VAR>J</VAR>)</CODE>
<DD>
This function should set the values of the <VAR>f</VAR> and <VAR>J</VAR> as above,
for arguments <VAR>x</VAR> and parameters <VAR>params</VAR>.  This function
provides an optimization of the separate functions for f(x) and
J(x)---it is always faster to compute the function and its
derivative at the same time.

<DT><CODE>size_t n</CODE>
<DD>
the dimension of the system, i.e. the number of components of the
vectors <VAR>x</VAR> and <VAR>f</VAR>.

<DT><CODE>void * params</CODE>
<DD>
a pointer to the parameters of the function.
</DL>
</DL>

<P>
The example of Powell's test function defined above can be extended to
include analytic derivatives using the following code,

</P>

<PRE class="example">
int
powell_df (gsl_vector * x, void * p, gsl_matrix * J) 
{
   struct powell_params * params 
     = *(struct powell_params *)p;
   const double A = (params-&#62;A);
   const double x0 = gsl_vector_get(x,0);
   const double x1 = gsl_vector_get(x,1);
   gsl_matrix_set (J, 0, 0, A * x1);
   gsl_matrix_set (J, 0, 1, A * x0);
   gsl_matrix_set (J, 1, 0, -exp(-x0));
   gsl_matrix_set (J, 1, 1, -exp(-x1));
   return GSL_SUCCESS
}

int
powell_fdf (gsl_vector * x, void * p, 
            gsl_matrix * f, gsl_matrix * J) {
   struct powell_params * params 
     = *(struct powell_params *)p;
   const double A = (params-&#62;A);
   const double x0 = gsl_vector_get(x,0);
   const double x1 = gsl_vector_get(x,1);

   const double u0 = exp(-x0);
   const double u1 = exp(-x1);

   gsl_vector_set (f, 0, A * x0 * x1 - 1);
   gsl_vector_set (f, 1, u0 + u1 - (1 + 1/A));

   gsl_matrix_set (J, 0, 0, A * x1);
   gsl_matrix_set (J, 0, 1, A * x0);
   gsl_matrix_set (J, 1, 0, -u0);
   gsl_matrix_set (J, 1, 1, -u1);
   return GSL_SUCCESS
}

gsl_multiroot_function_fdf FDF;

FDF.f = &#38;powell_f;
FDF.df = &#38;powell_df;
FDF.fdf = &#38;powell_fdf;
FDF.n = 2;
FDF.params = 0;
</PRE>

<P>
Note that the function <CODE>powell_fdf</CODE> is able to reuse existing terms
from the function when calculating the Jacobian, thus saving time.

</P>


<H2><A NAME="SEC461" HREF="gsl_manual.html#TOC461">Iteration</A></H2>

<P>
The following functions drive the iteration of each algorithm.  Each
function performs one iteration to update the state of any solver of the
corresponding type.  The same functions work for all solvers so that
different methods can be substituted at runtime without modifications to
the code.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_multiroot_fsolver_iterate</B> <I>(gsl_multiroot_fsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2158"></A>
<DT><U>Function:</U> int <B>gsl_multiroot_fdfsolver_iterate</B> <I>(gsl_multiroot_fdfsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2159"></A>
These functions perform a single iteration of the solver <VAR>s</VAR>.  If the
iteration encounters an unexpected problem then an error code will be
returned,

</P>
<DL COMPACT>

<DT><CODE>GSL_EBADFUNC</CODE>
<DD>
the iteration encountered a singular point where the function or its
derivative evaluated to <CODE>Inf</CODE> or <CODE>NaN</CODE>.

<DT><CODE>GSL_ENOPROG</CODE>
<DD>
the iteration is not making any progress, preventing the algorithm from
continuing.
</DL>
</DL>

<P>
The solver maintains a current best estimate of the root at all times.
This information can be accessed with the following auxiliary functions,

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_vector * <B>gsl_multiroot_fsolver_root</B> <I>(const gsl_multiroot_fsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2160"></A>
<DT><U>Function:</U> gsl_vector * <B>gsl_multiroot_fdfsolver_root</B> <I>(const gsl_multiroot_fdfsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2161"></A>
These functions return the current estimate of the root for the solver <VAR>s</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_vector * <B>gsl_multiroot_fsolver_f</B> <I>(const gsl_multiroot_fsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2162"></A>
<DT><U>Function:</U> gsl_vector * <B>gsl_multiroot_fdfsolver_f</B> <I>(const gsl_multiroot_fdfsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2163"></A>
These functions return the function value f(x) at the current
estimate of the root for the solver <VAR>s</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_vector * <B>gsl_multiroot_fsolver_dx</B> <I>(const gsl_multiroot_fsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2164"></A>
<DT><U>Function:</U> gsl_vector * <B>gsl_multiroot_fdfsolver_dx</B> <I>(const gsl_multiroot_fdfsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2165"></A>
These functions return the last step dx taken by the solver
<VAR>s</VAR>.
</DL>

</P>


<H2><A NAME="SEC462" HREF="gsl_manual.html#TOC462">Search Stopping Parameters</A></H2>
<P>
<A NAME="IDX2166"></A>

</P>
<P>
A root finding procedure should stop when one of the following conditions is
true:

</P>

<UL class="itemize">
<LI>

A multidimensional root has been found to within the user-specified precision.

<LI>

A user-specified maximum number of iterations has been reached.

<LI>

An error has occurred.
</UL>

<P>
The handling of these conditions is under user control.  The functions
below allow the user to test the precision of the current result in
several standard ways.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_multiroot_test_delta</B> <I>(const gsl_vector * <VAR>dx</VAR>, const gsl_vector * <VAR>x</VAR>, double <VAR>epsabs</VAR>, double <VAR>epsrel</VAR>)</I>
<DD><A NAME="IDX2167"></A>

</P>
<P>
This function tests for the convergence of the sequence by comparing the
last step <VAR>dx</VAR> with the absolute error <VAR>epsabs</VAR> and relative
error <VAR>epsrel</VAR> to the current position <VAR>x</VAR>.  The test returns
<CODE>GSL_SUCCESS</CODE> if the following condition is achieved,

<SPAN class="ifinfo">


<PRE class="example">
|dx_i| &#60; epsabs + epsrel |x_i|
</PRE>

</SPAN>

<P>
for each component of <VAR>x</VAR> and returns <CODE>GSL_CONTINUE</CODE> otherwise.
</DL>

</P>
<P>
<A NAME="IDX2168"></A>
<DL>
<DT><U>Function:</U> int <B>gsl_multiroot_test_residual</B> <I>(const gsl_vector * <VAR>f</VAR>, double <VAR>epsabs</VAR>)</I>
<DD><A NAME="IDX2169"></A>
This function tests the residual value <VAR>f</VAR> against the absolute
error bound <VAR>epsabs</VAR>.  The test returns <CODE>GSL_SUCCESS</CODE> if the
following condition is achieved,

<SPAN class="ifinfo">


<PRE class="example">
\sum_i |f_i| &#60; epsabs
</PRE>

</SPAN>

<P>
and returns <CODE>GSL_CONTINUE</CODE> otherwise.  This criterion is suitable
for situations where the precise location of the root, x, is
unimportant provided a value can be found where the residual is small
enough.
</DL>

</P>



<H2><A NAME="SEC463" HREF="gsl_manual.html#TOC463">Algorithms using Derivatives</A></H2>

<P>
The root finding algorithms described in this section make use of both
the function and its derivative.  They require an initial guess for the
location of the root, but there is no absolute guarantee of
convergence--the function must be suitable for this technique and the
initial guess must be sufficiently close to the root for it to work.
When the conditions are satisfied then convergence is quadratic.

</P>

<P>
<A NAME="IDX2170"></A>
<DL>
<DT><U>Derivative Solver:</U> <B>gsl_multiroot_fdfsolver_hybridsj</B>
<DD><A NAME="IDX2171"></A>
<A NAME="IDX2172"></A>
<A NAME="IDX2173"></A>
This is a modified version of Powell's Hybrid method as implemented in
the HYBRJ algorithm in MINPACK.  Minpack was written by Jorge
J. Mor&eacute;, Burton S. Garbow and Kenneth E. Hillstrom.  The Hybrid
algorithm retains the fast convergence of Newton's method but will also
reduce the residual when Newton's method is unreliable. 

</P>
<P>
The algorithm uses a generalized trust region to keep each step under
control.  In order to be accepted a proposed new position x' must
satisfy the condition |D (x' - x)| &#60; \delta, where D is a
diagonal scaling matrix and \delta is the size of the trust
region.  The components of D are computed internally, using the
column norms of the Jacobian to estimate the sensitivity of the residual
to each component of x.  This improves the behavior of the
algorithm for badly scaled functions.

</P>
<P>
On each iteration the algorithm first determines the standard Newton
step by solving the system J dx = - f.  If this step falls inside
the trust region it is used as a trial step in the next stage.  If not,
the algorithm uses the linear combination of the Newton and gradient
directions which is predicted to minimize the norm of the function while
staying inside the trust region,

<SPAN class="ifinfo">


<PRE class="example">
dx = - \alpha J^{-1} f(x) - \beta \nabla |f(x)|^2.
</PRE>

</SPAN>

<P>
This combination of Newton and gradient directions is referred to as a
<I>dogleg step</I>.

</P>
<P>
The proposed step is now tested by evaluating the function at the
resulting point, x'.  If the step reduces the norm of the function
sufficiently then it is accepted and size of the trust region is
increased.  If the proposed step fails to improve the solution then the
size of the trust region is decreased and another trial step is
computed.

</P>
<P>
The speed of the algorithm is increased by computing the changes to the
Jacobian approximately, using a rank-1 update.  If two successive
attempts fail to reduce the residual then the full Jacobian is
recomputed.  The algorithm also monitors the progress of the solution
and returns an error if several steps fail to make any improvement,

</P>
<DL COMPACT>

<DT><CODE>GSL_ENOPROG</CODE>
<DD>
the iteration is not making any progress, preventing the algorithm from
continuing.

<DT><CODE>GSL_ENOPROGJ</CODE>
<DD>
re-evaluations of the Jacobian indicate that the iteration is not
making any progress, preventing the algorithm from continuing.
</DL>

</DL>

<P>
<DL>
<DT><U>Derivative Solver:</U> <B>gsl_multiroot_fdfsolver_hybridj</B>
<DD><A NAME="IDX2174"></A>
<A NAME="IDX2175"></A>
This algorithm is an unscaled version of <CODE>hybridsj</CODE>.  The steps are
controlled by a spherical trust region |x' - x| &#60; \delta, instead
of a generalized region.  This can be useful if the generalized region
estimated by <CODE>hybridsj</CODE> is inappropriate.
</DL>

</P>

<P>
<DL>
<DT><U>Derivative Solver:</U> <B>gsl_multiroot_fdfsolver_newton</B>
<DD><A NAME="IDX2176"></A>
<A NAME="IDX2177"></A>

</P>
<P>
Newton's Method is the standard root-polishing algorithm.  The algorithm
begins with an initial guess for the location of the solution.  On each
iteration a linear approximation to the function F is used to
estimate the step which will zero all the components of the residual.
The iteration is defined by the following sequence,

<SPAN class="ifinfo">


<PRE class="example">
x -&#62; x' = x - J^{-1} f(x)
</PRE>

</SPAN>

<P>
where the Jacobian matrix J is computed from the derivative
functions provided by <VAR>f</VAR>.  The step dx is obtained by solving
the linear system,

<SPAN class="ifinfo">


<PRE class="example">
J dx = - f(x)
</PRE>

</SPAN>

<P>
using LU decomposition.
</DL>

</P>

<P>
<DL>
<DT><U>Derivative Solver:</U> <B>gsl_multiroot_fdfsolver_gnewton</B>
<DD><A NAME="IDX2178"></A>
<A NAME="IDX2179"></A>
<A NAME="IDX2180"></A>
This is a modified version of Newton's method which attempts to improve
global convergence by requiring every step to reduce the Euclidean norm
of the residual, |f(x)|.  If the Newton step leads to an increase
in the norm then a reduced step of relative size,

<SPAN class="ifinfo">


<PRE class="example">
t = (\sqrt(1 + 6 r) - 1) / (3 r)
</PRE>

</SPAN>

<P>
is proposed, with r being the ratio of norms
|f(x')|^2/|f(x)|^2.  This procedure is repeated until a suitable step
size is found. 
</DL>

</P>



<H2><A NAME="SEC464" HREF="gsl_manual.html#TOC464">Algorithms without Derivatives</A></H2>

<P>
The algorithms described in this section do not require any derivative
information to be supplied by the user.  Any derivatives needed are
approximated by finite differences.  Note that if the
finite-differencing step size chosen by these routines is inappropriate,
an explicit user-supplied numerical derivative can always be used with
the algorithms described in the previous section.

</P>
<P>
<DL>
<DT><U>Solver:</U> <B>gsl_multiroot_fsolver_hybrids</B>
<DD><A NAME="IDX2181"></A>
<A NAME="IDX2182"></A>
This is a version of the Hybrid algorithm which replaces calls to the
Jacobian function by its finite difference approximation.  The finite
difference approximation is computed using <CODE>gsl_multiroots_fdjac</CODE>
with a relative step size of <CODE>GSL_SQRT_DBL_EPSILON</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Solver:</U> <B>gsl_multiroot_fsolver_hybrid</B>
<DD><A NAME="IDX2183"></A>
<A NAME="IDX2184"></A>
This is a finite difference version of the Hybrid algorithm without
internal scaling.
</DL>

</P>

<P>
<DL>
<DT><U>Solver:</U> <B>gsl_multiroot_fsolver_dnewton</B>
<DD><A NAME="IDX2185"></A>

</P>
<P>
<A NAME="IDX2186"></A>
<A NAME="IDX2187"></A>

</P>
<P>
The <I>discrete Newton algorithm</I> is the simplest method of solving a
multidimensional system.  It uses the Newton iteration

<SPAN class="ifinfo">


<PRE class="example">
x -&#62; x - J^{-1} f(x)
</PRE>

</SPAN>

<P>
where the Jacobian matrix J is approximated by taking finite
differences of the function <VAR>f</VAR>.  The approximation scheme used by
this implementation is,

<SPAN class="ifinfo">


<PRE class="example">
J_{ij} = (f_i(x + \delta_j) - f_i(x)) /  \delta_j
</PRE>

</SPAN>

<P>
where \delta_j is a step of size \sqrt\epsilon |x_j| with
\epsilon being the machine precision 
(
\epsilon \approx 2.22 \times 10^-16).
The order of convergence of Newton's algorithm is quadratic, but the
finite differences require n^2 function evaluations on each
iteration.  The algorithm may become unstable if the finite differences
are not a good approximation to the true derivatives.
</DL>

</P>

<P>
<DL>
<DT><U>Solver:</U> <B>gsl_multiroot_fsolver_broyden</B>
<DD><A NAME="IDX2188"></A>
<A NAME="IDX2189"></A>
<A NAME="IDX2190"></A>

</P>
<P>
The <I>Broyden algorithm</I> is a version of the discrete Newton
algorithm which attempts to avoids the expensive update of the Jacobian
matrix on each iteration.  The changes to the Jacobian are also
approximated, using a rank-1 update,

<SPAN class="ifinfo">


<PRE class="example">
J^{-1} \to J^{-1} - (J^{-1} df - dx) dx^T J^{-1} / dx^T J^{-1} df
</PRE>

</SPAN>

<P>
where the vectors dx and df are the changes in x
and f.  On the first iteration the inverse Jacobian is estimated
using finite differences, as in the discrete Newton algorithm.
 
This approximation gives a fast update but is unreliable if the changes
are not small, and the estimate of the inverse Jacobian becomes worse as
time passes.  The algorithm has a tendency to become unstable unless it
starts close to the root.  The Jacobian is refreshed if this instability
is detected (consult the source for details).

</P>
<P>
This algorithm is included only for demonstration purposes, and is not
recommended for serious use.
</DL>

</P>



<H2><A NAME="SEC465" HREF="gsl_manual.html#TOC465">Examples</A></H2>

<P>
The multidimensional solvers are used in a similar way to the
one-dimensional root finding algorithms.  This first example
demonstrates the <CODE>hybrids</CODE> scaled-hybrid algorithm, which does not
require derivatives. The program solves the Rosenbrock system of equations,

<SPAN class="ifinfo">


<PRE class="example">
f_1 (x, y) = a (1 - x)
f_2 (x, y) = b (y - x^2)
</PRE>

</SPAN>

<P>
with a = 1, b = 10. The solution of this system lies at
(x,y) = (1,1) in a narrow valley.

</P>
<P>
The first stage of the program is to define the system of equations,

</P>

<PRE class="example">
#include &#60;stdlib.h&#62;
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_vector.h&#62;
#include &#60;gsl/gsl_multiroots.h&#62;

struct rparams
  {
    double a;
    double b;
  };

int
rosenbrock_f (const gsl_vector * x, void *params, 
              gsl_vector * f)
{
  double a = ((struct rparams *) params)-&#62;a;
  double b = ((struct rparams *) params)-&#62;b;

  const double x0 = gsl_vector_get (x, 0);
  const double x1 = gsl_vector_get (x, 1);

  const double y0 = a * (1 - x0);
  const double y1 = b * (x1 - x0 * x0);

  gsl_vector_set (f, 0, y0);
  gsl_vector_set (f, 1, y1);

  return GSL_SUCCESS;
}
</PRE>

<P>
The main program begins by creating the function object <CODE>f</CODE>, with
the arguments <CODE>(x,y)</CODE> and parameters <CODE>(a,b)</CODE>. The solver
<CODE>s</CODE> is initialized to use this function, with the <CODE>hybrids</CODE>
method.

</P>

<PRE class="example">
int
main (void)
{
  const gsl_multiroot_fsolver_type *T;
  gsl_multiroot_fsolver *s;

  int status;
  size_t i, iter = 0;

  const size_t n = 2;
  struct rparams p = {1.0, 10.0};
  gsl_multiroot_function f = {&#38;rosenbrock_f, n, &#38;p};

  double x_init[2] = {-10.0, -5.0};
  gsl_vector *x = gsl_vector_alloc (n);

  gsl_vector_set (x, 0, x_init[0]);
  gsl_vector_set (x, 1, x_init[1]);

  T = gsl_multiroot_fsolver_hybrids;
  s = gsl_multiroot_fsolver_alloc (T, 2);
  gsl_multiroot_fsolver_set (s, &#38;f, x);

  print_state (iter, s);

  do
    {
      iter++;
      status = gsl_multiroot_fsolver_iterate (s);

      print_state (iter, s);

      if (status)   /* check if solver is stuck */
        break;

      status = 
        gsl_multiroot_test_residual (s-&#62;f, 1e-7);
    }
  while (status == GSL_CONTINUE &#38;&#38; iter &#60; 1000);

  printf ("status = %s\n", gsl_strerror (status));

  gsl_multiroot_fsolver_free (s);
  gsl_vector_free (x);
  return 0;
}
</PRE>

<P>
Note that it is important to check the return status of each solver
step, in case the algorithm becomes stuck.  If an error condition is
detected, indicating that the algorithm cannot proceed, then the error
can be reported to the user, a new starting point chosen or a different
algorithm used.

</P>
<P>
The intermediate state of the solution is displayed by the following
function.  The solver state contains the vector <CODE>s-&#62;x</CODE> which is the
current position, and the vector <CODE>s-&#62;f</CODE> with corresponding function
values.

</P>

<PRE class="example">
int
print_state (size_t iter, gsl_multiroot_fsolver * s)
{
  printf ("iter = %3u x = % .3f % .3f "
          "f(x) = % .3e % .3e\n",
          iter,
          gsl_vector_get (s-&#62;x, 0), 
          gsl_vector_get (s-&#62;x, 1),
          gsl_vector_get (s-&#62;f, 0), 
          gsl_vector_get (s-&#62;f, 1));
}
</PRE>

<P>
Here are the results of running the program. The algorithm is started at
(-10,-5) far from the solution.  Since the solution is hidden in
a narrow valley the earliest steps follow the gradient of the function
downhill, in an attempt to reduce the large value of the residual. Once
the root has been approximately located, on iteration 8, the Newton
behavior takes over and convergence is very rapid.

</P>

<PRE class="smallexample">
iter =  0 x = -10.000  -5.000  f(x) = 1.100e+01 -1.050e+03
iter =  1 x = -10.000  -5.000  f(x) = 1.100e+01 -1.050e+03
iter =  2 x =  -3.976  24.827  f(x) = 4.976e+00  9.020e+01
iter =  3 x =  -3.976  24.827  f(x) = 4.976e+00  9.020e+01
iter =  4 x =  -3.976  24.827  f(x) = 4.976e+00  9.020e+01
iter =  5 x =  -1.274  -5.680  f(x) = 2.274e+00 -7.302e+01
iter =  6 x =  -1.274  -5.680  f(x) = 2.274e+00 -7.302e+01
iter =  7 x =   0.249   0.298  f(x) = 7.511e-01  2.359e+00
iter =  8 x =   0.249   0.298  f(x) = 7.511e-01  2.359e+00
iter =  9 x =   1.000   0.878  f(x) = 1.268e-10 -1.218e+00
iter = 10 x =   1.000   0.989  f(x) = 1.124e-11 -1.080e-01
iter = 11 x =   1.000   1.000  f(x) = 0.000e+00  0.000e+00
status = success
</PRE>

<P>
Note that the algorithm does not update the location on every
iteration. Some iterations are used to adjust the trust-region
parameter, after trying a step which was found to be divergent, or to
recompute the Jacobian, when poor convergence behavior is detected.

</P>
<P>
The next example program adds derivative information, in order to
accelerate the solution. There are two derivative functions
<CODE>rosenbrock_df</CODE> and <CODE>rosenbrock_fdf</CODE>. The latter computes both
the function and its derivative simultaneously. This allows the
optimization of any common terms.  For simplicity we substitute calls to
the separate <CODE>f</CODE> and <CODE>df</CODE> functions at this point in the code
below.

</P>

<PRE class="example">
int
rosenbrock_df (const gsl_vector * x, void *params, 
               gsl_matrix * J)
{
  const double a = ((struct rparams *) params)-&#62;a;
  const double b = ((struct rparams *) params)-&#62;b;

  const double x0 = gsl_vector_get (x, 0);

  const double df00 = -a;
  const double df01 = 0;
  const double df10 = -2 * b  * x0;
  const double df11 = b;

  gsl_matrix_set (J, 0, 0, df00);
  gsl_matrix_set (J, 0, 1, df01);
  gsl_matrix_set (J, 1, 0, df10);
  gsl_matrix_set (J, 1, 1, df11);

  return GSL_SUCCESS;
}

int
rosenbrock_fdf (const gsl_vector * x, void *params,
                gsl_vector * f, gsl_matrix * J)
{
  rosenbrock_f (x, params, f);
  rosenbrock_df (x, params, J);

  return GSL_SUCCESS;
}
</PRE>

<P>
The main program now makes calls to the corresponding <CODE>fdfsolver</CODE>
versions of the functions,

</P>

<PRE class="example">
int
main (void)
{
  const gsl_multiroot_fdfsolver_type *T;
  gsl_multiroot_fdfsolver *s;

  int status;
  size_t i, iter = 0;

  const size_t n = 2;
  struct rparams p = {1.0, 10.0};
  gsl_multiroot_function_fdf f = {&#38;rosenbrock_f, 
                                  &#38;rosenbrock_df, 
                                  &#38;rosenbrock_fdf, 
                                  n, &#38;p};

  double x_init[2] = {-10.0, -5.0};
  gsl_vector *x = gsl_vector_alloc (n);

  gsl_vector_set (x, 0, x_init[0]);
  gsl_vector_set (x, 1, x_init[1]);

  T = gsl_multiroot_fdfsolver_gnewton;
  s = gsl_multiroot_fdfsolver_alloc (T, n);
  gsl_multiroot_fdfsolver_set (s, &#38;f, x);

  print_state (iter, s);

  do
    {
      iter++;

      status = gsl_multiroot_fdfsolver_iterate (s);

      print_state (iter, s);

      if (status)
        break;

      status = gsl_multiroot_test_residual (s-&#62;f, 1e-7);
    }
  while (status == GSL_CONTINUE &#38;&#38; iter &#60; 1000);

  printf ("status = %s\n", gsl_strerror (status));

  gsl_multiroot_fdfsolver_free (s);
  gsl_vector_free (x);
  return 0;
}
</PRE>

<P>
The addition of derivative information to the <CODE>hybrids</CODE> solver does
not make any significant difference to its behavior, since it able to
approximate the Jacobian numerically with sufficient accuracy.  To
illustrate the behavior of a different derivative solver we switch to
<CODE>gnewton</CODE>. This is a traditional Newton solver with the constraint
that it scales back its step if the full step would lead "uphill". Here
is the output for the <CODE>gnewton</CODE> algorithm,

</P>

<PRE class="smallexample">
iter = 0 x = -10.000  -5.000 f(x) =  1.100e+01 -1.050e+03
iter = 1 x =  -4.231 -65.317 f(x) =  5.231e+00 -8.321e+02
iter = 2 x =   1.000 -26.358 f(x) = -8.882e-16 -2.736e+02
iter = 3 x =   1.000   1.000 f(x) = -2.220e-16 -4.441e-15
status = success
</PRE>

<P>
The convergence is much more rapid, but takes a wide excursion out to
the point (-4.23,-65.3). This could cause the algorithm to go
astray in a realistic application.  The hybrid algorithm follows the
downhill path to the solution more reliably.

</P>


<H2><A NAME="SEC466" HREF="gsl_manual.html#TOC466">References and Further Reading</A></H2>

<P>
The original version of the Hybrid method is described in the following
articles by Powell,

</P>

<UL class="itemize">
<LI>

M.J.D. Powell, "A Hybrid Method for Nonlinear Equations" (Chap 6, p
87--114) and "A Fortran Subroutine for Solving systems of Nonlinear
Algebraic Equations" (Chap 7, p 115--161), in <CITE>Numerical Methods for
Nonlinear Algebraic Equations</CITE>, P. Rabinowitz, editor.  Gordon and
Breach, 1970.
</UL>

<P>
The following papers are also relevant to the algorithms described in
this section,

</P>

<UL class="itemize">
<LI>

J.J. Mor&eacute;, M.Y. Cosnard, "Numerical Solution of Nonlinear Equations",
<CITE>ACM Transactions on Mathematical Software</CITE>, Vol 5, No 1, (1979), p 64--85

<LI>

C.G. Broyden, "A Class of Methods for Solving Nonlinear
Simultaneous Equations", <CITE>Mathematics of Computation</CITE>, Vol 19 (1965),
p 577--593

<LI>

J.J. Mor&eacute;, B.S. Garbow, K.E. Hillstrom, "Testing Unconstrained
Optimization Software", ACM Transactions on Mathematical Software, Vol
7, No 1 (1981), p 17--41
</UL>



<H1><A NAME="SEC467" HREF="gsl_manual.html#TOC467">Multidimensional Minimization</A></H1>
<P>
<A NAME="IDX2191"></A>

</P>
<P>
This chapter describes routines for finding minima of arbitrary
multidimensional functions.  The library provides low level components
for a variety of iterative minimizers and convergence tests.  These can
be combined by the user to achieve the desired solution, while providing
full access to the intermediate steps of the algorithms.  Each class of
methods uses the same framework, so that you can switch between
minimizers at runtime without needing to recompile your program.  Each
instance of a minimizer keeps track of its own state, allowing the
minimizers to be used in multi-threaded programs. The minimization
algorithms can be used to maximize a function by inverting its sign.

</P>
<P>
The header file <TT>'gsl_multimin.h'</TT> contains prototypes for the
minimization functions and related declarations.  

</P>



<H2><A NAME="SEC468" HREF="gsl_manual.html#TOC468">Overview</A></H2>

<P>
The problem of multidimensional minimization requires finding a point
x such that the scalar function,

<SPAN class="ifinfo">


<PRE class="example">
f(x_1, ..., x_n)
</PRE>

</SPAN>

<P>
takes a value which is lower than at any neighboring point. For smooth
functions the gradient g = \nabla f vanishes at the minimum. In
general there are no bracketing methods available for the
minimization of n-dimensional functions.  The algorithms
proceed from an initial guess using a search algorithm which attempts
to move in a downhill direction. 

</P>
<P>
Algorithms making use of the gradient of the function perform a
one-dimensional line minimisation along this direction until the lowest
point is found to a suitable tolerance.  The search direction is then
updated with local information from the function and its derivatives,
and the whole process repeated until the true n-dimensional
minimum is found.

</P>
<P>
The Nelder-Mead Simplex algorithm applies a different strategy.  It
maintains n+1 trial parameter vectors as the vertices of a
n-dimensional simplex.  In each iteration step it tries to
improve the worst vertex by a simple geometrical transformation until
the size of the simplex falls below a given tolerance.

</P>
<P>
Both types of algorithms use a standard framework. The user provides a
high-level driver for the algorithms, and the library provides the
individual functions necessary for each of the steps.  There are three
main phases of the iteration.  The steps are,

</P>

<UL class="itemize">
<LI>

initialize minimizer state, <VAR>s</VAR>, for algorithm <VAR>T</VAR>

<LI>

update <VAR>s</VAR> using the iteration <VAR>T</VAR>

<LI>

test <VAR>s</VAR> for convergence, and repeat iteration if necessary
</UL>

<P>
Each iteration step consists either of an improvement to the
line-minimisation in the current direction or an update to the search
direction itself.  The state for the minimizers is held in a
<CODE>gsl_multimin_fdfminimizer</CODE> struct or a
<CODE>gsl_multimin_fminimizer</CODE> struct.

</P>


<H2><A NAME="SEC469" HREF="gsl_manual.html#TOC469">Caveats</A></H2>
<P>
<A NAME="IDX2192"></A>

</P>
<P>
Note that the minimization algorithms can only search for one local
minimum at a time.  When there are several local minima in the search
area, the first minimum to be found will be returned; however it is
difficult to predict which of the minima this will be.  In most cases,
no error will be reported if you try to find a local minimum in an area
where there is more than one.

</P>
<P>
It is also important to note that the minimization algorithms find local
minima; there is no way to determine whether a minimum is a global
minimum of the function in question.

</P>


<H2><A NAME="SEC470" HREF="gsl_manual.html#TOC470">Initializing the Multidimensional Minimizer</A></H2>

<P>
The following function initializes a multidimensional minimizer.  The
minimizer itself depends only on the dimension of the problem and the
algorithm and can be reused for different problems.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_multimin_fdfminimizer * <B>gsl_multimin_fdfminimizer_alloc</B> <I>(const gsl_multimin_fdfminimizer_type * <VAR>T</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX2193"></A>
<DT><U>Function:</U> gsl_multimin_fminimizer * <B>gsl_multimin_fminimizer_alloc</B> <I>(const gsl_multimin_fminimizer_type * <VAR>T</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX2194"></A>
This function returns a pointer to a newly allocated instance of a
minimizer of type <VAR>T</VAR> for an <VAR>n</VAR>-dimension function.  If there
is insufficient memory to create the minimizer then the function returns
a null pointer and the error handler is invoked with an error code of
<CODE>GSL_ENOMEM</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_multimin_fdfminimizer_set</B> <I>(gsl_multimin_fdfminimizer * <VAR>s</VAR>, gsl_multimin_function_fdf * <VAR>fdf</VAR>, const gsl_vector * <VAR>x</VAR>, double <VAR>step_size</VAR>, double <VAR>tol</VAR>)</I>
<DD><A NAME="IDX2195"></A>
This function initializes the minimizer <VAR>s</VAR> to minimize the function
<VAR>fdf</VAR> starting from the initial point <VAR>x</VAR>.  The size of the
first trial step is given by <VAR>step_size</VAR>.  The accuracy of the line
minimization is specified by <VAR>tol</VAR>.  The precise meaning of this
parameter depends on the method used.  Typically the line minimization
is considered successful if the gradient of the function g is
orthogonal to the current search direction p to a relative
accuracy of <VAR>tol</VAR>, where 
dot(p,g) &#60; tol |p| |g|.

</P>
<P>
<DT><U>Function:</U> int <B>gsl_multimin_fminimizer_set</B> <I>(gsl_multimin_fminimizer * <VAR>s</VAR>, gsl_multimin_function * <VAR>f</VAR>, const gsl_vector * <VAR>x</VAR>, const gsl_vector * <VAR>step_size</VAR>)</I>
<DD><A NAME="IDX2196"></A>
This function initializes the minimizer <VAR>s</VAR> to minimize the function
<VAR>f</VAR>, starting from the initial point
<VAR>x</VAR>. The size of the initial trial steps is given in vector
<VAR>step_size</VAR>. The precise meaning of this parameter depends on the
method used. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_multimin_fdfminimizer_free</B> <I>(gsl_multimin_fdfminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2197"></A>
<DT><U>Function:</U> void <B>gsl_multimin_fminimizer_free</B> <I>(gsl_multimin_fminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2198"></A>
This function frees all the memory associated with the minimizer
<VAR>s</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> const char * <B>gsl_multimin_fdfminimizer_name</B> <I>(const gsl_multimin_fdfminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2199"></A>
<DT><U>Function:</U> const char * <B>gsl_multimin_fminimizer_name</B> <I>(const gsl_multimin_fminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2200"></A>
This function returns a pointer to the name of the minimizer.  For example,

</P>

<PRE class="example">
printf ("s is a '%s' minimizer\n", 
        gsl_multimin_fdfminimizer_name (s));
</PRE>

<P>
would print something like <CODE>s is a 'conjugate_pr' minimizer</CODE>.
</DL>

</P>


<H2><A NAME="SEC471" HREF="gsl_manual.html#TOC471">Providing a function to minimize</A></H2>

<P>
You must provide a parametric function of n variables for the
minimizers to operate on.  You may also need to provide a routine which
calculates the gradient of the function and a third routine which
calculates both the function value and the gradient together.  In order
to allow for general parameters the functions are defined by the
following data types:

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_multimin_function_fdf</B>
<DD><A NAME="IDX2201"></A>
This data type defines a general function of n variables with
parameters and the corresponding gradient vector of derivatives,

</P>
<DL COMPACT>

<DT><CODE>double (* f) (const gsl_vector * <VAR>x</VAR>, void * <VAR>params</VAR>)</CODE>
<DD>
this function should return the result
f(x,params) for argument <VAR>x</VAR> and parameters <VAR>params</VAR>.

<DT><CODE>void (* df) (const gsl_vector * <VAR>x</VAR>, void * <VAR>params</VAR>, gsl_vector * <VAR>g</VAR>)</CODE>
<DD>
this function should store the <VAR>n</VAR>-dimensional gradient
g_i = d f(x,params) / d x_i in the vector <VAR>g</VAR> for argument <VAR>x</VAR> 
and parameters <VAR>params</VAR>, returning an appropriate error code if the
function cannot be computed.

<DT><CODE>void (* fdf) (const gsl_vector * <VAR>x</VAR>, void * <VAR>params</VAR>, double * f, gsl_vector * <VAR>g</VAR>)</CODE>
<DD>
This function should set the values of the <VAR>f</VAR> and <VAR>g</VAR> as above,
for arguments <VAR>x</VAR> and parameters <VAR>params</VAR>.  This function
provides an optimization of the separate functions for f(x) and
g(x)---it is always faster to compute the function and its
derivative at the same time.

<DT><CODE>size_t n</CODE>
<DD>
the dimension of the system, i.e. the number of components of the
vectors <VAR>x</VAR>.

<DT><CODE>void * params</CODE>
<DD>
a pointer to the parameters of the function.
</DL>
</DL>
<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_multimin_function</B>
<DD><A NAME="IDX2202"></A>
This data type defines a general function of n variables with
parameters,

</P>
<DL COMPACT>

<DT><CODE>double (* f) (const gsl_vector * <VAR>x</VAR>, void * <VAR>params</VAR>)</CODE>
<DD>
this function should return the result
f(x,params) for argument <VAR>x</VAR> and parameters <VAR>params</VAR>.

<DT><CODE>size_t n</CODE>
<DD>
the dimension of the system, i.e. the number of components of the
vectors <VAR>x</VAR>.

<DT><CODE>void * params</CODE>
<DD>
a pointer to the parameters of the function.
</DL>
</DL>
<P>
The following example function defines a simple paraboloid with two
parameters,

</P>

<PRE class="example">
/* Paraboloid centered on (dp[0],dp[1]) */

double
my_f (const gsl_vector *v, void *params)
{
  double x, y;
  double *dp = (double *)params;
  
  x = gsl_vector_get(v, 0);
  y = gsl_vector_get(v, 1);
 
  return 10.0 * (x - dp[0]) * (x - dp[0]) +
           20.0 * (y - dp[1]) * (y - dp[1]) + 30.0; 
}

/* The gradient of f, df = (df/dx, df/dy). */
void 
my_df (const gsl_vector *v, void *params, 
       gsl_vector *df)
{
  double x, y;
  double *dp = (double *)params;
  
  x = gsl_vector_get(v, 0);
  y = gsl_vector_get(v, 1);
 
  gsl_vector_set(df, 0, 20.0 * (x - dp[0]));
  gsl_vector_set(df, 1, 40.0 * (y - dp[1]));
}

/* Compute both f and df together. */
void 
my_fdf (const gsl_vector *x, void *params, 
        double *f, gsl_vector *df) 
{
  *f = my_f(x, params); 
  my_df(x, params, df);
}
</PRE>

<P>
The function can be initialized using the following code,

</P>

<PRE class="example">
gsl_multimin_function_fdf my_func;

double p[2] = { 1.0, 2.0 }; /* center at (1,2) */

my_func.f = &#38;my_f;
my_func.df = &#38;my_df;
my_func.fdf = &#38;my_fdf;
my_func.n = 2;
my_func.params = (void *)p;
</PRE>



<H2><A NAME="SEC472" HREF="gsl_manual.html#TOC472">Iteration</A></H2>

<P>
The following function drives the iteration of each algorithm.  The
function performs one iteration to update the state of the minimizer.
The same function works for all minimizers so that different methods can
be substituted at runtime without modifications to the code.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_multimin_fdfminimizer_iterate</B> <I>(gsl_multimin_fdfminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2203"></A>
<DT><U>Function:</U> int <B>gsl_multimin_fminimizer_iterate</B> <I>(gsl_multimin_fminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2204"></A>
These functions perform a single iteration of the minimizer <VAR>s</VAR>.  If
the iteration encounters an unexpected problem then an error code will
be returned.
</DL>
The minimizer maintains a current best estimate of the minimum at all
times.  This information can be accessed with the following auxiliary
functions,

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_vector * <B>gsl_multimin_fdfminimizer_x</B> <I>(const gsl_multimin_fdfminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2205"></A>
<DT><U>Function:</U> gsl_vector * <B>gsl_multimin_fminimizer_x</B> <I>(const gsl_multimin_fminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2206"></A>
<DT><U>Function:</U> double <B>gsl_multimin_fdfminimizer_minimum</B> <I>(const gsl_multimin_fdfminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2207"></A>
<DT><U>Function:</U> double <B>gsl_multimin_fminimizer_minimum</B> <I>(const gsl_multimin_fminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2208"></A>
<DT><U>Function:</U> gsl_vector * <B>gsl_multimin_fdfminimizer_gradient</B> <I>(const gsl_multimin_fdfminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2209"></A>
<DT><U>Function:</U> double <B>gsl_multimin_fminimizer_size</B> <I>(const gsl_multimin_fminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2210"></A>
These functions return the current best estimate of the location of the
minimum, the value of the function at that point, its gradient, 
and minimizer specific characteristic size for the minimizer <VAR>s</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_multimin_fdfminimizer_restart</B> <I>(gsl_multimin_fdfminimizer * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2211"></A>
This function resets the minimizer <VAR>s</VAR> to use the current point as a
new starting point.
</DL>

</P>


<H2><A NAME="SEC473" HREF="gsl_manual.html#TOC473">Stopping Criteria</A></H2>

<P>
A minimization procedure should stop when one of the following
conditions is true:

</P>

<UL class="itemize">
<LI>

A minimum has been found to within the user-specified precision.

<LI>

A user-specified maximum number of iterations has been reached.

<LI>

An error has occurred.
</UL>

<P>
The handling of these conditions is under user control.  The functions
below allow the user to test the precision of the current result.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_multimin_test_gradient</B> <I>(const gsl_vector * <VAR>g</VAR>, double <VAR>epsabs</VAR>)</I>
<DD><A NAME="IDX2212"></A>
This function tests the norm of the gradient <VAR>g</VAR> against the
absolute tolerance <VAR>epsabs</VAR>. The gradient of a multidimensional
function goes to zero at a minimum. The test returns <CODE>GSL_SUCCESS</CODE>
if the following condition is achieved,

<SPAN class="ifinfo">


<PRE class="example">
|g| &#60; epsabs
</PRE>

</SPAN>

<P>
and returns <CODE>GSL_CONTINUE</CODE> otherwise.  A suitable choice of
<VAR>epsabs</VAR> can be made from the desired accuracy in the function for
small variations in x.  The relationship between these quantities
is given by 
\delta f = g \delta x.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_multimin_test_size</B> <I>(const double <VAR>size</VAR>, double <VAR>epsabs</VAR>)</I>
<DD><A NAME="IDX2213"></A>
This function tests the minimizer specific characteristic
size (if applicable to the used minimizer) against absolute tolerance <VAR>epsabs</VAR>. 
The test returns <CODE>GSL_SUCCESS</CODE> if the size is smaller than tolerance,
otherwise <CODE>GSL_CONTINUE</CODE> is returned.
</DL>

</P>


<H2><A NAME="SEC474" HREF="gsl_manual.html#TOC474">Algorithms</A></H2>

<P>
There are several minimization methods available. The best choice of
algorithm depends on the problem.  All of the algorithms use the value
of the function and its gradient at each evaluation point, except for
the Simplex algorithm which uses function values only.

</P>
<P>
<DL>
<DT><U>Minimizer:</U> <B>gsl_multimin_fdfminimizer_conjugate_fr</B>
<DD><A NAME="IDX2214"></A>
<A NAME="IDX2215"></A>
<A NAME="IDX2216"></A>
<A NAME="IDX2217"></A>
This is the Fletcher-Reeves conjugate gradient algorithm. The conjugate
gradient algorithm proceeds as a succession of line minimizations. The
sequence of search directions is used to build up an approximation to the
curvature of the function in the neighborhood of the minimum.  

</P>
<P>
An initial search direction <VAR>p</VAR> is chosen using the gradient, and line
minimization is carried out in that direction.  The accuracy of the line
minimization is specified by the parameter <VAR>tol</VAR>.  The minimum
along this line occurs when the function gradient <VAR>g</VAR> and the search direction
<VAR>p</VAR> are orthogonal.  The line minimization terminates when
dot(p,g) &#60; tol |p| |g|.  The
search direction is updated  using the Fletcher-Reeves formula
p' = g' - \beta g where \beta=-|g'|^2/|g|^2, and
the line minimization is then repeated for the new search
direction.
</DL>

</P>
<P>
<DL>
<DT><U>Minimizer:</U> <B>gsl_multimin_fdfminimizer_conjugate_pr</B>
<DD><A NAME="IDX2218"></A>
<A NAME="IDX2219"></A>
<A NAME="IDX2220"></A>
This is the Polak-Ribiere conjugate gradient algorithm.  It is similar
to the Fletcher-Reeves method, differing only in the choice of the
coefficient \beta. Both methods work well when the evaluation
point is close enough to the minimum of the objective function that it
is well approximated by a quadratic hypersurface.
</DL>

</P>
<P>
<DL>
<DT><U>Minimizer:</U> <B>gsl_multimin_fdfminimizer_vector_bfgs</B>
<DD><A NAME="IDX2221"></A>
<A NAME="IDX2222"></A>
<A NAME="IDX2223"></A>
This is the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) conjugate gradient
algorithm.  It is a quasi-Newton method which builds up an approximation
to the second derivatives of the function f using the difference
between successive gradient vectors.  By combining the first and second
derivatives the algorithm is able to take Newton-type steps towards the
function minimum, assuming quadratic behavior in that region.
</DL>

</P>
<P>
<DL>
<DT><U>Minimizer:</U> <B>gsl_multimin_fdfminimizer_steepest_descent</B>
<DD><A NAME="IDX2224"></A>
<A NAME="IDX2225"></A>
<A NAME="IDX2226"></A>
The steepest descent algorithm follows the downhill gradient of the
function at each step. When a downhill step is successful the step-size
is increased by a factor of two.  If the downhill step leads to a higher
function value then the algorithm backtracks and the step size is
decreased using the parameter <VAR>tol</VAR>.  A suitable value of <VAR>tol</VAR>
for most applications is 0.1.  The steepest descent method is
inefficient and is included only for demonstration purposes.
</DL>

</P>
<P>
<DL>
<DT><U>Minimizer:</U> <B>gsl_multimin_fminimizer_nmsimplex</B>
<DD><A NAME="IDX2227"></A>
<A NAME="IDX2228"></A>
<A NAME="IDX2229"></A>
<A NAME="IDX2230"></A>
This is the Simplex algorithm of Nelder and Mead. It constructs 
n vectors p_i from the
starting vector <VAR>x</VAR> and the vector <VAR>step_size</VAR> as follows:

<SPAN class="ifinfo">


<PRE class="example">
p_0 = (x_0, x_1, ... , x_n) 
p_1 = (x_0 + step_size_0, x_1, ... , x_n) 
p_2 = (x_0, x_1 + step_size_1, ... , x_n) 
... = ...
p_n = (x_0, x_1, ... , x_n+step_size_n)
</PRE>

</SPAN>

<P>
These vectors form the n+1 vertices of a simplex in n
dimensions.  On each iteration the algorithm tries to improve
the parameter vector p_i corresponding to the highest
function value by simple geometrical transformations.  These
are reflection, reflection followed by expansion, contraction and multiple
contraction. Using these transformations the simplex moves through 
the parameter space towards the minimum, where it contracts itself.  

</P>
<P>
After each iteration, the best vertex is returned.  Note, that due to
the nature of the algorithm not every step improves the current
best parameter vector.  Usually several iterations are required.

</P>
<P>
The routine calculates the minimizer specific characteristic size as the
average distance from the geometrical center of the simplex to all its
vertices.  This size can be used as a stopping criteria, as the simplex
contracts itself near the minimum. The size is returned by the function
<CODE>gsl_multimin_fminimizer_size</CODE>.
</DL>

</P>


<H2><A NAME="SEC475" HREF="gsl_manual.html#TOC475">Examples</A></H2>

<P>
This example program finds the minimum of the paraboloid function
defined earlier.  The location of the minimum is offset from the origin
in x and y, and the function value at the minimum is
non-zero. The main program is given below, it requires the example
function given earlier in this chapter.

</P>

<PRE class="smallexample">
int
main (void)
{
  size_t iter = 0;
  int status;

  const gsl_multimin_fdfminimizer_type *T;
  gsl_multimin_fdfminimizer *s;

  /* Position of the minimum (1,2). */
  double par[2] = { 1.0, 2.0 };

  gsl_vector *x;
  gsl_multimin_function_fdf my_func;

  my_func.f = &#38;my_f;
  my_func.df = &#38;my_df;
  my_func.fdf = &#38;my_fdf;
  my_func.n = 2;
  my_func.params = &#38;par;

  /* Starting point, x = (5,7) */
  x = gsl_vector_alloc (2);
  gsl_vector_set (x, 0, 5.0);
  gsl_vector_set (x, 1, 7.0);

  T = gsl_multimin_fdfminimizer_conjugate_fr;
  s = gsl_multimin_fdfminimizer_alloc (T, 2);

  gsl_multimin_fdfminimizer_set (s, &#38;my_func, x, 0.01, 1e-4);

  do
    {
      iter++;
      status = gsl_multimin_fdfminimizer_iterate (s);

      if (status)
        break;

      status = gsl_multimin_test_gradient (s-&#62;gradient, 1e-3);

      if (status == GSL_SUCCESS)
        printf ("Minimum found at:\n");

      printf ("%5d %.5f %.5f %10.5f\n", iter,
              gsl_vector_get (s-&#62;x, 0), 
              gsl_vector_get (s-&#62;x, 1), 
              s-&#62;f);

    }
  while (status == GSL_CONTINUE &#38;&#38; iter &#60; 100);

  gsl_multimin_fdfminimizer_free (s);
  gsl_vector_free (x);

  return 0;
}
</PRE>

<P>
The initial step-size is chosen as 0.01, a conservative estimate in this
case, and the line minimization parameter is set at 0.0001.  The program
terminates when the norm of the gradient has been reduced below
0.001. The output of the program is shown below,

</P>

<PRE class="example">
         x       y         f
    1 4.99629 6.99072  687.84780
    2 4.98886 6.97215  683.55456
    3 4.97400 6.93501  675.01278
    4 4.94429 6.86073  658.10798
    5 4.88487 6.71217  625.01340
    6 4.76602 6.41506  561.68440
    7 4.52833 5.82083  446.46694
    8 4.05295 4.63238  261.79422
    9 3.10219 2.25548   75.49762
   10 2.85185 1.62963   67.03704
   11 2.19088 1.76182   45.31640
   12 0.86892 2.02622   30.18555
Minimum found at:
   13 1.00000 2.00000   30.00000
</PRE>

<P>
Note that the algorithm gradually increases the step size as it
successfully moves downhill, as can be seen by plotting the successive
points.

</P>
<P>
<BR><IMG SRC="multimin"><BR>
The conjugate gradient algorithm finds the minimum on its second
direction because the function is purely quadratic. Additional
iterations would be needed for a more complicated function.

</P>
<P>
Here is another example using the Nelder-Mead Simplex algorithm to
minimize the same example object function, as above.

</P>

<PRE class="smallexample">
int 
main(void)
{
  size_t np = 2;
  double par[2] = {1.0, 2.0};

  const gsl_multimin_fminimizer_type *T = 
    gsl_multimin_fminimizer_nmsimplex;
  gsl_multimin_fminimizer *s = NULL;
  gsl_vector *ss, *x;
  gsl_multimin_function minex_func;

  size_t iter = 0, i;
  int status;
  double size;

  /* Initial vertex size vector */
  ss = gsl_vector_alloc (np);

  /* Set all step sizes to 1 */
  gsl_vector_set_all (ss, 1.0);

  /* Starting point */
  x = gsl_vector_alloc (np);

  gsl_vector_set (x, 0, 5.0);
  gsl_vector_set (x, 1, 7.0);

  /* Initialize method and iterate */
  minex_func.f = &#38;my_f;
  minex_func.n = np;
  minex_func.params = (void *)&#38;par;

  s = gsl_multimin_fminimizer_alloc (T, np);
  gsl_multimin_fminimizer_set (s, &#38;minex_func, x, ss);

  do
    {
      iter++;
      status = gsl_multimin_fminimizer_iterate(s);
      
      if (status) 
        break;

      size = gsl_multimin_fminimizer_size (s);
      status = gsl_multimin_test_size (size, 1e-2);

      if (status == GSL_SUCCESS)
        {
          printf ("converged to minimum at\n");
        }

      printf ("%5d ", iter);
      for (i = 0; i &#60; np; i++)
        {
          printf ("%10.3e ", gsl_vector_get (s-&#62;x, i));
        }
      printf ("f() = %7.3f size = %.3f\n", s-&#62;fval, size);
    }
  while (status == GSL_CONTINUE &#38;&#38; iter &#60; 100);
  
  gsl_vector_free(x);
  gsl_vector_free(ss);
  gsl_multimin_fminimizer_free (s);

  return status;
}
</PRE>

<P>
The minimum search stops when the Simplex size drops to 0.01. The output is
shown below.

</P>

<PRE class="example">
    1  6.500e+00  5.000e+00 f() = 512.500 size = 1.082
    2  5.250e+00  4.000e+00 f() = 290.625 size = 1.372
    3  5.250e+00  4.000e+00 f() = 290.625 size = 1.372
    4  5.500e+00  1.000e+00 f() = 252.500 size = 1.372
    5  2.625e+00  3.500e+00 f() = 101.406 size = 1.823
    6  3.469e+00  1.375e+00 f() = 98.760  size = 1.526
    7  1.820e+00  3.156e+00 f() = 63.467  size = 1.105
    8  1.820e+00  3.156e+00 f() = 63.467  size = 1.105
    9  1.016e+00  2.812e+00 f() = 43.206  size = 1.105
   10  2.041e+00  2.008e+00 f() = 40.838  size = 0.645
   11  1.236e+00  1.664e+00 f() = 32.816  size = 0.645
   12  1.236e+00  1.664e+00 f() = 32.816  size = 0.447
   13  5.225e-01  1.980e+00 f() = 32.288  size = 0.447
   14  1.103e+00  2.073e+00 f() = 30.214  size = 0.345
   15  1.103e+00  2.073e+00 f() = 30.214  size = 0.264
   16  1.103e+00  2.073e+00 f() = 30.214  size = 0.160
   17  9.864e-01  1.934e+00 f() = 30.090  size = 0.132
   18  9.190e-01  1.987e+00 f() = 30.069  size = 0.092
   19  1.028e+00  2.017e+00 f() = 30.013  size = 0.056
   20  1.028e+00  2.017e+00 f() = 30.013  size = 0.046
   21  1.028e+00  2.017e+00 f() = 30.013  size = 0.033
   22  9.874e-01  1.985e+00 f() = 30.006  size = 0.028
   23  9.846e-01  1.995e+00 f() = 30.003  size = 0.023
   24  1.007e+00  2.003e+00 f() = 30.001  size = 0.012
converged to minimum at                  
   25  1.007e+00  2.003e+00 f() = 30.001  size = 0.010
</PRE>

<P>
The simplex size first increases, while the simplex moves towards the
minimum. After a while the size begins to decrease as the simplex
contracts around the minimum.

</P>


<H2><A NAME="SEC476" HREF="gsl_manual.html#TOC476">References and Further Reading</A></H2>

<P>
A brief description of multidimensional minimization algorithms and
further references can be found in the following book,

</P>

<UL class="itemize">
<LI>C.W. Ueberhuber,

<CITE>Numerical Computation (Volume 2)</CITE>, Chapter 14, Section 4.4
"Minimization Methods", p. 325--335, Springer (1997), ISBN
3-540-62057-5.
</UL>

<P>
The simplex algorithm is described in the following paper, 

</P>

<UL class="itemize">
<LI>J.A. Nelder and R. Mead,

<CITE>A simplex method for function minimization</CITE>, Computer Journal
vol. 7 (1965), 308--315.
</UL>

<P>

</P>


<H1><A NAME="SEC477" HREF="gsl_manual.html#TOC477">Least-Squares Fitting</A></H1>
<P>
<A NAME="IDX2231"></A>
<A NAME="IDX2232"></A>
<A NAME="IDX2233"></A>
<A NAME="IDX2234"></A>
This chapter describes routines for performing least squares fits to
experimental data using linear combinations of functions. The data may
be weighted or unweighted.  For weighted data the functions compute the
best fit parameters and their associated covariance matrix.  For
unweighted data the covariance matrix is estimated from the scatter of
the points, giving a variance-covariance matrix. The functions are
divided into separate versions for simple one- or two-parameter
regression and multiple-parameter fits.  The functions are declared in
the header file <TT>'gsl_fit.h'</TT>.

</P>



<H2><A NAME="SEC478" HREF="gsl_manual.html#TOC478">Linear regression</A></H2>
<P>
<A NAME="IDX2235"></A>
The functions described in this section can be used to perform
least-squares fits to a straight line model, Y = c_0 + c_1 X.
For weighted data the best-fit is found by minimizing the weighted sum of
squared residuals, \chi^2,

<SPAN class="ifinfo">


<PRE class="example">
\chi^2 = \sum_i w_i (y_i - (c_0 + c_1 x_i))^2
</PRE>

</SPAN>

<P>
for the parameters c_0, c_1.  For unweighted data the
sum is computed with w_i = 1.

</P>
<P>
<A NAME="IDX2236"></A>
<DL>
<DT><U>Function:</U> int <B>gsl_fit_linear</B> <I>(const double * <VAR>x</VAR>, const size_t <VAR>xstride</VAR>, const double * <VAR>y</VAR>, const size_t <VAR>ystride</VAR>, size_t <VAR>n</VAR>, double * <VAR>c0</VAR>, double * <VAR>c1</VAR>, double * <VAR>cov00</VAR>, double * <VAR>cov01</VAR>, double * <VAR>cov11</VAR>, double * <VAR>sumsq</VAR>)</I>
<DD><A NAME="IDX2237"></A>
This function computes the best-fit linear regression coefficients
(<VAR>c0</VAR>,<VAR>c1</VAR>) of the model Y = c_0 + c_1 X for the datasets
(<VAR>x</VAR>, <VAR>y</VAR>), two vectors of length <VAR>n</VAR> with strides
<VAR>xstride</VAR> and <VAR>ystride</VAR>.  The variance-covariance matrix for the
parameters (<VAR>c0</VAR>, <VAR>c1</VAR>) is estimated from the scatter of the
points around the best-fit line and returned via the parameters
(<VAR>cov00</VAR>, <VAR>cov01</VAR>, <VAR>cov11</VAR>).  The sum of squares of the
residuals from the best-fit line is returned in <VAR>sumsq</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_fit_wlinear</B> <I>(const double * <VAR>x</VAR>, const size_t <VAR>xstride</VAR>, const double * <VAR>w</VAR>, const size_t <VAR>wstride</VAR>, const double * <VAR>y</VAR>, const size_t <VAR>ystride</VAR>, size_t <VAR>n</VAR>, double * <VAR>c0</VAR>, double * <VAR>c1</VAR>, double * <VAR>cov00</VAR>, double * <VAR>cov01</VAR>, double * <VAR>cov11</VAR>, double * <VAR>chisq</VAR>)</I>
<DD><A NAME="IDX2238"></A>
This function computes the best-fit linear regression coefficients
(<VAR>c0</VAR>,<VAR>c1</VAR>) of the model Y = c_0 + c_1 X for the weighted
datasets (<VAR>x</VAR>, <VAR>y</VAR>), two vectors of length <VAR>n</VAR> with strides
<VAR>xstride</VAR> and <VAR>ystride</VAR>.  The vector <VAR>w</VAR>, of length <VAR>n</VAR>
and stride <VAR>wstride</VAR>, specifies the weight of each datapoint. The
weight is the reciprocal of the variance for each datapoint in <VAR>y</VAR>.

</P>
<P>
The covariance matrix for the parameters (<VAR>c0</VAR>, <VAR>c1</VAR>) is
estimated from weighted data and returned via the parameters
(<VAR>cov00</VAR>, <VAR>cov01</VAR>, <VAR>cov11</VAR>).  The weighted sum of squares of
the residuals from the best-fit line, \chi^2, is returned in
<VAR>chisq</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_fit_linear_est</B> <I>(double <VAR>x</VAR>, double <VAR>c0</VAR>, double <VAR>c1</VAR>, double <VAR>c00</VAR>, double <VAR>c01</VAR>, double <VAR>c11</VAR>, double * <VAR>y</VAR>, double * <VAR>y_err</VAR>)</I>
<DD><A NAME="IDX2239"></A>
This function uses the best-fit linear regression coefficients
<VAR>c0</VAR>,<VAR>c1</VAR> and their estimated covariance
<VAR>cov00</VAR>,<VAR>cov01</VAR>,<VAR>cov11</VAR> to compute the fitted function
<VAR>y</VAR> and its standard deviation <VAR>y_err</VAR> for the model Y =
c_0 + c_1 X at the point <VAR>x</VAR>.
</DL>

</P>


<H2><A NAME="SEC479" HREF="gsl_manual.html#TOC479">Linear fitting without a constant term</A></H2>

<P>
The functions described in this section can be used to perform
least-squares fits to a straight line model without a constant term,
Y = c_1 X.  For weighted data the best-fit is found by minimizing
the weighted sum of squared residuals, \chi^2,

<SPAN class="ifinfo">


<PRE class="example">
\chi^2 = \sum_i w_i (y_i - c_1 x_i)^2
</PRE>

</SPAN>

<P>
for the parameter c_1.  For unweighted data the sum is
computed with w_i = 1.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_fit_mul</B> <I>(const double * <VAR>x</VAR>, const size_t <VAR>xstride</VAR>, const double * <VAR>y</VAR>, const size_t <VAR>ystride</VAR>, size_t <VAR>n</VAR>, double * <VAR>c1</VAR>, double * <VAR>cov11</VAR>, double * <VAR>sumsq</VAR>)</I>
<DD><A NAME="IDX2240"></A>
This function computes the best-fit linear regression coefficient
<VAR>c1</VAR> of the model Y = c_1 X for the datasets (<VAR>x</VAR>,
<VAR>y</VAR>), two vectors of length <VAR>n</VAR> with strides <VAR>xstride</VAR> and
<VAR>ystride</VAR>.  The variance of the parameter <VAR>c1</VAR> is estimated from
the scatter of the points around the best-fit line and returned via the
parameter <VAR>cov11</VAR>.  The sum of squares of the residuals from the
best-fit line is returned in <VAR>sumsq</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_fit_wmul</B> <I>(const double * <VAR>x</VAR>, const size_t <VAR>xstride</VAR>, const double * <VAR>w</VAR>, const size_t <VAR>wstride</VAR>, const double * <VAR>y</VAR>, const size_t <VAR>ystride</VAR>, size_t <VAR>n</VAR>, double * <VAR>c1</VAR>, double * <VAR>cov11</VAR>, double * <VAR>sumsq</VAR>)</I>
<DD><A NAME="IDX2241"></A>
This function computes the best-fit linear regression coefficient
<VAR>c1</VAR> of the model Y = c_1 X for the weighted datasets
(<VAR>x</VAR>, <VAR>y</VAR>), two vectors of length <VAR>n</VAR> with strides
<VAR>xstride</VAR> and <VAR>ystride</VAR>.  The vector <VAR>w</VAR>, of length <VAR>n</VAR>
and stride <VAR>wstride</VAR>, specifies the weight of each datapoint. The
weight is the reciprocal of the variance for each datapoint in <VAR>y</VAR>.

</P>
<P>
The variance of the parameter <VAR>c1</VAR> is estimated from the weighted
data and returned via the parameter <VAR>cov11</VAR>.  The weighted sum of
squares of the residuals from the best-fit line, \chi^2, is
returned in <VAR>chisq</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_fit_mul_est</B> <I>(double <VAR>x</VAR>, double <VAR>c1</VAR>, double <VAR>c11</VAR>, double * <VAR>y</VAR>, double * <VAR>y_err</VAR>)</I>
<DD><A NAME="IDX2242"></A>
This function uses the best-fit linear regression coefficient <VAR>c1</VAR>
and its estimated covariance <VAR>cov11</VAR> to compute the fitted function
<VAR>y</VAR> and its standard deviation <VAR>y_err</VAR> for the model Y =
c_1 X at the point <VAR>x</VAR>.
</DL>

</P>


<H2><A NAME="SEC480" HREF="gsl_manual.html#TOC480">Multi-parameter fitting</A></H2>
<P>
<A NAME="IDX2243"></A>
<A NAME="IDX2244"></A>
The functions described in this section perform least-squares fits to a
general linear model, y = X c where y is a vector of
n observations, X is an n by p matrix of
predictor variables, and the elements of the vector c are the p unknown best-fit parameters which are to be estimated.

</P>
<P>
The best-fit is found by minimizing the weighted sums of squared
residuals, \chi^2,

<SPAN class="ifinfo">


<PRE class="example">
\chi^2 = (y - X c)^T W (y - X c)
</PRE>

</SPAN>

<P>
with respect to the parameters c. The weights are specified by
the diagonal elements of the n by n matrix W.  For
unweighted data W is replaced by the identity matrix.

</P>
<P>
This formulation can be used for fits to any number of functions and/or
variables by preparing the n-by-p matrix X
appropriately.  For example, to fit to a p-th order polynomial in
<VAR>x</VAR>, use the following matrix,

<SPAN class="ifinfo">


<PRE class="example">
X_{ij} = x_i^j
</PRE>

</SPAN>

<P>
where the index i runs over the observations and the index
j runs from 0 to p-1.

</P>
<P>
To fit to a set of p sinusoidal functions with fixed frequencies
\omega_1, \omega_2, ..., \omega_p, use,

<SPAN class="ifinfo">


<PRE class="example">
X_{ij} = sin(\omega_j x_i)
</PRE>

</SPAN>

<P>
To fit to p independent variables x_1, x_2, ...,
x_p, use,

<SPAN class="ifinfo">


<PRE class="example">
X_{ij} = x_j(i)
</PRE>

</SPAN>

<P>
where x_j(i) is the i-th value of the predictor variable
x_j.

</P>
<P>
The functions described in this section are declared in the header file
<TT>'gsl_multifit.h'</TT>.

</P>
<P>
The solution of the general linear least-squares system requires an
additional working space for intermediate results, such as the singular
value decomposition of the matrix X.

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_multifit_linear_workspace * <B>gsl_multifit_linear_alloc</B> <I>(size_t <VAR>n</VAR>, size_t <VAR>p</VAR>)</I>
<DD><A NAME="IDX2245"></A>
This function allocates a workspace for fitting a model to <VAR>n</VAR>
observations using <VAR>p</VAR> parameters.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_multifit_linear_free</B> <I>(gsl_multifit_linear_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2246"></A>
This function frees the memory associated with the workspace <VAR>w</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_multifit_linear</B> <I>(const gsl_matrix * <VAR>X</VAR>, const gsl_vector * <VAR>y</VAR>, gsl_vector * <VAR>c</VAR>, gsl_matrix * <VAR>cov</VAR>, double * <VAR>chisq</VAR>, gsl_multifit_linear_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2247"></A>
<DT><U>Function:</U> int <B>gsl_multifit_linear_svd</B> <I>(const gsl_matrix * <VAR>X</VAR>, const gsl_vector * <VAR>y</VAR>, double <VAR>tol</VAR>, size_t * <VAR>rank</VAR>, gsl_vector * <VAR>c</VAR>, gsl_matrix * <VAR>cov</VAR>, double * <VAR>chisq</VAR>, gsl_multifit_linear_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2248"></A>
These functions compute the best-fit parameters <VAR>c</VAR> of the model
y = X c for the observations <VAR>y</VAR> and the matrix of predictor
variables <VAR>X</VAR>.  The variance-covariance matrix of the model
parameters <VAR>cov</VAR> is estimated from the scatter of the observations
about the best-fit.  The sum of squares of the residuals from the
best-fit, \chi^2, is returned in <VAR>chisq</VAR>. 

</P>
<P>
The best-fit is found by singular value decomposition of the matrix
<VAR>X</VAR> using the preallocated workspace provided in <VAR>work</VAR>. The
modified Golub-Reinsch SVD algorithm is used, with column scaling to
improve the accuracy of the singular values. Any components which have
zero singular value (to machine precision) are discarded from the fit.
In the second form of the function the components are discarded if the
ratio of singular values s_i/s_0 falls below the user-specified
tolerance <VAR>tol</VAR>, and the effective rank is returned in <VAR>rank</VAR>.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_multifit_wlinear</B> <I>(const gsl_matrix * <VAR>X</VAR>, const gsl_vector * <VAR>w</VAR>, const gsl_vector * <VAR>y</VAR>, gsl_vector * <VAR>c</VAR>, gsl_matrix * <VAR>cov</VAR>, double * <VAR>chisq</VAR>, gsl_multifit_linear_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2249"></A>
<DT><U>Function:</U> int <B>gsl_multifit_wlinear_svd</B> <I>(const gsl_matrix * <VAR>X</VAR>, const gsl_vector * <VAR>w</VAR>, const gsl_vector * <VAR>y</VAR>, double <VAR>tol</VAR>, size_t * <VAR>rank</VAR>, gsl_vector * <VAR>c</VAR>, gsl_matrix * <VAR>cov</VAR>, double * <VAR>chisq</VAR>, gsl_multifit_linear_workspace * <VAR>work</VAR>)</I>
<DD><A NAME="IDX2250"></A>

</P>
<P>
This function computes the best-fit parameters <VAR>c</VAR> of the weighted
model y = X c for the observations <VAR>y</VAR> with weights <VAR>w</VAR>
and the matrix of predictor variables <VAR>X</VAR>.  The covariance matrix of
the model parameters <VAR>cov</VAR> is estimated from the weighted data.  The
weighted sum of squares of the residuals from the best-fit,
\chi^2, is returned in <VAR>chisq</VAR>.

</P>
<P>
The best-fit is found by singular value decomposition of the matrix
<VAR>X</VAR> using the preallocated workspace provided in <VAR>work</VAR>. Any
components which have zero singular value (to machine precision) are
discarded from the fit.  In the second form of the function the
components are discarded if the ratio of singular values s_i/s_0
falls below the user-specified tolerance <VAR>tol</VAR>, and the effective
rank is returned in <VAR>rank</VAR>.
</DL>

</P>


<H2><A NAME="SEC481" HREF="gsl_manual.html#TOC481">Examples</A></H2>

<P>
The following program computes a least squares straight-line fit to a
simple (fictitious) dataset, and outputs the best-fit line and its
associated one standard-deviation error bars.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_fit.h&#62;

int
main (void)
{
  int i, n = 4;
  double x[4] = { 1970, 1980, 1990, 2000 };
  double y[4] = {   12,   11,   14,   13 };
  double w[4] = {  0.1,  0.2,  0.3,  0.4 };

  double c0, c1, cov00, cov01, cov11, chisq;

  gsl_fit_wlinear (x, 1, w, 1, y, 1, n, 
                   &#38;c0, &#38;c1, &#38;cov00, &#38;cov01, &#38;cov11, 
                   &#38;chisq);

  printf ("# best fit: Y = %g + %g X\n", c0, c1);
  printf ("# covariance matrix:\n");
  printf ("# [ %g, %g\n#   %g, %g]\n", 
          cov00, cov01, cov01, cov11);
  printf ("# chisq = %g\n", chisq);

  for (i = 0; i &#60; n; i++)
    printf ("data: %g %g %g\n", 
                   x[i], y[i], 1/sqrt(w[i]));

  printf ("\n");

  for (i = -30; i &#60; 130; i++)
    {
      double xf = x[0] + (i/100.0) * (x[n-1] - x[0]);
      double yf, yf_err;

      gsl_fit_linear_est (xf, 
                          c0, c1, 
                          cov00, cov01, cov11, 
                          &#38;yf, &#38;yf_err);

      printf ("fit: %g %g\n", xf, yf);
      printf ("hi : %g %g\n", xf, yf + yf_err);
      printf ("lo : %g %g\n", xf, yf - yf_err);
    }
  return 0;
}
</PRE>

<P>
The following commands extract the data from the output of the program
and display it using the GNU plotutils <CODE>graph</CODE> utility, 

</P>

<PRE class="example">
$ ./demo &#62; tmp
$ more tmp
# best fit: Y = -106.6 + 0.06 X
# covariance matrix:
# [ 39602, -19.9
#   -19.9, 0.01]
# chisq = 0.8

$ for n in data fit hi lo ; 
   do 
     grep "^$n" tmp | cut -d: -f2 &#62; $n ; 
   done
$ graph -T X -X x -Y y -y 0 20 -m 0 -S 2 -Ie data 
     -S 0 -I a -m 1 fit -m 2 hi -m 2 lo
</PRE>

<P>
<BR><IMG SRC="fit-wlinear"><BR>

</P>
<P>
The next program performs a quadratic fit y = c_0 + c_1 x + c_2
x^2 to a weighted dataset using the generalised linear fitting function
<CODE>gsl_multifit_wlinear</CODE>.  The model matrix X for a quadratic
fit is given by,

<SPAN class="ifinfo">


<PRE class="example">
X = [ 1   , x_0  , x_0^2 ;
      1   , x_1  , x_1^2 ;
      1   , x_2  , x_2^2 ;
      ... , ...  , ...   ]
</PRE>

</SPAN>

<P>
where the column of ones corresponds to the constant term c_0.
The two remaining columns corresponds to the terms c_1 x and
c_2 x^2.

</P>
<P>
The program reads <VAR>n</VAR> lines of data in the format (<VAR>x</VAR>, <VAR>y</VAR>,
<VAR>err</VAR>) where <VAR>err</VAR> is the error (standard deviation) in the
value <VAR>y</VAR>.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_multifit.h&#62;

int
main (int argc, char **argv)
{
  int i, n;
  double xi, yi, ei, chisq;
  gsl_matrix *X, *cov;
  gsl_vector *y, *w, *c;

  if (argc != 2)
    {
      fprintf (stderr,"usage: fit n &#60; data\n");
      exit (-1);
    }

  n = atoi (argv[1]);

  X = gsl_matrix_alloc (n, 3);
  y = gsl_vector_alloc (n);
  w = gsl_vector_alloc (n);

  c = gsl_vector_alloc (3);
  cov = gsl_matrix_alloc (3, 3);

  for (i = 0; i &#60; n; i++)
    {
      int count = fscanf (stdin, "%lg %lg %lg",
                          &#38;xi, &#38;yi, &#38;ei);

      if (count != 3)
        {
          fprintf (stderr, "error reading file\n");
          exit (-1);
        }

      printf ("%g %g +/- %g\n", xi, yi, ei);
      
      gsl_matrix_set (X, i, 0, 1.0);
      gsl_matrix_set (X, i, 1, xi);
      gsl_matrix_set (X, i, 2, xi*xi);
      
      gsl_vector_set (y, i, yi);
      gsl_vector_set (w, i, 1.0/(ei*ei));
    }

  {
    gsl_multifit_linear_workspace * work 
      = gsl_multifit_linear_alloc (n, 3);
    gsl_multifit_wlinear (X, w, y, c, cov,
                          &#38;chisq, work);
    gsl_multifit_linear_free (work);
  }

#define C(i) (gsl_vector_get(c,(i)))
#define COV(i,j) (gsl_matrix_get(cov,(i),(j)))

  {
    printf ("# best fit: Y = %g + %g X + %g X^2\n", 
            C(0), C(1), C(2));

    printf ("# covariance matrix:\n");
    printf ("[ %+.5e, %+.5e, %+.5e  \n",
               COV(0,0), COV(0,1), COV(0,2));
    printf ("  %+.5e, %+.5e, %+.5e  \n", 
               COV(1,0), COV(1,1), COV(1,2));
    printf ("  %+.5e, %+.5e, %+.5e ]\n", 
               COV(2,0), COV(2,1), COV(2,2));
    printf ("# chisq = %g\n", chisq);
  }
  return 0;
}
</PRE>

<P>
A suitable set of data for fitting can be generated using the following
program.  It outputs a set of points with gaussian errors from the curve
y = e^x in the region 0 &#60; x &#60; 2.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;math.h&#62;
#include &#60;gsl/gsl_randist.h&#62;

int
main (void)
{
  double x;
  const gsl_rng_type * T;
  gsl_rng * r;
  
  gsl_rng_env_setup ();
  
  T = gsl_rng_default;
  r = gsl_rng_alloc (T);

  for (x = 0.1; x &#60; 2; x+= 0.1)
    {
      double y0 = exp (x);
      double sigma = 0.1 * y0;
      double dy = gsl_ran_gaussian (r, sigma);

      printf ("%g %g %g\n", x, y0 + dy, sigma);
    }
  return 0;
}
</PRE>

<P>
The data can be prepared by running the resulting executable program,

</P>

<PRE class="example">
$ ./generate &#62; exp.dat
$ more exp.dat
0.1 0.97935 0.110517
0.2 1.3359 0.12214
0.3 1.52573 0.134986
0.4 1.60318 0.149182
0.5 1.81731 0.164872
0.6 1.92475 0.182212
....
</PRE>

<P>
To fit the data use the previous program, with the number of data points
given as the first argument.  In this case there are 19 data points.

</P>

<PRE class="example">
$ ./fit 19 &#60; exp.dat
0.1 0.97935 +/- 0.110517
0.2 1.3359 +/- 0.12214
...
# best fit: Y = 1.02318 + 0.956201 X + 0.876796 X^2
# covariance matrix:
[ +1.25612e-02, -3.64387e-02, +1.94389e-02  
  -3.64387e-02, +1.42339e-01, -8.48761e-02  
  +1.94389e-02, -8.48761e-02, +5.60243e-02 ]
# chisq = 23.0987
</PRE>

<P>
The parameters of the quadratic fit match the coefficients of the
expansion of e^x, taking into account the errors on the
parameters and the O(x^3) difference between the exponential and
quadratic functions for the larger values of x.  The errors on
the parameters are given by the square-root of the corresponding
diagonal elements of the covariance matrix.  The chi-squared per degree
of freedom is 1.4, indicating a reasonable fit to the data.

</P>
<P>
<BR><IMG SRC="fit-wlinear2"><BR>

</P>


<H2><A NAME="SEC482" HREF="gsl_manual.html#TOC482">References and Further Reading</A></H2>

<P>
A summary of formulas and techniques for least squares fitting can be
found in the "Statistics" chapter of the Annual Review of Particle
Physics prepared by the Particle Data Group,

</P>

<UL class="itemize">
<LI>

<CITE>Review of Particle Properties</CITE>,
R.M. Barnett et al., Physical Review D54, 1 (1996)
<A HREF="http://pdg.lbl.gov/">http://pdg.lbl.gov/</A>
</UL>

<P>
The Review of Particle Physics is available online at the website given
above.

</P>
<P>
<A NAME="IDX2251"></A>
<A NAME="IDX2252"></A>
The tests used to prepare these routines are based on the NIST
Statistical Reference Datasets. The datasets and their documentation are
available from NIST at the following website,

</P>
<P>
<A HREF="http://www.nist.gov/itl/div898/strd/index.html">http://www.nist.gov/itl/div898/strd/index.html</A>.

</P>



<H1><A NAME="SEC483" HREF="gsl_manual.html#TOC483">Nonlinear Least-Squares Fitting</A></H1>
<P>
<A NAME="IDX2253"></A>
<A NAME="IDX2254"></A>

</P>
<P>
This chapter describes functions for multidimensional nonlinear
least-squares fitting.  The library provides low level components for a
variety of iterative solvers and convergence tests.  These can be
combined by the user to achieve the desired solution, with full access
to the intermediate steps of the iteration.  Each class of methods uses
the same framework, so that you can switch between solvers at runtime
without needing to recompile your program.  Each instance of a solver
keeps track of its own state, allowing the solvers to be used in
multi-threaded programs.

</P>
<P>
The header file <TT>'gsl_multifit_nlin.h'</TT> contains prototypes for the
multidimensional nonlinear fitting functions and related declarations.

</P>



<H2><A NAME="SEC484" HREF="gsl_manual.html#TOC484">Overview</A></H2>
<P>
<A NAME="IDX2255"></A>

</P>
<P>
The problem of multidimensional nonlinear least-squares fitting requires
the minimization of the squared residuals of n functions,
f_i, in p parameters, x_i,

<SPAN class="ifinfo">


<PRE class="example">
\Phi(x) = (1/2) \sum_{i=1}^{n} f_i(x_1, ..., x_p)^2 
        = (1/2) || F(x) ||^2
</PRE>

</SPAN>

<P>
All algorithms proceed from an initial guess using the linearization,

<SPAN class="ifinfo">


<PRE class="example">
\psi(p) = || F(x+p) || ~=~ || F(x) + J p ||
</PRE>

</SPAN>

<P>
where x is the initial point, p is the proposed step
and J is the
Jacobian matrix 
J_{ij} = d f_i / d x_j.  
Additional strategies are used to enlarge the region of convergence.
These include requiring a decrease in the norm ||F|| on each
step or using a trust region to avoid steps which fall outside the linear 
regime.

</P>


<H2><A NAME="SEC485" HREF="gsl_manual.html#TOC485">Initializing the Solver</A></H2>

<P>
<DL>
<DT><U>Function:</U> gsl_multifit_fsolver * <B>gsl_multifit_fsolver_alloc</B> <I>(const gsl_multifit_fsolver_type * <VAR>T</VAR>, size_t <VAR>n</VAR>, size_t <VAR>p</VAR>)</I>
<DD><A NAME="IDX2256"></A>
This function returns a pointer to a newly allocated instance of a
solver of type <VAR>T</VAR> for <VAR>n</VAR> observations and <VAR>p</VAR> parameters.

</P>
<P>
If there is insufficient memory to create the solver then the function
returns a null pointer and the error handler is invoked with an error
code of <CODE>GSL_ENOMEM</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_multifit_fdfsolver * <B>gsl_multifit_fdfsolver_alloc</B> <I>(const gsl_multifit_fdfsolver_type * <VAR>T</VAR>, size_t <VAR>n</VAR>, size_t <VAR>p</VAR>)</I>
<DD><A NAME="IDX2257"></A>
This function returns a pointer to a newly allocated instance of a
derivative solver of type <VAR>T</VAR> for <VAR>n</VAR> observations and <VAR>p</VAR>
parameters. For example, the following code creates an instance of a
Levenberg-Marquardt solver for 100 data points and 3 parameters,

</P>

<PRE class="example">
const gsl_multifit_fdfsolver_type * T 
    = gsl_multifit_fdfsolver_lmder;
gsl_multifit_fdfsolver * s 
    = gsl_multifit_fdfsolver_alloc (T, 100, 3);
</PRE>

<P>
If there is insufficient memory to create the solver then the function
returns a null pointer and the error handler is invoked with an error
code of <CODE>GSL_ENOMEM</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_multifit_fsolver_set</B> <I>(gsl_multifit_fsolver * <VAR>s</VAR>, gsl_multifit_function * <VAR>f</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX2258"></A>
This function initializes, or reinitializes, an existing solver <VAR>s</VAR>
to use the function <VAR>f</VAR> and the initial guess <VAR>x</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_multifit_fdfsolver_set</B> <I>(gsl_multifit_fdfsolver * <VAR>s</VAR>, gsl_function_fdf * <VAR>fdf</VAR>, gsl_vector * <VAR>x</VAR>)</I>
<DD><A NAME="IDX2259"></A>
This function initializes, or reinitializes, an existing solver <VAR>s</VAR>
to use the function and derivative <VAR>fdf</VAR> and the initial guess
<VAR>x</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_multifit_fsolver_free</B> <I>(gsl_multifit_fsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2260"></A>
<DT><U>Function:</U> void <B>gsl_multifit_fdfsolver_free</B> <I>(gsl_multifit_fdfsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2261"></A>
These functions free all the memory associated with the solver <VAR>s</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> const char * <B>gsl_multifit_fsolver_name</B> <I>(const gsl_multifit_fdfsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2262"></A>
<DT><U>Function:</U> const char * <B>gsl_multifit_fdfsolver_name</B> <I>(const gsl_multifit_fdfsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2263"></A>
These functions return a pointer to the name of the solver.  For example,

</P>

<PRE class="example">
printf ("s is a '%s' solver\n", 
        gsl_multifit_fdfsolver_name (s));
</PRE>

<P>
would print something like <CODE>s is a 'lmder' solver</CODE>.
</DL>

</P>


<H2><A NAME="SEC486" HREF="gsl_manual.html#TOC486">Providing the Function to be Minimized</A></H2>

<P>
You must provide n functions of p variables for the minimization algorithms to operate on.  In order to allow for general parameters the
functions are defined by the following data types:

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_multifit_function</B>
<DD><A NAME="IDX2264"></A>
This data type defines a general system of functions with parameters.

</P>
<DL COMPACT>

<DT><CODE>int (* f) (const gsl_vector * <VAR>x</VAR>, void * <VAR>params</VAR>, gsl_vector * <VAR>f</VAR>)</CODE>
<DD>
this function should store the vector result
f(x,params) in <VAR>f</VAR> for argument <VAR>x</VAR> and parameters <VAR>params</VAR>,
returning an appropriate error code if the function cannot be computed.

<DT><CODE>size_t n</CODE>
<DD>
the number of functions, i.e. the number of components of the
vector <VAR>f</VAR>.

<DT><CODE>size_t p</CODE>
<DD>
the number of independent variables, i.e. the number of components of
the vectors <VAR>x</VAR>.

<DT><CODE>void * params</CODE>
<DD>
a pointer to the parameters of the function.
</DL>
</DL>

<P>
<DL>
<DT><U>Data Type:</U> <B>gsl_multifit_function_fdf</B>
<DD><A NAME="IDX2265"></A>
This data type defines a general system of functions with parameters and
the corresponding Jacobian matrix of derivatives,

</P>
<DL COMPACT>

<DT><CODE>int (* f) (const gsl_vector * <VAR>x</VAR>, void * <VAR>params</VAR>, gsl_vector * <VAR>f</VAR>)</CODE>
<DD>
this function should store the vector result
f(x,params) in <VAR>f</VAR> for argument <VAR>x</VAR> and parameters <VAR>params</VAR>,
returning an appropriate error code if the function cannot be computed.

<DT><CODE>int (* df) (const gsl_vector * <VAR>x</VAR>, void * <VAR>params</VAR>, gsl_matrix * <VAR>J</VAR>)</CODE>
<DD>
this function should store the <VAR>n</VAR>-by-<VAR>p</VAR> matrix result
J_ij = d f_i(x,params) / d x_j in <VAR>J</VAR> for argument <VAR>x</VAR> 
and parameters <VAR>params</VAR>, returning an appropriate error code if the
function cannot be computed.

<DT><CODE>int (* fdf) (const gsl_vector * <VAR>x</VAR>, void * <VAR>params</VAR>, gsl_vector * <VAR>f</VAR>, gsl_matrix * <VAR>J</VAR>)</CODE>
<DD>
This function should set the values of the <VAR>f</VAR> and <VAR>J</VAR> as above,
for arguments <VAR>x</VAR> and parameters <VAR>params</VAR>.  This function
provides an optimization of the separate functions for f(x) and
J(x)---it is always faster to compute the function and its
derivative at the same time.

<DT><CODE>size_t n</CODE>
<DD>
the number of functions, i.e. the number of components of the
vector <VAR>f</VAR>.

<DT><CODE>size_t p</CODE>
<DD>
the number of independent variables, i.e. the number of components of
the vectors <VAR>x</VAR>.

<DT><CODE>void * params</CODE>
<DD>
a pointer to the parameters of the function.
</DL>
</DL>



<H2><A NAME="SEC487" HREF="gsl_manual.html#TOC487">Iteration</A></H2>

<P>
The following functions drive the iteration of each algorithm.  Each
function performs one iteration to update the state of any solver of the
corresponding type.  The same functions work for all solvers so that
different methods can be substituted at runtime without modifications to
the code.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_multifit_fsolver_iterate</B> <I>(gsl_multifit_fsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2266"></A>
<DT><U>Function:</U> int <B>gsl_multifit_fdfsolver_iterate</B> <I>(gsl_multifit_fdfsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2267"></A>
These functions perform a single iteration of the solver <VAR>s</VAR>.  If
the iteration encounters an unexpected problem then an error code will
be returned.  The solver maintains a current estimate of the best-fit
parameters at all times. 
</DL>

</P>
<P>
The solver struct <VAR>s</VAR> contains the following entries, which can
be used to track the progress of the solution:

</P>
<DL COMPACT>

<DT><CODE>gsl_vector * x</CODE>
<DD>
The current position.

<DT><CODE>gsl_vector * f</CODE>
<DD>
The function value at the current position.

<DT><CODE>gsl_vector * dx</CODE>
<DD>
The difference between the current position and the previous position,
i.e. the last step, taken as a vector.

<DT><CODE>gsl_matrix * J</CODE>
<DD>
The Jacobian matrix at the current position (for the
<CODE>gsl_multifit_fdfsolver</CODE> struct only)
</DL>

<P>
The best-fit information also can be accessed with the following
auxiliary functions,

</P>
<P>
<DL>
<DT><U>Function:</U> gsl_vector * <B>gsl_multifit_fsolver_position</B> <I>(const gsl_multifit_fsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2268"></A>
<DT><U>Function:</U> gsl_vector * <B>gsl_multifit_fdfsolver_position</B> <I>(const gsl_multifit_fdfsolver * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2269"></A>
These functions return the current position (i.e. best-fit parameters)
<CODE>s-&#62;x</CODE> of the solver <VAR>s</VAR>.
</DL>

</P>


<H2><A NAME="SEC488" HREF="gsl_manual.html#TOC488">Search Stopping Parameters</A></H2>
<P>
<A NAME="IDX2270"></A>

</P>
<P>
A minimization procedure should stop when one of the following conditions is
true:

</P>

<UL class="itemize">
<LI>

A minimum has been found to within the user-specified precision.

<LI>

A user-specified maximum number of iterations has been reached.

<LI>

An error has occurred.
</UL>

<P>
The handling of these conditions is under user control.  The functions
below allow the user to test the current estimate of the best-fit
parameters in several standard ways.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_multifit_test_delta</B> <I>(const gsl_vector * <VAR>dx</VAR>, const gsl_vector * <VAR>x</VAR>, double <VAR>epsabs</VAR>, double <VAR>epsrel</VAR>)</I>
<DD><A NAME="IDX2271"></A>

</P>
<P>
This function tests for the convergence of the sequence by comparing the
last step <VAR>dx</VAR> with the absolute error <VAR>epsabs</VAR> and relative
error <VAR>epsrel</VAR> to the current position <VAR>x</VAR>.  The test returns
<CODE>GSL_SUCCESS</CODE> if the following condition is achieved,

<SPAN class="ifinfo">


<PRE class="example">
|dx_i| &#60; epsabs + epsrel |x_i|
</PRE>

</SPAN>

<P>
for each component of <VAR>x</VAR> and returns <CODE>GSL_CONTINUE</CODE> otherwise.
</DL>

</P>
<P>
<A NAME="IDX2272"></A>
<DL>
<DT><U>Function:</U> int <B>gsl_multifit_test_gradient</B> <I>(const gsl_vector * <VAR>g</VAR>, double <VAR>epsabs</VAR>)</I>
<DD><A NAME="IDX2273"></A>
This function tests the residual gradient <VAR>g</VAR> against the absolute
error bound <VAR>epsabs</VAR>.  Mathematically, the gradient should be
exactly zero at the minimum. The test returns <CODE>GSL_SUCCESS</CODE> if the
following condition is achieved,

<SPAN class="ifinfo">


<PRE class="example">
\sum_i |g_i| &#60; epsabs
</PRE>

</SPAN>

<P>
and returns <CODE>GSL_CONTINUE</CODE> otherwise.  This criterion is suitable
for situations where the precise location of the minimum, x,
is unimportant provided a value can be found where the gradient is small
enough.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> int <B>gsl_multifit_gradient</B> <I>(const gsl_matrix * <VAR>J</VAR>, const gsl_vector * <VAR>f</VAR>, gsl_vector * <VAR>g</VAR>)</I>
<DD><A NAME="IDX2274"></A>
This function computes the gradient <VAR>g</VAR> of \Phi(x) = (1/2)
||F(x)||^2 from the Jacobian matrix J and the function values
<VAR>f</VAR>, using the formula g = J^T f.
</DL>

</P>


<H2><A NAME="SEC489" HREF="gsl_manual.html#TOC489">Minimization Algorithms using Derivatives</A></H2>

<P>
The minimization algorithms described in this section make use of both
the function and its derivative.  They require an initial guess for the
location of the minimum. There is no absolute guarantee of
convergence--the function must be suitable for this technique and the
initial guess must be sufficiently close to the minimum for it to work.

</P>
<P>
<A NAME="IDX2275"></A>
<DL>
<DT><U>Derivative Solver:</U> <B>gsl_multifit_fdfsolver_lmsder</B>
<DD><A NAME="IDX2276"></A>
<A NAME="IDX2277"></A>
<A NAME="IDX2278"></A>
This is a robust and efficient version of the Levenberg-Marquardt
algorithm as implemented in the scaled LMDER routine in
MINPACK.  Minpack was written by Jorge J. Mor&eacute;, Burton S. Garbow
and Kenneth E. Hillstrom.

</P>
<P>
The algorithm uses a generalized trust region to keep each step under
control.  In order to be accepted a proposed new position x' must
satisfy the condition |D (x' - x)| &#60; \delta, where D is a
diagonal scaling matrix and \delta is the size of the trust
region.  The components of D are computed internally, using the
column norms of the Jacobian to estimate the sensitivity of the residual
to each component of x.  This improves the behavior of the
algorithm for badly scaled functions.

</P>
<P>
On each iteration the algorithm attempts to minimize the linear system
|F + J p| subject to the constraint |D p| &#60; \Delta.  The
solution to this constrained linear system is found using the
Levenberg-Marquardt method.

</P>
<P>
The proposed step is now tested by evaluating the function at the
resulting point, x'.  If the step reduces the norm of the
function sufficiently, and follows the predicted behavior of the
function within the trust region, then it is accepted and the size of the
trust region is increased.  If the proposed step fails to improve the
solution, or differs significantly from the expected behavior within
the trust region, then the size of the trust region is decreased and
another trial step is computed.

</P>
<P>
The algorithm also monitors the progress of the solution and returns an
error if the changes in the solution are smaller than the machine
precision.  The possible error codes are,

</P>
<DL COMPACT>

<DT><CODE>GSL_ETOLF</CODE>
<DD>
the decrease in the function falls below machine precision

<DT><CODE>GSL_ETOLX</CODE>
<DD>
the change in the position vector falls below machine precision

<DT><CODE>GSL_ETOLG</CODE>
<DD>
the norm of the gradient, relative to the norm of the function, falls
below machine precision
</DL>
<P>
These error codes indicate that further iterations will be unlikely to
change the solution from its current value.

</P>
</DL>

<P>
<DL>
<DT><U>Derivative Solver:</U> <B>gsl_multifit_fdfsolver_lmder</B>
<DD><A NAME="IDX2279"></A>
This is an unscaled version of the LMDER algorithm.  The elements of the
diagonal scaling matrix D are set to 1.  This algorithm may be
useful in circumstances where the scaled version of LMDER converges too
slowly, or the function is already scaled appropriately.
</DL>

</P>


<H2><A NAME="SEC490" HREF="gsl_manual.html#TOC490">Minimization Algorithms without Derivatives</A></H2>

<P>
There are no algorithms implemented in this section at the moment.

</P>


<H2><A NAME="SEC491" HREF="gsl_manual.html#TOC491">Computing the covariance matrix of best fit parameters</A></H2>
<P>
<A NAME="IDX2280"></A>
<A NAME="IDX2281"></A>
<A NAME="IDX2282"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gsl_multifit_covar</B> <I>(const gsl_matrix * <VAR>J</VAR>, double <VAR>epsrel</VAR>, gsl_matrix * <VAR>covar</VAR>)</I>
<DD><A NAME="IDX2283"></A>
This function uses the Jacobian matrix <VAR>J</VAR> to compute the covariance
matrix of the best-fit parameters, <VAR>covar</VAR>.  The parameter
<VAR>epsrel</VAR> is used to remove linear-dependent columns when <VAR>J</VAR> is
rank deficient.

</P>
<P>
The covariance matrix is given by,

<SPAN class="ifinfo">


<PRE class="example">
covar = (J^T J)^{-1}
</PRE>

</SPAN>

<P>
and is computed by QR decomposition of J with column-pivoting.  Any
columns of R which satisfy 

<SPAN class="ifinfo">


<PRE class="example">
|R_{kk}| &#60;= epsrel |R_{11}|
</PRE>

</SPAN>

<P>
are considered linearly-dependent and are excluded from the covariance
matrix (the corresponding rows and columns of the covariance matrix are
set to zero).
</DL>

</P>



<H2><A NAME="SEC492" HREF="gsl_manual.html#TOC492">Examples</A></H2>

<P>
The following example program fits a weighted exponential model with
background to experimental data, Y = A \exp(-\lambda t) + b. The
first part of the program sets up the functions <CODE>expb_f</CODE> and
<CODE>expb_df</CODE> to calculate the model and its Jacobian.  The appropriate
fitting function is given by,

<SPAN class="ifinfo">


<PRE class="example">
f_i = ((A \exp(-\lambda t_i) + b) - y_i)/\sigma_i
</PRE>

</SPAN>

<P>
where we have chosen t_i = i.  The Jacobian matrix J is
the derivative of these functions with respect to the three parameters
(A, \lambda, b).  It is given by,

<SPAN class="ifinfo">


<PRE class="example">
J_{ij} = d f_i / d x_j
</PRE>

</SPAN>

<P>
where x_0 = A, x_1 = \lambda and x_2 = b.

</P>

<PRE class="example">
#include &#60;stdlib.h&#62;
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_rng.h&#62;
#include &#60;gsl/gsl_randist.h&#62;
#include &#60;gsl/gsl_vector.h&#62;
#include &#60;gsl/gsl_blas.h&#62;
#include &#60;gsl/gsl_multifit_nlin.h&#62;

struct data {
  size_t n;
  double * y;
  double * sigma;
};

int
expb_f (const gsl_vector * x, void *params, 
        gsl_vector * f)
{
  size_t n = ((struct data *)params)-&#62;n;
  double *y = ((struct data *)params)-&#62;y;
  double *sigma = ((struct data *) params)-&#62;sigma;

  double A = gsl_vector_get (x, 0);
  double lambda = gsl_vector_get (x, 1);
  double b = gsl_vector_get (x, 2);

  size_t i;

  for (i = 0; i &#60; n; i++)
    {
      /* Model Yi = A * exp(-lambda * i) + b */
      double t = i;
      double Yi = A * exp (-lambda * t) + b;
      gsl_vector_set (f, i, (Yi - y[i])/sigma[i]);
    }

  return GSL_SUCCESS;
}

int
expb_df (const gsl_vector * x, void *params, 
         gsl_matrix * J)
{
  size_t n = ((struct data *)params)-&#62;n;
  double *sigma = ((struct data *) params)-&#62;sigma;

  double A = gsl_vector_get (x, 0);
  double lambda = gsl_vector_get (x, 1);

  size_t i;

  for (i = 0; i &#60; n; i++)
    {
      /* Jacobian matrix J(i,j) = dfi / dxj, */
      /* where fi = (Yi - yi)/sigma[i],      */
      /*       Yi = A * exp(-lambda * i) + b  */
      /* and the xj are the parameters (A,lambda,b) */
      double t = i;
      double s = sigma[i];
      double e = exp(-lambda * t);
      gsl_matrix_set (J, i, 0, e/s); 
      gsl_matrix_set (J, i, 1, -t * A * e/s);
      gsl_matrix_set (J, i, 2, 1/s);
    }
  return GSL_SUCCESS;
}

int
expb_fdf (const gsl_vector * x, void *params,
          gsl_vector * f, gsl_matrix * J)
{
  expb_f (x, params, f);
  expb_df (x, params, J);

  return GSL_SUCCESS;
}
</PRE>

<P>
The main part of the program sets up a Levenberg-Marquardt solver and
some simulated random data. The data uses the known parameters
(1.0,5.0,0.1) combined with gaussian noise (standard deviation = 0.1)
over a range of 40 timesteps. The initial guess for the parameters is
chosen as (0.0, 1.0, 0.0).

</P>

<PRE class="example">
#define N 40

int
main (void)
{
  const gsl_multifit_fdfsolver_type *T;
  gsl_multifit_fdfsolver *s;

  int status;
  size_t i, iter = 0;

  const size_t n = N;
  const size_t p = 3;

  gsl_matrix *covar = gsl_matrix_alloc (p, p);
  double y[N], sigma[N];
  struct data d = { n, y, sigma};
  gsl_multifit_function_fdf f;
  double x_init[3] = { 1.0, 0.0, 0.0 };
  gsl_vector_view x = gsl_vector_view_array (x_init, p);
  const gsl_rng_type * type;
  gsl_rng * r;

  gsl_rng_env_setup();

  type = gsl_rng_default;
  r = gsl_rng_alloc (type);

  f.f = &#38;expb_f;
  f.df = &#38;expb_df;
  f.fdf = &#38;expb_fdf;
  f.n = n;
  f.p = p;
  f.params = &#38;d;

  /* This is the data to be fitted */

  for (i = 0; i &#60; n; i++)
    {
      double t = i;
      y[i] = 1.0 + 5 * exp (-0.1 * t) 
                 + gsl_ran_gaussian (r, 0.1);
      sigma[i] = 0.1;
      printf ("data: %d %g %g\n", i, y[i], sigma[i]);
    };

  T = gsl_multifit_fdfsolver_lmsder;
  s = gsl_multifit_fdfsolver_alloc (T, n, p);
  gsl_multifit_fdfsolver_set (s, &#38;f, &#38;x.vector);

  print_state (iter, s);

  do
    {
      iter++;
      status = gsl_multifit_fdfsolver_iterate (s);

      printf ("status = %s\n", gsl_strerror (status));

      print_state (iter, s);

      if (status)
        break;

      status = gsl_multifit_test_delta (s-&#62;dx, s-&#62;x,
                                        1e-4, 1e-4);
    }
  while (status == GSL_CONTINUE &#38;&#38; iter &#60; 500);

  gsl_multifit_covar (s-&#62;J, 0.0, covar);

#define FIT(i) gsl_vector_get(s-&#62;x, i)
#define ERR(i) sqrt(gsl_matrix_get(covar,i,i))

  printf ("A      = %.5f +/- %.5f\n", FIT(0), ERR(0));
  printf ("lambda = %.5f +/- %.5f\n", FIT(1), ERR(1));
  printf ("b      = %.5f +/- %.5f\n", FIT(2), ERR(2));

  { 
    double chi = gsl_blas_dnrm2(s-&#62;f);
    printf("chisq/dof = %g\n",  pow(chi, 2.0)/ (n - p));
  }

  printf ("status = %s\n", gsl_strerror (status));

  gsl_multifit_fdfsolver_free (s);
  return 0;
}

void
print_state (size_t iter, gsl_multifit_fdfsolver * s)
{
  printf ("iter: %3u x = % 15.8f % 15.8f % 15.8f "
          "|f(x)| = %g\n",
          iter,
          gsl_vector_get (s-&#62;x, 0), 
          gsl_vector_get (s-&#62;x, 1),
          gsl_vector_get (s-&#62;x, 2), 
          gsl_blas_dnrm2 (s-&#62;f));
}
</PRE>

<P>
The iteration terminates when the change in x is smaller than 0.0001, as
both an absolute and relative change.  Here are the results of running
the program:

</P>

<PRE class="smallexample">
iter: 0 x = 1.00000000 0.00000000 0.00000000 |f(x)| = 118.574
iter: 1 x = 1.64919392 0.01780040 0.64919392 |f(x)| = 77.2068
iter: 2 x = 2.86269020 0.08032198 1.45913464 |f(x)| = 38.0579
iter: 3 x = 4.97908864 0.11510525 1.06649948 |f(x)| = 10.1548
iter: 4 x = 5.03295496 0.09912462 1.00939075 |f(x)| = 6.4982
iter: 5 x = 5.05811477 0.10055914 0.99819876 |f(x)| = 6.33121
iter: 6 x = 5.05827645 0.10051697 0.99756444 |f(x)| = 6.33119
iter: 7 x = 5.05828006 0.10051819 0.99757710 |f(x)| = 6.33119

A      = 5.05828 +/- 0.05983
lambda = 0.10052 +/- 0.00309
b      = 0.99758 +/- 0.03944
chisq/dof = 1.08335
status = success
</PRE>

<P>
The approximate values of the parameters are found correctly, and the
chi-squared value indicates a good fit (the chi-squared per degree of
freedom is approximately 1).  In this case the errors on the parameters
can be estimated from the square roots of the diagonal elements of the
covariance matrix.  If the chi-squared value indicates a poor fit then
error estimates obtained from the covariance matrix are not valid, since
the Gaussian approximation would not apply.

</P>
<P>
<BR><IMG SRC="fit-exp"><BR>

</P>


<H2><A NAME="SEC493" HREF="gsl_manual.html#TOC493">References and Further Reading</A></H2>

<P>
The MINPACK algorithm is described in the following article,

</P>

<UL class="itemize">
<LI>

J.J. Mor&eacute;, <CITE>The Levenberg-Marquardt Algorithm: Implementation and
Theory</CITE>, Lecture Notes in Mathematics, v630 (1978), ed G. Watson.
</UL>

<P>
The following paper is also relevant to the algorithms described in this
section,

</P>

<UL class="itemize">
<LI>

J.J. Mor&eacute;, B.S. Garbow, K.E. Hillstrom, "Testing Unconstrained
Optimization Software", ACM Transactions on Mathematical Software, Vol
7, No 1 (1981), p 17--41.
</UL>



<H1><A NAME="SEC494" HREF="gsl_manual.html#TOC494">Physical Constants</A></H1>
<P>
<A NAME="IDX2284"></A>
<A NAME="IDX2285"></A>
<A NAME="IDX2286"></A>
<A NAME="IDX2287"></A>
This chapter describes macros for the values of physical constants, such
as the speed of light, c, and gravitational constant, G.
The values are available in different unit systems, including the
standard MKSA system (meters, kilograms, seconds, amperes) and the CGSM
system (centimeters, grams, seconds, gauss), which is commonly used in
Astronomy.

</P>
<P>
The definitions of constants in the MKSA system are available in the file
<TT>'gsl_const_mksa.h'</TT>.  The constants in the CGSM system are defined in
<TT>'gsl_const_cgsm.h'</TT>.  Dimensionless constants, such as the fine
structure constant, which are pure numbers are defined in
<TT>'gsl_const_num.h'</TT>.

</P>

<P>
The full list of constants is described briefly below.  Consult the
header files themselves for the values of the constants used in the
library.

</P>


<H2><A NAME="SEC495" HREF="gsl_manual.html#TOC495">Fundamental Constants</A></H2>
<P>
<A NAME="IDX2288"></A>
<A NAME="IDX2289"></A>
<DL COMPACT>

<DT><CODE>GSL_CONST_MKSA_SPEED_OF_LIGHT</CODE>
<DD>
The speed of light in vacuum, c.

<DT><CODE>GSL_CONST_MKSA_VACUUM_PERMEABILITY</CODE>
<DD>
The permeability of free space, \mu_0. This constant is defined
in the MKSA system only.

<DT><CODE>GSL_CONST_MKSA_VACUUM_PERMITTIVITY</CODE>
<DD>
The permittivity of free space, \epsilon_0.  This constant is
defined in the MKSA system only.

<DT><CODE>GSL_CONST_MKSA_PLANCKS_CONSTANT_H</CODE>
<DD>
Planck's constant, h.

<DT><CODE>GSL_CONST_MKSA_PLANCKS_CONSTANT_HBAR</CODE>
<DD>
Planck's constant divided by 2\pi, \hbar.

<DT><CODE>GSL_CONST_NUM_AVOGADRO</CODE>
<DD>
Avogadro's number, N_a.

<DT><CODE>GSL_CONST_MKSA_FARADAY</CODE>
<DD>
The molar charge of 1 Faraday.

<DT><CODE>GSL_CONST_MKSA_BOLTZMANN</CODE>
<DD>
The Boltzmann constant, k.

<DT><CODE>GSL_CONST_MKSA_MOLAR_GAS</CODE>
<DD>
The molar gas constant, R_0.

<DT><CODE>GSL_CONST_MKSA_STANDARD_GAS_VOLUME</CODE>
<DD>
The standard gas volume, V_0.

<DT><CODE>GSL_CONST_MKSA_STEFAN_BOLTZMANN_CONSTANT</CODE>
<DD>
The Stefan-Boltzmann radiation constant, \sigma.

<DT><CODE>GSL_CONST_MKSA_GAUSS</CODE>
<DD>
The magnetic field of 1 Gauss.
</DL>



<H2><A NAME="SEC496" HREF="gsl_manual.html#TOC496">Astronomy and Astrophysics</A></H2>
<P>
<A NAME="IDX2290"></A>
<DL COMPACT>

<DT><CODE>GSL_CONST_MKSA_ASTRONOMICAL_UNIT</CODE>
<DD>
The length of 1 astronomical unit (mean earth-sun distance), au.

<DT><CODE>GSL_CONST_MKSA_GRAVITATIONAL_CONSTANT</CODE>
<DD>
The gravitational constant, G.

<DT><CODE>GSL_CONST_MKSA_LIGHT_YEAR</CODE>
<DD>
The distance of 1 light-year, ly.

<DT><CODE>GSL_CONST_MKSA_PARSEC</CODE>
<DD>
The distance of 1 parsec, pc.

<DT><CODE>GSL_CONST_MKSA_GRAV_ACCEL</CODE>
<DD>
The standard gravitational acceleration on Earth, g.

<DT><CODE>GSL_CONST_MKSA_SOLAR_MASS</CODE>
<DD>
The mass of the Sun.
</DL>



<H2><A NAME="SEC497" HREF="gsl_manual.html#TOC497">Atomic and Nuclear Physics</A></H2>
<P>
<A NAME="IDX2291"></A>
<A NAME="IDX2292"></A>
<DL COMPACT>

<DT><CODE>GSL_CONST_MKSA_ELECTRON_CHARGE</CODE>
<DD>
The charge of the electron, e.

<DT><CODE>GSL_CONST_MKSA_ELECTRON_VOLT</CODE>
<DD>
The energy of 1 electron volt, eV.

<DT><CODE>GSL_CONST_MKSA_UNIFIED_ATOMIC_MASS</CODE>
<DD>
The unified atomic mass, amu.

<DT><CODE>GSL_CONST_MKSA_MASS_ELECTRON</CODE>
<DD>
The mass of the electron, m_e.

<DT><CODE>GSL_CONST_MKSA_MASS_MUON</CODE>
<DD>
The mass of the muon, m_\mu.

<DT><CODE>GSL_CONST_MKSA_MASS_PROTON</CODE>
<DD>
The mass of the proton, m_p.

<DT><CODE>GSL_CONST_MKSA_MASS_NEUTRON</CODE>
<DD>
The mass of the neutron, m_n.

<DT><CODE>GSL_CONST_NUM_FINE_STRUCTURE</CODE>
<DD>
The electromagnetic fine structure constant \alpha.

<DT><CODE>GSL_CONST_MKSA_RYDBERG</CODE>
<DD>
The Rydberg constant, Ry, in units of energy.  This is related to
the Rydberg inverse wavelength R by Ry = h c R.

<DT><CODE>GSL_CONST_MKSA_BOHR_RADIUS</CODE>
<DD>
The Bohr radius, a_0.

<DT><CODE>GSL_CONST_MKSA_ANGSTROM</CODE>
<DD>
The length of 1 angstrom.

<DT><CODE>GSL_CONST_MKSA_BARN</CODE>
<DD>
The area of 1 barn.

<DT><CODE>GSL_CONST_MKSA_BOHR_MAGNETON</CODE>
<DD>
The Bohr Magneton, \mu_B.

<DT><CODE>GSL_CONST_MKSA_NUCLEAR_MAGNETON</CODE>
<DD>
The Nuclear Magneton, \mu_N.

<DT><CODE>GSL_CONST_MKSA_ELECTRON_MAGNETIC_MOMENT</CODE>
<DD>
The absolute value of the magnetic moment of the electron, \mu_e.
The physical magnetic moment of the electron is negative.

<DT><CODE>GSL_CONST_MKSA_PROTON_MAGNETIC_MOMENT</CODE>
<DD>
The magnetic moment of the proton, \mu_p.

<DT><CODE>GSL_CONST_MKSA_THOMSON_CROSS_SECTION</CODE>
<DD>
The Thomson cross section, \sigma_T.
</DL>



<H2><A NAME="SEC498" HREF="gsl_manual.html#TOC498">Measurement of Time</A></H2>
<P>
<A NAME="IDX2293"></A>
<DL COMPACT>

<DT><CODE>GSL_CONST_MKSA_MINUTE</CODE>
<DD>
The number of seconds in 1 minute.

<DT><CODE>GSL_CONST_MKSA_HOUR</CODE>
<DD>
The number of seconds in 1 hour.

<DT><CODE>GSL_CONST_MKSA_DAY</CODE>
<DD>
The number of seconds in 1 day.

<DT><CODE>GSL_CONST_MKSA_WEEK</CODE>
<DD>
The number of seconds in 1 week.
</DL>



<H2><A NAME="SEC499" HREF="gsl_manual.html#TOC499">Imperial Units</A></H2>
<P>
<A NAME="IDX2294"></A>
<A NAME="IDX2295"></A>
<DL COMPACT>

<DT><CODE>GSL_CONST_MKSA_INCH</CODE>
<DD>
The length of 1 inch.

<DT><CODE>GSL_CONST_MKSA_FOOT</CODE>
<DD>
The length of 1 foot.

<DT><CODE>GSL_CONST_MKSA_YARD</CODE>
<DD>
The length of 1 yard.

<DT><CODE>GSL_CONST_MKSA_MILE</CODE>
<DD>
The length of 1 mile.

<DT><CODE>GSL_CONST_MKSA_MIL</CODE>
<DD>
The length of 1 mil (1/1000th of an inch).
</DL>



<H2><A NAME="SEC500" HREF="gsl_manual.html#TOC500">Speed and Nautical Units</A></H2>
<P>
<A NAME="IDX2296"></A>

</P>
<DL COMPACT>

<DT><CODE>GSL_CONST_MKSA_KILOMETERS_PER_HOUR</CODE>
<DD>
The speed of 1 kilometer per hour.

<DT><CODE>GSL_CONST_MKSA_MILES_PER_HOUR</CODE>
<DD>
The speed of 1 mile per hour.

<DT><CODE>GSL_CONST_MKSA_NAUTICAL_MILE</CODE>
<DD>
The length of 1 nautical mile.

<DT><CODE>GSL_CONST_MKSA_FATHOM</CODE>
<DD>
The length of 1 fathom.

<DT><CODE>GSL_CONST_MKSA_KNOT</CODE>
<DD>
The speed of 1 knot.
</DL>



<H2><A NAME="SEC501" HREF="gsl_manual.html#TOC501">Printers Units</A></H2>
<P>
<A NAME="IDX2297"></A>

</P>
<DL COMPACT>

<DT><CODE>GSL_CONST_MKSA_POINT</CODE>
<DD>
The length of 1 printer's point (1/72 inch).

<DT><CODE>GSL_CONST_MKSA_TEXPOINT</CODE>
<DD>
The length of 1 TeX point (1/72.27 inch).
</DL>



<H2><A NAME="SEC502" HREF="gsl_manual.html#TOC502">Volume, Area and Length</A></H2>
<P>
<A NAME="IDX2298"></A>

</P>
<DL COMPACT>

<DT><CODE>GSL_CONST_MKSA_MICRON</CODE>
<DD>
The length of 1 micron.

<DT><CODE>GSL_CONST_MKSA_HECTARE</CODE>
<DD>
The area of 1 hectare.

<DT><CODE>GSL_CONST_MKSA_ACRE</CODE>
<DD>
The area of 1 acre.

<DT><CODE>GSL_CONST_MKSA_LITER</CODE>
<DD>
The volume of 1 liter.

<DT><CODE>GSL_CONST_MKSA_US_GALLON</CODE>
<DD>
The volume of 1 US gallon.

<DT><CODE>GSL_CONST_MKSA_CANADIAN_GALLON</CODE>
<DD>
The volume of 1 Canadian gallon.

<DT><CODE>GSL_CONST_MKSA_UK_GALLON</CODE>
<DD>
The volume of 1 UK gallon.

<DT><CODE>GSL_CONST_MKSA_QUART</CODE>
<DD>
The volume of 1 quart.

<DT><CODE>GSL_CONST_MKSA_PINT</CODE>
<DD>
The volume of 1 pint.
</DL>



<H2><A NAME="SEC503" HREF="gsl_manual.html#TOC503">Mass and Weight</A></H2>
<P>
<A NAME="IDX2299"></A>
<A NAME="IDX2300"></A>
<DL COMPACT>

<DT><CODE>GSL_CONST_MKSA_POUND_MASS</CODE>
<DD>
The mass of 1 pound.

<DT><CODE>GSL_CONST_MKSA_OUNCE_MASS</CODE>
<DD>
The mass of 1 ounce.

<DT><CODE>GSL_CONST_MKSA_TON</CODE>
<DD>
The mass of 1 ton.

<DT><CODE>GSL_CONST_MKSA_METRIC_TON</CODE>
<DD>
The mass of 1 metric ton (1000 kg).

<DT><CODE>GSL_CONST_MKSA_UK_TON</CODE>
<DD>
The mass of 1 UK ton.

<DT><CODE>GSL_CONST_MKSA_TROY_OUNCE</CODE>
<DD>
The mass of 1 troy ounce.

<DT><CODE>GSL_CONST_MKSA_CARAT</CODE>
<DD>
The mass of 1 carat.

<DT><CODE>GSL_CONST_MKSA_GRAM_FORCE</CODE>
<DD>
The force of 1 gram weight.

<DT><CODE>GSL_CONST_MKSA_POUND_FORCE</CODE>
<DD>
The force of 1 pound weight.

<DT><CODE>GSL_CONST_MKSA_KILOPOUND_FORCE</CODE>
<DD>
The force of 1 kilopound weight.

<DT><CODE>GSL_CONST_MKSA_POUNDAL</CODE>
<DD>
The force of 1 poundal.
</DL>



<H2><A NAME="SEC504" HREF="gsl_manual.html#TOC504">Thermal Energy and Power</A></H2>
<P>
<A NAME="IDX2301"></A>
<A NAME="IDX2302"></A>
<A NAME="IDX2303"></A>
<DL COMPACT>

<DT><CODE>GSL_CONST_MKSA_CALORIE</CODE>
<DD>
The energy of 1 calorie.

<DT><CODE>GSL_CONST_MKSA_BTU</CODE>
<DD>
The energy of 1 British Thermal Unit, btu.

<DT><CODE>GSL_CONST_MKSA_THERM</CODE>
<DD>
The energy of 1 Therm.

<DT><CODE>GSL_CONST_MKSA_HORSEPOWER</CODE>
<DD>
The power of 1 horsepower.
</DL>



<H2><A NAME="SEC505" HREF="gsl_manual.html#TOC505">Pressure</A></H2>
<P>
<A NAME="IDX2304"></A>
<DL COMPACT>

<DT><CODE>GSL_CONST_MKSA_BAR</CODE>
<DD>
The pressure of 1 bar.

<DT><CODE>GSL_CONST_MKSA_STD_ATMOSPHERE</CODE>
<DD>
The pressure of 1 standard atmosphere.

<DT><CODE>GSL_CONST_MKSA_TORR</CODE>
<DD>
The pressure of 1 torr.

<DT><CODE>GSL_CONST_MKSA_METER_OF_MERCURY</CODE>
<DD>
The pressure of 1 meter of mercury.

<DT><CODE>GSL_CONST_MKSA_INCH_OF_MERCURY</CODE>
<DD>
The pressure of 1 inch of mercury.

<DT><CODE>GSL_CONST_MKSA_INCH_OF_WATER</CODE>
<DD>
The pressure of 1 inch of water.

<DT><CODE>GSL_CONST_MKSA_PSI</CODE>
<DD>
The pressure of 1 pound per square inch.
</DL>



<H2><A NAME="SEC506" HREF="gsl_manual.html#TOC506">Viscosity</A></H2>
<P>
<A NAME="IDX2305"></A>
<DL COMPACT>

<DT><CODE>GSL_CONST_MKSA_POISE</CODE>
<DD>
The dynamic viscosity of 1 poise.

<DT><CODE>GSL_CONST_MKSA_STOKES</CODE>
<DD>
The kinematic viscosity of 1 stokes.
</DL>



<H2><A NAME="SEC507" HREF="gsl_manual.html#TOC507">Light and Illumination</A></H2>
<P>
<A NAME="IDX2306"></A>
<A NAME="IDX2307"></A>

</P>
<DL COMPACT>

<DT><CODE>GSL_CONST_MKSA_STILB</CODE>
<DD>
The luminance of 1 stilb.

<DT><CODE>GSL_CONST_MKSA_LUMEN</CODE>
<DD>
The luminous flux of 1 lumen.

<DT><CODE>GSL_CONST_MKSA_LUX</CODE>
<DD>
The illuminance of 1 lux.

<DT><CODE>GSL_CONST_MKSA_PHOT</CODE>
<DD>
The illuminance of 1 phot.

<DT><CODE>GSL_CONST_MKSA_FOOTCANDLE</CODE>
<DD>
The illuminance of 1 footcandle.

<DT><CODE>GSL_CONST_MKSA_LAMBERT</CODE>
<DD>
The luminance of 1 lambert.

<DT><CODE>GSL_CONST_MKSA_FOOTLAMBERT</CODE>
<DD>
The luminance of 1 footlambert.
</DL>



<H2><A NAME="SEC508" HREF="gsl_manual.html#TOC508">Radioactivity</A></H2>
<P>
<A NAME="IDX2308"></A>
<DL COMPACT>

<DT><CODE>GSL_CONST_MKSA_CURIE</CODE>
<DD>
The activity of 1 curie.

<DT><CODE>GSL_CONST_MKSA_ROENTGEN</CODE>
<DD>
The exposure of 1 roentgen.

<DT><CODE>GSL_CONST_MKSA_RAD</CODE>
<DD>
The absorbed dose of 1 rad.
</DL>



<H2><A NAME="SEC509" HREF="gsl_manual.html#TOC509">Force and Energy</A></H2>
<P>
<A NAME="IDX2309"></A>
<DL COMPACT>

<DT><CODE>GSL_CONST_MKSA_NEWTON</CODE>
<DD>
The SI unit of force, 1 Newton.

<DT><CODE>GSL_CONST_MKSA_DYNE</CODE>
<DD>
The force of 1 Dyne = 
10^-5 Newton.

<DT><CODE>GSL_CONST_MKSA_JOULE</CODE>
<DD>
The SI unit of energy, 1 Joule.

<DT><CODE>GSL_CONST_MKSA_ERG</CODE>
<DD>
The energy 1 erg = 
10^-7 Joule.
</DL>



<H2><A NAME="SEC510" HREF="gsl_manual.html#TOC510">Prefixes</A></H2>
<P>
<A NAME="IDX2310"></A>
<A NAME="IDX2311"></A>

</P>
<P>
These constants are dimensionless scaling factors.

</P>
<DL COMPACT>

<DT><CODE>GSL_CONST_NUM_YOTTA</CODE>
<DD>
10^24

<DT><CODE>GSL_CONST_NUM_ZETTA</CODE>
<DD>
10^21

<DT><CODE>GSL_CONST_NUM_EXA</CODE>
<DD>
10^18

<DT><CODE>GSL_CONST_NUM_PETA</CODE>
<DD>
10^15

<DT><CODE>GSL_CONST_NUM_TERA</CODE>
<DD>
10^12

<DT><CODE>GSL_CONST_NUM_GIGA</CODE>
<DD>
10^9

<DT><CODE>GSL_CONST_NUM_MEGA</CODE>
<DD>
10^6

<DT><CODE>GSL_CONST_NUM_KILO</CODE>
<DD>
10^3

<DT><CODE>GSL_CONST_NUM_MILLI</CODE>
<DD>
10^-3

<DT><CODE>GSL_CONST_NUM_MICRO</CODE>
<DD>
10^-6

<DT><CODE>GSL_CONST_NUM_NANO</CODE>
<DD>
10^-9

<DT><CODE>GSL_CONST_NUM_PICO</CODE>
<DD>
10^-12

<DT><CODE>GSL_CONST_NUM_FEMTO</CODE>
<DD>
10^-15

<DT><CODE>GSL_CONST_NUM_ATTO</CODE>
<DD>
10^-18

<DT><CODE>GSL_CONST_NUM_ZEPTO</CODE>
<DD>
10^-21

<DT><CODE>GSL_CONST_NUM_YOCTO</CODE>
<DD>
10^-24
</DL>



<H2><A NAME="SEC511" HREF="gsl_manual.html#TOC511">Examples</A></H2>

<P>
The following program demonstrates the use of the physical constants in
a calculation.  In this case, the goal is to calculate the range of
light-travel times from Earth to Mars.

</P>
<P>
The required data is the average distance of each planet from the Sun in
astronomical units (the eccentricities and inclinations of the orbits
will be neglected for the purposes of this calculation).  The average
radius of the orbit of Mars is 1.52 astronomical units, and for the
orbit of Earth it is 1 astronomical unit (by definition).  These values
are combined with the MKSA values of the constants for the speed of
light and the length of an astronomical unit to produce a result for the
shortest and longest light-travel times in seconds.  The figures are
converted into minutes before being displayed.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_const_mksa.h&#62;

int
main (void)
{
  double c  = GSL_CONST_MKSA_SPEED_OF_LIGHT;
  double au = GSL_CONST_MKSA_ASTRONOMICAL_UNIT;
  double minutes = GSL_CONST_MKSA_MINUTE;

  /* distance stored in meters */
  double r_earth = 1.00 * au;  
  double r_mars  = 1.52 * au;

  double t_min, t_max;

  t_min = (r_mars - r_earth) / c;
  t_max = (r_mars + r_earth) / c;

  printf ("light travel time from Earth to Mars:\n");
  printf ("minimum = %.1f minutes\n", t_min / minutes);
  printf ("maximum = %.1f minutes\n", t_max / minutes);

  return 0;
}
</PRE>

<P>
Here is the output from the program,

</P>

<PRE class="example">
light travel time from Earth to Mars:
minimum = 4.3 minutes
maximum = 21.0 minutes
</PRE>



<H2><A NAME="SEC512" HREF="gsl_manual.html#TOC512">References and Further Reading</A></H2>

<P>
The authoritative sources for physical constanst are the 2002 CODATA
recommended values, published in the articles below. Further information
on the values of physical constants is also available from the cited
articles and the NIST website. 

</P>

<UL class="itemize">
<LI>Journal of Physical and Chemical Reference Data, 28(6), 1713-1852, 1999

<LI>Reviews of Modern Physics, 72(2), 351-495, 2000

<LI><A HREF="http://www.physics.nist.gov/cuu/Constants/index.html">http://www.physics.nist.gov/cuu/Constants/index.html</A>

<LI><A HREF="http://physics.nist.gov/Pubs/SP811/appenB9.html">http://physics.nist.gov/Pubs/SP811/appenB9.html</A>

</UL>



<H1><A NAME="SEC513" HREF="gsl_manual.html#TOC513">IEEE floating-point arithmetic</A></H1>
<P>
<A NAME="IDX2312"></A>

</P>
<P>
This chapter describes functions for examining the representation of
floating point numbers and controlling the floating point environment of
your program.  The functions described in this chapter are declared in
the header file <TT>'gsl_ieee_utils.h'</TT>.

</P>



<H2><A NAME="SEC514" HREF="gsl_manual.html#TOC514">Representation of floating point numbers</A></H2>
<P>
<A NAME="IDX2313"></A>
<A NAME="IDX2314"></A>
<A NAME="IDX2315"></A>
<A NAME="IDX2316"></A>
<A NAME="IDX2317"></A>
The IEEE Standard for Binary Floating-Point Arithmetic defines binary
formats for single and double precision numbers.  Each number is composed
of three parts: a <I>sign bit</I> (s), an <I>exponent</I>
(E) and a <I>fraction</I> (f).  The numerical value of the
combination (s,E,f) is given by the following formula,

<SPAN class="ifinfo">


<PRE class="example">
(-1)^s (1.fffff...) 2^E
</PRE>

</SPAN>

<P>
<A NAME="IDX2318"></A>
<A NAME="IDX2319"></A>
The sign bit is either zero or one.  The exponent ranges from a minimum value
E_min 
to a maximum value
E_max depending on the precision.  The exponent is converted to an 
unsigned number
e, known as the <I>biased exponent</I>, for storage by adding a
<I>bias</I> parameter,
e = E + bias.
The sequence fffff... represents the digits of the binary
fraction f.  The binary digits are stored in <I>normalized
form</I>, by adjusting the exponent to give a leading digit of 1. 
Since the leading digit is always 1 for normalized numbers it is
assumed implicitly and does not have to be stored.
Numbers smaller than 
2^(E_min)
are be stored in <I>denormalized form</I> with a leading zero,

<SPAN class="ifinfo">


<PRE class="example">
(-1)^s (0.fffff...) 2^(E_min)
</PRE>

</SPAN>

<P>
<A NAME="IDX2320"></A>
<A NAME="IDX2321"></A>
This allows gradual underflow down to 
2^(E_min - p) for p bits of precision. 
A zero is encoded with the special exponent of 
2^(E_min - 1) and infinities with the exponent of 
2^(E_max + 1).
<A NAME="IDX2322"></A>
The format for single precision numbers uses 32 bits divided in the
following way,

</P>

<PRE class="smallexample">
seeeeeeeefffffffffffffffffffffff
    
s = sign bit, 1 bit
e = exponent, 8 bits  (E_min=-126, E_max=127, bias=127)
f = fraction, 23 bits
</PRE>

<P>
<A NAME="IDX2323"></A>
The format for double precision numbers uses 64 bits divided in the
following way,

</P>

<PRE class="smallexample">
seeeeeeeeeeeffffffffffffffffffffffffffffffffffffffffffffffffffff

s = sign bit, 1 bit
e = exponent, 11 bits  (E_min=-1022, E_max=1023, bias=1023)
f = fraction, 52 bits
</PRE>

<P>
It is often useful to be able to investigate the behavior of a
calculation at the bit-level and the library provides functions for
printing the IEEE representations in a human-readable form.

</P>

<P>
<DL>
<DT><U>Function:</U> void <B>gsl_ieee_fprintf_float</B> <I>(FILE * <VAR>stream</VAR>, const float * <VAR>x</VAR>)</I>
<DD><A NAME="IDX2324"></A>
<DT><U>Function:</U> void <B>gsl_ieee_fprintf_double</B> <I>(FILE * <VAR>stream</VAR>, const double * <VAR>x</VAR>)</I>
<DD><A NAME="IDX2325"></A>
These functions output a formatted version of the IEEE floating-point
number pointed to by <VAR>x</VAR> to the stream <VAR>stream</VAR>. A pointer is
used to pass the number indirectly, to avoid any undesired promotion
from <CODE>float</CODE> to <CODE>double</CODE>.  The output takes one of the
following forms,

</P>
<DL COMPACT>

<DT><CODE>NaN</CODE>
<DD>
the Not-a-Number symbol

<DT><CODE>Inf, -Inf</CODE>
<DD>
positive or negative infinity

<DT><CODE>1.fffff...*2^E, -1.fffff...*2^E</CODE>
<DD>
a normalized floating point number

<DT><CODE>0.fffff...*2^E, -0.fffff...*2^E</CODE>
<DD>
a denormalized floating point number

<DT><CODE>0, -0</CODE>
<DD>
positive or negative zero

</DL>

<P>
The output can be used directly in GNU Emacs Calc mode by preceding it
with <CODE>2#</CODE> to indicate binary.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_ieee_printf_float</B> <I>(const float * <VAR>x</VAR>)</I>
<DD><A NAME="IDX2326"></A>
<DT><U>Function:</U> void <B>gsl_ieee_printf_double</B> <I>(const double * <VAR>x</VAR>)</I>
<DD><A NAME="IDX2327"></A>
These functions output a formatted version of the IEEE floating-point
number pointed to by <VAR>x</VAR> to the stream <CODE>stdout</CODE>.
</DL>
The following program demonstrates the use of the functions by printing
the single and double precision representations of the fraction
1/3.  For comparison the representation of the value promoted from
single to double precision is also printed.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_ieee_utils.h&#62;

int
main (void) 
{
  float f = 1.0/3.0;
  double d = 1.0/3.0;

  double fd = f; /* promote from float to double */
  
  printf (" f="); gsl_ieee_printf_float(&#38;f); 
  printf ("\n");

  printf ("fd="); gsl_ieee_printf_double(&#38;fd); 
  printf ("\n");

  printf (" d="); gsl_ieee_printf_double(&#38;d); 
  printf ("\n");

  return 0;
}
</PRE>

<P>
The binary representation of 1/3 is 0.01010101... .  The
output below shows that the IEEE format normalizes this fraction to give
a leading digit of 1,

</P>

<PRE class="smallexample">
 f= 1.01010101010101010101011*2^-2
fd= 1.0101010101010101010101100000000000000000000000000000*2^-2
 d= 1.0101010101010101010101010101010101010101010101010101*2^-2
</PRE>

<P>
The output also shows that a single-precision number is promoted to
double-precision by adding zeros in the binary representation.

</P>

<P>
  

</P>



<H2><A NAME="SEC515" HREF="gsl_manual.html#TOC515">Setting up your IEEE environment</A></H2>
<P>
<A NAME="IDX2328"></A>
<A NAME="IDX2329"></A>
<A NAME="IDX2330"></A>
<A NAME="IDX2331"></A>
<A NAME="IDX2332"></A>
<A NAME="IDX2333"></A>
<A NAME="IDX2334"></A>
<A NAME="IDX2335"></A>
The IEEE standard defines several <I>modes</I> for controlling the
behavior of floating point operations.  These modes specify the important
properties of computer arithmetic: the direction used for rounding (e.g.
whether numbers should be rounded up, down or to the nearest number),
the rounding precision and how the program should handle arithmetic
exceptions, such as division by zero.

</P>
<P>
Many of these features can now be controlled via standard functions such
as <CODE>fpsetround</CODE>, which should be used whenever they are available.
Unfortunately in the past there has been no universal API for
controlling their behavior--each system has had its own low-level way
of accessing them.  To help you write portable programs GSL allows you
to specify modes in a platform-independent way using the environment
variable <CODE>GSL_IEEE_MODE</CODE>.  The library then takes care of all the
necessary machine-specific initializations for you when you call the
function <CODE>gsl_ieee_env_setup</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gsl_ieee_env_setup</B> <I>()</I>
<DD><A NAME="IDX2336"></A>
This function reads the environment variable <CODE>GSL_IEEE_MODE</CODE> and
attempts to set up the corresponding specified IEEE modes.  The
environment variable should be a list of keywords, separated by
commas, like this,

</P>

<PRE class="display">
<CODE>GSL_IEEE_MODE</CODE> = "<VAR>keyword</VAR>,<VAR>keyword</VAR>,..."
</PRE>

<P>
where <VAR>keyword</VAR> is one of the following mode-names,

</P>

<UL class="itemize">
<LI>

<CODE>single-precision</CODE>
<LI>

<CODE>double-precision</CODE>
<LI>

<CODE>extended-precision</CODE>
<LI>

<CODE>round-to-nearest</CODE>
<LI>

<CODE>round-down</CODE>
<LI>

<CODE>round-up</CODE>
<LI>

<CODE>round-to-zero</CODE>
<LI>

<CODE>mask-all</CODE>
<LI>

<CODE>mask-invalid</CODE>
<LI>

<CODE>mask-denormalized</CODE>
<LI>

<CODE>mask-division-by-zero</CODE>
<LI>

<CODE>mask-overflow</CODE>
<LI>

<CODE>mask-underflow</CODE>
<LI>

<CODE>trap-inexact</CODE>
<LI>

<CODE>trap-common</CODE>
</UL>

<P>
If <CODE>GSL_IEEE_MODE</CODE> is empty or undefined then the function returns
immediately and no attempt is made to change the system's IEEE
mode.  When the modes from <CODE>GSL_IEEE_MODE</CODE> are turned on the
function prints a short message showing the new settings to remind you
that the results of the program will be affected.

</P>
<P>
If the requested modes are not supported by the platform being used then
the function calls the error handler and returns an error code of
<CODE>GSL_EUNSUP</CODE>.

</P>
<P>
When options are specified using this method, the resulting mode is
based on a default setting of the highest available precision (double
precision or extended precision, depending on the platform) in
round-to-nearest mode, with all exceptions enabled apart from the
INEXACT exception.  The INEXACT exception is generated
whenever rounding occurs, so it must generally be disabled in typical
scientific calculations.  All other floating-point exceptions are
enabled by default, including underflows and the use of denormalized
numbers, for safety.  They can be disabled with the individual
<CODE>mask-</CODE> settings or together using <CODE>mask-all</CODE>.

</P>
<P>
The following adjusted combination of modes is convenient for many
purposes,

</P>

<PRE class="example">
GSL_IEEE_MODE="double-precision,"\
                "mask-underflow,"\
                  "mask-denormalized"
</PRE>

<P>
This choice ignores any errors relating to small numbers (either
denormalized, or underflowing to zero) but traps overflows, division by
zero and invalid operations.
</DL>
To demonstrate the effects of different rounding modes consider the
following program which computes e, the base of natural
logarithms, by summing a rapidly-decreasing series,

<SPAN class="ifinfo">


<PRE class="example">
e = 1 + 1/2! + 1/3! + 1/4! + ... 
  = 2.71828182846...
</PRE>

</SPAN>


<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_math.h&#62;
#include &#60;gsl/gsl_ieee_utils.h&#62;

int
main (void)
{
  double x = 1, oldsum = 0, sum = 0; 
  int i = 0;

  gsl_ieee_env_setup (); /* read GSL_IEEE_MODE */

  do 
    {
      i++;
      
      oldsum = sum;
      sum += x;
      x = x / i;
      
      printf ("i=%2d sum=%.18f error=%g\n",
              i, sum, sum - M_E);

      if (i &#62; 30)
         break;
    }  
  while (sum != oldsum);

  return 0;
}
</PRE>

<P>
Here are the results of running the program in <CODE>round-to-nearest</CODE>
mode.  This is the IEEE default so it isn't really necessary to specify
it here,

</P>

<PRE class="example">
$ GSL_IEEE_MODE="round-to-nearest" ./a.out 
i= 1 sum=1.000000000000000000 error=-1.71828
i= 2 sum=2.000000000000000000 error=-0.718282
....
i=18 sum=2.718281828459045535 error=4.44089e-16
i=19 sum=2.718281828459045535 error=4.44089e-16
</PRE>

<P>
After nineteen terms the sum converges to within 
4 \times 10^-16 of the correct value.  
If we now change the rounding mode to
<CODE>round-down</CODE> the final result is less accurate,

</P>

<PRE class="example">
$ GSL_IEEE_MODE="round-down" ./a.out 
i= 1 sum=1.000000000000000000 error=-1.71828
....
i=19 sum=2.718281828459041094 error=-3.9968e-15
</PRE>

<P>
The result is about 
4 \times 10^-15 
below the correct value, an order of magnitude worse than the result
obtained in the <CODE>round-to-nearest</CODE> mode.

</P>
<P>
If we change to rounding mode to <CODE>round-up</CODE> then the series no
longer converges (the reason is that when we add each term to the sum
the final result is always rounded up.  This is guaranteed to increase the sum
by at least one tick on each iteration).  To avoid this problem we would
need to use a safer converge criterion, such as <CODE>while (fabs(sum -
oldsum) &#62; epsilon)</CODE>, with a suitably chosen value of epsilon.

</P>
<P>
Finally we can see the effect of computing the sum using
single-precision rounding, in the default <CODE>round-to-nearest</CODE>
mode.  In this case the program thinks it is still using double precision
numbers but the CPU rounds the result of each floating point operation
to single-precision accuracy.  This simulates the effect of writing the
program using single-precision <CODE>float</CODE> variables instead of
<CODE>double</CODE> variables.  The iteration stops after about half the number
of iterations and the final result is much less accurate,

</P>

<PRE class="example">
$ GSL_IEEE_MODE="single-precision" ./a.out 
....
i=12 sum=2.718281984329223633 error=1.5587e-07
</PRE>

<P>
with an error of 
O(10^-7), which corresponds to single
precision accuracy (about 1 part in 10^7).  Continuing the
iterations further does not decrease the error because all the
subsequent results are rounded to the same value.

</P>


<H2><A NAME="SEC516" HREF="gsl_manual.html#TOC516">References and Further Reading</A></H2>

<P>
The reference for the IEEE standard is,

</P>

<UL class="itemize">
<LI>

ANSI/IEEE Std 754-1985, IEEE Standard for Binary Floating-Point Arithmetic.
</UL>

<P>
A more pedagogical introduction to the standard can be found in the
following paper,

</P>

<UL class="itemize">
<LI>

David Goldberg: What Every Computer Scientist Should Know About
Floating-Point Arithmetic. <CITE>ACM Computing Surveys</CITE>, Vol. 23, No. 1
(March 1991), pages 5--48.

Corrigendum: <CITE>ACM Computing Surveys</CITE>, Vol. 23, No. 3 (September
1991), page 413. and see also the sections by B. A. Wichmann and Charles
B. Dunham in Surveyor's Forum: "What Every Computer Scientist Should
Know About Floating-Point Arithmetic". <CITE>ACM Computing Surveys</CITE>,
Vol. 24, No. 3 (September 1992), page 319.
</UL>

<P>

</P>
<P>
A detailed textbook on IEEE arithmetic and its practical use is
available from SIAM Press,

</P>

<UL class="itemize">
<LI>

Michael L. Overton, <CITE>Numerical Computing with IEEE Floating Point Arithmetic</CITE>,
SIAM Press, ISBN 0898715717.
</UL>

<P>

</P>



<H1><A NAME="SEC517" HREF="gsl_manual.html#TOC517">Debugging Numerical Programs</A></H1>
<P>
This chapter describes some tips and tricks for debugging numerical
programs which use GSL.

</P>



<H2><A NAME="SEC518" HREF="gsl_manual.html#TOC518">Using gdb</A></H2>
<P>
<A NAME="IDX2337"></A>
<A NAME="IDX2338"></A>
<A NAME="IDX2339"></A>
Any errors reported by the library are passed to the function
<CODE>gsl_error</CODE>.  By running your programs under gdb and setting a
breakpoint in this function you can automatically catch any library
errors.  You can add a breakpoint for every session by putting

</P>

<PRE class="example">
break gsl_error
</PRE>

<P>
into your <TT>'.gdbinit'</TT> file in the directory where your program is
started.  

</P>
<P>
If the breakpoint catches an error then you can use a backtrace
(<CODE>bt</CODE>) to see the call-tree, and the arguments which possibly
caused the error.  By moving up into the calling function you can
investigate the values of variables at that point.  Here is an example
from the program <CODE>fft/test_trap</CODE>, which contains the following
line,

</P>

<PRE class="smallexample">
status = gsl_fft_complex_wavetable_alloc (0, &#38;complex_wavetable);
</PRE>

<P>
The function <CODE>gsl_fft_complex_wavetable_alloc</CODE> takes the length of
an FFT as its first argument.  When this line is executed an error will
be generated because the length of an FFT is not allowed to be zero.

</P>
<P>
To debug this problem we start <CODE>gdb</CODE>, using the file
<TT>'.gdbinit'</TT> to define a breakpoint in <CODE>gsl_error</CODE>,

</P>

<PRE class="smallexample">
$ gdb test_trap

GDB is free software and you are welcome to distribute copies
of it under certain conditions; type "show copying" to see
the conditions.  There is absolutely no warranty for GDB;
type "show warranty" for details.  GDB 4.16 (i586-debian-linux), 
Copyright 1996 Free Software Foundation, Inc.

Breakpoint 1 at 0x8050b1e: file error.c, line 14.
</PRE>

<P>
When we run the program this breakpoint catches the error and shows the
reason for it. 

</P>

<PRE class="smallexample">
(gdb) run
Starting program: test_trap 

Breakpoint 1, gsl_error (reason=0x8052b0d 
    "length n must be positive integer", 
    file=0x8052b04 "c_init.c", line=108, gsl_errno=1) 
    at error.c:14
14        if (gsl_error_handler) 
</PRE>

<P>
The first argument of <CODE>gsl_error</CODE> is always a string describing the
error.  Now we can look at the backtrace to see what caused the problem,

</P>

<PRE class="smallexample">
(gdb) bt
#0  gsl_error (reason=0x8052b0d 
    "length n must be positive integer", 
    file=0x8052b04 "c_init.c", line=108, gsl_errno=1)
    at error.c:14
#1  0x8049376 in gsl_fft_complex_wavetable_alloc (n=0,
    wavetable=0xbffff778) at c_init.c:108
#2  0x8048a00 in main (argc=1, argv=0xbffff9bc) 
    at test_trap.c:94
#3  0x80488be in ___crt_dummy__ ()
</PRE>

<P>
We can see that the error was generated in the function
<CODE>gsl_fft_complex_wavetable_alloc</CODE> when it was called with an
argument of <VAR>n=0</VAR>.  The original call came from line 94 in the
file <TT>'test_trap.c'</TT>.

</P>
<P>
By moving up to the level of the original call we can find the line that
caused the error,

</P>

<PRE class="smallexample">
(gdb) up
#1  0x8049376 in gsl_fft_complex_wavetable_alloc (n=0,
    wavetable=0xbffff778) at c_init.c:108
108   GSL_ERROR ("length n must be positive integer", GSL_EDOM);
(gdb) up
#2  0x8048a00 in main (argc=1, argv=0xbffff9bc) 
    at test_trap.c:94
94    status = gsl_fft_complex_wavetable_alloc (0,
        &#38;complex_wavetable);
</PRE>

<P>
Thus we have found the line that caused the problem.  From this point we
could also print out the values of other variables such as
<CODE>complex_wavetable</CODE>.

</P>


<H2><A NAME="SEC519" HREF="gsl_manual.html#TOC519">Examining floating point registers</A></H2>

<P>
The contents of floating point registers can be examined using the
command <CODE>info float</CODE> (on supported platforms).

</P>

<PRE class="smallexample">
(gdb) info float
     st0: 0xc4018b895aa17a945000  Valid Normal -7.838871e+308
     st1: 0x3ff9ea3f50e4d7275000  Valid Normal 0.0285946
     st2: 0x3fe790c64ce27dad4800  Valid Normal 6.7415931e-08
     st3: 0x3ffaa3ef0df6607d7800  Spec  Normal 0.0400229
     st4: 0x3c028000000000000000  Valid Normal 4.4501477e-308
     st5: 0x3ffef5412c22219d9000  Zero  Normal 0.9580257
     st6: 0x3fff8000000000000000  Valid Normal 1
     st7: 0xc4028b65a1f6d243c800  Valid Normal -1.566206e+309
   fctrl: 0x0272 53 bit; NEAR; mask DENOR UNDER LOS;
   fstat: 0xb9ba flags 0001; top 7; excep DENOR OVERF UNDER LOS
    ftag: 0x3fff
     fip: 0x08048b5c
     fcs: 0x051a0023
  fopoff: 0x08086820
  fopsel: 0x002b
</PRE>

<P>
Individual registers can be examined using the variables <VAR>$reg</VAR>,
where <VAR>reg</VAR> is the register name.

</P>

<PRE class="smallexample">
(gdb) p $st1 
$1 = 0.02859464454261210347719
</PRE>



<H2><A NAME="SEC520" HREF="gsl_manual.html#TOC520">Handling floating point exceptions</A></H2>

<P>
It is possible to stop the program whenever a <CODE>SIGFPE</CODE> floating
point exception occurs.  This can be useful for finding the cause of an
unexpected infinity or <CODE>NaN</CODE>.  The current handler settings can be
shown with the command <CODE>info signal SIGFPE</CODE>.

</P>

<PRE class="smallexample">
(gdb) info signal SIGFPE
Signal  Stop  Print  Pass to program Description
SIGFPE  Yes   Yes    Yes             Arithmetic exception
</PRE>

<P>
Unless the program uses a signal handler the default setting should be
changed so that SIGFPE is not passed to the program, as this would cause
it to exit.  The command <CODE>handle SIGFPE stop nopass</CODE> prevents this.

</P>

<PRE class="smallexample">
(gdb) handle SIGFPE stop nopass
Signal  Stop  Print  Pass to program Description
SIGFPE  Yes   Yes    No              Arithmetic exception
</PRE>

<P>
Depending on the platform it may be necessary to instruct the kernel to
generate signals for floating point exceptions.  For programs using GSL
this can be achieved using the <CODE>GSL_IEEE_MODE</CODE> environment variable
in conjunction with the function <CODE>gsl_ieee_env_setup()</CODE> as described
in see section <A HREF="gsl_manual.html#SEC513">IEEE floating-point arithmetic</A>.

</P>

<PRE class="example">
(gdb) set env GSL_IEEE_MODE=double-precision
</PRE>



<H2><A NAME="SEC521" HREF="gsl_manual.html#TOC521">GCC warning options for numerical programs</A></H2>
<P>
<A NAME="IDX2340"></A>
<A NAME="IDX2341"></A>

</P>
<P>
Writing reliable numerical programs in C requires great care.  The
following GCC warning options are recommended when compiling numerical
programs:

</P>


<PRE class="example">
gcc -ansi -pedantic -Werror -Wall -W 
  -Wmissing-prototypes -Wstrict-prototypes 
  -Wtraditional -Wconversion -Wshadow
  -Wpointer-arith -Wcast-qual -Wcast-align 
  -Wwrite-strings -Wnested-externs 
  -fshort-enums -fno-common -Dinline= -g -O4
</PRE>

<P>
For details of each option consult the manual <CITE>Using and Porting
GCC</CITE>.  The following table gives a brief explanation of what types of
errors these options catch.

</P>
<DL COMPACT>

<DT><CODE>-ansi -pedantic</CODE>
<DD>
Use ANSI C, and reject any non-ANSI extensions.  These flags help in
writing portable programs that will compile on other systems.
<DT><CODE>-Werror</CODE>
<DD>
Consider warnings to be errors, so that compilation stops.  This prevents
warnings from scrolling off the top of the screen and being lost.  You
won't be able to compile the program until it is completely
warning-free.
<DT><CODE>-Wall</CODE>
<DD>
This turns on a set of warnings for common programming problems.  You
need <CODE>-Wall</CODE>, but it is not enough on its own.
<DT><CODE>-O2</CODE>
<DD>
Turn on optimization.  The warnings for uninitialized variables in
<CODE>-Wall</CODE> rely on the optimizer to analyze the code.  If there is no
optimization then these warnings aren't generated.
<DT><CODE>-W</CODE>
<DD>
This turns on some extra warnings not included in <CODE>-Wall</CODE>, such as
missing return values and comparisons between signed and unsigned
integers.
<DT><CODE>-Wmissing-prototypes -Wstrict-prototypes</CODE>
<DD>
Warn if there are any missing or inconsistent prototypes.  Without
prototypes it is harder to detect problems with incorrect arguments. 
<DT><CODE>-Wtraditional</CODE>
<DD>
This warns about certain constructs that behave differently in
traditional and ANSI C. Whether the traditional or ANSI interpretation
is used might be unpredictable on other compilers. 
<DT><CODE>-Wconversion</CODE>
<DD>
The main use of this option is to warn about conversions from signed to
unsigned integers.  For example, <CODE>unsigned int x = -1</CODE>.  If you need
to perform such a conversion you can use an explicit cast.
<DT><CODE>-Wshadow</CODE>
<DD>
This warns whenever a local variable shadows another local variable.  If
two variables have the same name then it is a potential source of
confusion.
<DT><CODE>-Wpointer-arith -Wcast-qual -Wcast-align</CODE>
<DD>
These options warn if you try to do pointer arithmetic for types which
don't have a size, such as <CODE>void</CODE>, if you remove a <CODE>const</CODE>
cast from a pointer, or if you cast a pointer to a type which has a
different size, causing an invalid alignment.
<DT><CODE>-Wwrite-strings</CODE>
<DD>
This option gives string constants a <CODE>const</CODE> qualifier so that it
will be a compile-time error to attempt to overwrite them.
<DT><CODE>-fshort-enums</CODE>
<DD>
This option makes the type of <CODE>enum</CODE> as short as possible.  Normally
this makes an <CODE>enum</CODE> different from an <CODE>int</CODE>.  Consequently any
attempts to assign a pointer-to-int to a pointer-to-enum will generate a
cast-alignment warning.
<DT><CODE>-fno-common</CODE>
<DD>
This option prevents global variables being simultaneously defined in
different object files (you get an error at link time).  Such a variable
should be defined in one file and referred to in other files with an
<CODE>extern</CODE> declaration.
<DT><CODE>-Wnested-externs</CODE>
<DD>
This warns if an <CODE>extern</CODE> declaration is encountered within a
function.
<DT><CODE>-Dinline=</CODE>
<DD>
The <CODE>inline</CODE> keyword is not part of ANSI C. Thus if you want to use
<CODE>-ansi</CODE> with a program which uses inline functions you can use this
preprocessor definition to remove the <CODE>inline</CODE> keywords.
<DT><CODE>-g</CODE>
<DD>
It always makes sense to put debugging symbols in the executable so that
you can debug it using <CODE>gdb</CODE>.  The only effect of debugging symbols
is to increase the size of the file, and you can use the <CODE>strip</CODE>
command to remove them later if necessary.
</DL>



<H2><A NAME="SEC522" HREF="gsl_manual.html#TOC522">References and Further Reading</A></H2>

<P>
The following books are essential reading for anyone writing and
debugging numerical programs with GCC and GDB.

</P>

<UL class="itemize">
<LI>

R.M. Stallman, <CITE>Using and Porting GNU CC</CITE>, Free Software
Foundation, ISBN 1882114388

<LI>

R.M. Stallman, R.H. Pesch, <CITE>Debugging with GDB: The GNU
Source-Level Debugger</CITE>, Free Software Foundation, ISBN 1882114779
</UL>

<P>
For a tutorial introduction to the GNU C Compiler and related programs,
see 

</P>

<UL class="itemize">
<LI>

B.J. Gough, <CITE>An Introduction to GCC</CITE>, Network Theory Ltd, ISBN
0954161793
</UL>



<H1><A NAME="SEC523" HREF="gsl_manual.html#TOC523">Contributors to GSL</A></H1>

<P>
(See the AUTHORS file in the distribution for up-to-date information.)

</P>
<DL COMPACT>

<DT><STRONG>Mark Galassi</STRONG>
<DD>
Conceived GSL (with James Theiler) and wrote the design document.  Wrote
the simulated annealing package and the relevant chapter in the manual.

<DT><STRONG>James Theiler</STRONG>
<DD>
Conceived GSL (with Mark Galassi).  Wrote the random number generators
and the relevant chapter in this manual.

<DT><STRONG>Jim Davies</STRONG>
<DD>
Wrote the statistical routines and the relevant chapter in this
manual.

<DT><STRONG>Brian Gough</STRONG>
<DD>
FFTs, numerical integration, random number generators and distributions,
root finding, minimization and fitting, polynomial solvers, complex
numbers, physical constants, permutations, vector and matrix functions,
histograms, statistics, ieee-utils, revised CBLAS Level 2 &#38; 3,
matrix decompositions, eigensystems, cumulative distribution functions,
testing, documentation and releases.

<DT><STRONG>Reid Priedhorsky</STRONG>
<DD>
Wrote and documented the initial version of the root finding routines
while at Los Alamos National Laboratory, Mathematical Modeling and
Analysis Group.  

<DT><STRONG>Gerard Jungman</STRONG>
<DD>
Special Functions, Series acceleration, ODEs, BLAS, Linear Algebra,
Eigensystems, Hankel Transforms.

<DT><STRONG>Mike Booth</STRONG>
<DD>
Wrote the Monte Carlo library.

<DT><STRONG>Jorma Olavi T&auml;htinen</STRONG>
<DD>
Wrote the initial complex arithmetic functions.

<DT><STRONG>Thomas Walter</STRONG>
<DD>
Wrote the initial heapsort routines and cholesky decomposition.

<DT><STRONG>Fabrice Rossi</STRONG>
<DD>
Multidimensional minimization.

<DT><STRONG>Carlo Perassi</STRONG>
<DD>
Implementation of the random number generators in Knuth's
<CITE>Seminumerical Algorithms</CITE>, 3rd Ed.

<DT><STRONG>Szymon Jaroszewicz</STRONG>
<DD>
Wrote the routines for generating combinations.

<DT><STRONG>Nicolas Darnis</STRONG>
<DD>
Wrote the initial routines for canonical permutations.

<DT><STRONG>Jason H. Stover</STRONG>
<DD>
Wrote the major cumulative distribution functions.

<DT><STRONG>Ivo Alxneit</STRONG>
<DD>
Wrote the routines for wavelet transforms.

<DT><STRONG>Tuomo Keskitalo</STRONG>
<DD>
Improved the implementation of the ODE solvers.

</DL>

<P>
Thanks to Nigel Lowry for help in proofreading the manual.

</P>


<H1><A NAME="SEC524" HREF="gsl_manual.html#TOC524">Autoconf Macros</A></H1>
<P>
<A NAME="IDX2342"></A>

</P>
<P>
For applications using <CODE>autoconf</CODE> the standard macro
<CODE>AC_CHECK_LIB</CODE> can be used to link with GSL automatically
from a <CODE>configure</CODE> script.  The library itself depends on the
presence of a CBLAS and math library as well, so these must also be
located before linking with the main <CODE>libgsl</CODE> file.  The following
commands should be placed in the <TT>'configure.ac'</TT> file to perform
these tests,

</P>

<PRE class="example">
AC_CHECK_LIB(m,main)
AC_CHECK_LIB(gslcblas,main)
AC_CHECK_LIB(gsl,main)
</PRE>

<P>
It is important to check for <CODE>libm</CODE> and <CODE>libgslcblas</CODE> before
<CODE>libgsl</CODE>, otherwise the tests will fail.  Assuming the libraries
are found the output during the configure stage looks like this,

</P>

<PRE class="example">
checking for main in -lm... yes
checking for main in -lgslcblas... yes
checking for main in -lgsl... yes
</PRE>

<P>
If the library is found then the tests will define the macros
<CODE>HAVE_LIBGSL</CODE>, <CODE>HAVE_LIBGSLCBLAS</CODE>, <CODE>HAVE_LIBM</CODE> and add
the options <CODE>-lgsl -lgslcblas -lm</CODE> to the variable <CODE>LIBS</CODE>.

</P>
<P>
The tests above will find any version of the library.  They are suitable
for general use, where the versions of the functions are not important.
An alternative macro is available in the file <TT>'gsl.m4'</TT> to test for
a specific version of the library.  To use this macro simply add the
following line to your <TT>'configure.in'</TT> file instead of the tests
above:

</P>

<PRE class="example">
AM_PATH_GSL(GSL_VERSION,
           [action-if-found],
           [action-if-not-found])
</PRE>

<P>
The argument <CODE>GSL_VERSION</CODE> should be the two or three digit
MAJOR.MINOR or MAJOR.MINOR.MICRO version number of the release
you require. A suitable choice for <CODE>action-if-not-found</CODE> is,

</P>

<PRE class="example">
AC_MSG_ERROR(could not find required version of GSL)
</PRE>

<P>
Then you can add the variables <CODE>GSL_LIBS</CODE> and <CODE>GSL_CFLAGS</CODE> to
your Makefile.am files to obtain the correct compiler flags.
<CODE>GSL_LIBS</CODE> is equal to the output of the <CODE>gsl-config --libs</CODE>
command and <CODE>GSL_CFLAGS</CODE> is equal to <CODE>gsl-config --cflags</CODE>
command. For example,

</P>

<PRE class="example">
libfoo_la_LDFLAGS = -lfoo $(GSL_LIBS) -lgslcblas
</PRE>

<P>
Note that the macro <CODE>AM_PATH_GSL</CODE> needs to use the C compiler so it
should appear in the <TT>'configure.in'</TT> file before the macro
<CODE>AC_LANG_CPLUSPLUS</CODE> for programs that use C++.

</P>
<P>
To test for <CODE>inline</CODE> the following test should be placed in your
<TT>'configure.in'</TT> file,

</P>

<PRE class="example">
AC_C_INLINE

if test "$ac_cv_c_inline" != no ; then
  AC_DEFINE(HAVE_INLINE,1)
  AC_SUBST(HAVE_INLINE)
fi
</PRE>

<P>
and the macro will then be defined in the compilation flags or by
including the file <TT>'config.h'</TT> before any library headers.  

</P>
<P>
The following autoconf test will check for <CODE>extern inline</CODE>,

</P>

<PRE class="smallexample">
dnl Check for "extern inline", using a modified version
dnl of the test for AC_C_INLINE from acspecific.mt
dnl
AC_CACHE_CHECK([for extern inline], ac_cv_c_extern_inline,
[ac_cv_c_extern_inline=no
AC_TRY_COMPILE([extern $ac_cv_c_inline double foo(double x);
extern $ac_cv_c_inline double foo(double x) { return x+1.0; };
double foo (double x) { return x + 1.0; };], 
[  foo(1.0)  ],
[ac_cv_c_extern_inline="yes"])
])

if test "$ac_cv_c_extern_inline" != no ; then
  AC_DEFINE(HAVE_INLINE,1)
  AC_SUBST(HAVE_INLINE)
fi
</PRE>

<P>
The substitution of portability functions can be made automatically if
you use <CODE>autoconf</CODE>. For example, to test whether the BSD function
<CODE>hypot</CODE> is available you can include the following line in the
configure file <TT>'configure.in'</TT> for your application,

</P>

<PRE class="example">
AC_CHECK_FUNCS(hypot)
</PRE>

<P>
and place the following macro definitions in the file
<TT>'config.h.in'</TT>,

</P>

<PRE class="example">
/* Substitute gsl_hypot for missing system hypot */

#ifndef HAVE_HYPOT
#define hypot gsl_hypot
#endif
</PRE>

<P>
The application source files can then use the include command
<CODE>#include &#60;config.h&#62;</CODE> to substitute <CODE>gsl_hypot</CODE> for each
occurrence of <CODE>hypot</CODE> when <CODE>hypot</CODE> is not available.

</P>


<H1><A NAME="SEC525" HREF="gsl_manual.html#TOC525">GSL CBLAS Library</A></H1>
<P>
<A NAME="IDX2343"></A>
<A NAME="IDX2344"></A>
<A NAME="IDX2345"></A>
<A NAME="IDX2346"></A>
The prototypes for the low-level CBLAS functions are declared in
the file <CODE>gsl_cblas.h</CODE>.  For the definition of the functions
consult the documentation available from Netlib (see section <A HREF="gsl_manual.html#SEC221">References and Further Reading</A>).

</P>



<H2><A NAME="SEC526" HREF="gsl_manual.html#TOC526">Level 1</A></H2>

<P>
<DL>
<DT><U>Function:</U> float <B>cblas_sdsdot</B> <I>(const int <VAR>N</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>, const float * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2347"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>cblas_dsdot</B> <I>(const int <VAR>N</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>, const float * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2348"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> float <B>cblas_sdot</B> <I>(const int <VAR>N</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>, const float * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2349"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>cblas_ddot</B> <I>(const int <VAR>N</VAR>, const double * <VAR>x</VAR>, const int <VAR>incx</VAR>, const double * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2350"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_cdotu_sub</B> <I>(const int <VAR>N</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>y</VAR>, const int <VAR>incy</VAR>, void * <VAR>dotu</VAR>)</I>
<DD><A NAME="IDX2351"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_cdotc_sub</B> <I>(const int <VAR>N</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>y</VAR>, const int <VAR>incy</VAR>, void * <VAR>dotc</VAR>)</I>
<DD><A NAME="IDX2352"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zdotu_sub</B> <I>(const int <VAR>N</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>y</VAR>, const int <VAR>incy</VAR>, void * <VAR>dotu</VAR>)</I>
<DD><A NAME="IDX2353"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zdotc_sub</B> <I>(const int <VAR>N</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>y</VAR>, const int <VAR>incy</VAR>, void * <VAR>dotc</VAR>)</I>
<DD><A NAME="IDX2354"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> float <B>cblas_snrm2</B> <I>(const int <VAR>N</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2355"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> float <B>cblas_sasum</B> <I>(const int <VAR>N</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2356"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>cblas_dnrm2</B> <I>(const int <VAR>N</VAR>, const double * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2357"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>cblas_dasum</B> <I>(const int <VAR>N</VAR>, const double * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2358"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> float <B>cblas_scnrm2</B> <I>(const int <VAR>N</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2359"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> float <B>cblas_scasum</B> <I>(const int <VAR>N</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2360"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>cblas_dznrm2</B> <I>(const int <VAR>N</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2361"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>cblas_dzasum</B> <I>(const int <VAR>N</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2362"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> CBLAS_INDEX <B>cblas_isamax</B> <I>(const int <VAR>N</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2363"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> CBLAS_INDEX <B>cblas_idamax</B> <I>(const int <VAR>N</VAR>, const double * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2364"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> CBLAS_INDEX <B>cblas_icamax</B> <I>(const int <VAR>N</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2365"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> CBLAS_INDEX <B>cblas_izamax</B> <I>(const int <VAR>N</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2366"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_sswap</B> <I>(const int <VAR>N</VAR>, float * <VAR>x</VAR>, const int <VAR>incx</VAR>, float * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2367"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_scopy</B> <I>(const int <VAR>N</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>, float * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2368"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_saxpy</B> <I>(const int <VAR>N</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>, float * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2369"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dswap</B> <I>(const int <VAR>N</VAR>, double * <VAR>x</VAR>, const int <VAR>incx</VAR>, double * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2370"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dcopy</B> <I>(const int <VAR>N</VAR>, const double * <VAR>x</VAR>, const int <VAR>incx</VAR>, double * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2371"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_daxpy</B> <I>(const int <VAR>N</VAR>, const double <VAR>alpha</VAR>, const double * <VAR>x</VAR>, const int <VAR>incx</VAR>, double * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2372"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_cswap</B> <I>(const int <VAR>N</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>, void * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2373"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ccopy</B> <I>(const int <VAR>N</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, void * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2374"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_caxpy</B> <I>(const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, void * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2375"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zswap</B> <I>(const int <VAR>N</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>, void * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2376"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zcopy</B> <I>(const int <VAR>N</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, void * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2377"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zaxpy</B> <I>(const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, void * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2378"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_srotg</B> <I>(float * <VAR>a</VAR>, float * <VAR>b</VAR>, float * <VAR>c</VAR>, float * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2379"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_srotmg</B> <I>(float * <VAR>d1</VAR>, float * <VAR>d2</VAR>, float * <VAR>b1</VAR>, const float <VAR>b2</VAR>, float * <VAR>P</VAR>)</I>
<DD><A NAME="IDX2380"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_srot</B> <I>(const int <VAR>N</VAR>, float * <VAR>x</VAR>, const int <VAR>incx</VAR>, float * <VAR>y</VAR>, const int <VAR>incy</VAR>, const float <VAR>c</VAR>, const float <VAR>s</VAR>)</I>
<DD><A NAME="IDX2381"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_srotm</B> <I>(const int <VAR>N</VAR>, float * <VAR>x</VAR>, const int <VAR>incx</VAR>, float * <VAR>y</VAR>, const int <VAR>incy</VAR>, const float * <VAR>P</VAR>)</I>
<DD><A NAME="IDX2382"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_drotg</B> <I>(double * <VAR>a</VAR>, double * <VAR>b</VAR>, double * <VAR>c</VAR>, double * <VAR>s</VAR>)</I>
<DD><A NAME="IDX2383"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_drotmg</B> <I>(double * <VAR>d1</VAR>, double * <VAR>d2</VAR>, double * <VAR>b1</VAR>, const double <VAR>b2</VAR>, double * <VAR>P</VAR>)</I>
<DD><A NAME="IDX2384"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_drot</B> <I>(const int <VAR>N</VAR>, double * <VAR>x</VAR>, const int <VAR>incx</VAR>, double * <VAR>y</VAR>, const int <VAR>incy</VAR>, const double <VAR>c</VAR>, const double <VAR>s</VAR>)</I>
<DD><A NAME="IDX2385"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_drotm</B> <I>(const int <VAR>N</VAR>, double * <VAR>x</VAR>, const int <VAR>incx</VAR>, double * <VAR>y</VAR>, const int <VAR>incy</VAR>, const double * <VAR>P</VAR>)</I>
<DD><A NAME="IDX2386"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_sscal</B> <I>(const int <VAR>N</VAR>, const float <VAR>alpha</VAR>, float * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2387"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dscal</B> <I>(const int <VAR>N</VAR>, const double <VAR>alpha</VAR>, double * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2388"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_cscal</B> <I>(const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2389"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zscal</B> <I>(const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2390"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_csscal</B> <I>(const int <VAR>N</VAR>, const float <VAR>alpha</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2391"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zdscal</B> <I>(const int <VAR>N</VAR>, const double <VAR>alpha</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2392"></A>
</DL>

</P>


<H2><A NAME="SEC527" HREF="gsl_manual.html#TOC527">Level 2</A></H2>

<P>
<DL>
<DT><U>Function:</U> void <B>cblas_sgemv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>A</VAR>, const int <VAR>lda</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>, const float <VAR>beta</VAR>, float * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2393"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_sgbmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const int <VAR>KL</VAR>, const int <VAR>KU</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>A</VAR>, const int <VAR>lda</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>, const float <VAR>beta</VAR>, float * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2394"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_strmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const float * <VAR>A</VAR>, const int <VAR>lda</VAR>, float * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2395"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_stbmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const float * <VAR>A</VAR>, const int <VAR>lda</VAR>, float * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2396"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_stpmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const float * <VAR>Ap</VAR>, float * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2397"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_strsv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const float * <VAR>A</VAR>, const int <VAR>lda</VAR>, float * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2398"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_stbsv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const float * <VAR>A</VAR>, const int <VAR>lda</VAR>, float * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2399"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_stpsv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const float * <VAR>Ap</VAR>, float * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2400"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dgemv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const double <VAR>alpha</VAR>, const double * <VAR>A</VAR>, const int <VAR>lda</VAR>, const double * <VAR>x</VAR>, const int <VAR>incx</VAR>, const double <VAR>beta</VAR>, double * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2401"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dgbmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const int <VAR>KL</VAR>, const int <VAR>KU</VAR>, const double <VAR>alpha</VAR>, const double * <VAR>A</VAR>, const int <VAR>lda</VAR>, const double * <VAR>x</VAR>, const int <VAR>incx</VAR>, const double <VAR>beta</VAR>, double * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2402"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dtrmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const double * <VAR>A</VAR>, const int <VAR>lda</VAR>, double * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2403"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dtbmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const double * <VAR>A</VAR>, const int <VAR>lda</VAR>, double * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2404"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dtpmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const double * <VAR>Ap</VAR>, double * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2405"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dtrsv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const double * <VAR>A</VAR>, const int <VAR>lda</VAR>, double * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2406"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dtbsv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const double * <VAR>A</VAR>, const int <VAR>lda</VAR>, double * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2407"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dtpsv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const double * <VAR>Ap</VAR>, double * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2408"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_cgemv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>beta</VAR>, void * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2409"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_cgbmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const int <VAR>KL</VAR>, const int <VAR>KU</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>beta</VAR>, void * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2410"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ctrmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2411"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ctbmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2412"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ctpmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const void * <VAR>Ap</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2413"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ctrsv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2414"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ctbsv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2415"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ctpsv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const void * <VAR>Ap</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2416"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zgemv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>beta</VAR>, void * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2417"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zgbmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const int <VAR>KL</VAR>, const int <VAR>KU</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>beta</VAR>, void * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2418"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ztrmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2419"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ztbmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2420"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ztpmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const void * <VAR>Ap</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2421"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ztrsv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2422"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ztbsv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2423"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ztpsv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>N</VAR>, const void * <VAR>Ap</VAR>, void * <VAR>x</VAR>, const int <VAR>incx</VAR>)</I>
<DD><A NAME="IDX2424"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ssymv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>A</VAR>, const int <VAR>lda</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>, const float <VAR>beta</VAR>, float * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2425"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ssbmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>A</VAR>, const int <VAR>lda</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>, const float <VAR>beta</VAR>, float * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2426"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_sspmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>Ap</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>, const float <VAR>beta</VAR>, float * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2427"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_sger</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>, const float * <VAR>y</VAR>, const int <VAR>incy</VAR>, float * <VAR>A</VAR>, const int <VAR>lda</VAR>)</I>
<DD><A NAME="IDX2428"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ssyr</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>, float * <VAR>A</VAR>, const int <VAR>lda</VAR>)</I>
<DD><A NAME="IDX2429"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_sspr</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>, float * <VAR>Ap</VAR>)</I>
<DD><A NAME="IDX2430"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ssyr2</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>, const float * <VAR>y</VAR>, const int <VAR>incy</VAR>, float * <VAR>A</VAR>, const int <VAR>lda</VAR>)</I>
<DD><A NAME="IDX2431"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_sspr2</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>x</VAR>, const int <VAR>incx</VAR>, const float * <VAR>y</VAR>, const int <VAR>incy</VAR>, float * <VAR>A</VAR>)</I>
<DD><A NAME="IDX2432"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dsymv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const double <VAR>alpha</VAR>, const double * <VAR>A</VAR>, const int <VAR>lda</VAR>, const double * <VAR>x</VAR>, const int <VAR>incx</VAR>, const double <VAR>beta</VAR>, double * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2433"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dsbmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const double <VAR>alpha</VAR>, const double * <VAR>A</VAR>, const int <VAR>lda</VAR>, const double * <VAR>x</VAR>, const int <VAR>incx</VAR>, const double <VAR>beta</VAR>, double * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2434"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dspmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const double <VAR>alpha</VAR>, const double * <VAR>Ap</VAR>, const double * <VAR>x</VAR>, const int <VAR>incx</VAR>, const double <VAR>beta</VAR>, double * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2435"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dger</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const double <VAR>alpha</VAR>, const double * <VAR>x</VAR>, const int <VAR>incx</VAR>, const double * <VAR>y</VAR>, const int <VAR>incy</VAR>, double * <VAR>A</VAR>, const int <VAR>lda</VAR>)</I>
<DD><A NAME="IDX2436"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dsyr</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const double <VAR>alpha</VAR>, const double * <VAR>x</VAR>, const int <VAR>incx</VAR>, double * <VAR>A</VAR>, const int <VAR>lda</VAR>)</I>
<DD><A NAME="IDX2437"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dspr</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const double <VAR>alpha</VAR>, const double * <VAR>x</VAR>, const int <VAR>incx</VAR>, double * <VAR>Ap</VAR>)</I>
<DD><A NAME="IDX2438"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dsyr2</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const double <VAR>alpha</VAR>, const double * <VAR>x</VAR>, const int <VAR>incx</VAR>, const double * <VAR>y</VAR>, const int <VAR>incy</VAR>, double * <VAR>A</VAR>, const int <VAR>lda</VAR>)</I>
<DD><A NAME="IDX2439"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dspr2</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const double <VAR>alpha</VAR>, const double * <VAR>x</VAR>, const int <VAR>incx</VAR>, const double * <VAR>y</VAR>, const int <VAR>incy</VAR>, double * <VAR>A</VAR>)</I>
<DD><A NAME="IDX2440"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_chemv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>beta</VAR>, void * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2441"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_chbmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>beta</VAR>, void * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2442"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_chpmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>Ap</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>beta</VAR>, void * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2443"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_cgeru</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>y</VAR>, const int <VAR>incy</VAR>, void * <VAR>A</VAR>, const int <VAR>lda</VAR>)</I>
<DD><A NAME="IDX2444"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_cgerc</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>y</VAR>, const int <VAR>incy</VAR>, void * <VAR>A</VAR>, const int <VAR>lda</VAR>)</I>
<DD><A NAME="IDX2445"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_cher</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const float <VAR>alpha</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, void * <VAR>A</VAR>, const int <VAR>lda</VAR>)</I>
<DD><A NAME="IDX2446"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_chpr</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const float <VAR>alpha</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, void * <VAR>A</VAR>)</I>
<DD><A NAME="IDX2447"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_cher2</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>y</VAR>, const int <VAR>incy</VAR>, void * <VAR>A</VAR>, const int <VAR>lda</VAR>)</I>
<DD><A NAME="IDX2448"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_chpr2</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>y</VAR>, const int <VAR>incy</VAR>, void * <VAR>Ap</VAR>)</I>
<DD><A NAME="IDX2449"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zhemv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>beta</VAR>, void * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2450"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zhbmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>beta</VAR>, void * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2451"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zhpmv</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>Ap</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>beta</VAR>, void * <VAR>y</VAR>, const int <VAR>incy</VAR>)</I>
<DD><A NAME="IDX2452"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zgeru</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>y</VAR>, const int <VAR>incy</VAR>, void * <VAR>A</VAR>, const int <VAR>lda</VAR>)</I>
<DD><A NAME="IDX2453"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zgerc</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>y</VAR>, const int <VAR>incy</VAR>, void * <VAR>A</VAR>, const int <VAR>lda</VAR>)</I>
<DD><A NAME="IDX2454"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zher</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const double <VAR>alpha</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, void * <VAR>A</VAR>, const int <VAR>lda</VAR>)</I>
<DD><A NAME="IDX2455"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zhpr</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const double <VAR>alpha</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, void * <VAR>A</VAR>)</I>
<DD><A NAME="IDX2456"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zher2</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>y</VAR>, const int <VAR>incy</VAR>, void * <VAR>A</VAR>, const int <VAR>lda</VAR>)</I>
<DD><A NAME="IDX2457"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zhpr2</B> <I>(const enum CBLAS_ORDER <VAR>order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>x</VAR>, const int <VAR>incx</VAR>, const void * <VAR>y</VAR>, const int <VAR>incy</VAR>, void * <VAR>Ap</VAR>)</I>
<DD><A NAME="IDX2458"></A>
</DL>

</P>


<H2><A NAME="SEC528" HREF="gsl_manual.html#TOC528">Level 3</A></H2>

<P>
<DL>
<DT><U>Function:</U> void <B>cblas_sgemm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransB</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>A</VAR>, const int <VAR>lda</VAR>, const float * <VAR>B</VAR>, const int <VAR>ldb</VAR>, const float <VAR>beta</VAR>, float * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2459"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ssymm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_SIDE <VAR>Side</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>A</VAR>, const int <VAR>lda</VAR>, const float * <VAR>B</VAR>, const int <VAR>ldb</VAR>, const float <VAR>beta</VAR>, float * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2460"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ssyrk</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>Trans</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>A</VAR>, const int <VAR>lda</VAR>, const float <VAR>beta</VAR>, float * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2461"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ssyr2k</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>Trans</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>A</VAR>, const int <VAR>lda</VAR>, const float * <VAR>B</VAR>, const int <VAR>ldb</VAR>, const float <VAR>beta</VAR>, float * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2462"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_strmm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_SIDE <VAR>Side</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>A</VAR>, const int <VAR>lda</VAR>, float * <VAR>B</VAR>, const int <VAR>ldb</VAR>)</I>
<DD><A NAME="IDX2463"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_strsm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_SIDE <VAR>Side</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const float <VAR>alpha</VAR>, const float * <VAR>A</VAR>, const int <VAR>lda</VAR>, float * <VAR>B</VAR>, const int <VAR>ldb</VAR>)</I>
<DD><A NAME="IDX2464"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dgemm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransB</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const double <VAR>alpha</VAR>, const double * <VAR>A</VAR>, const int <VAR>lda</VAR>, const double * <VAR>B</VAR>, const int <VAR>ldb</VAR>, const double <VAR>beta</VAR>, double * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2465"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dsymm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_SIDE <VAR>Side</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const double <VAR>alpha</VAR>, const double * <VAR>A</VAR>, const int <VAR>lda</VAR>, const double * <VAR>B</VAR>, const int <VAR>ldb</VAR>, const double <VAR>beta</VAR>, double * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2466"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dsyrk</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>Trans</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const double <VAR>alpha</VAR>, const double * <VAR>A</VAR>, const int <VAR>lda</VAR>, const double <VAR>beta</VAR>, double * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2467"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dsyr2k</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>Trans</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const double <VAR>alpha</VAR>, const double * <VAR>A</VAR>, const int <VAR>lda</VAR>, const double * <VAR>B</VAR>, const int <VAR>ldb</VAR>, const double <VAR>beta</VAR>, double * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2468"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dtrmm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_SIDE <VAR>Side</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const double <VAR>alpha</VAR>, const double * <VAR>A</VAR>, const int <VAR>lda</VAR>, double * <VAR>B</VAR>, const int <VAR>ldb</VAR>)</I>
<DD><A NAME="IDX2469"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_dtrsm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_SIDE <VAR>Side</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const double <VAR>alpha</VAR>, const double * <VAR>A</VAR>, const int <VAR>lda</VAR>, double * <VAR>B</VAR>, const int <VAR>ldb</VAR>)</I>
<DD><A NAME="IDX2470"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_cgemm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransB</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>B</VAR>, const int <VAR>ldb</VAR>, const void * <VAR>beta</VAR>, void * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2471"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_csymm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_SIDE <VAR>Side</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>B</VAR>, const int <VAR>ldb</VAR>, const void * <VAR>beta</VAR>, void * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2472"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_csyrk</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>Trans</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>beta</VAR>, void * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2473"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_csyr2k</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>Trans</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>B</VAR>, const int <VAR>ldb</VAR>, const void * <VAR>beta</VAR>, void * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2474"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ctrmm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_SIDE <VAR>Side</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, void * <VAR>B</VAR>, const int <VAR>ldb</VAR>)</I>
<DD><A NAME="IDX2475"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ctrsm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_SIDE <VAR>Side</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, void * <VAR>B</VAR>, const int <VAR>ldb</VAR>)</I>
<DD><A NAME="IDX2476"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zgemm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransB</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>B</VAR>, const int <VAR>ldb</VAR>, const void * <VAR>beta</VAR>, void * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2477"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zsymm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_SIDE <VAR>Side</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>B</VAR>, const int <VAR>ldb</VAR>, const void * <VAR>beta</VAR>, void * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2478"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zsyrk</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>Trans</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>beta</VAR>, void * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2479"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zsyr2k</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>Trans</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>B</VAR>, const int <VAR>ldb</VAR>, const void * <VAR>beta</VAR>, void * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2480"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ztrmm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_SIDE <VAR>Side</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, void * <VAR>B</VAR>, const int <VAR>ldb</VAR>)</I>
<DD><A NAME="IDX2481"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_ztrsm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_SIDE <VAR>Side</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>TransA</VAR>, const enum CBLAS_DIAG <VAR>Diag</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, void * <VAR>B</VAR>, const int <VAR>ldb</VAR>)</I>
<DD><A NAME="IDX2482"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_chemm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_SIDE <VAR>Side</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>B</VAR>, const int <VAR>ldb</VAR>, const void * <VAR>beta</VAR>, void * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2483"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_cherk</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>Trans</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const float <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const float <VAR>beta</VAR>, void * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2484"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_cher2k</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>Trans</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>B</VAR>, const int <VAR>ldb</VAR>, const float <VAR>beta</VAR>, void * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2485"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zhemm</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_SIDE <VAR>Side</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const int <VAR>M</VAR>, const int <VAR>N</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>B</VAR>, const int <VAR>ldb</VAR>, const void * <VAR>beta</VAR>, void * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2486"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zherk</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>Trans</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const double <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const double <VAR>beta</VAR>, void * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2487"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_zher2k</B> <I>(const enum CBLAS_ORDER <VAR>Order</VAR>, const enum CBLAS_UPLO <VAR>Uplo</VAR>, const enum CBLAS_TRANSPOSE <VAR>Trans</VAR>, const int <VAR>N</VAR>, const int <VAR>K</VAR>, const void * <VAR>alpha</VAR>, const void * <VAR>A</VAR>, const int <VAR>lda</VAR>, const void * <VAR>B</VAR>, const int <VAR>ldb</VAR>, const double <VAR>beta</VAR>, void * <VAR>C</VAR>, const int <VAR>ldc</VAR>)</I>
<DD><A NAME="IDX2488"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>cblas_xerbla</B> <I>(int <VAR>p</VAR>, const char * <VAR>rout</VAR>, const char * <VAR>form</VAR>, ...)</I>
<DD><A NAME="IDX2489"></A>
</DL>

</P>


<H2><A NAME="SEC529" HREF="gsl_manual.html#TOC529">Examples</A></H2>

<P>
The following program computes the product of two matrices using the
Level-3 BLAS function SGEMM,

<SPAN class="ifinfo">


<PRE class="example">
[ 0.11 0.12 0.13 ]  [ 1011 1012 ]     [ 367.76 368.12 ]
[ 0.21 0.22 0.23 ]  [ 1021 1022 ]  =  [ 674.06 674.72 ]
                    [ 1031 1032 ]
</PRE>

</SPAN>

<P>
The matrices are stored in row major order but could be stored in column
major order if the first argument of the call to <CODE>cblas_sgemm</CODE> was
changed to <CODE>CblasColMajor</CODE>.

</P>

<PRE class="example">
#include &#60;stdio.h&#62;
#include &#60;gsl/gsl_cblas.h&#62;

int
main (void)
{
  int lda = 3;

  float A[] = { 0.11, 0.12, 0.13,
                0.21, 0.22, 0.23 };

  int ldb = 2;
  
  float B[] = { 1011, 1012,
                1021, 1022,
                1031, 1032 };

  int ldc = 2;

  float C[] = { 0.00, 0.00,
                0.00, 0.00 };

  /* Compute C = A B */

  cblas_sgemm (CblasRowMajor, 
               CblasNoTrans, CblasNoTrans, 2, 2, 3,
               1.0, A, lda, B, ldb, 0.0, C, ldc);

  printf ("[ %g, %g\n", C[0], C[1]);
  printf ("  %g, %g ]\n", C[2], C[3]);

  return 0;  
}
</PRE>

<P>
To compile the program use the following command line,

</P>

<PRE class="example">
$ gcc -Wall demo.c -lgslcblas
</PRE>

<P>
There is no need to link with the main library <CODE>-lgsl</CODE> in this
case as the CBLAS library is an independent unit. Here is the output
from the program,

</P>

<PRE class="example">
$ ./a.out
[ 367.76, 368.12
  674.06, 674.72 ]
</PRE>



<H1><A NAME="SEC530" HREF="gsl_manual.html#TOC530">Free Software Needs Free Documentation</A></H1>
<P>
<A NAME="IDX2490"></A>

</P>

<BLOCKQUOTE class="quotation">
<P>
<I>The following article was written by Richard Stallman, founder of the
GNU Project.</I>
</BLOCKQUOTE>

<P>
The biggest deficiency in the free software community today is not in
the software--it is the lack of good free documentation that we can
include with the free software.  Many of our most important
programs do not come with free reference manuals and free introductory
texts.  Documentation is an essential part of any software package;
when an important free software package does not come with a free
manual and a free tutorial, that is a major gap.  We have many such
gaps today.

</P>
<P>
Consider Perl, for instance.  The tutorial manuals that people
normally use are non-free.  How did this come about?  Because the
authors of those manuals published them with restrictive terms--no
copying, no modification, source files not available--which exclude
them from the free software world.

</P>
<P>
That wasn't the first time this sort of thing happened, and it was far
from the last.  Many times we have heard a GNU user eagerly describe a
manual that he is writing, his intended contribution to the community,
only to learn that he had ruined everything by signing a publication
contract to make it non-free.

</P>
<P>
Free documentation, like free software, is a matter of freedom, not
price.  The problem with the non-free manual is not that publishers
charge a price for printed copies--that in itself is fine.  (The Free
Software Foundation sells printed copies of manuals, too.)  The
problem is the restrictions on the use of the manual.  Free manuals
are available in source code form, and give you permission to copy and
modify.  Non-free manuals do not allow this.

</P>
<P>
The criteria of freedom for a free manual are roughly the same as for
free software.  Redistribution (including the normal kinds of
commercial redistribution) must be permitted, so that the manual can
accompany every copy of the program, both on-line and on paper.

</P>
<P>
Permission for modification of the technical content is crucial too.
When people modify the software, adding or changing features, if they
are conscientious they will change the manual too--so they can
provide accurate and clear documentation for the modified program.  A
manual that leaves you no choice but to write a new manual to document
a changed version of the program is not really available to our
community.

</P>
<P>
Some kinds of limits on the way modification is handled are
acceptable.  For example, requirements to preserve the original
author's copyright notice, the distribution terms, or the list of
authors, are ok.  It is also no problem to require modified versions
to include notice that they were modified.  Even entire sections that
may not be deleted or changed are acceptable, as long as they deal
with nontechnical topics (like this one).  These kinds of restrictions
are acceptable because they don't obstruct the community's normal use
of the manual.

</P>
<P>
However, it must be possible to modify all the <EM>technical</EM>
content of the manual, and then distribute the result in all the usual
media, through all the usual channels.  Otherwise, the restrictions
obstruct the use of the manual, it is not free, and we need another
manual to replace it.

</P>
<P>
Please spread the word about this issue.  Our community continues to
lose manuals to proprietary publishing.  If we spread the word that
free software needs free reference manuals and free tutorials, perhaps
the next person who wants to contribute by writing documentation will
realize, before it is too late, that only free manuals contribute to
the free software community.

</P>
<P>
If you are writing documentation, please insist on publishing it under
the GNU Free Documentation License or another free documentation
license.  Remember that this decision requires your approval--you
don't have to let the publisher decide.  Some commercial publishers
will use a free license if you insist, but they will not propose the
option; it is up to you to raise the issue and say firmly that this is
what you want.  If the publisher you are dealing with refuses, please
try other publishers.  If you're not sure whether a proposed license
is free, write to <TT>licensing at gnu.org</TT>.

</P>
<P>
You can encourage commercial publishers to sell more free, copylefted
manuals and tutorials by buying them, and particularly by buying
copies from the publishers that paid for their writing or for major
improvements.  Meanwhile, try to avoid buying non-free documentation
at all.  Check the distribution terms of a manual before you buy it,
and insist that whoever seeks your business must respect your freedom.
Check the history of the book, and try reward the publishers that have
paid or pay the authors to work on it.

</P>
<P>
The Free Software Foundation maintains a list of free documentation
published by other publishers:

</P>

<UL class="itemize">
<LI>

<A HREF="http://www.fsf.org/doc/other-free-books.html">http://www.fsf.org/doc/other-free-books.html</A>
</UL>



<H1><A NAME="SEC531" HREF="gsl_manual.html#TOC531">GNU General Public License</A></H1>
<P>
Version 2, June 1991

</P>


<PRE class="display">
Copyright &#169; 1989, 1991 Free Software Foundation, Inc.
59 Temple Place - Suite 330, Boston, MA  02111-1307, USA

Everyone is permitted to copy and distribute verbatim copies of this
license document, but changing it is not allowed.
</PRE>


<H2>Preamble</H2>

<P>
  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

</P>
<P>
  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

</P>
<P>
  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

</P>
<P>
  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

</P>
<P>
  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

</P>
<P>
  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

</P>
<P>
  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

</P>
<P>
  The precise terms and conditions for copying, distribution and
modification follow.

</P>

<H2>TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION</H2>

<SPAN class="ifinfo">
TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
</SPAN>


<OL class="enumerate">
<LI>

This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

<LI>

You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

<LI>

You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:


<OL class="enumerate">
<LI>

You must cause the modified files to carry prominent notices
stating that you changed the files and the date of any change.

<LI>

You must cause any work that you distribute or publish, that in
whole or in part contains or is derived from the Program or any
part thereof, to be licensed as a whole at no charge to all third
parties under the terms of this License.

<LI>

If the modified program normally reads commands interactively
when run, you must cause it, when started running for such
interactive use in the most ordinary way, to print or display an
announcement including an appropriate copyright notice and a
notice that there is no warranty (or else, saying that you provide
a warranty) and that users may redistribute the program under
these conditions, and telling the user how to view a copy of this
License.  (Exception: if the Program itself is interactive but
does not normally print such an announcement, your work based on
the Program is not required to print an announcement.)
</OL>

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

<LI>

You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:


<OL class="enumerate">
<LI>

Accompany it with the complete corresponding machine-readable
source code, which must be distributed under the terms of Sections
1 and 2 above on a medium customarily used for software interchange; or,

<LI>

Accompany it with a written offer, valid for at least three
years, to give any third party, for a charge no more than your
cost of physically performing source distribution, a complete
machine-readable copy of the corresponding source code, to be
distributed under the terms of Sections 1 and 2 above on a medium
customarily used for software interchange; or,

<LI>

Accompany it with the information you received as to the offer
to distribute corresponding source code.  (This alternative is
allowed only for noncommercial distribution and only if you
received the program in object code or executable form with such
an offer, in accord with Subsection b above.)
</OL>

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

<LI>

You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

<LI>

You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

<LI>

Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

<LI>

If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

<LI>

If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

<LI>

The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

<LI>

If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.



<P><STRONG>NO WARRANTY</STRONG></P>

<SPAN class="ifinfo">
NO WARRANTY
</SPAN>

<LI>

BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

<LI>

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.
</OL>


<H2>END OF TERMS AND CONDITIONS</H2>

<SPAN class="ifinfo">
END OF TERMS AND CONDITIONS
</SPAN>


<H2>Appendix: How to Apply These Terms to Your New Programs</H2>

<P>
  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

</P>
<P>
  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

</P>

<PRE class="smallexample">
<VAR>one line to give the program's name and a brief idea <BR>of what it does.</VAR>
Copyright (C) <VAR>yyyy</VAR>  <VAR>name of author</VAR>

This program is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.  See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.
</PRE>

<P>
Also add information on how to contact you by electronic and paper mail.

</P>
<P>
If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

</P>

<PRE class="smallexample">
Gnomovision version 69, Copyright (C) 19<VAR>yy</VAR> <VAR>name of author</VAR>
Gnomovision comes with ABSOLUTELY NO WARRANTY; for details
type `show w'.  This is free software, and you are welcome
to redistribute it under certain conditions; type `show c'
for details.
</PRE>

<P>
The hypothetical commands <SAMP>'show w'</SAMP> and <SAMP>'show c'</SAMP> should show
the appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than <SAMP>'show w'</SAMP> and
<SAMP>'show c'</SAMP>; they could even be mouse-clicks or menu items--whatever
suits your program.

</P>
<P>
You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

</P>

<PRE class="smallexample">
Yoyodyne, Inc., hereby disclaims all copyright interest in
the program `Gnomovision' (which makes passes at compilers)
written by James Hacker.

<VAR>signature of Ty Coon</VAR>, 1 April 1989
Ty Coon, President of Vice
</PRE>

<P>
This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.

</P>
<P>
<BR>
@textfonts @rm

</P>


<H1><A NAME="SEC532" HREF="gsl_manual.html#TOC532">GNU Free Documentation License</A></H1>
<P>
<A NAME="IDX2491"></A>
Version 1.2, November 2002

</P>

<PRE class="display">
Copyright &#169; 2000,2001,2002 Free Software Foundation, Inc.
51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA

Everyone is permitted to copy and distribute verbatim copies of this license 
document, but changing it is not allowed.
</PRE>


<OL class="enumerate">
<LI>

PREAMBLE

The purpose of this License is to make a manual, textbook, or other
functional and useful document <I>free</I> in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.

This License is a kind of "copyleft", which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.

We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.

<LI>

APPLICABILITY AND DEFINITIONS

This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The "Document", below,
refers to any such manual or work.  Any member of the public is a
licensee, and is addressed as "you".  You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.

A "Modified Version" of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.

A "Secondary Section" is a named appendix or a front-matter section
of the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall
subject (or to related matters) and contains nothing that could fall
directly within that overall subject.  (Thus, if the Document is in
part a textbook of mathematics, a Secondary Section may not explain
any mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.

The "Invariant Sections" are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.  If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant.  The Document may contain zero
Invariant Sections.  If the Document does not identify any Invariant
Sections then there are none.

The "Cover Texts" are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.

A "Transparent" copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount
of text.  A copy that is not "Transparent" is called "Opaque".

Examples of suitable formats for Transparent copies include plain
ASCII without markup, Texinfo input format, LaTeX input
format, SGML or XML using a publicly available
DTD, and standard-conforming simple HTML,
PostScript or PDF designed for human modification.  Examples
of transparent image formats include PNG, XCF and
JPG.  Opaque formats include proprietary formats that can be
read and edited only by proprietary word processors, SGML or
XML for which the DTD and/or processing tools are
not generally available, and the machine-generated HTML,
PostScript or PDF produced by some word processors for
output purposes only.

The "Title Page" means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, "Title Page" means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.

A section "Entitled XYZ" means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as "Acknowledgements",
"Dedications", "Endorsements", or "History".)  To "Preserve the Title"
of such a section when you modify the Document means that it remains a
section "Entitled XYZ" according to this definition.

The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.

<LI>

VERBATIM COPYING

You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.

You may also lend copies, under the same conditions stated above, and
you may publicly display copies.

<LI>

COPYING IN QUANTITY

If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document's license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.

If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.

If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material.
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.

It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.

<LI>

MODIFICATIONS

You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:


<OL class="enumerate">
<LI>

Use in the Title Page (and on the covers, if any) a title distinct
from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document).  You may use the same title as a previous version
if the original publisher of that version gives permission.

<LI>

List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified
Version, together with at least five of the principal authors of the
Document (all of its principal authors, if it has fewer than five),
unless they release you from this requirement.

<LI>

State on the Title page the name of the publisher of the
Modified Version, as the publisher.

<LI>

Preserve all the copyright notices of the Document.

<LI>

Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.

<LI>

Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modified Version under the
terms of this License, in the form shown in the Addendum below.

<LI>

Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document's license notice.

<LI>

Include an unaltered copy of this License.

<LI>

Preserve the section Entitled "History", Preserve its Title, and add
to it an item stating at least the title, year, new authors, and
publisher of the Modified Version as given on the Title Page.  If
there is no section Entitled "History" in the Document, create one
stating the title, year, authors, and publisher of the Document as
given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.

<LI>

Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on.  These may be placed in the "History" section.
You may omit a network location for a work that was published at
least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.

<LI>

For any section Entitled "Acknowledgements" or "Dedications", Preserve
the Title of the section, and preserve in the section all the
substance and tone of each of the contributor acknowledgements and/or
dedications given therein.

<LI>

Preserve all the Invariant Sections of the Document,
unaltered in their text and in their titles.  Section numbers
or the equivalent are not considered part of the section titles.

<LI>

Delete any section Entitled "Endorsements".  Such a section
may not be included in the Modified Version.

<LI>

Do not retitle any existing section to be Entitled "Endorsements" or
to conflict in title with any Invariant Section.

<LI>

Preserve any Warranty Disclaimers.
</OL>

If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice.
These titles must be distinct from any other section titles.

You may add a section Entitled "Endorsements", provided it contains
nothing but endorsements of your Modified Version by various
parties--for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.

You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.

The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.

<LI>

COMBINING DOCUMENTS

You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.

The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.

In the combination, you must combine any sections Entitled "History"
in the various original documents, forming one section Entitled
"History"; likewise combine any sections Entitled "Acknowledgements",
and any sections Entitled "Dedications".  You must delete all
sections Entitled "Endorsements."

<LI>

COLLECTIONS OF DOCUMENTS

You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.

You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.

<LI>

AGGREGATION WITH INDEPENDENT WORKS

A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an "aggregate" if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation's users beyond what the individual works permit.
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.

If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document's Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.

<LI>

TRANSLATION

Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.

If a section in the Document is Entitled "Acknowledgements",
"Dedications", or "History", the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.

<LI>

TERMINATION

You may not copy, modify, sublicense, or distribute the Document except
as expressly provided for under this License.  Any other attempt to
copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License.  However,
parties who have received copies, or rights, from you under this
License will not have their licenses terminated so long as such
parties remain in full compliance.

<LI>

FUTURE REVISIONS OF THIS LICENSE

The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
<A HREF="http://www.gnu.org/copyleft/">http://www.gnu.org/copyleft/</A>.

Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License "or any later version" applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.
</OL>


<H2>ADDENDUM: How to use this License for your documents</H2>

<P>
To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:

</P>

<PRE class="smallexample">
  Copyright (C) <VAR>year</VAR> <VAR>your name</VAR>.  
  Permission is granted to copy, distribute and/or modify
  this document under the terms of the GNU Free
  Documentation License, Version 1.2 or any later version
  published by the Free Software Foundation; with no
  Invariant Sections, no Front-Cover Texts, and no
  Back-Cover Texts.  A copy of the license is included in
  the section entitled "GNU Free Documentation License".
</PRE>

<P>
If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the "with...Texts." line with this:

</P>

<PRE class="smallexample">
  with the Invariant Sections being <VAR>list their
  titles</VAR>, with the Front-Cover Texts being <VAR>list</VAR>, and
  with the Back-Cover Texts being <VAR>list</VAR>.
</PRE>

<P>
If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

</P>
<P>
If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.

</P>
<P>
@textfonts @rm

</P>

<P>
@normalbottom

</P>


<H1><A NAME="SEC533" HREF="gsl_manual.html#TOC533">Function Index</A></H1>

<P>
<H2>c</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX2375">cblas_caxpy</A>
<LI><A HREF="gsl_manual.html#IDX2374">cblas_ccopy</A>
<LI><A HREF="gsl_manual.html#IDX2352">cblas_cdotc_sub</A>
<LI><A HREF="gsl_manual.html#IDX2351">cblas_cdotu_sub</A>
<LI><A HREF="gsl_manual.html#IDX2410">cblas_cgbmv</A>
<LI><A HREF="gsl_manual.html#IDX2471">cblas_cgemm</A>
<LI><A HREF="gsl_manual.html#IDX2409">cblas_cgemv</A>
<LI><A HREF="gsl_manual.html#IDX2445">cblas_cgerc</A>
<LI><A HREF="gsl_manual.html#IDX2444">cblas_cgeru</A>
<LI><A HREF="gsl_manual.html#IDX2442">cblas_chbmv</A>
<LI><A HREF="gsl_manual.html#IDX2483">cblas_chemm</A>
<LI><A HREF="gsl_manual.html#IDX2441">cblas_chemv</A>
<LI><A HREF="gsl_manual.html#IDX2446">cblas_cher</A>
<LI><A HREF="gsl_manual.html#IDX2448">cblas_cher2</A>
<LI><A HREF="gsl_manual.html#IDX2485">cblas_cher2k</A>
<LI><A HREF="gsl_manual.html#IDX2484">cblas_cherk</A>
<LI><A HREF="gsl_manual.html#IDX2443">cblas_chpmv</A>
<LI><A HREF="gsl_manual.html#IDX2447">cblas_chpr</A>
<LI><A HREF="gsl_manual.html#IDX2449">cblas_chpr2</A>
<LI><A HREF="gsl_manual.html#IDX2389">cblas_cscal</A>
<LI><A HREF="gsl_manual.html#IDX2391">cblas_csscal</A>
<LI><A HREF="gsl_manual.html#IDX2373">cblas_cswap</A>
<LI><A HREF="gsl_manual.html#IDX2472">cblas_csymm</A>
<LI><A HREF="gsl_manual.html#IDX2474">cblas_csyr2k</A>
<LI><A HREF="gsl_manual.html#IDX2473">cblas_csyrk</A>
<LI><A HREF="gsl_manual.html#IDX2412">cblas_ctbmv</A>
<LI><A HREF="gsl_manual.html#IDX2415">cblas_ctbsv</A>
<LI><A HREF="gsl_manual.html#IDX2413">cblas_ctpmv</A>
<LI><A HREF="gsl_manual.html#IDX2416">cblas_ctpsv</A>
<LI><A HREF="gsl_manual.html#IDX2475">cblas_ctrmm</A>
<LI><A HREF="gsl_manual.html#IDX2411">cblas_ctrmv</A>
<LI><A HREF="gsl_manual.html#IDX2476">cblas_ctrsm</A>
<LI><A HREF="gsl_manual.html#IDX2414">cblas_ctrsv</A>
<LI><A HREF="gsl_manual.html#IDX2358">cblas_dasum</A>
<LI><A HREF="gsl_manual.html#IDX2372">cblas_daxpy</A>
<LI><A HREF="gsl_manual.html#IDX2371">cblas_dcopy</A>
<LI><A HREF="gsl_manual.html#IDX2350">cblas_ddot</A>
<LI><A HREF="gsl_manual.html#IDX2402">cblas_dgbmv</A>
<LI><A HREF="gsl_manual.html#IDX2465">cblas_dgemm</A>
<LI><A HREF="gsl_manual.html#IDX2401">cblas_dgemv</A>
<LI><A HREF="gsl_manual.html#IDX2436">cblas_dger</A>
<LI><A HREF="gsl_manual.html#IDX2357">cblas_dnrm2</A>
<LI><A HREF="gsl_manual.html#IDX2385">cblas_drot</A>
<LI><A HREF="gsl_manual.html#IDX2383">cblas_drotg</A>
<LI><A HREF="gsl_manual.html#IDX2386">cblas_drotm</A>
<LI><A HREF="gsl_manual.html#IDX2384">cblas_drotmg</A>
<LI><A HREF="gsl_manual.html#IDX2434">cblas_dsbmv</A>
<LI><A HREF="gsl_manual.html#IDX2388">cblas_dscal</A>
<LI><A HREF="gsl_manual.html#IDX2348">cblas_dsdot</A>
<LI><A HREF="gsl_manual.html#IDX2435">cblas_dspmv</A>
<LI><A HREF="gsl_manual.html#IDX2438">cblas_dspr</A>
<LI><A HREF="gsl_manual.html#IDX2440">cblas_dspr2</A>
<LI><A HREF="gsl_manual.html#IDX2370">cblas_dswap</A>
<LI><A HREF="gsl_manual.html#IDX2466">cblas_dsymm</A>
<LI><A HREF="gsl_manual.html#IDX2433">cblas_dsymv</A>
<LI><A HREF="gsl_manual.html#IDX2437">cblas_dsyr</A>
<LI><A HREF="gsl_manual.html#IDX2439">cblas_dsyr2</A>
<LI><A HREF="gsl_manual.html#IDX2468">cblas_dsyr2k</A>
<LI><A HREF="gsl_manual.html#IDX2467">cblas_dsyrk</A>
<LI><A HREF="gsl_manual.html#IDX2404">cblas_dtbmv</A>
<LI><A HREF="gsl_manual.html#IDX2407">cblas_dtbsv</A>
<LI><A HREF="gsl_manual.html#IDX2405">cblas_dtpmv</A>
<LI><A HREF="gsl_manual.html#IDX2408">cblas_dtpsv</A>
<LI><A HREF="gsl_manual.html#IDX2469">cblas_dtrmm</A>
<LI><A HREF="gsl_manual.html#IDX2403">cblas_dtrmv</A>
<LI><A HREF="gsl_manual.html#IDX2470">cblas_dtrsm</A>
<LI><A HREF="gsl_manual.html#IDX2406">cblas_dtrsv</A>
<LI><A HREF="gsl_manual.html#IDX2362">cblas_dzasum</A>
<LI><A HREF="gsl_manual.html#IDX2361">cblas_dznrm2</A>
<LI><A HREF="gsl_manual.html#IDX2365">cblas_icamax</A>
<LI><A HREF="gsl_manual.html#IDX2364">cblas_idamax</A>
<LI><A HREF="gsl_manual.html#IDX2363">cblas_isamax</A>
<LI><A HREF="gsl_manual.html#IDX2366">cblas_izamax</A>
<LI><A HREF="gsl_manual.html#IDX2356">cblas_sasum</A>
<LI><A HREF="gsl_manual.html#IDX2369">cblas_saxpy</A>
<LI><A HREF="gsl_manual.html#IDX2360">cblas_scasum</A>
<LI><A HREF="gsl_manual.html#IDX2359">cblas_scnrm2</A>
<LI><A HREF="gsl_manual.html#IDX2368">cblas_scopy</A>
<LI><A HREF="gsl_manual.html#IDX2349">cblas_sdot</A>
<LI><A HREF="gsl_manual.html#IDX2347">cblas_sdsdot</A>
<LI><A HREF="gsl_manual.html#IDX2394">cblas_sgbmv</A>
<LI><A HREF="gsl_manual.html#IDX2459">cblas_sgemm</A>
<LI><A HREF="gsl_manual.html#IDX2393">cblas_sgemv</A>
<LI><A HREF="gsl_manual.html#IDX2428">cblas_sger</A>
<LI><A HREF="gsl_manual.html#IDX2355">cblas_snrm2</A>
<LI><A HREF="gsl_manual.html#IDX2381">cblas_srot</A>
<LI><A HREF="gsl_manual.html#IDX2379">cblas_srotg</A>
<LI><A HREF="gsl_manual.html#IDX2382">cblas_srotm</A>
<LI><A HREF="gsl_manual.html#IDX2380">cblas_srotmg</A>
<LI><A HREF="gsl_manual.html#IDX2426">cblas_ssbmv</A>
<LI><A HREF="gsl_manual.html#IDX2387">cblas_sscal</A>
<LI><A HREF="gsl_manual.html#IDX2427">cblas_sspmv</A>
<LI><A HREF="gsl_manual.html#IDX2430">cblas_sspr</A>
<LI><A HREF="gsl_manual.html#IDX2432">cblas_sspr2</A>
<LI><A HREF="gsl_manual.html#IDX2367">cblas_sswap</A>
<LI><A HREF="gsl_manual.html#IDX2460">cblas_ssymm</A>
<LI><A HREF="gsl_manual.html#IDX2425">cblas_ssymv</A>
<LI><A HREF="gsl_manual.html#IDX2429">cblas_ssyr</A>
<LI><A HREF="gsl_manual.html#IDX2431">cblas_ssyr2</A>
<LI><A HREF="gsl_manual.html#IDX2462">cblas_ssyr2k</A>
<LI><A HREF="gsl_manual.html#IDX2461">cblas_ssyrk</A>
<LI><A HREF="gsl_manual.html#IDX2396">cblas_stbmv</A>
<LI><A HREF="gsl_manual.html#IDX2399">cblas_stbsv</A>
<LI><A HREF="gsl_manual.html#IDX2397">cblas_stpmv</A>
<LI><A HREF="gsl_manual.html#IDX2400">cblas_stpsv</A>
<LI><A HREF="gsl_manual.html#IDX2463">cblas_strmm</A>
<LI><A HREF="gsl_manual.html#IDX2395">cblas_strmv</A>
<LI><A HREF="gsl_manual.html#IDX2464">cblas_strsm</A>
<LI><A HREF="gsl_manual.html#IDX2398">cblas_strsv</A>
<LI><A HREF="gsl_manual.html#IDX2489">cblas_xerbla</A>
<LI><A HREF="gsl_manual.html#IDX2378">cblas_zaxpy</A>
<LI><A HREF="gsl_manual.html#IDX2377">cblas_zcopy</A>
<LI><A HREF="gsl_manual.html#IDX2354">cblas_zdotc_sub</A>
<LI><A HREF="gsl_manual.html#IDX2353">cblas_zdotu_sub</A>
<LI><A HREF="gsl_manual.html#IDX2392">cblas_zdscal</A>
<LI><A HREF="gsl_manual.html#IDX2418">cblas_zgbmv</A>
<LI><A HREF="gsl_manual.html#IDX2477">cblas_zgemm</A>
<LI><A HREF="gsl_manual.html#IDX2417">cblas_zgemv</A>
<LI><A HREF="gsl_manual.html#IDX2454">cblas_zgerc</A>
<LI><A HREF="gsl_manual.html#IDX2453">cblas_zgeru</A>
<LI><A HREF="gsl_manual.html#IDX2451">cblas_zhbmv</A>
<LI><A HREF="gsl_manual.html#IDX2486">cblas_zhemm</A>
<LI><A HREF="gsl_manual.html#IDX2450">cblas_zhemv</A>
<LI><A HREF="gsl_manual.html#IDX2455">cblas_zher</A>
<LI><A HREF="gsl_manual.html#IDX2457">cblas_zher2</A>
<LI><A HREF="gsl_manual.html#IDX2488">cblas_zher2k</A>
<LI><A HREF="gsl_manual.html#IDX2487">cblas_zherk</A>
<LI><A HREF="gsl_manual.html#IDX2452">cblas_zhpmv</A>
<LI><A HREF="gsl_manual.html#IDX2456">cblas_zhpr</A>
<LI><A HREF="gsl_manual.html#IDX2458">cblas_zhpr2</A>
<LI><A HREF="gsl_manual.html#IDX2390">cblas_zscal</A>
<LI><A HREF="gsl_manual.html#IDX2376">cblas_zswap</A>
<LI><A HREF="gsl_manual.html#IDX2478">cblas_zsymm</A>
<LI><A HREF="gsl_manual.html#IDX2480">cblas_zsyr2k</A>
<LI><A HREF="gsl_manual.html#IDX2479">cblas_zsyrk</A>
<LI><A HREF="gsl_manual.html#IDX2420">cblas_ztbmv</A>
<LI><A HREF="gsl_manual.html#IDX2423">cblas_ztbsv</A>
<LI><A HREF="gsl_manual.html#IDX2421">cblas_ztpmv</A>
<LI><A HREF="gsl_manual.html#IDX2424">cblas_ztpsv</A>
<LI><A HREF="gsl_manual.html#IDX2481">cblas_ztrmm</A>
<LI><A HREF="gsl_manual.html#IDX2419">cblas_ztrmv</A>
<LI><A HREF="gsl_manual.html#IDX2482">cblas_ztrsm</A>
<LI><A HREF="gsl_manual.html#IDX2422">cblas_ztrsv</A>
</DIR>
<H2>g</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX90">gsl_acosh</A>
<LI><A HREF="gsl_manual.html#IDX94">gsl_asinh</A>
<LI><A HREF="gsl_manual.html#IDX98">gsl_atanh</A>
<LI><A HREF="gsl_manual.html#IDX1070">gsl_blas_caxpy</A>
<LI><A HREF="gsl_manual.html#IDX1065">gsl_blas_ccopy</A>
<LI><A HREF="gsl_manual.html#IDX1041">gsl_blas_cdotc</A>
<LI><A HREF="gsl_manual.html#IDX1039">gsl_blas_cdotu</A>
<LI><A HREF="gsl_manual.html#IDX1136">gsl_blas_cgemm</A>
<LI><A HREF="gsl_manual.html#IDX1094">gsl_blas_cgemv</A>
<LI><A HREF="gsl_manual.html#IDX1119">gsl_blas_cgerc</A>
<LI><A HREF="gsl_manual.html#IDX1115">gsl_blas_cgeru</A>
<LI><A HREF="gsl_manual.html#IDX1144">gsl_blas_chemm</A>
<LI><A HREF="gsl_manual.html#IDX1110">gsl_blas_chemv</A>
<LI><A HREF="gsl_manual.html#IDX1125">gsl_blas_cher</A>
<LI><A HREF="gsl_manual.html#IDX1131">gsl_blas_cher2</A>
<LI><A HREF="gsl_manual.html#IDX1170">gsl_blas_cher2k</A>
<LI><A HREF="gsl_manual.html#IDX1162">gsl_blas_cherk</A>
<LI><A HREF="gsl_manual.html#IDX1075">gsl_blas_cscal</A>
<LI><A HREF="gsl_manual.html#IDX1077">gsl_blas_csscal</A>
<LI><A HREF="gsl_manual.html#IDX1060">gsl_blas_cswap</A>
<LI><A HREF="gsl_manual.html#IDX1141">gsl_blas_csymm</A>
<LI><A HREF="gsl_manual.html#IDX1167">gsl_blas_csyr2k</A>
<LI><A HREF="gsl_manual.html#IDX1159">gsl_blas_csyrk</A>
<LI><A HREF="gsl_manual.html#IDX1149">gsl_blas_ctrmm</A>
<LI><A HREF="gsl_manual.html#IDX1099">gsl_blas_ctrmv</A>
<LI><A HREF="gsl_manual.html#IDX1154">gsl_blas_ctrsm</A>
<LI><A HREF="gsl_manual.html#IDX1104">gsl_blas_ctrsv</A>
<LI><A HREF="gsl_manual.html#IDX1049">gsl_blas_dasum</A>
<LI><A HREF="gsl_manual.html#IDX1069">gsl_blas_daxpy</A>
<LI><A HREF="gsl_manual.html#IDX1064">gsl_blas_dcopy</A>
<LI><A HREF="gsl_manual.html#IDX1038">gsl_blas_ddot</A>
<LI><A HREF="gsl_manual.html#IDX1135">gsl_blas_dgemm</A>
<LI><A HREF="gsl_manual.html#IDX1093">gsl_blas_dgemv</A>
<LI><A HREF="gsl_manual.html#IDX1114">gsl_blas_dger</A>
<LI><A HREF="gsl_manual.html#IDX1044">gsl_blas_dnrm2</A>
<LI><A HREF="gsl_manual.html#IDX1085">gsl_blas_drot</A>
<LI><A HREF="gsl_manual.html#IDX1081">gsl_blas_drotg</A>
<LI><A HREF="gsl_manual.html#IDX1091">gsl_blas_drotm</A>
<LI><A HREF="gsl_manual.html#IDX1087">gsl_blas_drotmg</A>
<LI><A HREF="gsl_manual.html#IDX1074">gsl_blas_dscal</A>
<LI><A HREF="gsl_manual.html#IDX1037">gsl_blas_dsdot</A>
<LI><A HREF="gsl_manual.html#IDX1059">gsl_blas_dswap</A>
<LI><A HREF="gsl_manual.html#IDX1140">gsl_blas_dsymm</A>
<LI><A HREF="gsl_manual.html#IDX1108">gsl_blas_dsymv</A>
<LI><A HREF="gsl_manual.html#IDX1123">gsl_blas_dsyr</A>
<LI><A HREF="gsl_manual.html#IDX1129">gsl_blas_dsyr2</A>
<LI><A HREF="gsl_manual.html#IDX1166">gsl_blas_dsyr2k</A>
<LI><A HREF="gsl_manual.html#IDX1158">gsl_blas_dsyrk</A>
<LI><A HREF="gsl_manual.html#IDX1148">gsl_blas_dtrmm</A>
<LI><A HREF="gsl_manual.html#IDX1098">gsl_blas_dtrmv</A>
<LI><A HREF="gsl_manual.html#IDX1153">gsl_blas_dtrsm</A>
<LI><A HREF="gsl_manual.html#IDX1103">gsl_blas_dtrsv</A>
<LI><A HREF="gsl_manual.html#IDX1052">gsl_blas_dzasum</A>
<LI><A HREF="gsl_manual.html#IDX1047">gsl_blas_dznrm2</A>
<LI><A HREF="gsl_manual.html#IDX1055">gsl_blas_icamax</A>
<LI><A HREF="gsl_manual.html#IDX1054">gsl_blas_idamax</A>
<LI><A HREF="gsl_manual.html#IDX1053">gsl_blas_isamax</A>
<LI><A HREF="gsl_manual.html#IDX1056">gsl_blas_izamax</A>
<LI><A HREF="gsl_manual.html#IDX1048">gsl_blas_sasum</A>
<LI><A HREF="gsl_manual.html#IDX1068">gsl_blas_saxpy</A>
<LI><A HREF="gsl_manual.html#IDX1051">gsl_blas_scasum</A>
<LI><A HREF="gsl_manual.html#IDX1046">gsl_blas_scnrm2</A>
<LI><A HREF="gsl_manual.html#IDX1063">gsl_blas_scopy</A>
<LI><A HREF="gsl_manual.html#IDX1036">gsl_blas_sdot</A>
<LI><A HREF="gsl_manual.html#IDX1034">gsl_blas_sdsdot</A>
<LI><A HREF="gsl_manual.html#IDX1134">gsl_blas_sgemm</A>
<LI><A HREF="gsl_manual.html#IDX1092">gsl_blas_sgemv</A>
<LI><A HREF="gsl_manual.html#IDX1113">gsl_blas_sger</A>
<LI><A HREF="gsl_manual.html#IDX1043">gsl_blas_snrm2</A>
<LI><A HREF="gsl_manual.html#IDX1084">gsl_blas_srot</A>
<LI><A HREF="gsl_manual.html#IDX1080">gsl_blas_srotg</A>
<LI><A HREF="gsl_manual.html#IDX1090">gsl_blas_srotm</A>
<LI><A HREF="gsl_manual.html#IDX1086">gsl_blas_srotmg</A>
<LI><A HREF="gsl_manual.html#IDX1073">gsl_blas_sscal</A>
<LI><A HREF="gsl_manual.html#IDX1058">gsl_blas_sswap</A>
<LI><A HREF="gsl_manual.html#IDX1139">gsl_blas_ssymm</A>
<LI><A HREF="gsl_manual.html#IDX1107">gsl_blas_ssymv</A>
<LI><A HREF="gsl_manual.html#IDX1122">gsl_blas_ssyr</A>
<LI><A HREF="gsl_manual.html#IDX1128">gsl_blas_ssyr2</A>
<LI><A HREF="gsl_manual.html#IDX1165">gsl_blas_ssyr2k</A>
<LI><A HREF="gsl_manual.html#IDX1157">gsl_blas_ssyrk</A>
<LI><A HREF="gsl_manual.html#IDX1147">gsl_blas_strmm</A>
<LI><A HREF="gsl_manual.html#IDX1097">gsl_blas_strmv</A>
<LI><A HREF="gsl_manual.html#IDX1152">gsl_blas_strsm</A>
<LI><A HREF="gsl_manual.html#IDX1102">gsl_blas_strsv</A>
<LI><A HREF="gsl_manual.html#IDX1071">gsl_blas_zaxpy</A>
<LI><A HREF="gsl_manual.html#IDX1066">gsl_blas_zcopy</A>
<LI><A HREF="gsl_manual.html#IDX1042">gsl_blas_zdotc</A>
<LI><A HREF="gsl_manual.html#IDX1040">gsl_blas_zdotu</A>
<LI><A HREF="gsl_manual.html#IDX1078">gsl_blas_zdscal</A>
<LI><A HREF="gsl_manual.html#IDX1137">gsl_blas_zgemm</A>
<LI><A HREF="gsl_manual.html#IDX1095">gsl_blas_zgemv</A>
<LI><A HREF="gsl_manual.html#IDX1120">gsl_blas_zgerc</A>
<LI><A HREF="gsl_manual.html#IDX1116">gsl_blas_zgeru</A>
<LI><A HREF="gsl_manual.html#IDX1145">gsl_blas_zhemm</A>
<LI><A HREF="gsl_manual.html#IDX1111">gsl_blas_zhemv</A>
<LI><A HREF="gsl_manual.html#IDX1126">gsl_blas_zher</A>
<LI><A HREF="gsl_manual.html#IDX1132">gsl_blas_zher2</A>
<LI><A HREF="gsl_manual.html#IDX1171">gsl_blas_zher2k</A>
<LI><A HREF="gsl_manual.html#IDX1163">gsl_blas_zherk</A>
<LI><A HREF="gsl_manual.html#IDX1076">gsl_blas_zscal</A>
<LI><A HREF="gsl_manual.html#IDX1061">gsl_blas_zswap</A>
<LI><A HREF="gsl_manual.html#IDX1142">gsl_blas_zsymm</A>
<LI><A HREF="gsl_manual.html#IDX1168">gsl_blas_zsyr2k</A>
<LI><A HREF="gsl_manual.html#IDX1160">gsl_blas_zsyrk</A>
<LI><A HREF="gsl_manual.html#IDX1150">gsl_blas_ztrmm</A>
<LI><A HREF="gsl_manual.html#IDX1100">gsl_blas_ztrmv</A>
<LI><A HREF="gsl_manual.html#IDX1155">gsl_blas_ztrsm</A>
<LI><A HREF="gsl_manual.html#IDX1105">gsl_blas_ztrsv</A>
<LI><A HREF="gsl_manual.html#IDX812">gsl_block_alloc</A>
<LI><A HREF="gsl_manual.html#IDX813">gsl_block_calloc</A>
<LI><A HREF="gsl_manual.html#IDX817">gsl_block_fprintf</A>
<LI><A HREF="gsl_manual.html#IDX816">gsl_block_fread</A>
<LI><A HREF="gsl_manual.html#IDX814">gsl_block_free</A>
<LI><A HREF="gsl_manual.html#IDX818">gsl_block_fscanf</A>
<LI><A HREF="gsl_manual.html#IDX815">gsl_block_fwrite</A>
<LI><A HREF="gsl_manual.html#IDX1582">gsl_cdf_beta_P</A>
<LI><A HREF="gsl_manual.html#IDX1583">gsl_cdf_beta_Q</A>
<LI><A HREF="gsl_manual.html#IDX1514">gsl_cdf_cauchy_P</A>
<LI><A HREF="gsl_manual.html#IDX1516">gsl_cdf_cauchy_Pinv</A>
<LI><A HREF="gsl_manual.html#IDX1515">gsl_cdf_cauchy_Q</A>
<LI><A HREF="gsl_manual.html#IDX1517">gsl_cdf_cauchy_Qinv</A>
<LI><A HREF="gsl_manual.html#IDX1562">gsl_cdf_chisq_P</A>
<LI><A HREF="gsl_manual.html#IDX1564">gsl_cdf_chisq_Pinv</A>
<LI><A HREF="gsl_manual.html#IDX1563">gsl_cdf_chisq_Q</A>
<LI><A HREF="gsl_manual.html#IDX1565">gsl_cdf_chisq_Qinv</A>
<LI><A HREF="gsl_manual.html#IDX1496">gsl_cdf_exponential_P</A>
<LI><A HREF="gsl_manual.html#IDX1498">gsl_cdf_exponential_Pinv</A>
<LI><A HREF="gsl_manual.html#IDX1497">gsl_cdf_exponential_Q</A>
<LI><A HREF="gsl_manual.html#IDX1499">gsl_cdf_exponential_Qinv</A>
<LI><A HREF="gsl_manual.html#IDX1569">gsl_cdf_fdist_P</A>
<LI><A HREF="gsl_manual.html#IDX1570">gsl_cdf_fdist_Q</A>
<LI><A HREF="gsl_manual.html#IDX1548">gsl_cdf_flat_P</A>
<LI><A HREF="gsl_manual.html#IDX1550">gsl_cdf_flat_Pinv</A>
<LI><A HREF="gsl_manual.html#IDX1549">gsl_cdf_flat_Q</A>
<LI><A HREF="gsl_manual.html#IDX1551">gsl_cdf_flat_Qinv</A>
<LI><A HREF="gsl_manual.html#IDX1540">gsl_cdf_gamma_P</A>
<LI><A HREF="gsl_manual.html#IDX1542">gsl_cdf_gamma_Pinv</A>
<LI><A HREF="gsl_manual.html#IDX1541">gsl_cdf_gamma_Q</A>
<LI><A HREF="gsl_manual.html#IDX1543">gsl_cdf_gamma_Qinv</A>
<LI><A HREF="gsl_manual.html#IDX1475">gsl_cdf_gaussian_P</A>
<LI><A HREF="gsl_manual.html#IDX1477">gsl_cdf_gaussian_Pinv</A>
<LI><A HREF="gsl_manual.html#IDX1476">gsl_cdf_gaussian_Q</A>
<LI><A HREF="gsl_manual.html#IDX1478">gsl_cdf_gaussian_Qinv</A>
<LI><A HREF="gsl_manual.html#IDX1622">gsl_cdf_gumbel1_P</A>
<LI><A HREF="gsl_manual.html#IDX1624">gsl_cdf_gumbel1_Pinv</A>
<LI><A HREF="gsl_manual.html#IDX1623">gsl_cdf_gumbel1_Q</A>
<LI><A HREF="gsl_manual.html#IDX1625">gsl_cdf_gumbel1_Qinv</A>
<LI><A HREF="gsl_manual.html#IDX1630">gsl_cdf_gumbel2_P</A>
<LI><A HREF="gsl_manual.html#IDX1632">gsl_cdf_gumbel2_Pinv</A>
<LI><A HREF="gsl_manual.html#IDX1631">gsl_cdf_gumbel2_Q</A>
<LI><A HREF="gsl_manual.html#IDX1633">gsl_cdf_gumbel2_Qinv</A>
<LI><A HREF="gsl_manual.html#IDX1504">gsl_cdf_laplace_P</A>
<LI><A HREF="gsl_manual.html#IDX1506">gsl_cdf_laplace_Pinv</A>
<LI><A HREF="gsl_manual.html#IDX1505">gsl_cdf_laplace_Q</A>
<LI><A HREF="gsl_manual.html#IDX1507">gsl_cdf_laplace_Qinv</A>
<LI><A HREF="gsl_manual.html#IDX1587">gsl_cdf_logistic_P</A>
<LI><A HREF="gsl_manual.html#IDX1589">gsl_cdf_logistic_Pinv</A>
<LI><A HREF="gsl_manual.html#IDX1588">gsl_cdf_logistic_Q</A>
<LI><A HREF="gsl_manual.html#IDX1590">gsl_cdf_logistic_Qinv</A>
<LI><A HREF="gsl_manual.html#IDX1555">gsl_cdf_lognormal_P</A>
<LI><A HREF="gsl_manual.html#IDX1557">gsl_cdf_lognormal_Pinv</A>
<LI><A HREF="gsl_manual.html#IDX1556">gsl_cdf_lognormal_Q</A>
<LI><A HREF="gsl_manual.html#IDX1558">gsl_cdf_lognormal_Qinv</A>
<LI><A HREF="gsl_manual.html#IDX1594">gsl_cdf_pareto_P</A>
<LI><A HREF="gsl_manual.html#IDX1596">gsl_cdf_pareto_Pinv</A>
<LI><A HREF="gsl_manual.html#IDX1595">gsl_cdf_pareto_Q</A>
<LI><A HREF="gsl_manual.html#IDX1597">gsl_cdf_pareto_Qinv</A>
<LI><A HREF="gsl_manual.html#IDX1521">gsl_cdf_rayleigh_P</A>
<LI><A HREF="gsl_manual.html#IDX1523">gsl_cdf_rayleigh_Pinv</A>
<LI><A HREF="gsl_manual.html#IDX1522">gsl_cdf_rayleigh_Q</A>
<LI><A HREF="gsl_manual.html#IDX1524">gsl_cdf_rayleigh_Qinv</A>
<LI><A HREF="gsl_manual.html#IDX1575">gsl_cdf_tdist_P</A>
<LI><A HREF="gsl_manual.html#IDX1577">gsl_cdf_tdist_Pinv</A>
<LI><A HREF="gsl_manual.html#IDX1576">gsl_cdf_tdist_Q</A>
<LI><A HREF="gsl_manual.html#IDX1578">gsl_cdf_tdist_Qinv</A>
<LI><A HREF="gsl_manual.html#IDX1479">gsl_cdf_ugaussian_P</A>
<LI><A HREF="gsl_manual.html#IDX1481">gsl_cdf_ugaussian_Pinv</A>
<LI><A HREF="gsl_manual.html#IDX1480">gsl_cdf_ugaussian_Q</A>
<LI><A HREF="gsl_manual.html#IDX1482">gsl_cdf_ugaussian_Qinv</A>
<LI><A HREF="gsl_manual.html#IDX1614">gsl_cdf_weibull_P</A>
<LI><A HREF="gsl_manual.html#IDX1616">gsl_cdf_weibull_Pinv</A>
<LI><A HREF="gsl_manual.html#IDX1615">gsl_cdf_weibull_Q</A>
<LI><A HREF="gsl_manual.html#IDX1617">gsl_cdf_weibull_Qinv</A>
<LI><A HREF="gsl_manual.html#IDX1996">gsl_cheb_alloc</A>
<LI><A HREF="gsl_manual.html#IDX2003">gsl_cheb_calc_deriv</A>
<LI><A HREF="gsl_manual.html#IDX2004">gsl_cheb_calc_integ</A>
<LI><A HREF="gsl_manual.html#IDX1999">gsl_cheb_eval</A>
<LI><A HREF="gsl_manual.html#IDX2000">gsl_cheb_eval_err</A>
<LI><A HREF="gsl_manual.html#IDX2001">gsl_cheb_eval_n</A>
<LI><A HREF="gsl_manual.html#IDX2002">gsl_cheb_eval_n_err</A>
<LI><A HREF="gsl_manual.html#IDX1997">gsl_cheb_free</A>
<LI><A HREF="gsl_manual.html#IDX1998">gsl_cheb_init</A>
<LI><A HREF="gsl_manual.html#IDX987">gsl_combination_alloc</A>
<LI><A HREF="gsl_manual.html#IDX988">gsl_combination_calloc</A>
<LI><A HREF="gsl_manual.html#IDX996">gsl_combination_data</A>
<LI><A HREF="gsl_manual.html#IDX1005">gsl_combination_fprintf</A>
<LI><A HREF="gsl_manual.html#IDX1004">gsl_combination_fread</A>
<LI><A HREF="gsl_manual.html#IDX991">gsl_combination_free</A>
<LI><A HREF="gsl_manual.html#IDX1006">gsl_combination_fscanf</A>
<LI><A HREF="gsl_manual.html#IDX1003">gsl_combination_fwrite</A>
<LI><A HREF="gsl_manual.html#IDX993">gsl_combination_get</A>
<LI><A HREF="gsl_manual.html#IDX989">gsl_combination_init_first</A>
<LI><A HREF="gsl_manual.html#IDX990">gsl_combination_init_last</A>
<LI><A HREF="gsl_manual.html#IDX995">gsl_combination_k</A>
<LI><A HREF="gsl_manual.html#IDX992">gsl_combination_memcpy</A>
<LI><A HREF="gsl_manual.html#IDX994">gsl_combination_n</A>
<LI><A HREF="gsl_manual.html#IDX1000">gsl_combination_next</A>
<LI><A HREF="gsl_manual.html#IDX1002">gsl_combination_prev</A>
<LI><A HREF="gsl_manual.html#IDX997">gsl_combination_valid</A>
<LI><A HREF="gsl_manual.html#IDX144">gsl_complex_abs</A>
<LI><A HREF="gsl_manual.html#IDX146">gsl_complex_abs2</A>
<LI><A HREF="gsl_manual.html#IDX149">gsl_complex_add</A>
<LI><A HREF="gsl_manual.html#IDX157">gsl_complex_add_imag</A>
<LI><A HREF="gsl_manual.html#IDX153">gsl_complex_add_real</A>
<LI><A HREF="gsl_manual.html#IDX190">gsl_complex_arccos</A>
<LI><A HREF="gsl_manual.html#IDX191">gsl_complex_arccos_real</A>
<LI><A HREF="gsl_manual.html#IDX207">gsl_complex_arccosh</A>
<LI><A HREF="gsl_manual.html#IDX208">gsl_complex_arccosh_real</A>
<LI><A HREF="gsl_manual.html#IDX197">gsl_complex_arccot</A>
<LI><A HREF="gsl_manual.html#IDX213">gsl_complex_arccoth</A>
<LI><A HREF="gsl_manual.html#IDX195">gsl_complex_arccsc</A>
<LI><A HREF="gsl_manual.html#IDX196">gsl_complex_arccsc_real</A>
<LI><A HREF="gsl_manual.html#IDX212">gsl_complex_arccsch</A>
<LI><A HREF="gsl_manual.html#IDX193">gsl_complex_arcsec</A>
<LI><A HREF="gsl_manual.html#IDX194">gsl_complex_arcsec_real</A>
<LI><A HREF="gsl_manual.html#IDX211">gsl_complex_arcsech</A>
<LI><A HREF="gsl_manual.html#IDX188">gsl_complex_arcsin</A>
<LI><A HREF="gsl_manual.html#IDX189">gsl_complex_arcsin_real</A>
<LI><A HREF="gsl_manual.html#IDX206">gsl_complex_arcsinh</A>
<LI><A HREF="gsl_manual.html#IDX192">gsl_complex_arctan</A>
<LI><A HREF="gsl_manual.html#IDX209">gsl_complex_arctanh</A>
<LI><A HREF="gsl_manual.html#IDX210">gsl_complex_arctanh_real</A>
<LI><A HREF="gsl_manual.html#IDX142">gsl_complex_arg</A>
<LI><A HREF="gsl_manual.html#IDX161">gsl_complex_conjugate</A>
<LI><A HREF="gsl_manual.html#IDX180">gsl_complex_cos</A>
<LI><A HREF="gsl_manual.html#IDX200">gsl_complex_cosh</A>
<LI><A HREF="gsl_manual.html#IDX186">gsl_complex_cot</A>
<LI><A HREF="gsl_manual.html#IDX204">gsl_complex_coth</A>
<LI><A HREF="gsl_manual.html#IDX185">gsl_complex_csc</A>
<LI><A HREF="gsl_manual.html#IDX203">gsl_complex_csch</A>
<LI><A HREF="gsl_manual.html#IDX152">gsl_complex_div</A>
<LI><A HREF="gsl_manual.html#IDX160">gsl_complex_div_imag</A>
<LI><A HREF="gsl_manual.html#IDX156">gsl_complex_div_real</A>
<LI><A HREF="gsl_manual.html#IDX172">gsl_complex_exp</A>
<LI><A HREF="gsl_manual.html#IDX163">gsl_complex_inverse</A>
<LI><A HREF="gsl_manual.html#IDX173">gsl_complex_log</A>
<LI><A HREF="gsl_manual.html#IDX175">gsl_complex_log10</A>
<LI><A HREF="gsl_manual.html#IDX176">gsl_complex_log_b</A>
<LI><A HREF="gsl_manual.html#IDX147">gsl_complex_logabs</A>
<LI><A HREF="gsl_manual.html#IDX151">gsl_complex_mul</A>
<LI><A HREF="gsl_manual.html#IDX159">gsl_complex_mul_imag</A>
<LI><A HREF="gsl_manual.html#IDX155">gsl_complex_mul_real</A>
<LI><A HREF="gsl_manual.html#IDX164">gsl_complex_negative</A>
<LI><A HREF="gsl_manual.html#IDX136">gsl_complex_polar</A>
<LI><A HREF="gsl_manual.html#IDX168">gsl_complex_pow</A>
<LI><A HREF="gsl_manual.html#IDX171">gsl_complex_pow_real</A>
<LI><A HREF="gsl_manual.html#IDX135">gsl_complex_rect</A>
<LI><A HREF="gsl_manual.html#IDX184">gsl_complex_sec</A>
<LI><A HREF="gsl_manual.html#IDX202">gsl_complex_sech</A>
<LI><A HREF="gsl_manual.html#IDX178">gsl_complex_sin</A>
<LI><A HREF="gsl_manual.html#IDX199">gsl_complex_sinh</A>
<LI><A HREF="gsl_manual.html#IDX165">gsl_complex_sqrt</A>
<LI><A HREF="gsl_manual.html#IDX167">gsl_complex_sqrt_real</A>
<LI><A HREF="gsl_manual.html#IDX150">gsl_complex_sub</A>
<LI><A HREF="gsl_manual.html#IDX158">gsl_complex_sub_imag</A>
<LI><A HREF="gsl_manual.html#IDX154">gsl_complex_sub_real</A>
<LI><A HREF="gsl_manual.html#IDX182">gsl_complex_tan</A>
<LI><A HREF="gsl_manual.html#IDX201">gsl_complex_tanh</A>
<LI><A HREF="gsl_manual.html#IDX1992">gsl_deriv_backward</A>
<LI><A HREF="gsl_manual.html#IDX1990">gsl_deriv_central</A>
<LI><A HREF="gsl_manual.html#IDX1991">gsl_deriv_forward</A>
<LI><A HREF="gsl_manual.html#IDX2058">gsl_dht_alloc</A>
<LI><A HREF="gsl_manual.html#IDX2062">gsl_dht_apply</A>
<LI><A HREF="gsl_manual.html#IDX2061">gsl_dht_free</A>
<LI><A HREF="gsl_manual.html#IDX2059">gsl_dht_init</A>
<LI><A HREF="gsl_manual.html#IDX2064">gsl_dht_k_sample</A>
<LI><A HREF="gsl_manual.html#IDX2060">gsl_dht_new</A>
<LI><A HREF="gsl_manual.html#IDX2063">gsl_dht_x_sample</A>
<LI><A HREF="gsl_manual.html#IDX48">GSL_EDOM</A>
<LI><A HREF="gsl_manual.html#IDX1283">gsl_eigen_herm</A>
<LI><A HREF="gsl_manual.html#IDX1281">gsl_eigen_herm_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1282">gsl_eigen_herm_free</A>
<LI><A HREF="gsl_manual.html#IDX1286">gsl_eigen_hermv</A>
<LI><A HREF="gsl_manual.html#IDX1284">gsl_eigen_hermv_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1285">gsl_eigen_hermv_free</A>
<LI><A HREF="gsl_manual.html#IDX1289">gsl_eigen_hermv_sort</A>
<LI><A HREF="gsl_manual.html#IDX1275">gsl_eigen_symm</A>
<LI><A HREF="gsl_manual.html#IDX1273">gsl_eigen_symm_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1274">gsl_eigen_symm_free</A>
<LI><A HREF="gsl_manual.html#IDX1278">gsl_eigen_symmv</A>
<LI><A HREF="gsl_manual.html#IDX1276">gsl_eigen_symmv_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1277">gsl_eigen_symmv_free</A>
<LI><A HREF="gsl_manual.html#IDX1288">gsl_eigen_symmv_sort</A>
<LI><A HREF="gsl_manual.html#IDX51">GSL_EINVAL</A>
<LI><A HREF="gsl_manual.html#IDX50">GSL_ENOMEM</A>
<LI><A HREF="gsl_manual.html#IDX49">GSL_ERANGE</A>
<LI><A HREF="gsl_manual.html#IDX58">GSL_ERROR</A>
<LI><A HREF="gsl_manual.html#IDX59">GSL_ERROR_VAL</A>
<LI><A HREF="gsl_manual.html#IDX83">gsl_expm1</A>
<LI><A HREF="gsl_manual.html#IDX128">gsl_fcmp</A>
<LI><A HREF="gsl_manual.html#IDX1316">gsl_fft_complex_backward</A>
<LI><A HREF="gsl_manual.html#IDX1314">gsl_fft_complex_forward</A>
<LI><A HREF="gsl_manual.html#IDX1317">gsl_fft_complex_inverse</A>
<LI><A HREF="gsl_manual.html#IDX1301">gsl_fft_complex_radix2_backward</A>
<LI><A HREF="gsl_manual.html#IDX1305">gsl_fft_complex_radix2_dif_backward</A>
<LI><A HREF="gsl_manual.html#IDX1303">gsl_fft_complex_radix2_dif_forward</A>
<LI><A HREF="gsl_manual.html#IDX1306">gsl_fft_complex_radix2_dif_inverse</A>
<LI><A HREF="gsl_manual.html#IDX1304">gsl_fft_complex_radix2_dif_transform</A>
<LI><A HREF="gsl_manual.html#IDX1299">gsl_fft_complex_radix2_forward</A>
<LI><A HREF="gsl_manual.html#IDX1302">gsl_fft_complex_radix2_inverse</A>
<LI><A HREF="gsl_manual.html#IDX1300">gsl_fft_complex_radix2_transform</A>
<LI><A HREF="gsl_manual.html#IDX1315">gsl_fft_complex_transform</A>
<LI><A HREF="gsl_manual.html#IDX1309">gsl_fft_complex_wavetable_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1310">gsl_fft_complex_wavetable_free</A>
<LI><A HREF="gsl_manual.html#IDX1312">gsl_fft_complex_workspace_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1313">gsl_fft_complex_workspace_free</A>
<LI><A HREF="gsl_manual.html#IDX1323">gsl_fft_halfcomplex_radix2_backward</A>
<LI><A HREF="gsl_manual.html#IDX1322">gsl_fft_halfcomplex_radix2_inverse</A>
<LI><A HREF="gsl_manual.html#IDX1333">gsl_fft_halfcomplex_transform</A>
<LI><A HREF="gsl_manual.html#IDX1335">gsl_fft_halfcomplex_unpack</A>
<LI><A HREF="gsl_manual.html#IDX1327">gsl_fft_halfcomplex_wavetable_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1329">gsl_fft_halfcomplex_wavetable_free</A>
<LI><A HREF="gsl_manual.html#IDX1321">gsl_fft_real_radix2_transform</A>
<LI><A HREF="gsl_manual.html#IDX1332">gsl_fft_real_transform</A>
<LI><A HREF="gsl_manual.html#IDX1334">gsl_fft_real_unpack</A>
<LI><A HREF="gsl_manual.html#IDX1326">gsl_fft_real_wavetable_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1328">gsl_fft_real_wavetable_free</A>
<LI><A HREF="gsl_manual.html#IDX1330">gsl_fft_real_workspace_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1331">gsl_fft_real_workspace_free</A>
<LI><A HREF="gsl_manual.html#IDX79">gsl_finite</A>
<LI><A HREF="gsl_manual.html#IDX2237">gsl_fit_linear</A>
<LI><A HREF="gsl_manual.html#IDX2239">gsl_fit_linear_est</A>
<LI><A HREF="gsl_manual.html#IDX2240">gsl_fit_mul</A>
<LI><A HREF="gsl_manual.html#IDX2242">gsl_fit_mul_est</A>
<LI><A HREF="gsl_manual.html#IDX2238">gsl_fit_wlinear</A>
<LI><A HREF="gsl_manual.html#IDX2241">gsl_fit_wmul</A>
<LI><A HREF="gsl_manual.html#IDX104">gsl_frexp</A>
<LI><A HREF="gsl_manual.html#IDX1010">gsl_heapsort</A>
<LI><A HREF="gsl_manual.html#IDX1012">gsl_heapsort_index</A>
<LI><A HREF="gsl_manual.html#IDX1792">gsl_histogram2d_accumulate</A>
<LI><A HREF="gsl_manual.html#IDX1815">gsl_histogram2d_add</A>
<LI><A HREF="gsl_manual.html#IDX1785">gsl_histogram2d_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1790">gsl_histogram2d_clone</A>
<LI><A HREF="gsl_manual.html#IDX1812">gsl_histogram2d_cov</A>
<LI><A HREF="gsl_manual.html#IDX1818">gsl_histogram2d_div</A>
<LI><A HREF="gsl_manual.html#IDX1814">gsl_histogram2d_equal_bins_p</A>
<LI><A HREF="gsl_manual.html#IDX1803">gsl_histogram2d_find</A>
<LI><A HREF="gsl_manual.html#IDX1823">gsl_histogram2d_fprintf</A>
<LI><A HREF="gsl_manual.html#IDX1822">gsl_histogram2d_fread</A>
<LI><A HREF="gsl_manual.html#IDX1788">gsl_histogram2d_free</A>
<LI><A HREF="gsl_manual.html#IDX1824">gsl_histogram2d_fscanf</A>
<LI><A HREF="gsl_manual.html#IDX1821">gsl_histogram2d_fwrite</A>
<LI><A HREF="gsl_manual.html#IDX1793">gsl_histogram2d_get</A>
<LI><A HREF="gsl_manual.html#IDX1794">gsl_histogram2d_get_xrange</A>
<LI><A HREF="gsl_manual.html#IDX1795">gsl_histogram2d_get_yrange</A>
<LI><A HREF="gsl_manual.html#IDX1791">gsl_histogram2d_increment</A>
<LI><A HREF="gsl_manual.html#IDX1805">gsl_histogram2d_max_bin</A>
<LI><A HREF="gsl_manual.html#IDX1804">gsl_histogram2d_max_val</A>
<LI><A HREF="gsl_manual.html#IDX1789">gsl_histogram2d_memcpy</A>
<LI><A HREF="gsl_manual.html#IDX1807">gsl_histogram2d_min_bin</A>
<LI><A HREF="gsl_manual.html#IDX1806">gsl_histogram2d_min_val</A>
<LI><A HREF="gsl_manual.html#IDX1817">gsl_histogram2d_mul</A>
<LI><A HREF="gsl_manual.html#IDX1798">gsl_histogram2d_nx</A>
<LI><A HREF="gsl_manual.html#IDX1801">gsl_histogram2d_ny</A>
<LI><A HREF="gsl_manual.html#IDX1826">gsl_histogram2d_pdf_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1828">gsl_histogram2d_pdf_free</A>
<LI><A HREF="gsl_manual.html#IDX1827">gsl_histogram2d_pdf_init</A>
<LI><A HREF="gsl_manual.html#IDX1829">gsl_histogram2d_pdf_sample</A>
<LI><A HREF="gsl_manual.html#IDX1802">gsl_histogram2d_reset</A>
<LI><A HREF="gsl_manual.html#IDX1819">gsl_histogram2d_scale</A>
<LI><A HREF="gsl_manual.html#IDX1786">gsl_histogram2d_set_ranges</A>
<LI><A HREF="gsl_manual.html#IDX1787">gsl_histogram2d_set_ranges_uniform</A>
<LI><A HREF="gsl_manual.html#IDX1820">gsl_histogram2d_shift</A>
<LI><A HREF="gsl_manual.html#IDX1816">gsl_histogram2d_sub</A>
<LI><A HREF="gsl_manual.html#IDX1813">gsl_histogram2d_sum</A>
<LI><A HREF="gsl_manual.html#IDX1796">gsl_histogram2d_xmax</A>
<LI><A HREF="gsl_manual.html#IDX1808">gsl_histogram2d_xmean</A>
<LI><A HREF="gsl_manual.html#IDX1797">gsl_histogram2d_xmin</A>
<LI><A HREF="gsl_manual.html#IDX1810">gsl_histogram2d_xsigma</A>
<LI><A HREF="gsl_manual.html#IDX1799">gsl_histogram2d_ymax</A>
<LI><A HREF="gsl_manual.html#IDX1809">gsl_histogram2d_ymean</A>
<LI><A HREF="gsl_manual.html#IDX1800">gsl_histogram2d_ymin</A>
<LI><A HREF="gsl_manual.html#IDX1811">gsl_histogram2d_ysigma</A>
<LI><A HREF="gsl_manual.html#IDX1737">gsl_histogram_accumulate</A>
<LI><A HREF="gsl_manual.html#IDX1760">gsl_histogram_add</A>
<LI><A HREF="gsl_manual.html#IDX1730">gsl_histogram_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1742">gsl_histogram_bins</A>
<LI><A HREF="gsl_manual.html#IDX1735">gsl_histogram_clone</A>
<LI><A HREF="gsl_manual.html#IDX1763">gsl_histogram_div</A>
<LI><A HREF="gsl_manual.html#IDX1759">gsl_histogram_equal_bins_p</A>
<LI><A HREF="gsl_manual.html#IDX1744">gsl_histogram_find</A>
<LI><A HREF="gsl_manual.html#IDX1768">gsl_histogram_fprintf</A>
<LI><A HREF="gsl_manual.html#IDX1767">gsl_histogram_fread</A>
<LI><A HREF="gsl_manual.html#IDX1733">gsl_histogram_free</A>
<LI><A HREF="gsl_manual.html#IDX1769">gsl_histogram_fscanf</A>
<LI><A HREF="gsl_manual.html#IDX1766">gsl_histogram_fwrite</A>
<LI><A HREF="gsl_manual.html#IDX1738">gsl_histogram_get</A>
<LI><A HREF="gsl_manual.html#IDX1739">gsl_histogram_get_range</A>
<LI><A HREF="gsl_manual.html#IDX1736">gsl_histogram_increment</A>
<LI><A HREF="gsl_manual.html#IDX1740">gsl_histogram_max</A>
<LI><A HREF="gsl_manual.html#IDX1750">gsl_histogram_max_bin</A>
<LI><A HREF="gsl_manual.html#IDX1749">gsl_histogram_max_val</A>
<LI><A HREF="gsl_manual.html#IDX1754">gsl_histogram_mean</A>
<LI><A HREF="gsl_manual.html#IDX1734">gsl_histogram_memcpy</A>
<LI><A HREF="gsl_manual.html#IDX1741">gsl_histogram_min</A>
<LI><A HREF="gsl_manual.html#IDX1752">gsl_histogram_min_bin</A>
<LI><A HREF="gsl_manual.html#IDX1751">gsl_histogram_min_val</A>
<LI><A HREF="gsl_manual.html#IDX1762">gsl_histogram_mul</A>
<LI><A HREF="gsl_manual.html#IDX1778">gsl_histogram_pdf_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1780">gsl_histogram_pdf_free</A>
<LI><A HREF="gsl_manual.html#IDX1779">gsl_histogram_pdf_init</A>
<LI><A HREF="gsl_manual.html#IDX1781">gsl_histogram_pdf_sample</A>
<LI><A HREF="gsl_manual.html#IDX1743">gsl_histogram_reset</A>
<LI><A HREF="gsl_manual.html#IDX1764">gsl_histogram_scale</A>
<LI><A HREF="gsl_manual.html#IDX1731">gsl_histogram_set_ranges</A>
<LI><A HREF="gsl_manual.html#IDX1732">gsl_histogram_set_ranges_uniform</A>
<LI><A HREF="gsl_manual.html#IDX1765">gsl_histogram_shift</A>
<LI><A HREF="gsl_manual.html#IDX1757">gsl_histogram_sigma</A>
<LI><A HREF="gsl_manual.html#IDX1761">gsl_histogram_sub</A>
<LI><A HREF="gsl_manual.html#IDX1758">gsl_histogram_sum</A>
<LI><A HREF="gsl_manual.html#IDX86">gsl_hypot</A>
<LI><A HREF="gsl_manual.html#IDX2336">gsl_ieee_env_setup</A>
<LI><A HREF="gsl_manual.html#IDX2325">gsl_ieee_fprintf_double</A>
<LI><A HREF="gsl_manual.html#IDX2324">gsl_ieee_fprintf_float</A>
<LI><A HREF="gsl_manual.html#IDX2327">gsl_ieee_printf_double</A>
<LI><A HREF="gsl_manual.html#IDX2326">gsl_ieee_printf_float</A>
<LI><A HREF="gsl_manual.html#IDX138">GSL_IMAG</A>
<LI><A HREF="gsl_manual.html#IDX1346">gsl_integration_qag</A>
<LI><A HREF="gsl_manual.html#IDX1350">gsl_integration_qagi</A>
<LI><A HREF="gsl_manual.html#IDX1352">gsl_integration_qagil</A>
<LI><A HREF="gsl_manual.html#IDX1351">gsl_integration_qagiu</A>
<LI><A HREF="gsl_manual.html#IDX1349">gsl_integration_qagp</A>
<LI><A HREF="gsl_manual.html#IDX1347">gsl_integration_qags</A>
<LI><A HREF="gsl_manual.html#IDX1354">gsl_integration_qawc</A>
<LI><A HREF="gsl_manual.html#IDX1367">gsl_integration_qawf</A>
<LI><A HREF="gsl_manual.html#IDX1365">gsl_integration_qawo</A>
<LI><A HREF="gsl_manual.html#IDX1361">gsl_integration_qawo_table_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1364">gsl_integration_qawo_table_free</A>
<LI><A HREF="gsl_manual.html#IDX1362">gsl_integration_qawo_table_set</A>
<LI><A HREF="gsl_manual.html#IDX1363">gsl_integration_qawo_table_set_length</A>
<LI><A HREF="gsl_manual.html#IDX1359">gsl_integration_qaws</A>
<LI><A HREF="gsl_manual.html#IDX1356">gsl_integration_qaws_table_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1358">gsl_integration_qaws_table_free</A>
<LI><A HREF="gsl_manual.html#IDX1357">gsl_integration_qaws_table_set</A>
<LI><A HREF="gsl_manual.html#IDX1343">gsl_integration_qng</A>
<LI><A HREF="gsl_manual.html#IDX1344">gsl_integration_workspace_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1345">gsl_integration_workspace_free</A>
<LI><A HREF="gsl_manual.html#IDX1963">gsl_interp_accel_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1964">gsl_interp_accel_find</A>
<LI><A HREF="gsl_manual.html#IDX1965">gsl_interp_accel_free</A>
<LI><A HREF="gsl_manual.html#IDX1957">gsl_interp_akima</A>
<LI><A HREF="gsl_manual.html#IDX1959">gsl_interp_akima_periodic</A>
<LI><A HREF="gsl_manual.html#IDX1947">gsl_interp_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1962">gsl_interp_bsearch</A>
<LI><A HREF="gsl_manual.html#IDX1954">gsl_interp_cspline</A>
<LI><A HREF="gsl_manual.html#IDX1956">gsl_interp_cspline_periodic</A>
<LI><A HREF="gsl_manual.html#IDX1966">gsl_interp_eval</A>
<LI><A HREF="gsl_manual.html#IDX1968">gsl_interp_eval_deriv</A>
<LI><A HREF="gsl_manual.html#IDX1970">gsl_interp_eval_deriv2</A>
<LI><A HREF="gsl_manual.html#IDX1971">gsl_interp_eval_deriv2_e</A>
<LI><A HREF="gsl_manual.html#IDX1969">gsl_interp_eval_deriv_e</A>
<LI><A HREF="gsl_manual.html#IDX1967">gsl_interp_eval_e</A>
<LI><A HREF="gsl_manual.html#IDX1972">gsl_interp_eval_integ</A>
<LI><A HREF="gsl_manual.html#IDX1973">gsl_interp_eval_integ_e</A>
<LI><A HREF="gsl_manual.html#IDX1949">gsl_interp_free</A>
<LI><A HREF="gsl_manual.html#IDX1948">gsl_interp_init</A>
<LI><A HREF="gsl_manual.html#IDX1950">gsl_interp_linear</A>
<LI><A HREF="gsl_manual.html#IDX1961">gsl_interp_min_size</A>
<LI><A HREF="gsl_manual.html#IDX1960">gsl_interp_name</A>
<LI><A HREF="gsl_manual.html#IDX1952">gsl_interp_polynomial</A>
<LI><A HREF="gsl_manual.html#IDX117">GSL_IS_EVEN</A>
<LI><A HREF="gsl_manual.html#IDX116">GSL_IS_ODD</A>
<LI><A HREF="gsl_manual.html#IDX78">gsl_isinf</A>
<LI><A HREF="gsl_manual.html#IDX77">gsl_isnan</A>
<LI><A HREF="gsl_manual.html#IDX102">gsl_ldexp</A>
<LI><A HREF="gsl_manual.html#IDX1249">gsl_linalg_bidiag_decomp</A>
<LI><A HREF="gsl_manual.html#IDX1250">gsl_linalg_bidiag_unpack</A>
<LI><A HREF="gsl_manual.html#IDX1251">gsl_linalg_bidiag_unpack2</A>
<LI><A HREF="gsl_manual.html#IDX1252">gsl_linalg_bidiag_unpack_B</A>
<LI><A HREF="gsl_manual.html#IDX1237">gsl_linalg_cholesky_decomp</A>
<LI><A HREF="gsl_manual.html#IDX1238">gsl_linalg_cholesky_solve</A>
<LI><A HREF="gsl_manual.html#IDX1239">gsl_linalg_cholesky_svx</A>
<LI><A HREF="gsl_manual.html#IDX1180">gsl_linalg_complex_LU_decomp</A>
<LI><A HREF="gsl_manual.html#IDX1198">gsl_linalg_complex_LU_det</A>
<LI><A HREF="gsl_manual.html#IDX1194">gsl_linalg_complex_LU_invert</A>
<LI><A HREF="gsl_manual.html#IDX1201">gsl_linalg_complex_LU_lndet</A>
<LI><A HREF="gsl_manual.html#IDX1190">gsl_linalg_complex_LU_refine</A>
<LI><A HREF="gsl_manual.html#IDX1204">gsl_linalg_complex_LU_sgndet</A>
<LI><A HREF="gsl_manual.html#IDX1183">gsl_linalg_complex_LU_solve</A>
<LI><A HREF="gsl_manual.html#IDX1185">gsl_linalg_complex_LU_svx</A>
<LI><A HREF="gsl_manual.html#IDX1245">gsl_linalg_hermtd_decomp</A>
<LI><A HREF="gsl_manual.html#IDX1246">gsl_linalg_hermtd_unpack</A>
<LI><A HREF="gsl_manual.html#IDX1247">gsl_linalg_hermtd_unpack_T</A>
<LI><A HREF="gsl_manual.html#IDX1262">gsl_linalg_HH_solve</A>
<LI><A HREF="gsl_manual.html#IDX1263">gsl_linalg_HH_svx</A>
<LI><A HREF="gsl_manual.html#IDX1257">gsl_linalg_householder_hm</A>
<LI><A HREF="gsl_manual.html#IDX1259">gsl_linalg_householder_hv</A>
<LI><A HREF="gsl_manual.html#IDX1258">gsl_linalg_householder_mh</A>
<LI><A HREF="gsl_manual.html#IDX1256">gsl_linalg_householder_transform</A>
<LI><A HREF="gsl_manual.html#IDX1179">gsl_linalg_LU_decomp</A>
<LI><A HREF="gsl_manual.html#IDX1197">gsl_linalg_LU_det</A>
<LI><A HREF="gsl_manual.html#IDX1193">gsl_linalg_LU_invert</A>
<LI><A HREF="gsl_manual.html#IDX1200">gsl_linalg_LU_lndet</A>
<LI><A HREF="gsl_manual.html#IDX1189">gsl_linalg_LU_refine</A>
<LI><A HREF="gsl_manual.html#IDX1203">gsl_linalg_LU_sgndet</A>
<LI><A HREF="gsl_manual.html#IDX1182">gsl_linalg_LU_solve</A>
<LI><A HREF="gsl_manual.html#IDX1184">gsl_linalg_LU_svx</A>
<LI><A HREF="gsl_manual.html#IDX1206">gsl_linalg_QR_decomp</A>
<LI><A HREF="gsl_manual.html#IDX1209">gsl_linalg_QR_lssolve</A>
<LI><A HREF="gsl_manual.html#IDX1215">gsl_linalg_QR_QRsolve</A>
<LI><A HREF="gsl_manual.html#IDX1210">gsl_linalg_QR_QTvec</A>
<LI><A HREF="gsl_manual.html#IDX1211">gsl_linalg_QR_Qvec</A>
<LI><A HREF="gsl_manual.html#IDX1212">gsl_linalg_QR_Rsolve</A>
<LI><A HREF="gsl_manual.html#IDX1213">gsl_linalg_QR_Rsvx</A>
<LI><A HREF="gsl_manual.html#IDX1207">gsl_linalg_QR_solve</A>
<LI><A HREF="gsl_manual.html#IDX1208">gsl_linalg_QR_svx</A>
<LI><A HREF="gsl_manual.html#IDX1214">gsl_linalg_QR_unpack</A>
<LI><A HREF="gsl_manual.html#IDX1216">gsl_linalg_QR_update</A>
<LI><A HREF="gsl_manual.html#IDX1220">gsl_linalg_QRPT_decomp</A>
<LI><A HREF="gsl_manual.html#IDX1221">gsl_linalg_QRPT_decomp2</A>
<LI><A HREF="gsl_manual.html#IDX1224">gsl_linalg_QRPT_QRsolve</A>
<LI><A HREF="gsl_manual.html#IDX1226">gsl_linalg_QRPT_Rsolve</A>
<LI><A HREF="gsl_manual.html#IDX1227">gsl_linalg_QRPT_Rsvx</A>
<LI><A HREF="gsl_manual.html#IDX1222">gsl_linalg_QRPT_solve</A>
<LI><A HREF="gsl_manual.html#IDX1223">gsl_linalg_QRPT_svx</A>
<LI><A HREF="gsl_manual.html#IDX1225">gsl_linalg_QRPT_update</A>
<LI><A HREF="gsl_manual.html#IDX1217">gsl_linalg_R_solve</A>
<LI><A HREF="gsl_manual.html#IDX1218">gsl_linalg_R_svx</A>
<LI><A HREF="gsl_manual.html#IDX1267">gsl_linalg_solve_cyc_tridiag</A>
<LI><A HREF="gsl_manual.html#IDX1268">gsl_linalg_solve_symm_cyc_tridiag</A>
<LI><A HREF="gsl_manual.html#IDX1266">gsl_linalg_solve_symm_tridiag</A>
<LI><A HREF="gsl_manual.html#IDX1265">gsl_linalg_solve_tridiag</A>
<LI><A HREF="gsl_manual.html#IDX1230">gsl_linalg_SV_decomp</A>
<LI><A HREF="gsl_manual.html#IDX1232">gsl_linalg_SV_decomp_jacobi</A>
<LI><A HREF="gsl_manual.html#IDX1231">gsl_linalg_SV_decomp_mod</A>
<LI><A HREF="gsl_manual.html#IDX1233">gsl_linalg_SV_solve</A>
<LI><A HREF="gsl_manual.html#IDX1241">gsl_linalg_symmtd_decomp</A>
<LI><A HREF="gsl_manual.html#IDX1242">gsl_linalg_symmtd_unpack</A>
<LI><A HREF="gsl_manual.html#IDX1243">gsl_linalg_symmtd_unpack_T</A>
<LI><A HREF="gsl_manual.html#IDX80">gsl_log1p</A>
<LI><A HREF="gsl_manual.html#IDX936">gsl_matrix_add</A>
<LI><A HREF="gsl_manual.html#IDX941">gsl_matrix_add_constant</A>
<LI><A HREF="gsl_manual.html#IDX875">gsl_matrix_alloc</A>
<LI><A HREF="gsl_manual.html#IDX876">gsl_matrix_calloc</A>
<LI><A HREF="gsl_manual.html#IDX911">gsl_matrix_column</A>
<LI><A HREF="gsl_manual.html#IDX912">gsl_matrix_const_column</A>
<LI><A HREF="gsl_manual.html#IDX916">gsl_matrix_const_diagonal</A>
<LI><A HREF="gsl_manual.html#IDX883">gsl_matrix_const_ptr</A>
<LI><A HREF="gsl_manual.html#IDX910">gsl_matrix_const_row</A>
<LI><A HREF="gsl_manual.html#IDX920">gsl_matrix_const_subdiagonal</A>
<LI><A HREF="gsl_manual.html#IDX900">gsl_matrix_const_submatrix</A>
<LI><A HREF="gsl_manual.html#IDX924">gsl_matrix_const_superdiagonal</A>
<LI><A HREF="gsl_manual.html#IDX902">gsl_matrix_const_view_array</A>
<LI><A HREF="gsl_manual.html#IDX904">gsl_matrix_const_view_array_with_tda</A>
<LI><A HREF="gsl_manual.html#IDX906">gsl_matrix_const_view_vector</A>
<LI><A HREF="gsl_manual.html#IDX908">gsl_matrix_const_view_vector_with_tda</A>
<LI><A HREF="gsl_manual.html#IDX915">gsl_matrix_diagonal</A>
<LI><A HREF="gsl_manual.html#IDX939">gsl_matrix_div_elements</A>
<LI><A HREF="gsl_manual.html#IDX897">gsl_matrix_fprintf</A>
<LI><A HREF="gsl_manual.html#IDX896">gsl_matrix_fread</A>
<LI><A HREF="gsl_manual.html#IDX877">gsl_matrix_free</A>
<LI><A HREF="gsl_manual.html#IDX898">gsl_matrix_fscanf</A>
<LI><A HREF="gsl_manual.html#IDX895">gsl_matrix_fwrite</A>
<LI><A HREF="gsl_manual.html#IDX880">gsl_matrix_get</A>
<LI><A HREF="gsl_manual.html#IDX928">gsl_matrix_get_col</A>
<LI><A HREF="gsl_manual.html#IDX927">gsl_matrix_get_row</A>
<LI><A HREF="gsl_manual.html#IDX948">gsl_matrix_isnull</A>
<LI><A HREF="gsl_manual.html#IDX942">gsl_matrix_max</A>
<LI><A HREF="gsl_manual.html#IDX945">gsl_matrix_max_index</A>
<LI><A HREF="gsl_manual.html#IDX925">gsl_matrix_memcpy</A>
<LI><A HREF="gsl_manual.html#IDX943">gsl_matrix_min</A>
<LI><A HREF="gsl_manual.html#IDX946">gsl_matrix_min_index</A>
<LI><A HREF="gsl_manual.html#IDX944">gsl_matrix_minmax</A>
<LI><A HREF="gsl_manual.html#IDX947">gsl_matrix_minmax_index</A>
<LI><A HREF="gsl_manual.html#IDX938">gsl_matrix_mul_elements</A>
<LI><A HREF="gsl_manual.html#IDX882">gsl_matrix_ptr</A>
<LI><A HREF="gsl_manual.html#IDX909">gsl_matrix_row</A>
<LI><A HREF="gsl_manual.html#IDX940">gsl_matrix_scale</A>
<LI><A HREF="gsl_manual.html#IDX881">gsl_matrix_set</A>
<LI><A HREF="gsl_manual.html#IDX892">gsl_matrix_set_all</A>
<LI><A HREF="gsl_manual.html#IDX930">gsl_matrix_set_col</A>
<LI><A HREF="gsl_manual.html#IDX894">gsl_matrix_set_identity</A>
<LI><A HREF="gsl_manual.html#IDX929">gsl_matrix_set_row</A>
<LI><A HREF="gsl_manual.html#IDX893">gsl_matrix_set_zero</A>
<LI><A HREF="gsl_manual.html#IDX937">gsl_matrix_sub</A>
<LI><A HREF="gsl_manual.html#IDX919">gsl_matrix_subdiagonal</A>
<LI><A HREF="gsl_manual.html#IDX899">gsl_matrix_submatrix</A>
<LI><A HREF="gsl_manual.html#IDX923">gsl_matrix_superdiagonal</A>
<LI><A HREF="gsl_manual.html#IDX926">gsl_matrix_swap</A>
<LI><A HREF="gsl_manual.html#IDX932">gsl_matrix_swap_columns</A>
<LI><A HREF="gsl_manual.html#IDX933">gsl_matrix_swap_rowcol</A>
<LI><A HREF="gsl_manual.html#IDX931">gsl_matrix_swap_rows</A>
<LI><A HREF="gsl_manual.html#IDX935">gsl_matrix_transpose</A>
<LI><A HREF="gsl_manual.html#IDX934">gsl_matrix_transpose_memcpy</A>
<LI><A HREF="gsl_manual.html#IDX901">gsl_matrix_view_array</A>
<LI><A HREF="gsl_manual.html#IDX903">gsl_matrix_view_array_with_tda</A>
<LI><A HREF="gsl_manual.html#IDX905">gsl_matrix_view_vector</A>
<LI><A HREF="gsl_manual.html#IDX907">gsl_matrix_view_vector_with_tda</A>
<LI><A HREF="gsl_manual.html#IDX118">GSL_MAX</A>
<LI><A HREF="gsl_manual.html#IDX122">GSL_MAX_DBL</A>
<LI><A HREF="gsl_manual.html#IDX124">GSL_MAX_INT</A>
<LI><A HREF="gsl_manual.html#IDX126">GSL_MAX_LDBL</A>
<LI><A HREF="gsl_manual.html#IDX120">GSL_MIN</A>
<LI><A HREF="gsl_manual.html#IDX123">GSL_MIN_DBL</A>
<LI><A HREF="gsl_manual.html#IDX2122">gsl_min_fminimizer_alloc</A>
<LI><A HREF="gsl_manual.html#IDX2140">gsl_min_fminimizer_brent</A>
<LI><A HREF="gsl_manual.html#IDX2134">gsl_min_fminimizer_f_lower</A>
<LI><A HREF="gsl_manual.html#IDX2132">gsl_min_fminimizer_f_minimum</A>
<LI><A HREF="gsl_manual.html#IDX2133">gsl_min_fminimizer_f_upper</A>
<LI><A HREF="gsl_manual.html#IDX2125">gsl_min_fminimizer_free</A>
<LI><A HREF="gsl_manual.html#IDX2137">gsl_min_fminimizer_goldensection</A>
<LI><A HREF="gsl_manual.html#IDX2128">gsl_min_fminimizer_iterate</A>
<LI><A HREF="gsl_manual.html#IDX2126">gsl_min_fminimizer_name</A>
<LI><A HREF="gsl_manual.html#IDX2123">gsl_min_fminimizer_set</A>
<LI><A HREF="gsl_manual.html#IDX2124">gsl_min_fminimizer_set_with_values</A>
<LI><A HREF="gsl_manual.html#IDX2131">gsl_min_fminimizer_x_lower</A>
<LI><A HREF="gsl_manual.html#IDX2129">gsl_min_fminimizer_x_minimum</A>
<LI><A HREF="gsl_manual.html#IDX2130">gsl_min_fminimizer_x_upper</A>
<LI><A HREF="gsl_manual.html#IDX125">GSL_MIN_INT</A>
<LI><A HREF="gsl_manual.html#IDX127">GSL_MIN_LDBL</A>
<LI><A HREF="gsl_manual.html#IDX2136">gsl_min_test_interval</A>
<LI><A HREF="gsl_manual.html#IDX1854">gsl_monte_miser_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1857">gsl_monte_miser_free</A>
<LI><A HREF="gsl_manual.html#IDX1855">gsl_monte_miser_init</A>
<LI><A HREF="gsl_manual.html#IDX1856">gsl_monte_miser_integrate</A>
<LI><A HREF="gsl_manual.html#IDX1848">gsl_monte_plain_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1851">gsl_monte_plain_free</A>
<LI><A HREF="gsl_manual.html#IDX1849">gsl_monte_plain_init</A>
<LI><A HREF="gsl_manual.html#IDX1850">gsl_monte_plain_integrate</A>
<LI><A HREF="gsl_manual.html#IDX1865">gsl_monte_vegas_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1868">gsl_monte_vegas_free</A>
<LI><A HREF="gsl_manual.html#IDX1866">gsl_monte_vegas_init</A>
<LI><A HREF="gsl_manual.html#IDX1867">gsl_monte_vegas_integrate</A>
<LI><A HREF="gsl_manual.html#IDX2283">gsl_multifit_covar</A>
<LI><A HREF="gsl_manual.html#IDX2257">gsl_multifit_fdfsolver_alloc</A>
<LI><A HREF="gsl_manual.html#IDX2261">gsl_multifit_fdfsolver_free</A>
<LI><A HREF="gsl_manual.html#IDX2267">gsl_multifit_fdfsolver_iterate</A>
<LI><A HREF="gsl_manual.html#IDX2279">gsl_multifit_fdfsolver_lmder</A>
<LI><A HREF="gsl_manual.html#IDX2276">gsl_multifit_fdfsolver_lmsder</A>
<LI><A HREF="gsl_manual.html#IDX2263">gsl_multifit_fdfsolver_name</A>
<LI><A HREF="gsl_manual.html#IDX2269">gsl_multifit_fdfsolver_position</A>
<LI><A HREF="gsl_manual.html#IDX2259">gsl_multifit_fdfsolver_set</A>
<LI><A HREF="gsl_manual.html#IDX2256">gsl_multifit_fsolver_alloc</A>
<LI><A HREF="gsl_manual.html#IDX2260">gsl_multifit_fsolver_free</A>
<LI><A HREF="gsl_manual.html#IDX2266">gsl_multifit_fsolver_iterate</A>
<LI><A HREF="gsl_manual.html#IDX2262">gsl_multifit_fsolver_name</A>
<LI><A HREF="gsl_manual.html#IDX2268">gsl_multifit_fsolver_position</A>
<LI><A HREF="gsl_manual.html#IDX2258">gsl_multifit_fsolver_set</A>
<LI><A HREF="gsl_manual.html#IDX2274">gsl_multifit_gradient</A>
<LI><A HREF="gsl_manual.html#IDX2247">gsl_multifit_linear</A>
<LI><A HREF="gsl_manual.html#IDX2245">gsl_multifit_linear_alloc</A>
<LI><A HREF="gsl_manual.html#IDX2246">gsl_multifit_linear_free</A>
<LI><A HREF="gsl_manual.html#IDX2248">gsl_multifit_linear_svd</A>
<LI><A HREF="gsl_manual.html#IDX2271">gsl_multifit_test_delta</A>
<LI><A HREF="gsl_manual.html#IDX2273">gsl_multifit_test_gradient</A>
<LI><A HREF="gsl_manual.html#IDX2249">gsl_multifit_wlinear</A>
<LI><A HREF="gsl_manual.html#IDX2250">gsl_multifit_wlinear_svd</A>
<LI><A HREF="gsl_manual.html#IDX2193">gsl_multimin_fdfminimizer_alloc</A>
<LI><A HREF="gsl_manual.html#IDX2214">gsl_multimin_fdfminimizer_conjugate_fr</A>
<LI><A HREF="gsl_manual.html#IDX2218">gsl_multimin_fdfminimizer_conjugate_pr</A>
<LI><A HREF="gsl_manual.html#IDX2197">gsl_multimin_fdfminimizer_free</A>
<LI><A HREF="gsl_manual.html#IDX2209">gsl_multimin_fdfminimizer_gradient</A>
<LI><A HREF="gsl_manual.html#IDX2203">gsl_multimin_fdfminimizer_iterate</A>
<LI><A HREF="gsl_manual.html#IDX2207">gsl_multimin_fdfminimizer_minimum</A>
<LI><A HREF="gsl_manual.html#IDX2199">gsl_multimin_fdfminimizer_name</A>
<LI><A HREF="gsl_manual.html#IDX2211">gsl_multimin_fdfminimizer_restart</A>
<LI><A HREF="gsl_manual.html#IDX2195">gsl_multimin_fdfminimizer_set</A>
<LI><A HREF="gsl_manual.html#IDX2224">gsl_multimin_fdfminimizer_steepest_descent</A>
<LI><A HREF="gsl_manual.html#IDX2221">gsl_multimin_fdfminimizer_vector_bfgs</A>
<LI><A HREF="gsl_manual.html#IDX2205">gsl_multimin_fdfminimizer_x</A>
<LI><A HREF="gsl_manual.html#IDX2194">gsl_multimin_fminimizer_alloc</A>
<LI><A HREF="gsl_manual.html#IDX2198">gsl_multimin_fminimizer_free</A>
<LI><A HREF="gsl_manual.html#IDX2204">gsl_multimin_fminimizer_iterate</A>
<LI><A HREF="gsl_manual.html#IDX2208">gsl_multimin_fminimizer_minimum</A>
<LI><A HREF="gsl_manual.html#IDX2200">gsl_multimin_fminimizer_name</A>
<LI><A HREF="gsl_manual.html#IDX2227">gsl_multimin_fminimizer_nmsimplex</A>
<LI><A HREF="gsl_manual.html#IDX2196">gsl_multimin_fminimizer_set</A>
<LI><A HREF="gsl_manual.html#IDX2210">gsl_multimin_fminimizer_size</A>
<LI><A HREF="gsl_manual.html#IDX2206">gsl_multimin_fminimizer_x</A>
<LI><A HREF="gsl_manual.html#IDX2212">gsl_multimin_test_gradient</A>
<LI><A HREF="gsl_manual.html#IDX2213">gsl_multimin_test_size</A>
<LI><A HREF="gsl_manual.html#IDX2148">gsl_multiroot_fdfsolver_alloc</A>
<LI><A HREF="gsl_manual.html#IDX2165">gsl_multiroot_fdfsolver_dx</A>
<LI><A HREF="gsl_manual.html#IDX2163">gsl_multiroot_fdfsolver_f</A>
<LI><A HREF="gsl_manual.html#IDX2152">gsl_multiroot_fdfsolver_free</A>
<LI><A HREF="gsl_manual.html#IDX2178">gsl_multiroot_fdfsolver_gnewton</A>
<LI><A HREF="gsl_manual.html#IDX2174">gsl_multiroot_fdfsolver_hybridj</A>
<LI><A HREF="gsl_manual.html#IDX2171">gsl_multiroot_fdfsolver_hybridsj</A>
<LI><A HREF="gsl_manual.html#IDX2159">gsl_multiroot_fdfsolver_iterate</A>
<LI><A HREF="gsl_manual.html#IDX2154">gsl_multiroot_fdfsolver_name</A>
<LI><A HREF="gsl_manual.html#IDX2176">gsl_multiroot_fdfsolver_newton</A>
<LI><A HREF="gsl_manual.html#IDX2161">gsl_multiroot_fdfsolver_root</A>
<LI><A HREF="gsl_manual.html#IDX2150">gsl_multiroot_fdfsolver_set</A>
<LI><A HREF="gsl_manual.html#IDX2147">gsl_multiroot_fsolver_alloc</A>
<LI><A HREF="gsl_manual.html#IDX2188">gsl_multiroot_fsolver_broyden</A>
<LI><A HREF="gsl_manual.html#IDX2185">gsl_multiroot_fsolver_dnewton</A>
<LI><A HREF="gsl_manual.html#IDX2164">gsl_multiroot_fsolver_dx</A>
<LI><A HREF="gsl_manual.html#IDX2162">gsl_multiroot_fsolver_f</A>
<LI><A HREF="gsl_manual.html#IDX2151">gsl_multiroot_fsolver_free</A>
<LI><A HREF="gsl_manual.html#IDX2183">gsl_multiroot_fsolver_hybrid</A>
<LI><A HREF="gsl_manual.html#IDX2181">gsl_multiroot_fsolver_hybrids</A>
<LI><A HREF="gsl_manual.html#IDX2158">gsl_multiroot_fsolver_iterate</A>
<LI><A HREF="gsl_manual.html#IDX2153">gsl_multiroot_fsolver_name</A>
<LI><A HREF="gsl_manual.html#IDX2160">gsl_multiroot_fsolver_root</A>
<LI><A HREF="gsl_manual.html#IDX2149">gsl_multiroot_fsolver_set</A>
<LI><A HREF="gsl_manual.html#IDX2167">gsl_multiroot_test_delta</A>
<LI><A HREF="gsl_manual.html#IDX2169">gsl_multiroot_test_residual</A>
<LI><A HREF="gsl_manual.html#IDX76">GSL_NAN</A>
<LI><A HREF="gsl_manual.html#IDX75">GSL_NEGINF</A>
<LI><A HREF="gsl_manual.html#IDX1834">gsl_ntuple_bookdata</A>
<LI><A HREF="gsl_manual.html#IDX1836">gsl_ntuple_close</A>
<LI><A HREF="gsl_manual.html#IDX1831">gsl_ntuple_create</A>
<LI><A HREF="gsl_manual.html#IDX1832">gsl_ntuple_open</A>
<LI><A HREF="gsl_manual.html#IDX1841">gsl_ntuple_project</A>
<LI><A HREF="gsl_manual.html#IDX1835">gsl_ntuple_read</A>
<LI><A HREF="gsl_manual.html#IDX1833">gsl_ntuple_write</A>
<LI><A HREF="gsl_manual.html#IDX1935">gsl_odeiv_control_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1937">gsl_odeiv_control_free</A>
<LI><A HREF="gsl_manual.html#IDX1938">gsl_odeiv_control_hadjust</A>
<LI><A HREF="gsl_manual.html#IDX1936">gsl_odeiv_control_init</A>
<LI><A HREF="gsl_manual.html#IDX1939">gsl_odeiv_control_name</A>
<LI><A HREF="gsl_manual.html#IDX1934">gsl_odeiv_control_scaled_new</A>
<LI><A HREF="gsl_manual.html#IDX1931">gsl_odeiv_control_standard_new</A>
<LI><A HREF="gsl_manual.html#IDX1932">gsl_odeiv_control_y_new</A>
<LI><A HREF="gsl_manual.html#IDX1933">gsl_odeiv_control_yp_new</A>
<LI><A HREF="gsl_manual.html#IDX1940">gsl_odeiv_evolve_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1941">gsl_odeiv_evolve_apply</A>
<LI><A HREF="gsl_manual.html#IDX1943">gsl_odeiv_evolve_free</A>
<LI><A HREF="gsl_manual.html#IDX1942">gsl_odeiv_evolve_reset</A>
<LI><A HREF="gsl_manual.html#IDX1901">gsl_odeiv_step_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1906">gsl_odeiv_step_apply</A>
<LI><A HREF="gsl_manual.html#IDX1923">gsl_odeiv_step_bsimp</A>
<LI><A HREF="gsl_manual.html#IDX1903">gsl_odeiv_step_free</A>
<LI><A HREF="gsl_manual.html#IDX1927">gsl_odeiv_step_gear1</A>
<LI><A HREF="gsl_manual.html#IDX1929">gsl_odeiv_step_gear2</A>
<LI><A HREF="gsl_manual.html#IDX1904">gsl_odeiv_step_name</A>
<LI><A HREF="gsl_manual.html#IDX1905">gsl_odeiv_step_order</A>
<LI><A HREF="gsl_manual.html#IDX1902">gsl_odeiv_step_reset</A>
<LI><A HREF="gsl_manual.html#IDX1907">gsl_odeiv_step_rk2</A>
<LI><A HREF="gsl_manual.html#IDX1921">gsl_odeiv_step_rk2imp</A>
<LI><A HREF="gsl_manual.html#IDX1910">gsl_odeiv_step_rk4</A>
<LI><A HREF="gsl_manual.html#IDX1922">gsl_odeiv_step_rk4imp</A>
<LI><A HREF="gsl_manual.html#IDX1918">gsl_odeiv_step_rk8pd</A>
<LI><A HREF="gsl_manual.html#IDX1915">gsl_odeiv_step_rkck</A>
<LI><A HREF="gsl_manual.html#IDX1912">gsl_odeiv_step_rkf45</A>
<LI><A HREF="gsl_manual.html#IDX950">gsl_permutation_alloc</A>
<LI><A HREF="gsl_manual.html#IDX951">gsl_permutation_calloc</A>
<LI><A HREF="gsl_manual.html#IDX985">gsl_permutation_canonical_cycles</A>
<LI><A HREF="gsl_manual.html#IDX982">gsl_permutation_canonical_to_linear</A>
<LI><A HREF="gsl_manual.html#IDX961">gsl_permutation_data</A>
<LI><A HREF="gsl_manual.html#IDX979">gsl_permutation_fprintf</A>
<LI><A HREF="gsl_manual.html#IDX978">gsl_permutation_fread</A>
<LI><A HREF="gsl_manual.html#IDX954">gsl_permutation_free</A>
<LI><A HREF="gsl_manual.html#IDX980">gsl_permutation_fscanf</A>
<LI><A HREF="gsl_manual.html#IDX977">gsl_permutation_fwrite</A>
<LI><A HREF="gsl_manual.html#IDX956">gsl_permutation_get</A>
<LI><A HREF="gsl_manual.html#IDX952">gsl_permutation_init</A>
<LI><A HREF="gsl_manual.html#IDX967">gsl_permutation_inverse</A>
<LI><A HREF="gsl_manual.html#IDX983">gsl_permutation_inversions</A>
<LI><A HREF="gsl_manual.html#IDX984">gsl_permutation_linear_cycles</A>
<LI><A HREF="gsl_manual.html#IDX981">gsl_permutation_linear_to_canonical</A>
<LI><A HREF="gsl_manual.html#IDX955">gsl_permutation_memcpy</A>
<LI><A HREF="gsl_manual.html#IDX976">gsl_permutation_mul</A>
<LI><A HREF="gsl_manual.html#IDX969">gsl_permutation_next</A>
<LI><A HREF="gsl_manual.html#IDX971">gsl_permutation_prev</A>
<LI><A HREF="gsl_manual.html#IDX965">gsl_permutation_reverse</A>
<LI><A HREF="gsl_manual.html#IDX960">gsl_permutation_size</A>
<LI><A HREF="gsl_manual.html#IDX957">gsl_permutation_swap</A>
<LI><A HREF="gsl_manual.html#IDX962">gsl_permutation_valid</A>
<LI><A HREF="gsl_manual.html#IDX972">gsl_permute</A>
<LI><A HREF="gsl_manual.html#IDX973">gsl_permute_inverse</A>
<LI><A HREF="gsl_manual.html#IDX974">gsl_permute_vector</A>
<LI><A HREF="gsl_manual.html#IDX975">gsl_permute_vector_inverse</A>
<LI><A HREF="gsl_manual.html#IDX232">gsl_poly_complex_solve</A>
<LI><A HREF="gsl_manual.html#IDX228">gsl_poly_complex_solve_cubic</A>
<LI><A HREF="gsl_manual.html#IDX225">gsl_poly_complex_solve_quadratic</A>
<LI><A HREF="gsl_manual.html#IDX230">gsl_poly_complex_workspace_alloc</A>
<LI><A HREF="gsl_manual.html#IDX231">gsl_poly_complex_workspace_free</A>
<LI><A HREF="gsl_manual.html#IDX221">gsl_poly_dd_eval</A>
<LI><A HREF="gsl_manual.html#IDX220">gsl_poly_dd_init</A>
<LI><A HREF="gsl_manual.html#IDX222">gsl_poly_dd_taylor</A>
<LI><A HREF="gsl_manual.html#IDX217">gsl_poly_eval</A>
<LI><A HREF="gsl_manual.html#IDX227">gsl_poly_solve_cubic</A>
<LI><A HREF="gsl_manual.html#IDX224">gsl_poly_solve_quadratic</A>
<LI><A HREF="gsl_manual.html#IDX74">GSL_POSINF</A>
<LI><A HREF="gsl_manual.html#IDX107">gsl_pow_2</A>
<LI><A HREF="gsl_manual.html#IDX108">gsl_pow_3</A>
<LI><A HREF="gsl_manual.html#IDX109">gsl_pow_4</A>
<LI><A HREF="gsl_manual.html#IDX110">gsl_pow_5</A>
<LI><A HREF="gsl_manual.html#IDX111">gsl_pow_6</A>
<LI><A HREF="gsl_manual.html#IDX112">gsl_pow_7</A>
<LI><A HREF="gsl_manual.html#IDX113">gsl_pow_8</A>
<LI><A HREF="gsl_manual.html#IDX114">gsl_pow_9</A>
<LI><A HREF="gsl_manual.html#IDX106">gsl_pow_int</A>
<LI><A HREF="gsl_manual.html#IDX1452">gsl_qrng_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1460">gsl_qrng_clone</A>
<LI><A HREF="gsl_manual.html#IDX1453">gsl_qrng_free</A>
<LI><A HREF="gsl_manual.html#IDX1455">gsl_qrng_get</A>
<LI><A HREF="gsl_manual.html#IDX1454">gsl_qrng_init</A>
<LI><A HREF="gsl_manual.html#IDX1459">gsl_qrng_memcpy</A>
<LI><A HREF="gsl_manual.html#IDX1456">gsl_qrng_name</A>
<LI><A HREF="gsl_manual.html#IDX1461">gsl_qrng_niederreiter_2</A>
<LI><A HREF="gsl_manual.html#IDX1457">gsl_qrng_size</A>
<LI><A HREF="gsl_manual.html#IDX1462">gsl_qrng_sobol</A>
<LI><A HREF="gsl_manual.html#IDX1458">gsl_qrng_state</A>
<LI><A HREF="gsl_manual.html#IDX1650">gsl_ran_bernoulli</A>
<LI><A HREF="gsl_manual.html#IDX1652">gsl_ran_bernoulli_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1579">gsl_ran_beta</A>
<LI><A HREF="gsl_manual.html#IDX1581">gsl_ran_beta_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1653">gsl_ran_binomial</A>
<LI><A HREF="gsl_manual.html#IDX1655">gsl_ran_binomial_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1488">gsl_ran_bivariate_gaussian</A>
<LI><A HREF="gsl_manual.html#IDX1492">gsl_ran_bivariate_gaussian_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1511">gsl_ran_cauchy</A>
<LI><A HREF="gsl_manual.html#IDX1513">gsl_ran_cauchy_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1559">gsl_ran_chisq</A>
<LI><A HREF="gsl_manual.html#IDX1561">gsl_ran_chisq_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1676">gsl_ran_choose</A>
<LI><A HREF="gsl_manual.html#IDX1598">gsl_ran_dir_2d</A>
<LI><A HREF="gsl_manual.html#IDX1599">gsl_ran_dir_2d_trig_method</A>
<LI><A HREF="gsl_manual.html#IDX1603">gsl_ran_dir_3d</A>
<LI><A HREF="gsl_manual.html#IDX1607">gsl_ran_dir_nd</A>
<LI><A HREF="gsl_manual.html#IDX1634">gsl_ran_dirichlet</A>
<LI><A HREF="gsl_manual.html#IDX1637">gsl_ran_dirichlet_lnpdf</A>
<LI><A HREF="gsl_manual.html#IDX1636">gsl_ran_dirichlet_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1641">gsl_ran_discrete</A>
<LI><A HREF="gsl_manual.html#IDX1645">gsl_ran_discrete_free</A>
<LI><A HREF="gsl_manual.html#IDX1643">gsl_ran_discrete_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1638">gsl_ran_discrete_preproc</A>
<LI><A HREF="gsl_manual.html#IDX1493">gsl_ran_exponential</A>
<LI><A HREF="gsl_manual.html#IDX1495">gsl_ran_exponential_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1508">gsl_ran_exppow</A>
<LI><A HREF="gsl_manual.html#IDX1510">gsl_ran_exppow_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1566">gsl_ran_fdist</A>
<LI><A HREF="gsl_manual.html#IDX1568">gsl_ran_fdist_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1544">gsl_ran_flat</A>
<LI><A HREF="gsl_manual.html#IDX1547">gsl_ran_flat_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1536">gsl_ran_gamma</A>
<LI><A HREF="gsl_manual.html#IDX1539">gsl_ran_gamma_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1468">gsl_ran_gaussian</A>
<LI><A HREF="gsl_manual.html#IDX1470">gsl_ran_gaussian_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1471">gsl_ran_gaussian_ratio_method</A>
<LI><A HREF="gsl_manual.html#IDX1483">gsl_ran_gaussian_tail</A>
<LI><A HREF="gsl_manual.html#IDX1485">gsl_ran_gaussian_tail_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1665">gsl_ran_geometric</A>
<LI><A HREF="gsl_manual.html#IDX1667">gsl_ran_geometric_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1618">gsl_ran_gumbel1</A>
<LI><A HREF="gsl_manual.html#IDX1621">gsl_ran_gumbel1_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1626">gsl_ran_gumbel2</A>
<LI><A HREF="gsl_manual.html#IDX1629">gsl_ran_gumbel2_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1669">gsl_ran_hypergeometric</A>
<LI><A HREF="gsl_manual.html#IDX1671">gsl_ran_hypergeometric_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1528">gsl_ran_landau</A>
<LI><A HREF="gsl_manual.html#IDX1530">gsl_ran_landau_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1500">gsl_ran_laplace</A>
<LI><A HREF="gsl_manual.html#IDX1503">gsl_ran_laplace_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1531">gsl_ran_levy</A>
<LI><A HREF="gsl_manual.html#IDX1533">gsl_ran_levy_skew</A>
<LI><A HREF="gsl_manual.html#IDX1672">gsl_ran_logarithmic</A>
<LI><A HREF="gsl_manual.html#IDX1674">gsl_ran_logarithmic_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1584">gsl_ran_logistic</A>
<LI><A HREF="gsl_manual.html#IDX1586">gsl_ran_logistic_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1552">gsl_ran_lognormal</A>
<LI><A HREF="gsl_manual.html#IDX1554">gsl_ran_lognormal_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1656">gsl_ran_multinomial</A>
<LI><A HREF="gsl_manual.html#IDX1659">gsl_ran_multinomial_lnpdf</A>
<LI><A HREF="gsl_manual.html#IDX1658">gsl_ran_multinomial_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1660">gsl_ran_negative_binomial</A>
<LI><A HREF="gsl_manual.html#IDX1662">gsl_ran_negative_binomial_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1591">gsl_ran_pareto</A>
<LI><A HREF="gsl_manual.html#IDX1593">gsl_ran_pareto_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1663">gsl_ran_pascal</A>
<LI><A HREF="gsl_manual.html#IDX1664">gsl_ran_pascal_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1647">gsl_ran_poisson</A>
<LI><A HREF="gsl_manual.html#IDX1649">gsl_ran_poisson_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1518">gsl_ran_rayleigh</A>
<LI><A HREF="gsl_manual.html#IDX1520">gsl_ran_rayleigh_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1525">gsl_ran_rayleigh_tail</A>
<LI><A HREF="gsl_manual.html#IDX1527">gsl_ran_rayleigh_tail_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1677">gsl_ran_sample</A>
<LI><A HREF="gsl_manual.html#IDX1675">gsl_ran_shuffle</A>
<LI><A HREF="gsl_manual.html#IDX1571">gsl_ran_tdist</A>
<LI><A HREF="gsl_manual.html#IDX1574">gsl_ran_tdist_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1472">gsl_ran_ugaussian</A>
<LI><A HREF="gsl_manual.html#IDX1473">gsl_ran_ugaussian_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1474">gsl_ran_ugaussian_ratio_method</A>
<LI><A HREF="gsl_manual.html#IDX1486">gsl_ran_ugaussian_tail</A>
<LI><A HREF="gsl_manual.html#IDX1487">gsl_ran_ugaussian_tail_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1611">gsl_ran_weibull</A>
<LI><A HREF="gsl_manual.html#IDX1613">gsl_ran_weibull_pdf</A>
<LI><A HREF="gsl_manual.html#IDX137">GSL_REAL</A>
<LI><A HREF="gsl_manual.html#IDX1369">gsl_rng_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1439">gsl_rng_borosh13</A>
<LI><A HREF="gsl_manual.html#IDX1384">gsl_rng_clone</A>
<LI><A HREF="gsl_manual.html#IDX1399">gsl_rng_cmrg</A>
<LI><A HREF="gsl_manual.html#IDX1440">gsl_rng_coveyou</A>
<LI><A HREF="gsl_manual.html#IDX1382">gsl_rng_env_setup</A>
<LI><A HREF="gsl_manual.html#IDX1441">gsl_rng_fishman18</A>
<LI><A HREF="gsl_manual.html#IDX1442">gsl_rng_fishman20</A>
<LI><A HREF="gsl_manual.html#IDX1443">gsl_rng_fishman2x</A>
<LI><A HREF="gsl_manual.html#IDX1386">gsl_rng_fread</A>
<LI><A HREF="gsl_manual.html#IDX1371">gsl_rng_free</A>
<LI><A HREF="gsl_manual.html#IDX1385">gsl_rng_fwrite</A>
<LI><A HREF="gsl_manual.html#IDX1372">gsl_rng_get</A>
<LI><A HREF="gsl_manual.html#IDX1406">gsl_rng_gfsr4</A>
<LI><A HREF="gsl_manual.html#IDX1445">gsl_rng_knuthran</A>
<LI><A HREF="gsl_manual.html#IDX1444">gsl_rng_knuthran2</A>
<LI><A HREF="gsl_manual.html#IDX1446">gsl_rng_lecuyer21</A>
<LI><A HREF="gsl_manual.html#IDX1377">gsl_rng_max</A>
<LI><A HREF="gsl_manual.html#IDX1383">gsl_rng_memcpy</A>
<LI><A HREF="gsl_manual.html#IDX1378">gsl_rng_min</A>
<LI><A HREF="gsl_manual.html#IDX1433">gsl_rng_minstd</A>
<LI><A HREF="gsl_manual.html#IDX1401">gsl_rng_mrg</A>
<LI><A HREF="gsl_manual.html#IDX1387">gsl_rng_mt19937</A>
<LI><A HREF="gsl_manual.html#IDX1376">gsl_rng_name</A>
<LI><A HREF="gsl_manual.html#IDX1423">gsl_rng_r250</A>
<LI><A HREF="gsl_manual.html#IDX1411">gsl_rng_rand</A>
<LI><A HREF="gsl_manual.html#IDX1416">gsl_rng_rand48</A>
<LI><A HREF="gsl_manual.html#IDX1413">gsl_rng_random_bsd</A>
<LI><A HREF="gsl_manual.html#IDX1415">gsl_rng_random_glibc2</A>
<LI><A HREF="gsl_manual.html#IDX1414">gsl_rng_random_libc5</A>
<LI><A HREF="gsl_manual.html#IDX1431">gsl_rng_randu</A>
<LI><A HREF="gsl_manual.html#IDX1418">gsl_rng_ranf</A>
<LI><A HREF="gsl_manual.html#IDX1396">gsl_rng_ranlux</A>
<LI><A HREF="gsl_manual.html#IDX1397">gsl_rng_ranlux389</A>
<LI><A HREF="gsl_manual.html#IDX1393">gsl_rng_ranlxd1</A>
<LI><A HREF="gsl_manual.html#IDX1394">gsl_rng_ranlxd2</A>
<LI><A HREF="gsl_manual.html#IDX1389">gsl_rng_ranlxs0</A>
<LI><A HREF="gsl_manual.html#IDX1390">gsl_rng_ranlxs1</A>
<LI><A HREF="gsl_manual.html#IDX1391">gsl_rng_ranlxs2</A>
<LI><A HREF="gsl_manual.html#IDX1421">gsl_rng_ranmar</A>
<LI><A HREF="gsl_manual.html#IDX1370">gsl_rng_set</A>
<LI><A HREF="gsl_manual.html#IDX1380">gsl_rng_size</A>
<LI><A HREF="gsl_manual.html#IDX1437">gsl_rng_slatec</A>
<LI><A HREF="gsl_manual.html#IDX1379">gsl_rng_state</A>
<LI><A HREF="gsl_manual.html#IDX1403">gsl_rng_taus</A>
<LI><A HREF="gsl_manual.html#IDX1404">gsl_rng_taus2</A>
<LI><A HREF="gsl_manual.html#IDX1430">gsl_rng_transputer</A>
<LI><A HREF="gsl_manual.html#IDX1426">gsl_rng_tt800</A>
<LI><A HREF="gsl_manual.html#IDX1381">gsl_rng_types_setup</A>
<LI><A HREF="gsl_manual.html#IDX1435">gsl_rng_uni</A>
<LI><A HREF="gsl_manual.html#IDX1436">gsl_rng_uni32</A>
<LI><A HREF="gsl_manual.html#IDX1373">gsl_rng_uniform</A>
<LI><A HREF="gsl_manual.html#IDX1375">gsl_rng_uniform_int</A>
<LI><A HREF="gsl_manual.html#IDX1374">gsl_rng_uniform_pos</A>
<LI><A HREF="gsl_manual.html#IDX1428">gsl_rng_vax</A>
<LI><A HREF="gsl_manual.html#IDX1447">gsl_rng_waterman14</A>
<LI><A HREF="gsl_manual.html#IDX1438">gsl_rng_zuf</A>
<LI><A HREF="gsl_manual.html#IDX2075">gsl_root_fdfsolver_alloc</A>
<LI><A HREF="gsl_manual.html#IDX2079">gsl_root_fdfsolver_free</A>
<LI><A HREF="gsl_manual.html#IDX2088">gsl_root_fdfsolver_iterate</A>
<LI><A HREF="gsl_manual.html#IDX2081">gsl_root_fdfsolver_name</A>
<LI><A HREF="gsl_manual.html#IDX2106">gsl_root_fdfsolver_newton</A>
<LI><A HREF="gsl_manual.html#IDX2090">gsl_root_fdfsolver_root</A>
<LI><A HREF="gsl_manual.html#IDX2109">gsl_root_fdfsolver_secant</A>
<LI><A HREF="gsl_manual.html#IDX2077">gsl_root_fdfsolver_set</A>
<LI><A HREF="gsl_manual.html#IDX2112">gsl_root_fdfsolver_steffenson</A>
<LI><A HREF="gsl_manual.html#IDX2074">gsl_root_fsolver_alloc</A>
<LI><A HREF="gsl_manual.html#IDX2097">gsl_root_fsolver_bisection</A>
<LI><A HREF="gsl_manual.html#IDX2103">gsl_root_fsolver_brent</A>
<LI><A HREF="gsl_manual.html#IDX2100">gsl_root_fsolver_falsepos</A>
<LI><A HREF="gsl_manual.html#IDX2078">gsl_root_fsolver_free</A>
<LI><A HREF="gsl_manual.html#IDX2087">gsl_root_fsolver_iterate</A>
<LI><A HREF="gsl_manual.html#IDX2080">gsl_root_fsolver_name</A>
<LI><A HREF="gsl_manual.html#IDX2089">gsl_root_fsolver_root</A>
<LI><A HREF="gsl_manual.html#IDX2076">gsl_root_fsolver_set</A>
<LI><A HREF="gsl_manual.html#IDX2091">gsl_root_fsolver_x_lower</A>
<LI><A HREF="gsl_manual.html#IDX2092">gsl_root_fsolver_x_upper</A>
<LI><A HREF="gsl_manual.html#IDX2095">gsl_root_test_delta</A>
<LI><A HREF="gsl_manual.html#IDX2094">gsl_root_test_interval</A>
<LI><A HREF="gsl_manual.html#IDX2096">gsl_root_test_residual</A>
<LI><A HREF="gsl_manual.html#IDX139">GSL_SET_COMPLEX</A>
<LI><A HREF="gsl_manual.html#IDX55">gsl_set_error_handler</A>
<LI><A HREF="gsl_manual.html#IDX56">gsl_set_error_handler_off</A>
<LI><A HREF="gsl_manual.html#IDX141">GSL_SET_IMAG</A>
<LI><A HREF="gsl_manual.html#IDX140">GSL_SET_REAL</A>
<LI><A HREF="gsl_manual.html#IDX239">gsl_sf_airy_Ai</A>
<LI><A HREF="gsl_manual.html#IDX247">gsl_sf_airy_Ai_deriv</A>
<LI><A HREF="gsl_manual.html#IDX248">gsl_sf_airy_Ai_deriv_e</A>
<LI><A HREF="gsl_manual.html#IDX251">gsl_sf_airy_Ai_deriv_scaled</A>
<LI><A HREF="gsl_manual.html#IDX252">gsl_sf_airy_Ai_deriv_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX240">gsl_sf_airy_Ai_e</A>
<LI><A HREF="gsl_manual.html#IDX243">gsl_sf_airy_Ai_scaled</A>
<LI><A HREF="gsl_manual.html#IDX244">gsl_sf_airy_Ai_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX241">gsl_sf_airy_Bi</A>
<LI><A HREF="gsl_manual.html#IDX249">gsl_sf_airy_Bi_deriv</A>
<LI><A HREF="gsl_manual.html#IDX250">gsl_sf_airy_Bi_deriv_e</A>
<LI><A HREF="gsl_manual.html#IDX253">gsl_sf_airy_Bi_deriv_scaled</A>
<LI><A HREF="gsl_manual.html#IDX254">gsl_sf_airy_Bi_deriv_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX242">gsl_sf_airy_Bi_e</A>
<LI><A HREF="gsl_manual.html#IDX245">gsl_sf_airy_Bi_scaled</A>
<LI><A HREF="gsl_manual.html#IDX246">gsl_sf_airy_Bi_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX255">gsl_sf_airy_zero_Ai</A>
<LI><A HREF="gsl_manual.html#IDX259">gsl_sf_airy_zero_Ai_deriv</A>
<LI><A HREF="gsl_manual.html#IDX260">gsl_sf_airy_zero_Ai_deriv_e</A>
<LI><A HREF="gsl_manual.html#IDX256">gsl_sf_airy_zero_Ai_e</A>
<LI><A HREF="gsl_manual.html#IDX257">gsl_sf_airy_zero_Bi</A>
<LI><A HREF="gsl_manual.html#IDX261">gsl_sf_airy_zero_Bi_deriv</A>
<LI><A HREF="gsl_manual.html#IDX262">gsl_sf_airy_zero_Bi_deriv_e</A>
<LI><A HREF="gsl_manual.html#IDX258">gsl_sf_airy_zero_Bi_e</A>
<LI><A HREF="gsl_manual.html#IDX787">gsl_sf_angle_restrict_pos</A>
<LI><A HREF="gsl_manual.html#IDX788">gsl_sf_angle_restrict_pos_e</A>
<LI><A HREF="gsl_manual.html#IDX785">gsl_sf_angle_restrict_symm</A>
<LI><A HREF="gsl_manual.html#IDX786">gsl_sf_angle_restrict_symm_e</A>
<LI><A HREF="gsl_manual.html#IDX521">gsl_sf_atanint</A>
<LI><A HREF="gsl_manual.html#IDX522">gsl_sf_atanint_e</A>
<LI><A HREF="gsl_manual.html#IDX283">gsl_sf_bessel_I0</A>
<LI><A HREF="gsl_manual.html#IDX284">gsl_sf_bessel_I0_e</A>
<LI><A HREF="gsl_manual.html#IDX336">gsl_sf_bessel_i0_scaled</A>
<LI><A HREF="gsl_manual.html#IDX290">gsl_sf_bessel_I0_scaled</A>
<LI><A HREF="gsl_manual.html#IDX291">gsl_sf_bessel_I0_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX337">gsl_sf_bessel_i0_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX285">gsl_sf_bessel_I1</A>
<LI><A HREF="gsl_manual.html#IDX286">gsl_sf_bessel_I1_e</A>
<LI><A HREF="gsl_manual.html#IDX292">gsl_sf_bessel_I1_scaled</A>
<LI><A HREF="gsl_manual.html#IDX338">gsl_sf_bessel_i1_scaled</A>
<LI><A HREF="gsl_manual.html#IDX339">gsl_sf_bessel_i1_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX293">gsl_sf_bessel_I1_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX340">gsl_sf_bessel_i2_scaled</A>
<LI><A HREF="gsl_manual.html#IDX341">gsl_sf_bessel_i2_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX342">gsl_sf_bessel_il_scaled</A>
<LI><A HREF="gsl_manual.html#IDX344">gsl_sf_bessel_il_scaled_array</A>
<LI><A HREF="gsl_manual.html#IDX343">gsl_sf_bessel_il_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX287">gsl_sf_bessel_In</A>
<LI><A HREF="gsl_manual.html#IDX289">gsl_sf_bessel_In_array</A>
<LI><A HREF="gsl_manual.html#IDX288">gsl_sf_bessel_In_e</A>
<LI><A HREF="gsl_manual.html#IDX294">gsl_sf_bessel_In_scaled</A>
<LI><A HREF="gsl_manual.html#IDX296">gsl_sf_bessel_In_scaled_array</A>
<LI><A HREF="gsl_manual.html#IDX295">gsl_sf_bessel_In_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX365">gsl_sf_bessel_Inu</A>
<LI><A HREF="gsl_manual.html#IDX366">gsl_sf_bessel_Inu_e</A>
<LI><A HREF="gsl_manual.html#IDX367">gsl_sf_bessel_Inu_scaled</A>
<LI><A HREF="gsl_manual.html#IDX368">gsl_sf_bessel_Inu_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX266">gsl_sf_bessel_J0</A>
<LI><A HREF="gsl_manual.html#IDX314">gsl_sf_bessel_j0</A>
<LI><A HREF="gsl_manual.html#IDX267">gsl_sf_bessel_J0_e</A>
<LI><A HREF="gsl_manual.html#IDX315">gsl_sf_bessel_j0_e</A>
<LI><A HREF="gsl_manual.html#IDX316">gsl_sf_bessel_j1</A>
<LI><A HREF="gsl_manual.html#IDX268">gsl_sf_bessel_J1</A>
<LI><A HREF="gsl_manual.html#IDX269">gsl_sf_bessel_J1_e</A>
<LI><A HREF="gsl_manual.html#IDX317">gsl_sf_bessel_j1_e</A>
<LI><A HREF="gsl_manual.html#IDX318">gsl_sf_bessel_j2</A>
<LI><A HREF="gsl_manual.html#IDX319">gsl_sf_bessel_j2_e</A>
<LI><A HREF="gsl_manual.html#IDX320">gsl_sf_bessel_jl</A>
<LI><A HREF="gsl_manual.html#IDX322">gsl_sf_bessel_jl_array</A>
<LI><A HREF="gsl_manual.html#IDX321">gsl_sf_bessel_jl_e</A>
<LI><A HREF="gsl_manual.html#IDX323">gsl_sf_bessel_jl_steed_array</A>
<LI><A HREF="gsl_manual.html#IDX270">gsl_sf_bessel_Jn</A>
<LI><A HREF="gsl_manual.html#IDX272">gsl_sf_bessel_Jn_array</A>
<LI><A HREF="gsl_manual.html#IDX271">gsl_sf_bessel_Jn_e</A>
<LI><A HREF="gsl_manual.html#IDX358">gsl_sf_bessel_Jnu</A>
<LI><A HREF="gsl_manual.html#IDX359">gsl_sf_bessel_Jnu_e</A>
<LI><A HREF="gsl_manual.html#IDX298">gsl_sf_bessel_K0</A>
<LI><A HREF="gsl_manual.html#IDX299">gsl_sf_bessel_K0_e</A>
<LI><A HREF="gsl_manual.html#IDX346">gsl_sf_bessel_k0_scaled</A>
<LI><A HREF="gsl_manual.html#IDX305">gsl_sf_bessel_K0_scaled</A>
<LI><A HREF="gsl_manual.html#IDX347">gsl_sf_bessel_k0_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX306">gsl_sf_bessel_K0_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX300">gsl_sf_bessel_K1</A>
<LI><A HREF="gsl_manual.html#IDX301">gsl_sf_bessel_K1_e</A>
<LI><A HREF="gsl_manual.html#IDX348">gsl_sf_bessel_k1_scaled</A>
<LI><A HREF="gsl_manual.html#IDX307">gsl_sf_bessel_K1_scaled</A>
<LI><A HREF="gsl_manual.html#IDX349">gsl_sf_bessel_k1_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX308">gsl_sf_bessel_K1_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX350">gsl_sf_bessel_k2_scaled</A>
<LI><A HREF="gsl_manual.html#IDX351">gsl_sf_bessel_k2_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX352">gsl_sf_bessel_kl_scaled</A>
<LI><A HREF="gsl_manual.html#IDX354">gsl_sf_bessel_kl_scaled_array</A>
<LI><A HREF="gsl_manual.html#IDX353">gsl_sf_bessel_kl_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX302">gsl_sf_bessel_Kn</A>
<LI><A HREF="gsl_manual.html#IDX304">gsl_sf_bessel_Kn_array</A>
<LI><A HREF="gsl_manual.html#IDX303">gsl_sf_bessel_Kn_e</A>
<LI><A HREF="gsl_manual.html#IDX309">gsl_sf_bessel_Kn_scaled</A>
<LI><A HREF="gsl_manual.html#IDX311">gsl_sf_bessel_Kn_scaled_array</A>
<LI><A HREF="gsl_manual.html#IDX310">gsl_sf_bessel_Kn_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX370">gsl_sf_bessel_Knu</A>
<LI><A HREF="gsl_manual.html#IDX371">gsl_sf_bessel_Knu_e</A>
<LI><A HREF="gsl_manual.html#IDX374">gsl_sf_bessel_Knu_scaled</A>
<LI><A HREF="gsl_manual.html#IDX375">gsl_sf_bessel_Knu_scaled_e</A>
<LI><A HREF="gsl_manual.html#IDX372">gsl_sf_bessel_lnKnu</A>
<LI><A HREF="gsl_manual.html#IDX373">gsl_sf_bessel_lnKnu_e</A>
<LI><A HREF="gsl_manual.html#IDX360">gsl_sf_bessel_sequence_Jnu_e</A>
<LI><A HREF="gsl_manual.html#IDX274">gsl_sf_bessel_Y0</A>
<LI><A HREF="gsl_manual.html#IDX325">gsl_sf_bessel_y0</A>
<LI><A HREF="gsl_manual.html#IDX326">gsl_sf_bessel_y0_e</A>
<LI><A HREF="gsl_manual.html#IDX275">gsl_sf_bessel_Y0_e</A>
<LI><A HREF="gsl_manual.html#IDX327">gsl_sf_bessel_y1</A>
<LI><A HREF="gsl_manual.html#IDX276">gsl_sf_bessel_Y1</A>
<LI><A HREF="gsl_manual.html#IDX328">gsl_sf_bessel_y1_e</A>
<LI><A HREF="gsl_manual.html#IDX277">gsl_sf_bessel_Y1_e</A>
<LI><A HREF="gsl_manual.html#IDX329">gsl_sf_bessel_y2</A>
<LI><A HREF="gsl_manual.html#IDX330">gsl_sf_bessel_y2_e</A>
<LI><A HREF="gsl_manual.html#IDX331">gsl_sf_bessel_yl</A>
<LI><A HREF="gsl_manual.html#IDX333">gsl_sf_bessel_yl_array</A>
<LI><A HREF="gsl_manual.html#IDX332">gsl_sf_bessel_yl_e</A>
<LI><A HREF="gsl_manual.html#IDX278">gsl_sf_bessel_Yn</A>
<LI><A HREF="gsl_manual.html#IDX280">gsl_sf_bessel_Yn_array</A>
<LI><A HREF="gsl_manual.html#IDX279">gsl_sf_bessel_Yn_e</A>
<LI><A HREF="gsl_manual.html#IDX361">gsl_sf_bessel_Ynu</A>
<LI><A HREF="gsl_manual.html#IDX362">gsl_sf_bessel_Ynu_e</A>
<LI><A HREF="gsl_manual.html#IDX378">gsl_sf_bessel_zero_J0</A>
<LI><A HREF="gsl_manual.html#IDX379">gsl_sf_bessel_zero_J0_e</A>
<LI><A HREF="gsl_manual.html#IDX380">gsl_sf_bessel_zero_J1</A>
<LI><A HREF="gsl_manual.html#IDX381">gsl_sf_bessel_zero_J1_e</A>
<LI><A HREF="gsl_manual.html#IDX382">gsl_sf_bessel_zero_Jnu</A>
<LI><A HREF="gsl_manual.html#IDX383">gsl_sf_bessel_zero_Jnu_e</A>
<LI><A HREF="gsl_manual.html#IDX602">gsl_sf_beta</A>
<LI><A HREF="gsl_manual.html#IDX603">gsl_sf_beta_e</A>
<LI><A HREF="gsl_manual.html#IDX608">gsl_sf_beta_inc</A>
<LI><A HREF="gsl_manual.html#IDX609">gsl_sf_beta_inc_e</A>
<LI><A HREF="gsl_manual.html#IDX509">gsl_sf_Chi</A>
<LI><A HREF="gsl_manual.html#IDX510">gsl_sf_Chi_e</A>
<LI><A HREF="gsl_manual.html#IDX576">gsl_sf_choose</A>
<LI><A HREF="gsl_manual.html#IDX577">gsl_sf_choose_e</A>
<LI><A HREF="gsl_manual.html#IDX518">gsl_sf_Ci</A>
<LI><A HREF="gsl_manual.html#IDX519">gsl_sf_Ci_e</A>
<LI><A HREF="gsl_manual.html#IDX385">gsl_sf_clausen</A>
<LI><A HREF="gsl_manual.html#IDX386">gsl_sf_clausen_e</A>
<LI><A HREF="gsl_manual.html#IDX769">gsl_sf_complex_cos_e</A>
<LI><A HREF="gsl_manual.html#IDX427">gsl_sf_complex_dilog_e</A>
<LI><A HREF="gsl_manual.html#IDX716">gsl_sf_complex_log_e</A>
<LI><A HREF="gsl_manual.html#IDX771">gsl_sf_complex_logsin_e</A>
<LI><A HREF="gsl_manual.html#IDX767">gsl_sf_complex_sin_e</A>
<LI><A HREF="gsl_manual.html#IDX696">gsl_sf_conicalP_0</A>
<LI><A HREF="gsl_manual.html#IDX697">gsl_sf_conicalP_0_e</A>
<LI><A HREF="gsl_manual.html#IDX698">gsl_sf_conicalP_1</A>
<LI><A HREF="gsl_manual.html#IDX699">gsl_sf_conicalP_1_e</A>
<LI><A HREF="gsl_manual.html#IDX702">gsl_sf_conicalP_cyl_reg</A>
<LI><A HREF="gsl_manual.html#IDX703">gsl_sf_conicalP_cyl_reg_e</A>
<LI><A HREF="gsl_manual.html#IDX692">gsl_sf_conicalP_half</A>
<LI><A HREF="gsl_manual.html#IDX693">gsl_sf_conicalP_half_e</A>
<LI><A HREF="gsl_manual.html#IDX694">gsl_sf_conicalP_mhalf</A>
<LI><A HREF="gsl_manual.html#IDX695">gsl_sf_conicalP_mhalf_e</A>
<LI><A HREF="gsl_manual.html#IDX700">gsl_sf_conicalP_sph_reg</A>
<LI><A HREF="gsl_manual.html#IDX701">gsl_sf_conicalP_sph_reg_e</A>
<LI><A HREF="gsl_manual.html#IDX758">gsl_sf_cos</A>
<LI><A HREF="gsl_manual.html#IDX759">gsl_sf_cos_e</A>
<LI><A HREF="gsl_manual.html#IDX791">gsl_sf_cos_err</A>
<LI><A HREF="gsl_manual.html#IDX792">gsl_sf_cos_err_e</A>
<LI><A HREF="gsl_manual.html#IDX399">gsl_sf_coulomb_CL_array</A>
<LI><A HREF="gsl_manual.html#IDX398">gsl_sf_coulomb_CL_e</A>
<LI><A HREF="gsl_manual.html#IDX394">gsl_sf_coulomb_wave_F_array</A>
<LI><A HREF="gsl_manual.html#IDX395">gsl_sf_coulomb_wave_FG_array</A>
<LI><A HREF="gsl_manual.html#IDX393">gsl_sf_coulomb_wave_FG_e</A>
<LI><A HREF="gsl_manual.html#IDX396">gsl_sf_coulomb_wave_FGp_array</A>
<LI><A HREF="gsl_manual.html#IDX397">gsl_sf_coulomb_wave_sphF_array</A>
<LI><A HREF="gsl_manual.html#IDX406">gsl_sf_coupling_3j</A>
<LI><A HREF="gsl_manual.html#IDX407">gsl_sf_coupling_3j_e</A>
<LI><A HREF="gsl_manual.html#IDX408">gsl_sf_coupling_6j</A>
<LI><A HREF="gsl_manual.html#IDX409">gsl_sf_coupling_6j_e</A>
<LI><A HREF="gsl_manual.html#IDX410">gsl_sf_coupling_9j</A>
<LI><A HREF="gsl_manual.html#IDX411">gsl_sf_coupling_9j_e</A>
<LI><A HREF="gsl_manual.html#IDX413">gsl_sf_dawson</A>
<LI><A HREF="gsl_manual.html#IDX414">gsl_sf_dawson_e</A>
<LI><A HREF="gsl_manual.html#IDX416">gsl_sf_debye_1</A>
<LI><A HREF="gsl_manual.html#IDX417">gsl_sf_debye_1_e</A>
<LI><A HREF="gsl_manual.html#IDX418">gsl_sf_debye_2</A>
<LI><A HREF="gsl_manual.html#IDX419">gsl_sf_debye_2_e</A>
<LI><A HREF="gsl_manual.html#IDX420">gsl_sf_debye_3</A>
<LI><A HREF="gsl_manual.html#IDX421">gsl_sf_debye_3_e</A>
<LI><A HREF="gsl_manual.html#IDX422">gsl_sf_debye_4</A>
<LI><A HREF="gsl_manual.html#IDX423">gsl_sf_debye_4_e</A>
<LI><A HREF="gsl_manual.html#IDX425">gsl_sf_dilog</A>
<LI><A HREF="gsl_manual.html#IDX426">gsl_sf_dilog_e</A>
<LI><A HREF="gsl_manual.html#IDX567">gsl_sf_doublefact</A>
<LI><A HREF="gsl_manual.html#IDX568">gsl_sf_doublefact_e</A>
<LI><A HREF="gsl_manual.html#IDX445">gsl_sf_ellint_D</A>
<LI><A HREF="gsl_manual.html#IDX446">gsl_sf_ellint_D_e</A>
<LI><A HREF="gsl_manual.html#IDX441">gsl_sf_ellint_E</A>
<LI><A HREF="gsl_manual.html#IDX442">gsl_sf_ellint_E_e</A>
<LI><A HREF="gsl_manual.html#IDX437">gsl_sf_ellint_Ecomp</A>
<LI><A HREF="gsl_manual.html#IDX438">gsl_sf_ellint_Ecomp_e</A>
<LI><A HREF="gsl_manual.html#IDX439">gsl_sf_ellint_F</A>
<LI><A HREF="gsl_manual.html#IDX440">gsl_sf_ellint_F_e</A>
<LI><A HREF="gsl_manual.html#IDX435">gsl_sf_ellint_Kcomp</A>
<LI><A HREF="gsl_manual.html#IDX436">gsl_sf_ellint_Kcomp_e</A>
<LI><A HREF="gsl_manual.html#IDX443">gsl_sf_ellint_P</A>
<LI><A HREF="gsl_manual.html#IDX444">gsl_sf_ellint_P_e</A>
<LI><A HREF="gsl_manual.html#IDX447">gsl_sf_ellint_RC</A>
<LI><A HREF="gsl_manual.html#IDX448">gsl_sf_ellint_RC_e</A>
<LI><A HREF="gsl_manual.html#IDX449">gsl_sf_ellint_RD</A>
<LI><A HREF="gsl_manual.html#IDX450">gsl_sf_ellint_RD_e</A>
<LI><A HREF="gsl_manual.html#IDX451">gsl_sf_ellint_RF</A>
<LI><A HREF="gsl_manual.html#IDX452">gsl_sf_ellint_RF_e</A>
<LI><A HREF="gsl_manual.html#IDX453">gsl_sf_ellint_RJ</A>
<LI><A HREF="gsl_manual.html#IDX454">gsl_sf_ellint_RJ_e</A>
<LI><A HREF="gsl_manual.html#IDX457">gsl_sf_elljac_e</A>
<LI><A HREF="gsl_manual.html#IDX461">gsl_sf_erf</A>
<LI><A HREF="gsl_manual.html#IDX462">gsl_sf_erf_e</A>
<LI><A HREF="gsl_manual.html#IDX469">gsl_sf_erf_Q</A>
<LI><A HREF="gsl_manual.html#IDX470">gsl_sf_erf_Q_e</A>
<LI><A HREF="gsl_manual.html#IDX467">gsl_sf_erf_Z</A>
<LI><A HREF="gsl_manual.html#IDX468">gsl_sf_erf_Z_e</A>
<LI><A HREF="gsl_manual.html#IDX463">gsl_sf_erfc</A>
<LI><A HREF="gsl_manual.html#IDX464">gsl_sf_erfc_e</A>
<LI><A HREF="gsl_manual.html#IDX806">gsl_sf_eta</A>
<LI><A HREF="gsl_manual.html#IDX807">gsl_sf_eta_e</A>
<LI><A HREF="gsl_manual.html#IDX804">gsl_sf_eta_int</A>
<LI><A HREF="gsl_manual.html#IDX805">gsl_sf_eta_int_e</A>
<LI><A HREF="gsl_manual.html#IDX477">gsl_sf_exp</A>
<LI><A HREF="gsl_manual.html#IDX478">gsl_sf_exp_e</A>
<LI><A HREF="gsl_manual.html#IDX479">gsl_sf_exp_e10_e</A>
<LI><A HREF="gsl_manual.html#IDX491">gsl_sf_exp_err_e</A>
<LI><A HREF="gsl_manual.html#IDX492">gsl_sf_exp_err_e10_e</A>
<LI><A HREF="gsl_manual.html#IDX480">gsl_sf_exp_mult</A>
<LI><A HREF="gsl_manual.html#IDX481">gsl_sf_exp_mult_e</A>
<LI><A HREF="gsl_manual.html#IDX482">gsl_sf_exp_mult_e10_e</A>
<LI><A HREF="gsl_manual.html#IDX493">gsl_sf_exp_mult_err_e</A>
<LI><A HREF="gsl_manual.html#IDX494">gsl_sf_exp_mult_err_e10_e</A>
<LI><A HREF="gsl_manual.html#IDX511">gsl_sf_expint_3</A>
<LI><A HREF="gsl_manual.html#IDX512">gsl_sf_expint_3_e</A>
<LI><A HREF="gsl_manual.html#IDX498">gsl_sf_expint_E1</A>
<LI><A HREF="gsl_manual.html#IDX499">gsl_sf_expint_E1_e</A>
<LI><A HREF="gsl_manual.html#IDX500">gsl_sf_expint_E2</A>
<LI><A HREF="gsl_manual.html#IDX501">gsl_sf_expint_E2_e</A>
<LI><A HREF="gsl_manual.html#IDX502">gsl_sf_expint_Ei</A>
<LI><A HREF="gsl_manual.html#IDX503">gsl_sf_expint_Ei_e</A>
<LI><A HREF="gsl_manual.html#IDX483">gsl_sf_expm1</A>
<LI><A HREF="gsl_manual.html#IDX484">gsl_sf_expm1_e</A>
<LI><A HREF="gsl_manual.html#IDX485">gsl_sf_exprel</A>
<LI><A HREF="gsl_manual.html#IDX487">gsl_sf_exprel_2</A>
<LI><A HREF="gsl_manual.html#IDX488">gsl_sf_exprel_2_e</A>
<LI><A HREF="gsl_manual.html#IDX486">gsl_sf_exprel_e</A>
<LI><A HREF="gsl_manual.html#IDX489">gsl_sf_exprel_n</A>
<LI><A HREF="gsl_manual.html#IDX490">gsl_sf_exprel_n_e</A>
<LI><A HREF="gsl_manual.html#IDX564">gsl_sf_fact</A>
<LI><A HREF="gsl_manual.html#IDX565">gsl_sf_fact_e</A>
<LI><A HREF="gsl_manual.html#IDX528">gsl_sf_fermi_dirac_0</A>
<LI><A HREF="gsl_manual.html#IDX529">gsl_sf_fermi_dirac_0_e</A>
<LI><A HREF="gsl_manual.html#IDX530">gsl_sf_fermi_dirac_1</A>
<LI><A HREF="gsl_manual.html#IDX531">gsl_sf_fermi_dirac_1_e</A>
<LI><A HREF="gsl_manual.html#IDX532">gsl_sf_fermi_dirac_2</A>
<LI><A HREF="gsl_manual.html#IDX533">gsl_sf_fermi_dirac_2_e</A>
<LI><A HREF="gsl_manual.html#IDX540">gsl_sf_fermi_dirac_3half</A>
<LI><A HREF="gsl_manual.html#IDX541">gsl_sf_fermi_dirac_3half_e</A>
<LI><A HREF="gsl_manual.html#IDX538">gsl_sf_fermi_dirac_half</A>
<LI><A HREF="gsl_manual.html#IDX539">gsl_sf_fermi_dirac_half_e</A>
<LI><A HREF="gsl_manual.html#IDX544">gsl_sf_fermi_dirac_inc_0</A>
<LI><A HREF="gsl_manual.html#IDX545">gsl_sf_fermi_dirac_inc_0_e</A>
<LI><A HREF="gsl_manual.html#IDX534">gsl_sf_fermi_dirac_int</A>
<LI><A HREF="gsl_manual.html#IDX535">gsl_sf_fermi_dirac_int_e</A>
<LI><A HREF="gsl_manual.html#IDX526">gsl_sf_fermi_dirac_m1</A>
<LI><A HREF="gsl_manual.html#IDX527">gsl_sf_fermi_dirac_m1_e</A>
<LI><A HREF="gsl_manual.html#IDX536">gsl_sf_fermi_dirac_mhalf</A>
<LI><A HREF="gsl_manual.html#IDX537">gsl_sf_fermi_dirac_mhalf_e</A>
<LI><A HREF="gsl_manual.html#IDX547">gsl_sf_gamma</A>
<LI><A HREF="gsl_manual.html#IDX548">gsl_sf_gamma_e</A>
<LI><A HREF="gsl_manual.html#IDX599">gsl_sf_gamma_inc</A>
<LI><A HREF="gsl_manual.html#IDX600">gsl_sf_gamma_inc_e</A>
<LI><A HREF="gsl_manual.html#IDX596">gsl_sf_gamma_inc_P</A>
<LI><A HREF="gsl_manual.html#IDX597">gsl_sf_gamma_inc_P_e</A>
<LI><A HREF="gsl_manual.html#IDX593">gsl_sf_gamma_inc_Q</A>
<LI><A HREF="gsl_manual.html#IDX594">gsl_sf_gamma_inc_Q_e</A>
<LI><A HREF="gsl_manual.html#IDX556">gsl_sf_gammainv</A>
<LI><A HREF="gsl_manual.html#IDX557">gsl_sf_gammainv_e</A>
<LI><A HREF="gsl_manual.html#IDX553">gsl_sf_gammastar</A>
<LI><A HREF="gsl_manual.html#IDX554">gsl_sf_gammastar_e</A>
<LI><A HREF="gsl_manual.html#IDX614">gsl_sf_gegenpoly_1</A>
<LI><A HREF="gsl_manual.html#IDX617">gsl_sf_gegenpoly_1_e</A>
<LI><A HREF="gsl_manual.html#IDX615">gsl_sf_gegenpoly_2</A>
<LI><A HREF="gsl_manual.html#IDX618">gsl_sf_gegenpoly_2_e</A>
<LI><A HREF="gsl_manual.html#IDX616">gsl_sf_gegenpoly_3</A>
<LI><A HREF="gsl_manual.html#IDX619">gsl_sf_gegenpoly_3_e</A>
<LI><A HREF="gsl_manual.html#IDX622">gsl_sf_gegenpoly_array</A>
<LI><A HREF="gsl_manual.html#IDX620">gsl_sf_gegenpoly_n</A>
<LI><A HREF="gsl_manual.html#IDX621">gsl_sf_gegenpoly_n_e</A>
<LI><A HREF="gsl_manual.html#IDX473">gsl_sf_hazard</A>
<LI><A HREF="gsl_manual.html#IDX474">gsl_sf_hazard_e</A>
<LI><A HREF="gsl_manual.html#IDX391">gsl_sf_hydrogenicR</A>
<LI><A HREF="gsl_manual.html#IDX389">gsl_sf_hydrogenicR_1</A>
<LI><A HREF="gsl_manual.html#IDX390">gsl_sf_hydrogenicR_1_e</A>
<LI><A HREF="gsl_manual.html#IDX392">gsl_sf_hydrogenicR_e</A>
<LI><A HREF="gsl_manual.html#IDX625">gsl_sf_hyperg_0F1</A>
<LI><A HREF="gsl_manual.html#IDX626">gsl_sf_hyperg_0F1_e</A>
<LI><A HREF="gsl_manual.html#IDX629">gsl_sf_hyperg_1F1</A>
<LI><A HREF="gsl_manual.html#IDX630">gsl_sf_hyperg_1F1_e</A>
<LI><A HREF="gsl_manual.html#IDX627">gsl_sf_hyperg_1F1_int</A>
<LI><A HREF="gsl_manual.html#IDX628">gsl_sf_hyperg_1F1_int_e</A>
<LI><A HREF="gsl_manual.html#IDX645">gsl_sf_hyperg_2F0</A>
<LI><A HREF="gsl_manual.html#IDX646">gsl_sf_hyperg_2F0_e</A>
<LI><A HREF="gsl_manual.html#IDX637">gsl_sf_hyperg_2F1</A>
<LI><A HREF="gsl_manual.html#IDX639">gsl_sf_hyperg_2F1_conj</A>
<LI><A HREF="gsl_manual.html#IDX640">gsl_sf_hyperg_2F1_conj_e</A>
<LI><A HREF="gsl_manual.html#IDX643">gsl_sf_hyperg_2F1_conj_renorm</A>
<LI><A HREF="gsl_manual.html#IDX644">gsl_sf_hyperg_2F1_conj_renorm_e</A>
<LI><A HREF="gsl_manual.html#IDX638">gsl_sf_hyperg_2F1_e</A>
<LI><A HREF="gsl_manual.html#IDX641">gsl_sf_hyperg_2F1_renorm</A>
<LI><A HREF="gsl_manual.html#IDX642">gsl_sf_hyperg_2F1_renorm_e</A>
<LI><A HREF="gsl_manual.html#IDX634">gsl_sf_hyperg_U</A>
<LI><A HREF="gsl_manual.html#IDX635">gsl_sf_hyperg_U_e</A>
<LI><A HREF="gsl_manual.html#IDX636">gsl_sf_hyperg_U_e10_e</A>
<LI><A HREF="gsl_manual.html#IDX631">gsl_sf_hyperg_U_int</A>
<LI><A HREF="gsl_manual.html#IDX632">gsl_sf_hyperg_U_int_e</A>
<LI><A HREF="gsl_manual.html#IDX633">gsl_sf_hyperg_U_int_e10_e</A>
<LI><A HREF="gsl_manual.html#IDX761">gsl_sf_hypot</A>
<LI><A HREF="gsl_manual.html#IDX762">gsl_sf_hypot_e</A>
<LI><A HREF="gsl_manual.html#IDX802">gsl_sf_hzeta</A>
<LI><A HREF="gsl_manual.html#IDX803">gsl_sf_hzeta_e</A>
<LI><A HREF="gsl_manual.html#IDX649">gsl_sf_laguerre_1</A>
<LI><A HREF="gsl_manual.html#IDX652">gsl_sf_laguerre_1_e</A>
<LI><A HREF="gsl_manual.html#IDX650">gsl_sf_laguerre_2</A>
<LI><A HREF="gsl_manual.html#IDX653">gsl_sf_laguerre_2_e</A>
<LI><A HREF="gsl_manual.html#IDX651">gsl_sf_laguerre_3</A>
<LI><A HREF="gsl_manual.html#IDX654">gsl_sf_laguerre_3_e</A>
<LI><A HREF="gsl_manual.html#IDX655">gsl_sf_laguerre_n</A>
<LI><A HREF="gsl_manual.html#IDX656">gsl_sf_laguerre_n_e</A>
<LI><A HREF="gsl_manual.html#IDX659">gsl_sf_lambert_W0</A>
<LI><A HREF="gsl_manual.html#IDX660">gsl_sf_lambert_W0_e</A>
<LI><A HREF="gsl_manual.html#IDX661">gsl_sf_lambert_Wm1</A>
<LI><A HREF="gsl_manual.html#IDX662">gsl_sf_lambert_Wm1_e</A>
<LI><A HREF="gsl_manual.html#IDX691">gsl_sf_legendre_array_size</A>
<LI><A HREF="gsl_manual.html#IDX708">gsl_sf_legendre_H3d</A>
<LI><A HREF="gsl_manual.html#IDX704">gsl_sf_legendre_H3d_0</A>
<LI><A HREF="gsl_manual.html#IDX705">gsl_sf_legendre_H3d_0_e</A>
<LI><A HREF="gsl_manual.html#IDX706">gsl_sf_legendre_H3d_1</A>
<LI><A HREF="gsl_manual.html#IDX707">gsl_sf_legendre_H3d_1_e</A>
<LI><A HREF="gsl_manual.html#IDX710">gsl_sf_legendre_H3d_array</A>
<LI><A HREF="gsl_manual.html#IDX709">gsl_sf_legendre_H3d_e</A>
<LI><A HREF="gsl_manual.html#IDX667">gsl_sf_legendre_P1</A>
<LI><A HREF="gsl_manual.html#IDX670">gsl_sf_legendre_P1_e</A>
<LI><A HREF="gsl_manual.html#IDX668">gsl_sf_legendre_P2</A>
<LI><A HREF="gsl_manual.html#IDX671">gsl_sf_legendre_P2_e</A>
<LI><A HREF="gsl_manual.html#IDX669">gsl_sf_legendre_P3</A>
<LI><A HREF="gsl_manual.html#IDX672">gsl_sf_legendre_P3_e</A>
<LI><A HREF="gsl_manual.html#IDX673">gsl_sf_legendre_Pl</A>
<LI><A HREF="gsl_manual.html#IDX675">gsl_sf_legendre_Pl_array</A>
<LI><A HREF="gsl_manual.html#IDX676">gsl_sf_legendre_Pl_deriv_array</A>
<LI><A HREF="gsl_manual.html#IDX674">gsl_sf_legendre_Pl_e</A>
<LI><A HREF="gsl_manual.html#IDX683">gsl_sf_legendre_Plm</A>
<LI><A HREF="gsl_manual.html#IDX685">gsl_sf_legendre_Plm_array</A>
<LI><A HREF="gsl_manual.html#IDX686">gsl_sf_legendre_Plm_deriv_array</A>
<LI><A HREF="gsl_manual.html#IDX684">gsl_sf_legendre_Plm_e</A>
<LI><A HREF="gsl_manual.html#IDX677">gsl_sf_legendre_Q0</A>
<LI><A HREF="gsl_manual.html#IDX678">gsl_sf_legendre_Q0_e</A>
<LI><A HREF="gsl_manual.html#IDX679">gsl_sf_legendre_Q1</A>
<LI><A HREF="gsl_manual.html#IDX680">gsl_sf_legendre_Q1_e</A>
<LI><A HREF="gsl_manual.html#IDX681">gsl_sf_legendre_Ql</A>
<LI><A HREF="gsl_manual.html#IDX682">gsl_sf_legendre_Ql_e</A>
<LI><A HREF="gsl_manual.html#IDX687">gsl_sf_legendre_sphPlm</A>
<LI><A HREF="gsl_manual.html#IDX689">gsl_sf_legendre_sphPlm_array</A>
<LI><A HREF="gsl_manual.html#IDX690">gsl_sf_legendre_sphPlm_deriv_array</A>
<LI><A HREF="gsl_manual.html#IDX688">gsl_sf_legendre_sphPlm_e</A>
<LI><A HREF="gsl_manual.html#IDX605">gsl_sf_lnbeta</A>
<LI><A HREF="gsl_manual.html#IDX606">gsl_sf_lnbeta_e</A>
<LI><A HREF="gsl_manual.html#IDX579">gsl_sf_lnchoose</A>
<LI><A HREF="gsl_manual.html#IDX580">gsl_sf_lnchoose_e</A>
<LI><A HREF="gsl_manual.html#IDX776">gsl_sf_lncosh</A>
<LI><A HREF="gsl_manual.html#IDX777">gsl_sf_lncosh_e</A>
<LI><A HREF="gsl_manual.html#IDX573">gsl_sf_lndoublefact</A>
<LI><A HREF="gsl_manual.html#IDX574">gsl_sf_lndoublefact_e</A>
<LI><A HREF="gsl_manual.html#IDX570">gsl_sf_lnfact</A>
<LI><A HREF="gsl_manual.html#IDX571">gsl_sf_lnfact_e</A>
<LI><A HREF="gsl_manual.html#IDX549">gsl_sf_lngamma</A>
<LI><A HREF="gsl_manual.html#IDX559">gsl_sf_lngamma_complex_e</A>
<LI><A HREF="gsl_manual.html#IDX550">gsl_sf_lngamma_e</A>
<LI><A HREF="gsl_manual.html#IDX552">gsl_sf_lngamma_sgn_e</A>
<LI><A HREF="gsl_manual.html#IDX586">gsl_sf_lnpoch</A>
<LI><A HREF="gsl_manual.html#IDX587">gsl_sf_lnpoch_e</A>
<LI><A HREF="gsl_manual.html#IDX589">gsl_sf_lnpoch_sgn_e</A>
<LI><A HREF="gsl_manual.html#IDX773">gsl_sf_lnsinh</A>
<LI><A HREF="gsl_manual.html#IDX774">gsl_sf_lnsinh_e</A>
<LI><A HREF="gsl_manual.html#IDX712">gsl_sf_log</A>
<LI><A HREF="gsl_manual.html#IDX717">gsl_sf_log_1plusx</A>
<LI><A HREF="gsl_manual.html#IDX718">gsl_sf_log_1plusx_e</A>
<LI><A HREF="gsl_manual.html#IDX719">gsl_sf_log_1plusx_mx</A>
<LI><A HREF="gsl_manual.html#IDX720">gsl_sf_log_1plusx_mx_e</A>
<LI><A HREF="gsl_manual.html#IDX714">gsl_sf_log_abs</A>
<LI><A HREF="gsl_manual.html#IDX715">gsl_sf_log_abs_e</A>
<LI><A HREF="gsl_manual.html#IDX713">gsl_sf_log_e</A>
<LI><A HREF="gsl_manual.html#IDX465">gsl_sf_log_erfc</A>
<LI><A HREF="gsl_manual.html#IDX466">gsl_sf_log_erfc_e</A>
<LI><A HREF="gsl_manual.html#IDX430">gsl_sf_multiply_e</A>
<LI><A HREF="gsl_manual.html#IDX431">gsl_sf_multiply_err_e</A>
<LI><A HREF="gsl_manual.html#IDX582">gsl_sf_poch</A>
<LI><A HREF="gsl_manual.html#IDX583">gsl_sf_poch_e</A>
<LI><A HREF="gsl_manual.html#IDX590">gsl_sf_pochrel</A>
<LI><A HREF="gsl_manual.html#IDX591">gsl_sf_pochrel_e</A>
<LI><A HREF="gsl_manual.html#IDX781">gsl_sf_polar_to_rect</A>
<LI><A HREF="gsl_manual.html#IDX723">gsl_sf_pow_int</A>
<LI><A HREF="gsl_manual.html#IDX724">gsl_sf_pow_int_e</A>
<LI><A HREF="gsl_manual.html#IDX730">gsl_sf_psi</A>
<LI><A HREF="gsl_manual.html#IDX736">gsl_sf_psi_1</A>
<LI><A HREF="gsl_manual.html#IDX737">gsl_sf_psi_1_e</A>
<LI><A HREF="gsl_manual.html#IDX734">gsl_sf_psi_1_int</A>
<LI><A HREF="gsl_manual.html#IDX735">gsl_sf_psi_1_int_e</A>
<LI><A HREF="gsl_manual.html#IDX732">gsl_sf_psi_1piy</A>
<LI><A HREF="gsl_manual.html#IDX733">gsl_sf_psi_1piy_e</A>
<LI><A HREF="gsl_manual.html#IDX731">gsl_sf_psi_e</A>
<LI><A HREF="gsl_manual.html#IDX728">gsl_sf_psi_int</A>
<LI><A HREF="gsl_manual.html#IDX729">gsl_sf_psi_int_e</A>
<LI><A HREF="gsl_manual.html#IDX738">gsl_sf_psi_n</A>
<LI><A HREF="gsl_manual.html#IDX739">gsl_sf_psi_n_e</A>
<LI><A HREF="gsl_manual.html#IDX782">gsl_sf_rect_to_polar</A>
<LI><A HREF="gsl_manual.html#IDX507">gsl_sf_Shi</A>
<LI><A HREF="gsl_manual.html#IDX508">gsl_sf_Shi_e</A>
<LI><A HREF="gsl_manual.html#IDX516">gsl_sf_Si</A>
<LI><A HREF="gsl_manual.html#IDX517">gsl_sf_Si_e</A>
<LI><A HREF="gsl_manual.html#IDX755">gsl_sf_sin</A>
<LI><A HREF="gsl_manual.html#IDX756">gsl_sf_sin_e</A>
<LI><A HREF="gsl_manual.html#IDX789">gsl_sf_sin_err</A>
<LI><A HREF="gsl_manual.html#IDX790">gsl_sf_sin_err_e</A>
<LI><A HREF="gsl_manual.html#IDX764">gsl_sf_sinc</A>
<LI><A HREF="gsl_manual.html#IDX765">gsl_sf_sinc_e</A>
<LI><A HREF="gsl_manual.html#IDX741">gsl_sf_synchrotron_1</A>
<LI><A HREF="gsl_manual.html#IDX742">gsl_sf_synchrotron_1_e</A>
<LI><A HREF="gsl_manual.html#IDX743">gsl_sf_synchrotron_2</A>
<LI><A HREF="gsl_manual.html#IDX744">gsl_sf_synchrotron_2_e</A>
<LI><A HREF="gsl_manual.html#IDX561">gsl_sf_taylorcoeff</A>
<LI><A HREF="gsl_manual.html#IDX562">gsl_sf_taylorcoeff_e</A>
<LI><A HREF="gsl_manual.html#IDX746">gsl_sf_transport_2</A>
<LI><A HREF="gsl_manual.html#IDX747">gsl_sf_transport_2_e</A>
<LI><A HREF="gsl_manual.html#IDX748">gsl_sf_transport_3</A>
<LI><A HREF="gsl_manual.html#IDX749">gsl_sf_transport_3_e</A>
<LI><A HREF="gsl_manual.html#IDX750">gsl_sf_transport_4</A>
<LI><A HREF="gsl_manual.html#IDX751">gsl_sf_transport_4_e</A>
<LI><A HREF="gsl_manual.html#IDX752">gsl_sf_transport_5</A>
<LI><A HREF="gsl_manual.html#IDX753">gsl_sf_transport_5_e</A>
<LI><A HREF="gsl_manual.html#IDX796">gsl_sf_zeta</A>
<LI><A HREF="gsl_manual.html#IDX797">gsl_sf_zeta_e</A>
<LI><A HREF="gsl_manual.html#IDX794">gsl_sf_zeta_int</A>
<LI><A HREF="gsl_manual.html#IDX795">gsl_sf_zeta_int_e</A>
<LI><A HREF="gsl_manual.html#IDX800">gsl_sf_zetam1</A>
<LI><A HREF="gsl_manual.html#IDX801">gsl_sf_zetam1_e</A>
<LI><A HREF="gsl_manual.html#IDX798">gsl_sf_zetam1_int</A>
<LI><A HREF="gsl_manual.html#IDX799">gsl_sf_zetam1_int_e</A>
<LI><A HREF="gsl_manual.html#IDX115">GSL_SIGN</A>
<LI><A HREF="gsl_manual.html#IDX1885">gsl_siman_solve</A>
<LI><A HREF="gsl_manual.html#IDX1015">gsl_sort</A>
<LI><A HREF="gsl_manual.html#IDX1018">gsl_sort_index</A>
<LI><A HREF="gsl_manual.html#IDX1021">gsl_sort_largest</A>
<LI><A HREF="gsl_manual.html#IDX1025">gsl_sort_largest_index</A>
<LI><A HREF="gsl_manual.html#IDX1020">gsl_sort_smallest</A>
<LI><A HREF="gsl_manual.html#IDX1024">gsl_sort_smallest_index</A>
<LI><A HREF="gsl_manual.html#IDX1016">gsl_sort_vector</A>
<LI><A HREF="gsl_manual.html#IDX1019">gsl_sort_vector_index</A>
<LI><A HREF="gsl_manual.html#IDX1023">gsl_sort_vector_largest</A>
<LI><A HREF="gsl_manual.html#IDX1027">gsl_sort_vector_largest_index</A>
<LI><A HREF="gsl_manual.html#IDX1022">gsl_sort_vector_smallest</A>
<LI><A HREF="gsl_manual.html#IDX1026">gsl_sort_vector_smallest_index</A>
<LI><A HREF="gsl_manual.html#IDX1974">gsl_spline_alloc</A>
<LI><A HREF="gsl_manual.html#IDX1977">gsl_spline_eval</A>
<LI><A HREF="gsl_manual.html#IDX1979">gsl_spline_eval_deriv</A>
<LI><A HREF="gsl_manual.html#IDX1981">gsl_spline_eval_deriv2</A>
<LI><A HREF="gsl_manual.html#IDX1982">gsl_spline_eval_deriv2_e</A>
<LI><A HREF="gsl_manual.html#IDX1980">gsl_spline_eval_deriv_e</A>
<LI><A HREF="gsl_manual.html#IDX1978">gsl_spline_eval_e</A>
<LI><A HREF="gsl_manual.html#IDX1983">gsl_spline_eval_integ</A>
<LI><A HREF="gsl_manual.html#IDX1984">gsl_spline_eval_integ_e</A>
<LI><A HREF="gsl_manual.html#IDX1976">gsl_spline_free</A>
<LI><A HREF="gsl_manual.html#IDX1975">gsl_spline_init</A>
<LI><A HREF="gsl_manual.html#IDX1695">gsl_stats_absdev</A>
<LI><A HREF="gsl_manual.html#IDX1696">gsl_stats_absdev_m</A>
<LI><A HREF="gsl_manual.html#IDX1704">gsl_stats_covariance</A>
<LI><A HREF="gsl_manual.html#IDX1705">gsl_stats_covariance_m</A>
<LI><A HREF="gsl_manual.html#IDX1699">gsl_stats_kurtosis</A>
<LI><A HREF="gsl_manual.html#IDX1700">gsl_stats_kurtosis_m_sd</A>
<LI><A HREF="gsl_manual.html#IDX1701">gsl_stats_lag1_autocorrelation</A>
<LI><A HREF="gsl_manual.html#IDX1702">gsl_stats_lag1_autocorrelation_m</A>
<LI><A HREF="gsl_manual.html#IDX1719">gsl_stats_max</A>
<LI><A HREF="gsl_manual.html#IDX1722">gsl_stats_max_index</A>
<LI><A HREF="gsl_manual.html#IDX1688">gsl_stats_mean</A>
<LI><A HREF="gsl_manual.html#IDX1725">gsl_stats_median_from_sorted_data</A>
<LI><A HREF="gsl_manual.html#IDX1720">gsl_stats_min</A>
<LI><A HREF="gsl_manual.html#IDX1723">gsl_stats_min_index</A>
<LI><A HREF="gsl_manual.html#IDX1721">gsl_stats_minmax</A>
<LI><A HREF="gsl_manual.html#IDX1724">gsl_stats_minmax_index</A>
<LI><A HREF="gsl_manual.html#IDX1726">gsl_stats_quantile_from_sorted_data</A>
<LI><A HREF="gsl_manual.html#IDX1691">gsl_stats_sd</A>
<LI><A HREF="gsl_manual.html#IDX1692">gsl_stats_sd_m</A>
<LI><A HREF="gsl_manual.html#IDX1694">gsl_stats_sd_with_fixed_mean</A>
<LI><A HREF="gsl_manual.html#IDX1697">gsl_stats_skew</A>
<LI><A HREF="gsl_manual.html#IDX1698">gsl_stats_skew_m_sd</A>
<LI><A HREF="gsl_manual.html#IDX1689">gsl_stats_variance</A>
<LI><A HREF="gsl_manual.html#IDX1690">gsl_stats_variance_m</A>
<LI><A HREF="gsl_manual.html#IDX1693">gsl_stats_variance_with_fixed_mean</A>
<LI><A HREF="gsl_manual.html#IDX1713">gsl_stats_wabsdev</A>
<LI><A HREF="gsl_manual.html#IDX1714">gsl_stats_wabsdev_m</A>
<LI><A HREF="gsl_manual.html#IDX1717">gsl_stats_wkurtosis</A>
<LI><A HREF="gsl_manual.html#IDX1718">gsl_stats_wkurtosis_m_sd</A>
<LI><A HREF="gsl_manual.html#IDX1706">gsl_stats_wmean</A>
<LI><A HREF="gsl_manual.html#IDX1709">gsl_stats_wsd</A>
<LI><A HREF="gsl_manual.html#IDX1710">gsl_stats_wsd_m</A>
<LI><A HREF="gsl_manual.html#IDX1712">gsl_stats_wsd_with_fixed_mean</A>
<LI><A HREF="gsl_manual.html#IDX1715">gsl_stats_wskew</A>
<LI><A HREF="gsl_manual.html#IDX1716">gsl_stats_wskew_m_sd</A>
<LI><A HREF="gsl_manual.html#IDX1707">gsl_stats_wvariance</A>
<LI><A HREF="gsl_manual.html#IDX1708">gsl_stats_wvariance_m</A>
<LI><A HREF="gsl_manual.html#IDX1711">gsl_stats_wvariance_with_fixed_mean</A>
<LI><A HREF="gsl_manual.html#IDX52">gsl_strerror</A>
<LI><A HREF="gsl_manual.html#IDX2013">gsl_sum_levin_u_accel</A>
<LI><A HREF="gsl_manual.html#IDX2011">gsl_sum_levin_u_alloc</A>
<LI><A HREF="gsl_manual.html#IDX2012">gsl_sum_levin_u_free</A>
<LI><A HREF="gsl_manual.html#IDX2016">gsl_sum_levin_utrunc_accel</A>
<LI><A HREF="gsl_manual.html#IDX2014">gsl_sum_levin_utrunc_alloc</A>
<LI><A HREF="gsl_manual.html#IDX2015">gsl_sum_levin_utrunc_free</A>
<LI><A HREF="gsl_manual.html#IDX858">gsl_vector_add</A>
<LI><A HREF="gsl_manual.html#IDX863">gsl_vector_add_constant</A>
<LI><A HREF="gsl_manual.html#IDX821">gsl_vector_alloc</A>
<LI><A HREF="gsl_manual.html#IDX822">gsl_vector_calloc</A>
<LI><A HREF="gsl_manual.html#IDX849">gsl_vector_complex_const_imag</A>
<LI><A HREF="gsl_manual.html#IDX847">gsl_vector_complex_const_real</A>
<LI><A HREF="gsl_manual.html#IDX848">gsl_vector_complex_imag</A>
<LI><A HREF="gsl_manual.html#IDX846">gsl_vector_complex_real</A>
<LI><A HREF="gsl_manual.html#IDX832">gsl_vector_const_ptr</A>
<LI><A HREF="gsl_manual.html#IDX843">gsl_vector_const_subvector</A>
<LI><A HREF="gsl_manual.html#IDX845">gsl_vector_const_subvector_with_stride</A>
<LI><A HREF="gsl_manual.html#IDX851">gsl_vector_const_view_array</A>
<LI><A HREF="gsl_manual.html#IDX853">gsl_vector_const_view_array_with_stride</A>
<LI><A HREF="gsl_manual.html#IDX861">gsl_vector_div</A>
<LI><A HREF="gsl_manual.html#IDX840">gsl_vector_fprintf</A>
<LI><A HREF="gsl_manual.html#IDX839">gsl_vector_fread</A>
<LI><A HREF="gsl_manual.html#IDX823">gsl_vector_free</A>
<LI><A HREF="gsl_manual.html#IDX841">gsl_vector_fscanf</A>
<LI><A HREF="gsl_manual.html#IDX838">gsl_vector_fwrite</A>
<LI><A HREF="gsl_manual.html#IDX829">gsl_vector_get</A>
<LI><A HREF="gsl_manual.html#IDX870">gsl_vector_isnull</A>
<LI><A HREF="gsl_manual.html#IDX864">gsl_vector_max</A>
<LI><A HREF="gsl_manual.html#IDX867">gsl_vector_max_index</A>
<LI><A HREF="gsl_manual.html#IDX854">gsl_vector_memcpy</A>
<LI><A HREF="gsl_manual.html#IDX865">gsl_vector_min</A>
<LI><A HREF="gsl_manual.html#IDX868">gsl_vector_min_index</A>
<LI><A HREF="gsl_manual.html#IDX866">gsl_vector_minmax</A>
<LI><A HREF="gsl_manual.html#IDX869">gsl_vector_minmax_index</A>
<LI><A HREF="gsl_manual.html#IDX860">gsl_vector_mul</A>
<LI><A HREF="gsl_manual.html#IDX831">gsl_vector_ptr</A>
<LI><A HREF="gsl_manual.html#IDX857">gsl_vector_reverse</A>
<LI><A HREF="gsl_manual.html#IDX862">gsl_vector_scale</A>
<LI><A HREF="gsl_manual.html#IDX830">gsl_vector_set</A>
<LI><A HREF="gsl_manual.html#IDX835">gsl_vector_set_all</A>
<LI><A HREF="gsl_manual.html#IDX837">gsl_vector_set_basis</A>
<LI><A HREF="gsl_manual.html#IDX836">gsl_vector_set_zero</A>
<LI><A HREF="gsl_manual.html#IDX859">gsl_vector_sub</A>
<LI><A HREF="gsl_manual.html#IDX842">gsl_vector_subvector</A>
<LI><A HREF="gsl_manual.html#IDX844">gsl_vector_subvector_with_stride</A>
<LI><A HREF="gsl_manual.html#IDX855">gsl_vector_swap</A>
<LI><A HREF="gsl_manual.html#IDX856">gsl_vector_swap_elements</A>
<LI><A HREF="gsl_manual.html#IDX850">gsl_vector_view_array</A>
<LI><A HREF="gsl_manual.html#IDX852">gsl_vector_view_array_with_stride</A>
<LI><A HREF="gsl_manual.html#IDX2049">gsl_wavelet2d_nstransform</A>
<LI><A HREF="gsl_manual.html#IDX2050">gsl_wavelet2d_nstransform_forward</A>
<LI><A HREF="gsl_manual.html#IDX2051">gsl_wavelet2d_nstransform_inverse</A>
<LI><A HREF="gsl_manual.html#IDX2052">gsl_wavelet2d_nstransform_matrix</A>
<LI><A HREF="gsl_manual.html#IDX2053">gsl_wavelet2d_nstransform_matrix_forward</A>
<LI><A HREF="gsl_manual.html#IDX2054">gsl_wavelet2d_nstransform_matrix_inverse</A>
<LI><A HREF="gsl_manual.html#IDX2043">gsl_wavelet2d_transform</A>
<LI><A HREF="gsl_manual.html#IDX2044">gsl_wavelet2d_transform_forward</A>
<LI><A HREF="gsl_manual.html#IDX2045">gsl_wavelet2d_transform_inverse</A>
<LI><A HREF="gsl_manual.html#IDX2046">gsl_wavelet2d_transform_matrix</A>
<LI><A HREF="gsl_manual.html#IDX2047">gsl_wavelet2d_transform_matrix_forward</A>
<LI><A HREF="gsl_manual.html#IDX2048">gsl_wavelet2d_transform_matrix_inverse</A>
<LI><A HREF="gsl_manual.html#IDX2022">gsl_wavelet_alloc</A>
<LI><A HREF="gsl_manual.html#IDX2030">gsl_wavelet_bspline</A>
<LI><A HREF="gsl_manual.html#IDX2031">gsl_wavelet_bspline_centered</A>
<LI><A HREF="gsl_manual.html#IDX2023">gsl_wavelet_daubechies</A>
<LI><A HREF="gsl_manual.html#IDX2024">gsl_wavelet_daubechies_centered</A>
<LI><A HREF="gsl_manual.html#IDX2035">gsl_wavelet_free</A>
<LI><A HREF="gsl_manual.html#IDX2027">gsl_wavelet_haar</A>
<LI><A HREF="gsl_manual.html#IDX2028">gsl_wavelet_haar_centered</A>
<LI><A HREF="gsl_manual.html#IDX2034">gsl_wavelet_name</A>
<LI><A HREF="gsl_manual.html#IDX2039">gsl_wavelet_transform</A>
<LI><A HREF="gsl_manual.html#IDX2040">gsl_wavelet_transform_forward</A>
<LI><A HREF="gsl_manual.html#IDX2041">gsl_wavelet_transform_inverse</A>
<LI><A HREF="gsl_manual.html#IDX2036">gsl_wavelet_workspace_alloc</A>
<LI><A HREF="gsl_manual.html#IDX2037">gsl_wavelet_workspace_free</A>
</DIR>

</P>


<H1><A NAME="SEC534" HREF="gsl_manual.html#TOC534">Variable Index</A></H1>

<P>
<H2>a</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1861">alpha</A>, <A HREF="gsl_manual.html#IDX1872">alpha</A>
</DIR>
<H2>c</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1871">chisq</A>
</DIR>
<H2>d</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1862">dither</A>
</DIR>
<H2>e</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1858">estimate_frac</A>
</DIR>
<H2>i</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1873">iterations</A>
</DIR>
<H2>m</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1859">min_calls</A>
<LI><A HREF="gsl_manual.html#IDX1860">min_calls_per_bisection</A>
<LI><A HREF="gsl_manual.html#IDX1875">mode</A>
</DIR>
<H2>o</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1877">ostream</A>
</DIR>
<H2>r</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1869">result</A>
</DIR>
<H2>s</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1870">sigma</A>
<LI><A HREF="gsl_manual.html#IDX1874">stage</A>
</DIR>
<H2>v</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1876">verbose</A>
</DIR>

</P>


<H1><A NAME="SEC535" HREF="gsl_manual.html#TOC535">Type Index</A></H1>

<P>
<H2>g</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX54">gsl_error_handler_t</A>
<LI><A HREF="gsl_manual.html#IDX1311">gsl_fft_complex_wavetable</A>
<LI><A HREF="gsl_manual.html#IDX2083">gsl_function</A>
<LI><A HREF="gsl_manual.html#IDX2084">gsl_function_fdf</A>
<LI><A HREF="gsl_manual.html#IDX1729">gsl_histogram</A>
<LI><A HREF="gsl_manual.html#IDX1784">gsl_histogram2d</A>
<LI><A HREF="gsl_manual.html#IDX1825">gsl_histogram2d_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1777">gsl_histogram_pdf</A>
<LI><A HREF="gsl_manual.html#IDX1846">gsl_monte_function</A>
<LI><A HREF="gsl_manual.html#IDX2264">gsl_multifit_function</A>
<LI><A HREF="gsl_manual.html#IDX2265">gsl_multifit_function_fdf</A>
<LI><A HREF="gsl_manual.html#IDX2202">gsl_multimin_function</A>
<LI><A HREF="gsl_manual.html#IDX2201">gsl_multimin_function_fdf</A>
<LI><A HREF="gsl_manual.html#IDX2156">gsl_multiroot_function</A>
<LI><A HREF="gsl_manual.html#IDX2157">gsl_multiroot_function_fdf</A>
<LI><A HREF="gsl_manual.html#IDX1900">gsl_odeiv_system</A>
<LI><A HREF="gsl_manual.html#IDX1891">gsl_siman_copy_construct_t</A>
<LI><A HREF="gsl_manual.html#IDX1890">gsl_siman_copy_t</A>
<LI><A HREF="gsl_manual.html#IDX1892">gsl_siman_destroy_t</A>
<LI><A HREF="gsl_manual.html#IDX1886">gsl_siman_Efunc_t</A>
<LI><A HREF="gsl_manual.html#IDX1888">gsl_siman_metric_t</A>
<LI><A HREF="gsl_manual.html#IDX1893">gsl_siman_params_t</A>
<LI><A HREF="gsl_manual.html#IDX1889">gsl_siman_print_t</A>
<LI><A HREF="gsl_manual.html#IDX1887">gsl_siman_step_t</A>
</DIR>

</P>


<H1><A NAME="SEC536" HREF="gsl_manual.html#TOC536">Concept Index</A></H1>

<P>
<H2>$</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX19"><CODE>$</CODE>, shell prompt</A>
</DIR>
<H2>2</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1783">2D histograms</A>
<LI><A HREF="gsl_manual.html#IDX1600">2D random direction vector</A>
</DIR>
<H2>3</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX401">3-j symbols</A>
<LI><A HREF="gsl_manual.html#IDX1604">3D random direction vector</A>
</DIR>
<H2>6</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX402">6-j symbols</A>
</DIR>
<H2>9</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX403">9-j symbols</A>
</DIR>
<H2>a</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX2005">acceleration of series</A>
<LI><A HREF="gsl_manual.html#IDX91">acosh</A>
<LI><A HREF="gsl_manual.html#IDX1930">Adaptive step-size control, differential equations</A>
<LI><A HREF="gsl_manual.html#IDX237">Ai(x)</A>
<LI><A HREF="gsl_manual.html#IDX236">Airy functions</A>
<LI><A HREF="gsl_manual.html#IDX1958">Akima splines</A>
<LI><A HREF="gsl_manual.html#IDX41">aliasing of arrays</A>
<LI><A HREF="gsl_manual.html#IDX38">alternative optimized functions</A>
<LI><A HREF="gsl_manual.html#IDX1057">AMAX, Level-1 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX783">angular reduction</A>
<LI><A HREF="gsl_manual.html#IDX23">ANSI C, use of</A>
<LI><A HREF="gsl_manual.html#IDX585">Apell symbol, see Pochammer symbol</A>
<LI><A HREF="gsl_manual.html#IDX129">approximate comparison of floating point numbers</A>
<LI><A HREF="gsl_manual.html#IDX520">arctangent integral</A>
<LI><A HREF="gsl_manual.html#IDX143">argument of complex number</A>
<LI><A HREF="gsl_manual.html#IDX2331">arithmetic exceptions</A>
<LI><A HREF="gsl_manual.html#IDX95">asinh</A>
<LI><A HREF="gsl_manual.html#IDX2290">astronomical constants</A>
<LI><A HREF="gsl_manual.html#IDX1050">ASUM, Level-1 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX99">atanh</A>
<LI><A HREF="gsl_manual.html#IDX2291">atomic physics, constants</A>
<LI><A HREF="gsl_manual.html#IDX2342">autoconf, using with GSL</A>
<LI><A HREF="gsl_manual.html#IDX1072">AXPY, Level-1 BLAS</A>
</DIR>
<H2>b</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX2033">B-spline wavelets</A>
<LI><A HREF="gsl_manual.html#IDX1925">Bader and Deuflhard, Bulirsch-Stoer method.</A>
<LI><A HREF="gsl_manual.html#IDX1033">Basic Linear Algebra Subroutines (BLAS)</A>, <A HREF="gsl_manual.html#IDX2346">Basic Linear Algebra Subroutines (BLAS)</A>
<LI><A HREF="gsl_manual.html#IDX1651">Bernoulli trial, random variates</A>
<LI><A HREF="gsl_manual.html#IDX263">Bessel functions</A>
<LI><A HREF="gsl_manual.html#IDX356">Bessel Functions, Fractional Order</A>
<LI><A HREF="gsl_manual.html#IDX2281">best-fit parameters, covariance</A>
<LI><A HREF="gsl_manual.html#IDX1580">Beta distribution</A>
<LI><A HREF="gsl_manual.html#IDX604">Beta function</A>
<LI><A HREF="gsl_manual.html#IDX612">Beta function, incomplete normalized</A>
<LI><A HREF="gsl_manual.html#IDX2222">BFGS conjugate gradient algorithm, minimization</A>
<LI><A HREF="gsl_manual.html#IDX238">Bi(x)</A>
<LI><A HREF="gsl_manual.html#IDX2314">bias, IEEE format</A>
<LI><A HREF="gsl_manual.html#IDX1248">bidiagonalization of real matrices</A>
<LI><A HREF="gsl_manual.html#IDX1728">binning data</A>
<LI><A HREF="gsl_manual.html#IDX1654">Binomial random variates</A>
<LI><A HREF="gsl_manual.html#IDX2032">biorthogonal wavelets</A>
<LI><A HREF="gsl_manual.html#IDX2098">bisection algorithm for finding roots</A>
<LI><A HREF="gsl_manual.html#IDX1489">Bivariate Gaussian distribution</A>
<LI><A HREF="gsl_manual.html#IDX1031">BLAS</A>
<LI><A HREF="gsl_manual.html#IDX2345">BLAS, Low-level C interface</A>
<LI><A HREF="gsl_manual.html#IDX809">blocks</A>
<LI><A HREF="gsl_manual.html#IDX826">bounds checking, extension to GCC</A>
<LI><A HREF="gsl_manual.html#IDX2339">breakpoints</A>
<LI><A HREF="gsl_manual.html#IDX2141">Brent's method for finding minima</A>
<LI><A HREF="gsl_manual.html#IDX2104">Brent's method for finding roots</A>
<LI><A HREF="gsl_manual.html#IDX2189">Broyden algorithm for multidimensional roots</A>
<LI><A HREF="gsl_manual.html#IDX1412">BSD random number generator</A>
<LI><A HREF="gsl_manual.html#IDX11">bug-gsl mailing list</A>
<LI><A HREF="gsl_manual.html#IDX10">bugs, how to report</A>
<LI><A HREF="gsl_manual.html#IDX1924">Bulirsch-Stoer method</A>
</DIR>
<H2>c</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX24">C extensions, compatible use of</A>
<LI><A HREF="gsl_manual.html#IDX40">C++, compatibility</A>
<LI><A HREF="gsl_manual.html#IDX434">Carlson forms of Elliptic integrals</A>
<LI><A HREF="gsl_manual.html#IDX1917">Cash-Karp, Runge-Kutta method</A>
<LI><A HREF="gsl_manual.html#IDX1512">Cauchy distribution</A>
<LI><A HREF="gsl_manual.html#IDX1353">Cauchy principal value, by numerical quadrature</A>
<LI><A HREF="gsl_manual.html#IDX1032">CBLAS</A>
<LI><A HREF="gsl_manual.html#IDX2344">CBLAS, Low-level interface</A>
<LI><A HREF="gsl_manual.html#IDX1465">CDFs, cumulative distribution functions</A>
<LI><A HREF="gsl_manual.html#IDX1993">Chebyshev series</A>
<LI><A HREF="gsl_manual.html#IDX998">checking combination for validity</A>
<LI><A HREF="gsl_manual.html#IDX963">checking permutation for validity</A>
<LI><A HREF="gsl_manual.html#IDX506">Chi(x)</A>
<LI><A HREF="gsl_manual.html#IDX1560">Chi-squared distribution</A>
<LI><A HREF="gsl_manual.html#IDX1234">Cholesky decomposition</A>
<LI><A HREF="gsl_manual.html#IDX515">Ci(x)</A>
<LI><A HREF="gsl_manual.html#IDX384">Clausen functions</A>
<LI><A HREF="gsl_manual.html#IDX1341">Clenshaw-Curtis quadrature</A>
<LI><A HREF="gsl_manual.html#IDX1400">CMRG, combined multiple recursive random number generator</A>
<LI><A HREF="gsl_manual.html#IDX43">code reuse in applications</A>
<LI><A HREF="gsl_manual.html#IDX986">combinations</A>
<LI><A HREF="gsl_manual.html#IDX578">combinatorial factor C(m,n)</A>
<LI><A HREF="gsl_manual.html#IDX1879">combinatorial optimization</A>
<LI><A HREF="gsl_manual.html#IDX1009">comparison functions, definition</A>
<LI><A HREF="gsl_manual.html#IDX25">compatibility</A>
<LI><A HREF="gsl_manual.html#IDX26">compiling programs, include paths</A>
<LI><A HREF="gsl_manual.html#IDX29">compiling programs, library paths</A>
<LI><A HREF="gsl_manual.html#IDX598">complementary incomplete Gamma function</A>
<LI><A HREF="gsl_manual.html#IDX524">complete Fermi-Dirac integrals</A>
<LI><A HREF="gsl_manual.html#IDX148">complex arithmetic</A>
<LI><A HREF="gsl_manual.html#IDX770">complex cosine function, special functions</A>
<LI><A HREF="gsl_manual.html#IDX560">Complex Gamma function</A>
<LI><A HREF="gsl_manual.html#IDX1280">complex hermitian matrix, eigensystem</A>
<LI><A HREF="gsl_manual.html#IDX772">complex log sine function, special functions</A>
<LI><A HREF="gsl_manual.html#IDX132">complex numbers</A>
<LI><A HREF="gsl_manual.html#IDX766">complex sinc function, special functions</A>
<LI><A HREF="gsl_manual.html#IDX768">complex sine function, special functions</A>
<LI><A HREF="gsl_manual.html#IDX648">confluent hypergeometric function</A>
<LI><A HREF="gsl_manual.html#IDX624">confluent hypergeometric functions</A>
<LI><A HREF="gsl_manual.html#IDX665">conical functions</A>
<LI><A HREF="gsl_manual.html#IDX2216">Conjugate gradient algorithm, minimization</A>
<LI><A HREF="gsl_manual.html#IDX162">conjugate of complex number</A>
<LI><A HREF="gsl_manual.html#IDX890">constant matrix</A>
<LI><A HREF="gsl_manual.html#IDX2289">constants, fundamental</A>
<LI><A HREF="gsl_manual.html#IDX64">constants, mathematical--defined as macros</A>
<LI><A HREF="gsl_manual.html#IDX2285">constants, physical</A>
<LI><A HREF="gsl_manual.html#IDX2311">constants, prefixes</A>
<LI><A HREF="gsl_manual.html#IDX15">contacting the GSL developers</A>
<LI><A HREF="gsl_manual.html#IDX16">conventions, used in manual</A>
<LI><A HREF="gsl_manual.html#IDX2010">convergence, accelerating a series</A>
<LI><A HREF="gsl_manual.html#IDX2286">conversion of units</A>
<LI><A HREF="gsl_manual.html#IDX1883">cooling schedule</A>
<LI><A HREF="gsl_manual.html#IDX1067">COPY, Level-1 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX760">cosine function, special functions</A>
<LI><A HREF="gsl_manual.html#IDX181">cosine of complex number</A>
<LI><A HREF="gsl_manual.html#IDX1882">cost function</A>
<LI><A HREF="gsl_manual.html#IDX387">Coulomb wave functions</A>
<LI><A HREF="gsl_manual.html#IDX400">coupling coefficients</A>
<LI><A HREF="gsl_manual.html#IDX2236">covariance matrix, from linear regression</A>
<LI><A HREF="gsl_manual.html#IDX2280">covariance of best-fit parameters</A>
<LI><A HREF="gsl_manual.html#IDX1703">covariance, of two datasets</A>
<LI><A HREF="gsl_manual.html#IDX1420">CRAY random number generator, RANF</A>
<LI><A HREF="gsl_manual.html#IDX226">cubic equation, solving</A>
<LI><A HREF="gsl_manual.html#IDX1955">cubic splines</A>
<LI><A HREF="gsl_manual.html#IDX1464">cumulative distribution functions (CDFs)</A>
<LI><A HREF="gsl_manual.html#IDX264">Cylindrical Bessel Functions</A>
</DIR>
<H2>d</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX2025">Daubechies wavelets</A>
<LI><A HREF="gsl_manual.html#IDX412">Dawson function</A>
<LI><A HREF="gsl_manual.html#IDX2338">debugging numerical programs</A>
<LI><A HREF="gsl_manual.html#IDX415">Debye functions</A>
<LI><A HREF="gsl_manual.html#IDX2319">denormalized form, IEEE format</A>
<LI><A HREF="gsl_manual.html#IDX42">deprecated functions</A>
<LI><A HREF="gsl_manual.html#IDX1987">derivatives, calculating numerically</A>
<LI><A HREF="gsl_manual.html#IDX1195">determinant of a matrix, by LU decomposition</A>
<LI><A HREF="gsl_manual.html#IDX1926">Deuflhard and Bader, Bulirsch-Stoer method.</A>
<LI><A HREF="gsl_manual.html#IDX1294">DFTs, see FFT</A>
<LI><A HREF="gsl_manual.html#IDX914">diagonal, of a matrix</A>
<LI><A HREF="gsl_manual.html#IDX1896">differential equations, initial value problems</A>
<LI><A HREF="gsl_manual.html#IDX1985">differentiation of functions, numeric</A>
<LI><A HREF="gsl_manual.html#IDX726">digamma function</A>
<LI><A HREF="gsl_manual.html#IDX424">dilogarithm</A>
<LI><A HREF="gsl_manual.html#IDX1601">direction vector, random 2D</A>
<LI><A HREF="gsl_manual.html#IDX1605">direction vector, random 3D</A>
<LI><A HREF="gsl_manual.html#IDX1609">direction vector, random N-dimensional</A>
<LI><A HREF="gsl_manual.html#IDX1635">Dirichlet distribution</A>
<LI><A HREF="gsl_manual.html#IDX1293">Discrete Fourier Transforms, see FFT</A>
<LI><A HREF="gsl_manual.html#IDX2055">discrete Hankel transforms</A>
<LI><A HREF="gsl_manual.html#IDX2186">Discrete Newton algorithm for multidimensional roots</A>
<LI><A HREF="gsl_manual.html#IDX1639">Discrete random numbers</A>, <A HREF="gsl_manual.html#IDX1642">Discrete random numbers</A>, <A HREF="gsl_manual.html#IDX1644">Discrete random numbers</A>, <A HREF="gsl_manual.html#IDX1646">Discrete random numbers</A>
<LI><A HREF="gsl_manual.html#IDX1640">Discrete random numbers, preprocessing</A>
<LI><A HREF="gsl_manual.html#IDX218">divided differences, polynomials</A>
<LI><A HREF="gsl_manual.html#IDX2333">division by zero, IEEE exceptions</A>
<LI><A HREF="gsl_manual.html#IDX20">dollar sign <CODE>$</CODE>, shell prompt</A>
<LI><A HREF="gsl_manual.html#IDX1035">DOT, Level-1 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX569">double factorial</A>
<LI><A HREF="gsl_manual.html#IDX2323">double precision, IEEE format</A>
<LI><A HREF="gsl_manual.html#IDX5">downloading GSL</A>
<LI><A HREF="gsl_manual.html#IDX2021">DWT initialization</A>
<LI><A HREF="gsl_manual.html#IDX2020">DWT, mathematical definition</A>
<LI><A HREF="gsl_manual.html#IDX2038">DWT, one dimensional</A>
<LI><A HREF="gsl_manual.html#IDX2017">DWT, see wavelet transforms</A>
<LI><A HREF="gsl_manual.html#IDX2042">DWT, two dimensional</A>
</DIR>
<H2>e</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX66">e, defined as a macro</A>
<LI><A HREF="gsl_manual.html#IDX497">E1(x), E2(x), Ei(x)</A>
<LI><A HREF="gsl_manual.html#IDX1269">eigenvalues and eigenvectors</A>
<LI><A HREF="gsl_manual.html#IDX60">elementary functions</A>
<LI><A HREF="gsl_manual.html#IDX428">elementary operations</A>
<LI><A HREF="gsl_manual.html#IDX456">elliptic functions (Jacobi)</A>
<LI><A HREF="gsl_manual.html#IDX432">elliptic integrals</A>
<LI><A HREF="gsl_manual.html#IDX1881">energy function</A>
<LI><A HREF="gsl_manual.html#IDX2301">energy, units of</A>
<LI><A HREF="gsl_manual.html#IDX459">erf(x)</A>
<LI><A HREF="gsl_manual.html#IDX460">erfc(x)</A>
<LI><A HREF="gsl_manual.html#IDX1538">Erlang distribution</A>
<LI><A HREF="gsl_manual.html#IDX47">error codes</A>
<LI><A HREF="gsl_manual.html#IDX458">error function</A>
<LI><A HREF="gsl_manual.html#IDX53">Error handlers</A>
<LI><A HREF="gsl_manual.html#IDX46">error handling</A>
<LI><A HREF="gsl_manual.html#IDX57">error handling macros</A>
<LI><A HREF="gsl_manual.html#IDX45">Errors</A>
<LI><A HREF="gsl_manual.html#IDX1682">estimated standard deviation</A>
<LI><A HREF="gsl_manual.html#IDX1683">estimated variance</A>
<LI><A HREF="gsl_manual.html#IDX88">euclidean distance function, hypot</A>
<LI><A HREF="gsl_manual.html#IDX68">Euler's constant, defined as a macro</A>
<LI><A HREF="gsl_manual.html#IDX216">evaluation of polynomials</A>
<LI><A HREF="gsl_manual.html#IDX219">evaluation of polynomials, in divided difference form</A>
<LI><A HREF="gsl_manual.html#IDX17">examples, conventions used in</A>
<LI><A HREF="gsl_manual.html#IDX2332">exceptions, IEEE arithmetic</A>
<LI><A HREF="gsl_manual.html#IDX958">exchanging permutation elements</A>
<LI><A HREF="gsl_manual.html#IDX476">exp</A>
<LI><A HREF="gsl_manual.html#IDX84">expm1</A>
<LI><A HREF="gsl_manual.html#IDX2315">exponent, IEEE format</A>
<LI><A HREF="gsl_manual.html#IDX1494">Exponential distribution</A>
<LI><A HREF="gsl_manual.html#IDX475">exponential function</A>
<LI><A HREF="gsl_manual.html#IDX495">exponential integrals</A>
<LI><A HREF="gsl_manual.html#IDX1509">Exponential power distribution</A>
<LI><A HREF="gsl_manual.html#IDX85">exponential, difference from 1 computed accurately</A>
<LI><A HREF="gsl_manual.html#IDX170">exponentiation of complex number</A>
</DIR>
<H2>f</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1567">F-distribution</A>
<LI><A HREF="gsl_manual.html#IDX566">factorial</A>
<LI><A HREF="gsl_manual.html#IDX1176">factorization of matrices</A>
<LI><A HREF="gsl_manual.html#IDX2101">false position algorithm for finding roots</A>
<LI><A HREF="gsl_manual.html#IDX1291">Fast Fourier Transforms, see FFT</A>
<LI><A HREF="gsl_manual.html#IDX2491">FDL, GNU Free Documentation License</A>
<LI><A HREF="gsl_manual.html#IDX1913">Fehlberg method, differential equations</A>
<LI><A HREF="gsl_manual.html#IDX523">Fermi-Dirac function</A>
<LI><A HREF="gsl_manual.html#IDX1290">FFT</A>
<LI><A HREF="gsl_manual.html#IDX1295">FFT mathematical definition</A>
<LI><A HREF="gsl_manual.html#IDX1307">FFT of complex data, mixed-radix algorithm</A>
<LI><A HREF="gsl_manual.html#IDX1297">FFT of complex data, radix-2 algorithm</A>
<LI><A HREF="gsl_manual.html#IDX1318">FFT of real data</A>
<LI><A HREF="gsl_manual.html#IDX1324">FFT of real data, mixed-radix algorithm</A>
<LI><A HREF="gsl_manual.html#IDX1319">FFT of real data, radix-2 algorithm</A>
<LI><A HREF="gsl_manual.html#IDX1296">FFT, complex data</A>
<LI><A HREF="gsl_manual.html#IDX2118">finding minima</A>
<LI><A HREF="gsl_manual.html#IDX2067">finding roots</A>
<LI><A HREF="gsl_manual.html#IDX2068">finding zeros</A>
<LI><A HREF="gsl_manual.html#IDX2244">fits, multi-parameter linear</A>
<LI><A HREF="gsl_manual.html#IDX2231">fitting</A>
<LI><A HREF="gsl_manual.html#IDX1994">fitting, using Chebyshev polynomials</A>
<LI><A HREF="gsl_manual.html#IDX525">Fj(x), Fermi-Dirac integral</A>
<LI><A HREF="gsl_manual.html#IDX543">Fj(x,b), incomplete Fermi-Dirac integral</A>
<LI><A HREF="gsl_manual.html#IDX1545">flat distribution</A>
<LI><A HREF="gsl_manual.html#IDX2215">Fletcher-Reeves conjugate gradient algorithm, minimization</A>
<LI><A HREF="gsl_manual.html#IDX131">floating point numbers, approximate comparison</A>
<LI><A HREF="gsl_manual.html#IDX2309">force and energy, units of</A>
<LI><A HREF="gsl_manual.html#IDX828">Fortran range checking, equivalent in gcc</A>
<LI><A HREF="gsl_manual.html#IDX1407">Four-tap Generalized Feedback Shift Register</A>
<LI><A HREF="gsl_manual.html#IDX1366">Fourier integrals, numerical</A>
<LI><A HREF="gsl_manual.html#IDX1292">Fourier Transforms, see FFT</A>
<LI><A HREF="gsl_manual.html#IDX355">Fractional Order Bessel Functions</A>
<LI><A HREF="gsl_manual.html#IDX2490">free documentation</A>
<LI><A HREF="gsl_manual.html#IDX3">free software, explanation of</A>
<LI><A HREF="gsl_manual.html#IDX105">frexp</A>
<LI><A HREF="gsl_manual.html#IDX1986">functions, numerical differentiation</A>
<LI><A HREF="gsl_manual.html#IDX2288">fundamental constants</A>
</DIR>
<H2>g</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1537">Gamma distribution</A>
<LI><A HREF="gsl_manual.html#IDX546">gamma function</A>
<LI><A HREF="gsl_manual.html#IDX1340">Gauss-Kronrod quadrature</A>
<LI><A HREF="gsl_manual.html#IDX1469">Gaussian distribution</A>
<LI><A HREF="gsl_manual.html#IDX1491">Gaussian distribution, bivariate</A>
<LI><A HREF="gsl_manual.html#IDX1484">Gaussian Tail distribution</A>
<LI><A HREF="gsl_manual.html#IDX827">gcc extensions, range-checking</A>
<LI><A HREF="gsl_manual.html#IDX2341">gcc warning options</A>
<LI><A HREF="gsl_manual.html#IDX2337">gdb</A>
<LI><A HREF="gsl_manual.html#IDX1928">Gear method, differential equations</A>
<LI><A HREF="gsl_manual.html#IDX613">Gegenbauer functions</A>
<LI><A HREF="gsl_manual.html#IDX1138">GEMM, Level-3 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1096">GEMV, Level-2 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX229">general polynomial equations, solving</A>
<LI><A HREF="gsl_manual.html#IDX1666">Geometric random variates</A>, <A HREF="gsl_manual.html#IDX1670">Geometric random variates</A>
<LI><A HREF="gsl_manual.html#IDX1117">GER, Level-2 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1121">GERC, Level-2 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1118">GERU, Level-2 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1083">Givens Rotation, BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1089">Givens Rotation, Modified, BLAS</A>
<LI><A HREF="gsl_manual.html#IDX2">GNU General Public License</A>
<LI><A HREF="gsl_manual.html#IDX2138">golden section algorithm for finding minima</A>
<LI><A HREF="gsl_manual.html#IDX234">gsl_sf_result</A>
<LI><A HREF="gsl_manual.html#IDX235">gsl_sf_result_e10</A>
<LI><A HREF="gsl_manual.html#IDX1619">Gumbel distribution (Type 1)</A>
<LI><A HREF="gsl_manual.html#IDX1627">Gumbel distribution (Type 2)</A>
</DIR>
<H2>h</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX2029">Haar wavelets</A>
<LI><A HREF="gsl_manual.html#IDX2056">Hankel transforms, discrete</A>
<LI><A HREF="gsl_manual.html#IDX36">HAVE_INLINE</A>
<LI><A HREF="gsl_manual.html#IDX471">hazard function, normal distribution</A>
<LI><A HREF="gsl_manual.html#IDX1843">HBOOK</A>
<LI><A HREF="gsl_manual.html#IDX28">header files, including</A>
<LI><A HREF="gsl_manual.html#IDX1008">heapsort</A>
<LI><A HREF="gsl_manual.html#IDX1146">HEMM, Level-3 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1112">HEMV, Level-2 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1127">HER, Level-2 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1133">HER2, Level-2 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1172">HER2K, Level-3 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1164">HERK, Level-3 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1279">hermitian matrix, complex, eigensystem</A>
<LI><A HREF="gsl_manual.html#IDX1745">histogram statistics</A>
<LI><A HREF="gsl_manual.html#IDX1839">histogram, from ntuple</A>
<LI><A HREF="gsl_manual.html#IDX1727">histograms</A>
<LI><A HREF="gsl_manual.html#IDX1776">histograms, random sampling from</A>
<LI><A HREF="gsl_manual.html#IDX1261">Householder linear solver</A>
<LI><A HREF="gsl_manual.html#IDX1253">Householder matrix</A>
<LI><A HREF="gsl_manual.html#IDX1254">Householder transformation</A>
<LI><A HREF="gsl_manual.html#IDX2184">HYBRID algorithm, unscaled without derivatives</A>
<LI><A HREF="gsl_manual.html#IDX2170">HYBRID algorithms for nonlinear systems</A>
<LI><A HREF="gsl_manual.html#IDX2175">HYBRIDJ algorithm</A>
<LI><A HREF="gsl_manual.html#IDX2182">HYBRIDS algorithm, scaled without derivatives</A>
<LI><A HREF="gsl_manual.html#IDX2172">HYBRIDSJ algorithm</A>
<LI><A HREF="gsl_manual.html#IDX388">hydrogen atom</A>
<LI><A HREF="gsl_manual.html#IDX92">hyperbolic cosine, inverse</A>
<LI><A HREF="gsl_manual.html#IDX198">hyperbolic functions, complex numbers</A>
<LI><A HREF="gsl_manual.html#IDX504">hyperbolic integrals</A>
<LI><A HREF="gsl_manual.html#IDX96">hyperbolic sine, inverse</A>
<LI><A HREF="gsl_manual.html#IDX666">hyperbolic space</A>
<LI><A HREF="gsl_manual.html#IDX100">hyperbolic tangent, inverse</A>
<LI><A HREF="gsl_manual.html#IDX623">hypergeometric functions</A>
<LI><A HREF="gsl_manual.html#IDX1668">hypergeometric random variates</A>
<LI><A HREF="gsl_manual.html#IDX87">hypot</A>
<LI><A HREF="gsl_manual.html#IDX763">hypot function, special functions</A>
</DIR>
<H2>i</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX886">identity matrix</A>
<LI><A HREF="gsl_manual.html#IDX953">identity permutation</A>
<LI><A HREF="gsl_manual.html#IDX2328">IEEE exceptions</A>
<LI><A HREF="gsl_manual.html#IDX2312">IEEE floating point</A>
<LI><A HREF="gsl_manual.html#IDX2313">IEEE format for floating point numbers</A>
<LI><A HREF="gsl_manual.html#IDX70">IEEE infinity, defined as a macro</A>
<LI><A HREF="gsl_manual.html#IDX73">IEEE NaN, defined as a macro</A>
<LI><A HREF="gsl_manual.html#IDX2307">illumination, units of</A>
<LI><A HREF="gsl_manual.html#IDX2294">imperial units</A>
<LI><A HREF="gsl_manual.html#IDX1864">importance sampling, VEGAS</A>
<LI><A HREF="gsl_manual.html#IDX27">including GSL header files</A>
<LI><A HREF="gsl_manual.html#IDX610">incomplete Beta function, normalized</A>
<LI><A HREF="gsl_manual.html#IDX542">incomplete Fermi-Dirac integral</A>
<LI><A HREF="gsl_manual.html#IDX595">incomplete Gamma function</A>
<LI><A HREF="gsl_manual.html#IDX1011">indirect sorting</A>
<LI><A HREF="gsl_manual.html#IDX1017">indirect sorting, of vector elements</A>
<LI><A HREF="gsl_manual.html#IDX69">infinity, defined as a macro</A>
<LI><A HREF="gsl_manual.html#IDX2321">infinity, IEEE format</A>
<LI><A HREF="gsl_manual.html#IDX7">info-gsl mailing list</A>
<LI><A HREF="gsl_manual.html#IDX1897">initial value problems, differential equations</A>
<LI><A HREF="gsl_manual.html#IDX885">initializing matrices</A>
<LI><A HREF="gsl_manual.html#IDX834">initializing vectors</A>
<LI><A HREF="gsl_manual.html#IDX35">inline functions</A>
<LI><A HREF="gsl_manual.html#IDX722">integer powers</A>
<LI><A HREF="gsl_manual.html#IDX496">integrals, exponential</A>
<LI><A HREF="gsl_manual.html#IDX1338">integration, numerical (quadrature)</A>
<LI><A HREF="gsl_manual.html#IDX1945">interpolation</A>
<LI><A HREF="gsl_manual.html#IDX1995">interpolation, using Chebyshev polynomials</A>
<LI><A HREF="gsl_manual.html#IDX187">inverse complex trigonometric functions</A>
<LI><A HREF="gsl_manual.html#IDX1466">inverse cumulative distribution functions</A>
<LI><A HREF="gsl_manual.html#IDX93">inverse hyperbolic cosine</A>
<LI><A HREF="gsl_manual.html#IDX205">inverse hyperbolic functions, complex numbers</A>
<LI><A HREF="gsl_manual.html#IDX97">inverse hyperbolic sine</A>
<LI><A HREF="gsl_manual.html#IDX101">inverse hyperbolic tangent</A>
<LI><A HREF="gsl_manual.html#IDX1191">inverse of a matrix, by LU decomposition</A>
<LI><A HREF="gsl_manual.html#IDX968">inverting a permutation</A>
<LI><A HREF="gsl_manual.html#IDX273">Irregular Cylindrical Bessel Functions</A>
<LI><A HREF="gsl_manual.html#IDX369">Irregular Modified Bessel Functions, Fractional Order</A>
<LI><A HREF="gsl_manual.html#IDX297">Irregular Modified Cylindrical Bessel Functions</A>
<LI><A HREF="gsl_manual.html#IDX345">Irregular Modified Spherical Bessel Functions</A>
<LI><A HREF="gsl_manual.html#IDX324">Irregular Spherical Bessel Functions</A>
<LI><A HREF="gsl_manual.html#IDX1001">iterating through combinations</A>
<LI><A HREF="gsl_manual.html#IDX970">iterating through permutations</A>
<LI><A HREF="gsl_manual.html#IDX1187">iterative refinement of solutions in linear systems</A>
</DIR>
<H2>j</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX455">Jacobi elliptic functions</A>
</DIR>
<H2>l</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX647">Laguerre functions</A>
<LI><A HREF="gsl_manual.html#IDX658">Lambert function</A>
<LI><A HREF="gsl_manual.html#IDX1529">Landau distribution</A>
<LI><A HREF="gsl_manual.html#IDX1177">LAPACK, recommended for linear algebra</A>, <A HREF="gsl_manual.html#IDX1270">LAPACK, recommended for linear algebra</A>
<LI><A HREF="gsl_manual.html#IDX1502">Laplace distribution</A>
<LI><A HREF="gsl_manual.html#IDX34">LD_LIBRARY_PATH</A>
<LI><A HREF="gsl_manual.html#IDX103">ldexp</A>
<LI><A HREF="gsl_manual.html#IDX874">leading dimension, matrices</A>
<LI><A HREF="gsl_manual.html#IDX2232">least squares fit</A>
<LI><A HREF="gsl_manual.html#IDX2254">least squares fitting, nonlinear</A>
<LI><A HREF="gsl_manual.html#IDX2282">least squares, covariance of best-fit parameters</A>
<LI><A HREF="gsl_manual.html#IDX433">Legendre forms of elliptic integrals</A>
<LI><A HREF="gsl_manual.html#IDX663">Legendre functions</A>
<LI><A HREF="gsl_manual.html#IDX89">length, computed accurately using hypot</A>
<LI><A HREF="gsl_manual.html#IDX2275">Levenberg-Marquardt algorithms</A>
<LI><A HREF="gsl_manual.html#IDX2009">Levin u-transform</A>
<LI><A HREF="gsl_manual.html#IDX1532">Levy distribution</A>
<LI><A HREF="gsl_manual.html#IDX1534">Levy distribution, skew</A>
<LI><A HREF="gsl_manual.html#IDX31">libraries, linking with</A>
<LI><A HREF="gsl_manual.html#IDX33">libraries, shared</A>
<LI><A HREF="gsl_manual.html#IDX1">license of GSL</A>
<LI><A HREF="gsl_manual.html#IDX2306">light, units of</A>
<LI><A HREF="gsl_manual.html#IDX1173">linear algebra</A>
<LI><A HREF="gsl_manual.html#IDX1028">linear algebra, BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1951">linear interpolation</A>
<LI><A HREF="gsl_manual.html#IDX2235">linear regression</A>
<LI><A HREF="gsl_manual.html#IDX1188">linear systems, refinement of solutions</A>
<LI><A HREF="gsl_manual.html#IDX1181">linear systems, solution of</A>
<LI><A HREF="gsl_manual.html#IDX30">linking with GSL libraries</A>
<LI><A HREF="gsl_manual.html#IDX2277">LMDER algorithm</A>
<LI><A HREF="gsl_manual.html#IDX81">log1p</A>
<LI><A HREF="gsl_manual.html#IDX711">logarithm and related functions</A>
<LI><A HREF="gsl_manual.html#IDX607">logarithm of Beta function</A>
<LI><A HREF="gsl_manual.html#IDX581">logarithm of combinatorial factor C(m,n)</A>
<LI><A HREF="gsl_manual.html#IDX174">logarithm of complex number</A>
<LI><A HREF="gsl_manual.html#IDX778">logarithm of cosh function, special functions</A>
<LI><A HREF="gsl_manual.html#IDX575">logarithm of double factorial</A>
<LI><A HREF="gsl_manual.html#IDX572">logarithm of factorial</A>
<LI><A HREF="gsl_manual.html#IDX551">logarithm of Gamma function</A>
<LI><A HREF="gsl_manual.html#IDX588">logarithm of Pochhammer symbol</A>
<LI><A HREF="gsl_manual.html#IDX775">logarithm of sinh function, special functions</A>
<LI><A HREF="gsl_manual.html#IDX1199">logarithm of the determinant of a matrix</A>
<LI><A HREF="gsl_manual.html#IDX82">logarithm, computed accurately near 1</A>
<LI><A HREF="gsl_manual.html#IDX1673">Logarithmic random variates</A>
<LI><A HREF="gsl_manual.html#IDX1585">Logistic distribution</A>
<LI><A HREF="gsl_manual.html#IDX1553">Lognormal distribution</A>
<LI><A HREF="gsl_manual.html#IDX37">long double</A>
<LI><A HREF="gsl_manual.html#IDX1449">low discrepancy sequences</A>
<LI><A HREF="gsl_manual.html#IDX2343">Low-level CBLAS</A>
<LI><A HREF="gsl_manual.html#IDX1178">LU decomposition</A>
</DIR>
<H2>m</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX65">macros for mathematical constants</A>
<LI><A HREF="gsl_manual.html#IDX145">magnitude of complex number</A>
<LI><A HREF="gsl_manual.html#IDX13">mailing list archives</A>
<LI><A HREF="gsl_manual.html#IDX6">mailing list for GSL announcements</A>
<LI><A HREF="gsl_manual.html#IDX12">mailing list, bug-gsl</A>
<LI><A HREF="gsl_manual.html#IDX2317">mantissa, IEEE format</A>
<LI><A HREF="gsl_manual.html#IDX2299">mass, units of</A>
<LI><A HREF="gsl_manual.html#IDX62">mathematical constants, defined as macros</A>
<LI><A HREF="gsl_manual.html#IDX61">mathematical functions, elementary</A>
<LI><A HREF="gsl_manual.html#IDX811">matrices</A>, <A HREF="gsl_manual.html#IDX871">matrices</A>
<LI><A HREF="gsl_manual.html#IDX884">matrices, initializing</A>
<LI><A HREF="gsl_manual.html#IDX878">matrices, range-checking</A>
<LI><A HREF="gsl_manual.html#IDX1196">matrix determinant</A>
<LI><A HREF="gsl_manual.html#IDX913">matrix diagonal</A>
<LI><A HREF="gsl_manual.html#IDX1175">matrix factorization</A>
<LI><A HREF="gsl_manual.html#IDX1192">matrix inverse</A>
<LI><A HREF="gsl_manual.html#IDX1236">matrix square root, Cholesky decomposition</A>
<LI><A HREF="gsl_manual.html#IDX917">matrix subdiagonal</A>
<LI><A HREF="gsl_manual.html#IDX921">matrix superdiagonal</A>
<LI><A HREF="gsl_manual.html#IDX891">matrix, constant</A>
<LI><A HREF="gsl_manual.html#IDX887">matrix, identity</A>
<LI><A HREF="gsl_manual.html#IDX1029">matrix, operations</A>
<LI><A HREF="gsl_manual.html#IDX889">matrix, zero</A>
<LI><A HREF="gsl_manual.html#IDX1687">max</A>
<LI><A HREF="gsl_manual.html#IDX2026">maximal phase, Daubechies wavelets</A>
<LI><A HREF="gsl_manual.html#IDX2116">maximization, see minimization</A>
<LI><A HREF="gsl_manual.html#IDX119">maximum of two numbers</A>
<LI><A HREF="gsl_manual.html#IDX1747">maximum value, from histogram</A>
<LI><A HREF="gsl_manual.html#IDX1679">mean</A>
<LI><A HREF="gsl_manual.html#IDX1753">mean value, from histogram</A>
<LI><A HREF="gsl_manual.html#IDX472">Mill's ratio, inverse</A>
<LI><A HREF="gsl_manual.html#IDX1686">min</A>
<LI><A HREF="gsl_manual.html#IDX2223">minimization, BFGS conjugate gradient algorithm</A>
<LI><A HREF="gsl_manual.html#IDX2121">minimization, caveats</A>
<LI><A HREF="gsl_manual.html#IDX2217">minimization, conjugate gradient algorithm</A>
<LI><A HREF="gsl_manual.html#IDX2191">minimization, multidimensional</A>
<LI><A HREF="gsl_manual.html#IDX2117">minimization, one-dimensional</A>
<LI><A HREF="gsl_manual.html#IDX2120">minimization, overview</A>
<LI><A HREF="gsl_manual.html#IDX2220">minimization, Polak-Ribiere algorithm</A>
<LI><A HREF="gsl_manual.html#IDX2127">minimization, providing a function to minimize</A>
<LI><A HREF="gsl_manual.html#IDX2230">minimization, simplex algorithm</A>
<LI><A HREF="gsl_manual.html#IDX2226">minimization, steepest descent algorithm</A>
<LI><A HREF="gsl_manual.html#IDX2135">minimization, stopping parameters</A>
<LI><A HREF="gsl_manual.html#IDX2142">minimum finding, Brent's method</A>
<LI><A HREF="gsl_manual.html#IDX2139">minimum finding, golden section algorithm</A>
<LI><A HREF="gsl_manual.html#IDX121">minimum of two numbers</A>
<LI><A HREF="gsl_manual.html#IDX1748">minimum value, from histogram</A>
<LI><A HREF="gsl_manual.html#IDX2173">MINPACK, minimization algorithms</A>, <A HREF="gsl_manual.html#IDX2278">MINPACK, minimization algorithms</A>
<LI><A HREF="gsl_manual.html#IDX808">MISCFUN</A>
<LI><A HREF="gsl_manual.html#IDX1852">MISER monte carlo integration</A>
<LI><A HREF="gsl_manual.html#IDX1308">Mixed-radix FFT, complex data</A>
<LI><A HREF="gsl_manual.html#IDX1325">Mixed-radix FFT, real data</A>
<LI><A HREF="gsl_manual.html#IDX363">Modified Bessel Functions, Fractional Order</A>
<LI><A HREF="gsl_manual.html#IDX1342">Modified Clenshaw-Curtis quadrature</A>
<LI><A HREF="gsl_manual.html#IDX281">Modified Cylindrical Bessel Functions</A>
<LI><A HREF="gsl_manual.html#IDX1088">Modified Givens Rotation, BLAS</A>
<LI><A HREF="gsl_manual.html#IDX2179">Modified Newton's method for nonlinear systems</A>
<LI><A HREF="gsl_manual.html#IDX334">Modified Spherical Bessel Functions</A>
<LI><A HREF="gsl_manual.html#IDX1844">Monte Carlo integration</A>
<LI><A HREF="gsl_manual.html#IDX1402">MRG, multiple recursive random number generator</A>
<LI><A HREF="gsl_manual.html#IDX1388">MT19937 random number generator</A>
<LI><A HREF="gsl_manual.html#IDX2243">multi-parameter regression</A>
<LI><A HREF="gsl_manual.html#IDX2190">multidimensional root finding, Broyden algorithm</A>
<LI><A HREF="gsl_manual.html#IDX2146">multidimensional root finding, overview</A>
<LI><A HREF="gsl_manual.html#IDX2155">multidimensional root finding, providing a function to solve</A>
<LI><A HREF="gsl_manual.html#IDX2192">Multimin, caveats</A>
<LI><A HREF="gsl_manual.html#IDX1657">Multinomial distribution</A>
<LI><A HREF="gsl_manual.html#IDX429">multiplication</A>
</DIR>
<H2>n</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1608">N-dimensional random direction vector</A>
<LI><A HREF="gsl_manual.html#IDX71">NaN, defined as a macro</A>
<LI><A HREF="gsl_manual.html#IDX2296">nautical units</A>
<LI><A HREF="gsl_manual.html#IDX1661">Negative Binomial distribution, random variates</A>
<LI><A HREF="gsl_manual.html#IDX2228">Nelder-Mead simplex algorithm for minimization</A>
<LI><A HREF="gsl_manual.html#IDX2187">Newton algorithm, discrete</A>
<LI><A HREF="gsl_manual.html#IDX2180">Newton algorithm, globally convergent</A>
<LI><A HREF="gsl_manual.html#IDX2107">Newton's method for finding roots</A>
<LI><A HREF="gsl_manual.html#IDX2177">Newton's method for systems of nonlinear equations</A>
<LI><A HREF="gsl_manual.html#IDX1451">Niederreiter sequence</A>
<LI><A HREF="gsl_manual.html#IDX2251">NIST Statistical Reference Datasets</A>
<LI><A HREF="gsl_manual.html#IDX601">non-normalized incomplete Gamma function</A>
<LI><A HREF="gsl_manual.html#IDX2071">nonlinear equation, solutions of</A>
<LI><A HREF="gsl_manual.html#IDX2270">nonlinear fitting, stopping parameters</A>
<LI><A HREF="gsl_manual.html#IDX2119">nonlinear functions, minimization</A>
<LI><A HREF="gsl_manual.html#IDX2253">nonlinear least squares fitting</A>
<LI><A HREF="gsl_manual.html#IDX2255">nonlinear least squares fitting, overview</A>
<LI><A HREF="gsl_manual.html#IDX2144">nonlinear systems of equations, solution of</A>
<LI><A HREF="gsl_manual.html#IDX2318">normalized form, IEEE format</A>
<LI><A HREF="gsl_manual.html#IDX611">normalized incomplete Beta function</A>
<LI><A HREF="gsl_manual.html#IDX72">Not-a-number, defined as a macro</A>
<LI><A HREF="gsl_manual.html#IDX1045">NRM2, Level-1 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1830">ntuples</A>
<LI><A HREF="gsl_manual.html#IDX2292">nuclear physics, constants</A>
<LI><A HREF="gsl_manual.html#IDX63">numerical constants, defined as macros</A>
<LI><A HREF="gsl_manual.html#IDX1988">numerical derivatives</A>
<LI><A HREF="gsl_manual.html#IDX1337">numerical integration (quadrature)</A>
</DIR>
<H2>o</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX4">obtaining GSL</A>
<LI><A HREF="gsl_manual.html#IDX1899">ODEs, initial value problems</A>
<LI><A HREF="gsl_manual.html#IDX1880">optimization, combinatorial</A>
<LI><A HREF="gsl_manual.html#IDX2115">optimization, see minimization</A>
<LI><A HREF="gsl_manual.html#IDX39">optimized functions, alternatives</A>
<LI><A HREF="gsl_manual.html#IDX1898">ordinary differential equations, initial value problem</A>
<LI><A HREF="gsl_manual.html#IDX1360">oscillatory functions, numerical integration of</A>
<LI><A HREF="gsl_manual.html#IDX2335">overflow, IEEE exceptions</A>
</DIR>
<H2>p</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1592">Pareto distribution</A>
<LI><A HREF="gsl_manual.html#IDX1842">PAW</A>
<LI><A HREF="gsl_manual.html#IDX949">permutations</A>
<LI><A HREF="gsl_manual.html#IDX2284">physical constants</A>
<LI><A HREF="gsl_manual.html#IDX872">physical dimension, matrices</A>
<LI><A HREF="gsl_manual.html#IDX67">pi, defined as a macro</A>
<LI><A HREF="gsl_manual.html#IDX1847">plain monte carlo</A>
<LI><A HREF="gsl_manual.html#IDX584">Pochhammer symbol</A>
<LI><A HREF="gsl_manual.html#IDX1648">Poisson random numbers</A>
<LI><A HREF="gsl_manual.html#IDX2219">Polak-Ribiere algorithm, minimization</A>
<LI><A HREF="gsl_manual.html#IDX134">polar form of complex numbers</A>
<LI><A HREF="gsl_manual.html#IDX779">polar to rectangular conversion</A>
<LI><A HREF="gsl_manual.html#IDX727">polygamma functions</A>
<LI><A HREF="gsl_manual.html#IDX215">polynomial evaluation</A>
<LI><A HREF="gsl_manual.html#IDX1953">polynomial interpolation</A>
<LI><A HREF="gsl_manual.html#IDX214">polynomials, roots of</A>
<LI><A HREF="gsl_manual.html#IDX721">power function</A>
<LI><A HREF="gsl_manual.html#IDX169">power of complex number</A>
<LI><A HREF="gsl_manual.html#IDX2302">power, units of</A>
<LI><A HREF="gsl_manual.html#IDX2329">precision, IEEE arithmetic</A>
<LI><A HREF="gsl_manual.html#IDX2310">prefixes</A>
<LI><A HREF="gsl_manual.html#IDX2304">pressure, units of</A>
<LI><A HREF="gsl_manual.html#IDX1920">Prince-Dormand, Runge-Kutta method</A>
<LI><A HREF="gsl_manual.html#IDX2297">printers units</A>
<LI><A HREF="gsl_manual.html#IDX1773">probability distribution, from histogram</A>
<LI><A HREF="gsl_manual.html#IDX1772">probability distributions, from histograms</A>
<LI><A HREF="gsl_manual.html#IDX1840">projection of ntuples</A>
<LI><A HREF="gsl_manual.html#IDX725">psi function</A>
</DIR>
<H2>q</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1205">QR decomposition</A>
<LI><A HREF="gsl_manual.html#IDX1219">QR decomposition with column pivoting</A>
<LI><A HREF="gsl_manual.html#IDX1339">QUADPACK</A>
<LI><A HREF="gsl_manual.html#IDX223">quadratic equation, solving</A>
<LI><A HREF="gsl_manual.html#IDX1336">quadrature</A>
<LI><A HREF="gsl_manual.html#IDX1467">quantile functions</A>
<LI><A HREF="gsl_manual.html#IDX1448">quasi-random sequences</A>
</DIR>
<H2>r</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1425">R250 shift-register random number generator</A>
<LI><A HREF="gsl_manual.html#IDX405">Racah coefficients</A>
<LI><A HREF="gsl_manual.html#IDX2308">radioactivity, units of</A>
<LI><A HREF="gsl_manual.html#IDX1320">Radix-2 FFT for real data</A>
<LI><A HREF="gsl_manual.html#IDX1298">Radix-2 FFT, complex data</A>
<LI><A HREF="gsl_manual.html#IDX1408">rand, BSD random number generator</A>
<LI><A HREF="gsl_manual.html#IDX1417">rand48 random number generator</A>
<LI><A HREF="gsl_manual.html#IDX1463">random number distributions</A>
<LI><A HREF="gsl_manual.html#IDX1368">random number generators</A>
<LI><A HREF="gsl_manual.html#IDX1775">random sampling from histograms</A>
<LI><A HREF="gsl_manual.html#IDX1432">RANDU random number generator</A>
<LI><A HREF="gsl_manual.html#IDX1419">RANF random number generator</A>
<LI><A HREF="gsl_manual.html#IDX1685">range</A>
<LI><A HREF="gsl_manual.html#IDX879">range-checking for matrices</A>
<LI><A HREF="gsl_manual.html#IDX825">range-checking for vectors</A>
<LI><A HREF="gsl_manual.html#IDX1398">RANLUX random number generator</A>
<LI><A HREF="gsl_manual.html#IDX1395">RANLXD random number generator</A>
<LI><A HREF="gsl_manual.html#IDX1392">RANLXS random number generator</A>
<LI><A HREF="gsl_manual.html#IDX1422">RANMAR random number generator</A>, <A HREF="gsl_manual.html#IDX1434">RANMAR random number generator</A>
<LI><A HREF="gsl_manual.html#IDX1519">Rayleigh distribution</A>
<LI><A HREF="gsl_manual.html#IDX1526">Rayleigh Tail distribution</A>
<LI><A HREF="gsl_manual.html#IDX1272">real symmetric matrix, eigensystem</A>
<LI><A HREF="gsl_manual.html#IDX558">Reciprocal Gamma function</A>
<LI><A HREF="gsl_manual.html#IDX780">rectangular to polar conversion</A>
<LI><A HREF="gsl_manual.html#IDX1853">recursive stratified sampling, MISER</A>
<LI><A HREF="gsl_manual.html#IDX784">reduction of angular variables</A>
<LI><A HREF="gsl_manual.html#IDX1186">refinement of solutions in linear systems</A>
<LI><A HREF="gsl_manual.html#IDX2233">regression, least squares</A>
<LI><A HREF="gsl_manual.html#IDX357">Regular Bessel Functions, Fractional Order</A>
<LI><A HREF="gsl_manual.html#IDX377">Regular Bessel Functions, Zeros of</A>
<LI><A HREF="gsl_manual.html#IDX265">Regular Cylindrical Bessel Functions</A>
<LI><A HREF="gsl_manual.html#IDX364">Regular Modified Bessel Functions, Fractional Order</A>
<LI><A HREF="gsl_manual.html#IDX282">Regular Modified Cylindrical Bessel Functions</A>
<LI><A HREF="gsl_manual.html#IDX335">Regular Modified Spherical Bessel Functions</A>
<LI><A HREF="gsl_manual.html#IDX313">Regular Spherical Bessel Functions</A>
<LI><A HREF="gsl_manual.html#IDX555">Regulated Gamma function</A>
<LI><A HREF="gsl_manual.html#IDX592">relative Pochhammer symbol</A>
<LI><A HREF="gsl_manual.html#IDX9">reporting bugs in GSL</A>
<LI><A HREF="gsl_manual.html#IDX133">representations of complex numbers</A>
<LI><A HREF="gsl_manual.html#IDX1770">resampling from histograms</A>
<LI><A HREF="gsl_manual.html#IDX2168">residual, in nonlinear systems of equations</A>, <A HREF="gsl_manual.html#IDX2272">residual, in nonlinear systems of equations</A>
<LI><A HREF="gsl_manual.html#IDX966">reversing a permutation</A>
<LI><A HREF="gsl_manual.html#IDX1908">RK2, Runge-Kutta method</A>
<LI><A HREF="gsl_manual.html#IDX1911">RK4, Runge-Kutta method</A>
<LI><A HREF="gsl_manual.html#IDX1914">RKF45, Runge-Kutta-Fehlberg method</A>
<LI><A HREF="gsl_manual.html#IDX2065">root finding</A>
<LI><A HREF="gsl_manual.html#IDX2099">root finding, bisection algorithm</A>
<LI><A HREF="gsl_manual.html#IDX2105">root finding, Brent's method</A>
<LI><A HREF="gsl_manual.html#IDX2073">root finding, caveats</A>
<LI><A HREF="gsl_manual.html#IDX2102">root finding, false position algorithm</A>
<LI><A HREF="gsl_manual.html#IDX2086">root finding, initial guess</A>
<LI><A HREF="gsl_manual.html#IDX2108">root finding, Newton's method</A>
<LI><A HREF="gsl_manual.html#IDX2072">root finding, overview</A>
<LI><A HREF="gsl_manual.html#IDX2082">root finding, providing a function to solve</A>
<LI><A HREF="gsl_manual.html#IDX2085">root finding, search bounds</A>
<LI><A HREF="gsl_manual.html#IDX2111">root finding, secant method</A>
<LI><A HREF="gsl_manual.html#IDX2114">root finding, Steffenson's method</A>
<LI><A HREF="gsl_manual.html#IDX2093">root finding, stopping parameters</A>, <A HREF="gsl_manual.html#IDX2166">root finding, stopping parameters</A>
<LI><A HREF="gsl_manual.html#IDX2069">roots</A>
<LI><A HREF="gsl_manual.html#IDX1082">ROTG, Level-1 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX2330">rounding mode</A>
<LI><A HREF="gsl_manual.html#IDX1916">Runge-Kutta Cash-Karp method</A>
<LI><A HREF="gsl_manual.html#IDX1909">Runge-Kutta methods, ordinary differential equations</A>
<LI><A HREF="gsl_manual.html#IDX1919">Runge-Kutta Prince-Dormand method</A>
</DIR>
<H2>s</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX130">safe comparison of floating point numbers</A>
<LI><A HREF="gsl_manual.html#IDX1771">sampling from histograms</A>, <A HREF="gsl_manual.html#IDX1774">sampling from histograms</A>
<LI><A HREF="gsl_manual.html#IDX1079">SCAL, Level-1 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1884">schedule, cooling</A>
<LI><A HREF="gsl_manual.html#IDX2110">secant method for finding roots</A>
<LI><A HREF="gsl_manual.html#IDX1837">selection function, ntuples</A>
<LI><A HREF="gsl_manual.html#IDX2007">series, acceleration</A>
<LI><A HREF="gsl_manual.html#IDX32">shared libraries</A>
<LI><A HREF="gsl_manual.html#IDX18">shell prompt</A>
<LI><A HREF="gsl_manual.html#IDX505">Shi(x)</A>
<LI><A HREF="gsl_manual.html#IDX1424">shift-register random number generator</A>
<LI><A HREF="gsl_manual.html#IDX514">Si(x)</A>
<LI><A HREF="gsl_manual.html#IDX2316">sign bit, IEEE format</A>
<LI><A HREF="gsl_manual.html#IDX1202">sign of the determinant of a matrix</A>
<LI><A HREF="gsl_manual.html#IDX2229">simplex algorithm, minimization</A>
<LI><A HREF="gsl_manual.html#IDX1878">simulated annealing</A>
<LI><A HREF="gsl_manual.html#IDX179">sin, of complex number</A>
<LI><A HREF="gsl_manual.html#IDX757">sine function, special functions</A>
<LI><A HREF="gsl_manual.html#IDX2322">single precision, IEEE format</A>
<LI><A HREF="gsl_manual.html#IDX1355">singular functions, numerical integration of</A>
<LI><A HREF="gsl_manual.html#IDX1348">singular points, specifying positions in quadrature</A>
<LI><A HREF="gsl_manual.html#IDX1229">singular value decomposition</A>
<LI><A HREF="gsl_manual.html#IDX1535">Skew Levy distribution</A>
<LI><A HREF="gsl_manual.html#IDX1989">slope, see numerical derivative</A>
<LI><A HREF="gsl_manual.html#IDX1450">Sobol sequence</A>
<LI><A HREF="gsl_manual.html#IDX1260">solution of linear system by Householder transformations</A>
<LI><A HREF="gsl_manual.html#IDX1174">solution of linear systems, Ax=b</A>
<LI><A HREF="gsl_manual.html#IDX2070">solving a nonlinear equation</A>
<LI><A HREF="gsl_manual.html#IDX2143">solving nonlinear systems of equations</A>
<LI><A HREF="gsl_manual.html#IDX1007">sorting</A>
<LI><A HREF="gsl_manual.html#IDX1287">sorting eigenvalues and eigenvectors</A>
<LI><A HREF="gsl_manual.html#IDX1013">sorting vector elements</A>
<LI><A HREF="gsl_manual.html#IDX44">source code, reuse in applications</A>
<LI><A HREF="gsl_manual.html#IDX233">special functions</A>
<LI><A HREF="gsl_manual.html#IDX312">Spherical Bessel Functions</A>
<LI><A HREF="gsl_manual.html#IDX664">spherical harmonics</A>
<LI><A HREF="gsl_manual.html#IDX1602">spherical random variates, 2D</A>
<LI><A HREF="gsl_manual.html#IDX1606">spherical random variates, 3D</A>
<LI><A HREF="gsl_manual.html#IDX1610">spherical random variates, N-dimensional</A>
<LI><A HREF="gsl_manual.html#IDX1946">spline</A>
<LI><A HREF="gsl_manual.html#IDX1235">square root of a matrix, Cholesky decomposition</A>
<LI><A HREF="gsl_manual.html#IDX166">square root of complex number</A>
<LI><A HREF="gsl_manual.html#IDX1680">standard deviation</A>
<LI><A HREF="gsl_manual.html#IDX1755">standard deviation, from histogram</A>
<LI><A HREF="gsl_manual.html#IDX22">standards conformance, ANSI C</A>
<LI><A HREF="gsl_manual.html#IDX2252">Statistical Reference Datasets (StRD)</A>
<LI><A HREF="gsl_manual.html#IDX1678">statistics</A>
<LI><A HREF="gsl_manual.html#IDX1746">statistics, from histogram</A>
<LI><A HREF="gsl_manual.html#IDX2225">steepest descent algorithm, minimization</A>
<LI><A HREF="gsl_manual.html#IDX2113">Steffenson's method for finding roots</A>
<LI><A HREF="gsl_manual.html#IDX1845">stratified sampling in monte carlo integration</A>
<LI><A HREF="gsl_manual.html#IDX820">stride, of vector index</A>
<LI><A HREF="gsl_manual.html#IDX1573">Student t-distribution</A>
<LI><A HREF="gsl_manual.html#IDX918">subdiagonal, of a matrix</A>
<LI><A HREF="gsl_manual.html#IDX2006">summation, acceleration</A>
<LI><A HREF="gsl_manual.html#IDX922">superdiagonal, matrix</A>
<LI><A HREF="gsl_manual.html#IDX1228">SVD</A>
<LI><A HREF="gsl_manual.html#IDX1062">SWAP, Level-1 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX959">swapping permutation elements</A>
<LI><A HREF="gsl_manual.html#IDX1143">SYMM, Level-3 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1271">symmetric matrix, real, eigensystem</A>
<LI><A HREF="gsl_manual.html#IDX1109">SYMV, Level-2 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX740">synchrotron functions</A>
<LI><A HREF="gsl_manual.html#IDX1124">SYR, Level-2 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1130">SYR2, Level-2 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1169">SYR2K, Level-3 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1161">SYRK, Level-3 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX2145">systems of equations, nonlinear</A>
</DIR>
<H2>t</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1572">t-distribution</A>
<LI><A HREF="gsl_manual.html#IDX1684">t-test</A>
<LI><A HREF="gsl_manual.html#IDX183">tangent of complex number</A>
<LI><A HREF="gsl_manual.html#IDX1405">Tausworthe random number generator</A>
<LI><A HREF="gsl_manual.html#IDX563">Taylor coefficients, computation of</A>
<LI><A HREF="gsl_manual.html#IDX999">testing combination for validity</A>
<LI><A HREF="gsl_manual.html#IDX964">testing permutation for validity</A>
<LI><A HREF="gsl_manual.html#IDX2303">thermal energy, units of</A>
<LI><A HREF="gsl_manual.html#IDX2293">time units</A>
<LI><A HREF="gsl_manual.html#IDX873">trailing dimension, matrices</A>
<LI><A HREF="gsl_manual.html#IDX1255">transformation, Householder</A>
<LI><A HREF="gsl_manual.html#IDX2057">transforms, Hankel</A>
<LI><A HREF="gsl_manual.html#IDX2019">transforms, wavelet</A>
<LI><A HREF="gsl_manual.html#IDX745">transport functions</A>
<LI><A HREF="gsl_manual.html#IDX1895">traveling salesman problem</A>
<LI><A HREF="gsl_manual.html#IDX1240">tridiagonal decomposition</A>, <A HREF="gsl_manual.html#IDX1244">tridiagonal decomposition</A>
<LI><A HREF="gsl_manual.html#IDX1264">tridiagonal systems</A>
<LI><A HREF="gsl_manual.html#IDX754">trigonometric functions</A>
<LI><A HREF="gsl_manual.html#IDX177">trigonometric functions of complex numbers</A>
<LI><A HREF="gsl_manual.html#IDX513">trigonometric integrals</A>
<LI><A HREF="gsl_manual.html#IDX1151">TRMM, Level-3 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1101">TRMV, Level-2 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1156">TRSM, Level-3 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1106">TRSV, Level-2 BLAS</A>
<LI><A HREF="gsl_manual.html#IDX1894">TSP</A>
<LI><A HREF="gsl_manual.html#IDX1427">TT800 random number generator</A>
<LI><A HREF="gsl_manual.html#IDX1490">two dimensional Gaussian distribution</A>
<LI><A HREF="gsl_manual.html#IDX1782">two dimensional histograms</A>
<LI><A HREF="gsl_manual.html#IDX1501">two-sided exponential distribution</A>
<LI><A HREF="gsl_manual.html#IDX1620">Type 1 Gumbel distribution, random variates</A>
<LI><A HREF="gsl_manual.html#IDX1628">Type 2 Gumbel distribution</A>
</DIR>
<H2>u</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX2008">u-transform for series</A>
<LI><A HREF="gsl_manual.html#IDX2334">underflow, IEEE exceptions</A>
<LI><A HREF="gsl_manual.html#IDX1546">uniform distribution</A>
<LI><A HREF="gsl_manual.html#IDX2287">units, conversion of</A>
<LI><A HREF="gsl_manual.html#IDX2295">units, imperial</A>
<LI><A HREF="gsl_manual.html#IDX1409">Unix random number generators, rand</A>
<LI><A HREF="gsl_manual.html#IDX1410">Unix random number generators, rand48</A>
<LI><A HREF="gsl_manual.html#IDX21">usage, compiling application programs</A>
</DIR>
<H2>v</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX1838">value function, ntuples</A>
<LI><A HREF="gsl_manual.html#IDX1944">Van der Pol oscillator, example</A>
<LI><A HREF="gsl_manual.html#IDX1681">variance</A>
<LI><A HREF="gsl_manual.html#IDX1756">variance, from histogram</A>
<LI><A HREF="gsl_manual.html#IDX1429">VAX random number generator</A>
<LI><A HREF="gsl_manual.html#IDX1030">vector, operations</A>
<LI><A HREF="gsl_manual.html#IDX1014">vector, sorting elements of</A>
<LI><A HREF="gsl_manual.html#IDX810">vectors</A>, <A HREF="gsl_manual.html#IDX819">vectors</A>
<LI><A HREF="gsl_manual.html#IDX833">vectors, initializing</A>
<LI><A HREF="gsl_manual.html#IDX824">vectors, range-checking</A>
<LI><A HREF="gsl_manual.html#IDX1863">VEGAS monte carlo integration</A>
<LI><A HREF="gsl_manual.html#IDX2305">viscosity, units of</A>
<LI><A HREF="gsl_manual.html#IDX2298">volume units</A>
</DIR>
<H2>w</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX657">W function</A>
<LI><A HREF="gsl_manual.html#IDX2340">warning options</A>
<LI><A HREF="gsl_manual.html#IDX8">warranty (none)</A>
<LI><A HREF="gsl_manual.html#IDX2018">wavelet transforms</A>
<LI><A HREF="gsl_manual.html#IDX14">website, developer information</A>
<LI><A HREF="gsl_manual.html#IDX1612">Weibull distribution</A>
<LI><A HREF="gsl_manual.html#IDX2300">weight, units of</A>
<LI><A HREF="gsl_manual.html#IDX2234">weighted linear fits</A>
<LI><A HREF="gsl_manual.html#IDX404">Wigner coefficients</A>
</DIR>
<H2>z</H2>
<DIR>
<LI><A HREF="gsl_manual.html#IDX2066">zero finding</A>
<LI><A HREF="gsl_manual.html#IDX888">zero matrix</A>
<LI><A HREF="gsl_manual.html#IDX2320">zero, IEEE format</A>
<LI><A HREF="gsl_manual.html#IDX376">Zeros of Regular Bessel Functions</A>
<LI><A HREF="gsl_manual.html#IDX793">Zeta functions</A>
</DIR>

</P>

<P><HR><P>
<H1>Footnotes</H1>
<P>(<A NAME="FOOT1" HREF="gsl_manual.html#DOCF1">1</A>) 
Note that the
first edition uses different definitions.
<P><HR><P>
This document was generated using the
<!-- <A HREF="http://wwwcn.cern.ch/dci/texi2html/">, this link is broken --> texi2html <!-- </A> -->
translator version 1.54.</P>
</BODY>
</HTML>
