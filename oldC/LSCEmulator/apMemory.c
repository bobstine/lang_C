/*	18 Jul 89 ... Error checking code.	14 Jul 89 ... Created.*/#include <stdlib.h>#include "Globals.h"#include "Utils.h"#include "apMemory.h"#include "ElemArrayOps.h"#ifdef DEBUG_ALLOC#include "DebugAlloc.h"#endifvoid InitMemory (theMemory)Matrix theMemory[];{	int i;		for (i=0; i<APMEMORYSIZE+1; ++i)         /* n+1 slots */	{	theMemory->pntr = NULL;			theMemory->nRows = 0;		theMemory->nCols = 0;		++theMemory;	}}void ClearMemory (theMemory)Matrix theMemory[];{	Matrix aMat;	int tag;		for (tag=0; tag<APMEMORYSIZE; ++tag)	{	if (theMemory->pntr NE NULL) DisposeMatrix (theMemory);		++theMemory;	}}	Boolean TagIsValid (theTag)int theTag;{	 return( (theTag > -1) AND (theTag < APMEMORYSIZE));	/* outside valid range? */}Boolean TagIsUsed (theTag, theMemory)int theTag;Matrix theMemory[];{	if (TagIsValid(theTag) AND (theMemory[theTag].pntr NE NULL))		return (TRUE);	else		return (FALSE);}		void StoreMatrix (theMat, theTag, theMemory)Matrix *theMat, theMemory[];int theTag;{	theMemory[theTag] = *theMat;}	void GetMatrixShape(theTag, theMemory, nRows, nCols)int theTag, *nRows, *nCols;Matrix theMemory[];{	if (TagIsUsed (theTag, theMemory))	{	*nRows = theMemory[theTag].nRows;		*nCols = theMemory[theTag].nCols;	}	else	{	SetErrorCode (-1, "APMemory tag not found");		*nRows = 0;		*nCols = 0;	}}	void GetMatrix (theTag, theMat, theMemory)int theTag;Matrix theMemory[], *theMat;{	theMat->nRows = theMemory[theTag].nRows;	theMat->nCols = theMemory[theTag].nCols;	theMat->pntr  = theMemory[theTag].pntr;}void SwapMemoryTags (tag1, tag2, theMemory)int tag1, tag2;Matrix theMemory[];{	Matrix temp;		temp = theMemory[tag1];	theMemory[tag1] = theMemory[tag2];	theMemory[tag2] = temp;}/*  _________________________  Allocation  ______________________  */void AllocateMatrixAtTag (theTag, nR, nC, theMemory)int theTag, nR, nC;Matrix theMemory[];{	Matrix mat;	AllocMatrix (nR, nC, &mat);	if (mat.pntr EQ NULL)		SetErrorCode (-2, "APMemory cannot allocate");	else		StoreMatrix (&mat, theTag, theMemory);}void DuplicateMatrix (oldTag, newTag, theMemory)int oldTag, newTag;Matrix theMemory[];{	Matrix oldMat, newMat;	oldMat = theMemory[oldTag];	newMat = theMemory[newTag];	CopyMatrix (&oldMat, &newMat);}void FreeMatrix (theTag, theMemory)int theTag;Matrix theMemory[];{	Matrix theMat;	theMat = theMemory[theTag];	DisposeMatrix (&theMat);	theMemory[theTag].pntr = NULL;}