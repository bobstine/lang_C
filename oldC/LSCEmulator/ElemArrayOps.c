/*				ElemArrayOps.c	18 Jul 89 ... Alter error handling so no printout.	19 Oct 87		 7 Oct 87*/#include "Globals.h"#include "Utils.h"#include "ElemArrayOps.h"#include <math.h> #include <string.h>#define min(A,B) ((A)<(B)?(A):(B))double DotProdVector (a,b)Vector *a,*b;{	if (a->len NE b->len) 		SetErrorCode (1, "Different lengths in dot prod; use min len"); 	return ( DotProdVec (a->pntr, b->pntr, min(a->len, b->len)) ); }double DotProdVec (a,b, len)double *a, *b;int len;{	int i;	double total = 0.0, temp;		for (i=0; i<len; ++i)		total += a[i] * b[i];	return (total);}double CrossLagProdVector (a, b, lag)Vector *a, *b;int lag;{	return (CrossLagProdVec (a->pntr, b->pntr, a->len, lag));}double CrossLagProdVec (a, b, len,lag)double *a, *b;int len, lag;{	/* order VIP to multivar AR models, need Sum a[t-lag]*b[t] */	return (DotProdVec (a, b+lag, len-lag));	}double SumVector (a)Vector *a;{	return (SumVec(a->pntr, a->len));}double SumVec (a, len)double *a;int len;{	int i;	double total = 0.0;		for (i=0; i<len; i++)		total += *a++;	return (total);}double StdDevVector (a, center)Vector *a;double center;{	return(StdDevVec(a->pntr, a->len, center));}double StdDevVec (a, len, center)double *a, center;int len;{	double temp, total = 0.0;	int i;	for (i=0; i<len; ++i)	{	temp = *a++ - center;		total += temp * temp;	}	return (sqrt(total));}void CalcLagProdVector (y, lp)Vector *y, *lp;{	CalcLagProdVec (y->pntr, y->len, lp->pntr, lp->len -1);}void CalcLagProdVec (y, len, lp, maxLag)double *y, *lp;int len, maxLag;{		int i, lag;	double total = 0.0;	double *shift;		shift = y;	for (lag=0; lag<=maxLag; ++lag)		*lp++ = DotProdVec (y, shift++, len-lag) / (double)len;}double QuadFormVector (v, mat)Vector *v;Matrix *mat;{	if ((v->len NE mat->nRows) || (mat->nRows NE mat->nCols))	{	SetErrorCode (-1, "Illegal lengths in QuadForm");		return (0.0);	} else		return (QuadFormVec (v->pntr, mat->pntr, v->len));}double QuadFormVec (v, mat, dim)double *v, *mat[];int dim;{	int row, col;	double total = 0.0;	for (row = 0; row < dim; ++row)		total += v[row] * v[row] * mat[row][row];	for (row = 0; row < dim-1; ++row)		for (col = row+1; col < dim; ++col)			total += 2.0 * v[row] * v[col] * mat[col][row];	return (total);}double MaxAbsVector (a)Vector *a;{	return(MaxAbsVec(a->pntr, a->len));}double MaxAbsVec (a, len)double *a;int len;{	int i;	double av, max = 0.0;		for (i = 0; i<len; ++i, ++a)	{	av = (*a < 0.0) ? -*a : *a;		if (av > max)			max = av;	}	return (max);}void CopyVector (a,b)Vector *a, *b;{	if (a->len != b->len)		SetErrorCode (1, "Unequal lengths in CopyVector; copy min");	CopyVec (a->pntr, b->pntr, min(a->len, b->len));}void CopyVec (a,b,len)double *a, *b;int len;{	int i;		memcpy( (char *)b, (char *)a, len * sizeof(double));  /* dest, src */	}void CopyMatrix (a,b)Matrix *a, *b;{	if (a->nCols != b->nCols)		SetErrorCode (1, "Unequal # cols in mat copy; using min");	if (a->nRows != b->nRows)		SetErrorCode (2, "Unequal # rows in mat copy; using min");	CopyMat (a->pntr, b->pntr, min(a->nRows, b->nRows), min(a->nCols, b->nCols));}void CopyMat (a, b, nRows, nCols)double *a[], *b[];int nRows, nCols;{	int   count, col;	count = nRows * sizeof(double);	for (col=0; col < nCols; ++col)		memcpy(b[col], a[col], count);	/* format dest, src */}void CopyCube (src, dest)Cube *src, *dest;{	int p;		for (p=0; p < src->nPlanes; ++p)		CopyMat (src->pntr[p], dest->pntr[p], dest->nRows, dest->nCols);}			void DiffVector (diff, y)int diff;Vector *y;{	if (diff >= y->len)		SetErrorCode (-1, "Vector too short to difference");	else		DiffVec (diff, y->pntr, y->len);}void DiffVec (diff, y, len)int diff;double *y;int len;{	int d, i;	for (d=1; d<=diff; ++d)		for (i=0; i<len - d; ++i)			y[i] = y[i + 1] - y[i];	for (i=len-diff; i<len; ++i)		y[i] = 0.0;			/* zero rest of vector */}