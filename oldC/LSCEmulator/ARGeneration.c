/*				--------------  ARGeneration.c  ----------------------		11 Mar 88 ... Fix sign error in scalar generation.		17 Oct 87 ... Created	*/#include "ARGeneration.h"#include "Globals.h"#include "Utils.h"#include "ElemArrayOps.h"#include "AdvArrayOps.h"#define TRANS	1/*  ______________________  Globals for AR Generation (g's)  __________________  */static enum ARType gModelType;static int	gOrder, gDim;  static Vector gCoefVec;static double *gCVPtr;static Cube gCoefCube;				/* holds coefs as entered in cube  */static double ***gCCPtr;static Matrix gRootMat;				/* holds Cholesky root of covariance */static Matrix gTempMat, gSumMat;	/*  allocated when model entered  */static double **gRMPtr, **gTMPtr, **gSMPtr;static int gHasBeenInititialized = FALSE;/*  ___________________  Local routines  ____________________________  */void InitGeneration (void);void FindCovMat (Matrix *covMat);		/* Must be dimensioned externally.	*//*  __________________________________________________________________  */void InitGeneration(){	gDim = 1;	gOrder = 1;	gModelType = scalar;		AllocVector(gOrder+1, &gCoefVec);	gCVPtr = gCoefVec.pntr;	AllocMatrix(gOrder*gDim, gOrder*gDim, &gRootMat);	gRMPtr = gRootMat.pntr;		AllocCube(gOrder+1, gOrder+1, gOrder+1, &gCoefCube);	gCCPtr = gCoefCube.pntr;	AllocMatrix(gDim, gDim, &gTempMat);	gTMPtr = gTempMat.pntr;	AllocMatrix(gDim, gDim, &gSumMat);	gSMPtr = gSumMat.pntr;}void FindCovMat(covMat)Matrix *covMat;{	Matrix invCovMat;	int r, c, i, j, k;	double tot;	AllocMatrix(gOrder * gDim, gOrder * gDim, &invCovMat);	if (gModelType EQ scalar) 	{	for (r=0; r<gOrder; ++r)			for (c=0; c<=r; ++c)				{	tot = 0.0;					for (k=0; k<=c; ++k)						tot += (gCVPtr[r-k] * gCVPtr[c-k]) - (gCVPtr[gOrder-r+k] * gCVPtr[gOrder-c+k]);						invCovMat.pntr[c][r] = tot;						if (r NE c) 							invCovMat.pntr[r][c] = tot;				}	} else 		/* multivariate */	{	for (r = 0; r<gOrder; ++r)			for (c = 0; c<=r; ++c)			{	for (i = 0; i<gDim; ++i)		/* Init sum */					for (j = 0; j<gDim; ++j)						gSMPtr[i][j] = 0.0;					for (k = 0; k<=c; ++k)					{	MultMat(gCCPtr[r - k], gCCPtr[c - k], gDim, gDim, gDim, TRANS, gTMPtr);						for (i = 0; i<gDim; ++i)			/* AddTempToSum */							for (j = 0; j<gDim; ++j)								gSMPtr[i][j] += gTMPtr[i][j];							MultMat (gCCPtr[gOrder-r+k], gCCPtr[gOrder-c+k], gDim, gDim, gDim, TRANS, gTMPtr);							for (i = 0; i<gDim; ++i)    /* SubTempFromSum */								for (j = 0; j<gDim; ++j)									gSMPtr[i][j] -= gTMPtr[i][j];					}		/* for k */					for (i = 0; i<gDim; ++i)						for (j = 0; j<gDim; ++j)						{	invCovMat.pntr[j+gDim*c][i+gDim*r] = gSMPtr[j][i];							if (r != c)								invCovMat.pntr[i+gDim*r][j+gDim*c] = gSMPtr[j][i];						}			}		/* for c & r */	}		/* else */	/* PrintMatrix(&invCovMat, "Inverse in multi gen"); */	InvertMatrix(&invCovMat, covMat);	DisposeMatrix(&invCovMat);}		/*  arFindCovMat *//*  _________________________________________________________________  */void arDefineGenModel(model)ARModel *model;{	int pln, r, c, size;	Matrix covMat, invCovMat;	if (NOT gHasBeenInititialized) 	{	InitGeneration();		gHasBeenInititialized = TRUE;	}		if (model->type EQ scalar)	{	gModelType = scalar;		gOrder = model->coef.sCoef.len - 1;		/* assume 0 spot holds 1 */		gDim = 1;		if (gCoefVec.len NE (gOrder + 1))		{	ResizeVector(model->coef.sCoef.len, &gCoefVec);			gCVPtr = gCoefVec.pntr;			ResizeMatrix(gOrder, gOrder, &gRootMat);			gRMPtr = gRootMat.pntr;		}		CopyVector (&model->coef.sCoef, &gCoefVec);	} else			/* multivariate */	{		gModelType = multivar;		gDim = model->coef.mCoef.nCols;		gOrder = model->coef.mCoef.nPlanes - 1;	/*  assume [0] holds identity  */		if ((gOrder NE gCoefCube.nPlanes-1) || (model->coef.mCoef.nCols != gCoefCube.nCols))		{	ResizeCube (model->coef.mCoef.nPlanes, model->coef.mCoef.nCols, model->coef.mCoef.nRows, &gCoefCube);			gCCPtr = gCoefCube.pntr;			ResizeMatrix(gDim, gDim, &gTempMat);			gTMPtr = gTempMat.pntr;			ResizeMatrix(gDim, gDim, &gSumMat);			gSMPtr = gSumMat.pntr;			ResizeMatrix(gDim * gOrder, gDim * gOrder, &gRootMat);			gRMPtr = gRootMat.pntr;		}		CopyCube (&model->coef.mCoef, &gCoefCube);	}						/* end of CASE	*/	size = gOrder * gDim;			/* calc sqrt cov mat for simulations  */	AllocMatrix(size, size, &covMat);	FindCovMat(&covMat);	/* 	PrintMatrix(&covMat, "AR Cov mat ");	*/	FactorMatrix (&covMat, &gRootMat);		/* lower triangular not used */	DisposeMatrix(&covMat);	/*	PrintMatrix(&gRootMat, "Cholesky factor"); */}	/*	DefineGenModel  */void arGenerateSeries (errors, data)Matrix *data, *errors;{	double *colPtr;	int t, i, j, d, index;	double tot;	for (t = 0; t<gOrder; ++t)						/* use upper tri Cholesky root */		for (d = 0; d<gDim; ++d)					/* to transform for startup    */		{	tot = 0.0;			for (i = 0; i<=t; ++i)				tot += errors->pntr[0][i] * gRMPtr[t][i];			data->pntr[d][t] = tot;		}	if (gModelType EQ scalar)	{	colPtr = data->pntr[0];		for (t = gOrder; t<data->nRows; ++t)		{	tot = errors->pntr[0][t];			for (i = 1; i<=gOrder; ++i)				tot -= gCVPtr[i] * colPtr[t-i];		/* neg spectral sign convention */			colPtr[t] = tot;		}	} else 											/*   multivariate 				*/	{	index = gOrder * gDim;						/* WRONG INDEXING HERE			*/		for (t = gOrder; t<data->nRows; ++t)		{	for (d = 0; d<gDim; ++d)				{	tot = errors->pntr[0][index];					for (i = 1; i<=gOrder; ++i)						for (j = 0; j<gDim; ++j)							tot -= gCCPtr[i][j][d] * data->pntr[j][t - i];	 /*neg sign */					data->pntr[d][t] = tot;					index += 1;				}		}	}	/*  multivar case  */}	/*  arGenerateSeries  */