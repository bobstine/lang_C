/* 	----------------  Density Estimation  ---------------------		7 Apr 88 ... Addtion of optimal kernel selection; not tested.	6 Apr 88 ... Created for kernel density estimation.	*/#include <math.h>#include <stdio.h>		/* debugging */#include "InOut.h"#include "DensityEstimation.h"		/* has globals, arraydef already included */#include "FourierTrans.h"#ifdef PROTOdouble ColumnSum(MATRIX *mat, int col);int printf (...);double exp(double);double sqrt(double);void SetupGlobals(VECTOR *data, MATRIX *density);int LengthFails(int);void Discretize(void);void MultGauss(double h, int shift);double OptimalScale(double lo, double hi);void RestorePtrs (void);#elsevoid SetupGlobals();void Discretize();int LengthFails();void MultGauss();void RestorePtrs();#endif/*  -----------------------  GLOBALS  ------------------------------  */static int nRows, nObs;static double *dataPtr, *indexPtr, **densMat;static double delta;/*  -----------------------  DEFINES  ------------------------------  */#define SHIFT 1#define NOSHIFT 0#define HCOUNT 10.0			/* number of optimal h's to consider. *//*  ----------------------------------------------------------------  */static void SetupGlobals(data, density)VECTOR *data;MATRIX *density;{	nObs = data->len;	dataPtr = data->pntr;	nRows = density->nRows;	densMat = density->pntr;	indexPtr = densMat[0];	densMat[0] = densMat[1];	/* shuffle indices for input to FFT; transform in "0" and "1" */	densMat[1] = densMat[2];		delta = indexPtr[1] - indexPtr[0];	/* spacing grid */}static int LengthFails(len)int len;/* Fails if input is NOT a power of two */{	int i=1;		while (i < len)		i *= 2;	/* printf ("Length is %d with i = %d\n", len, i); */	if (i != len)		return(1);	else		return(0);}	static void Discretize()/*	Accums weights based on evaluation points in first column of dens matrix */{	int obs, interval;	register double value, konst;		konst = delta * delta * (double)nObs;	/* printf ("Value of konst is %f with delta=%f.\n",konst,delta); */	for (obs=0; obs<nObs; ++obs)	{	value = dataPtr[obs];		/* printf ("Current value = %f ", value); */		interval = 1;		while (value > indexPtr[interval])			++interval;		/* printf ("-- Interval stops at %d.\n", interval); */		densMat[0][interval]   += (value - indexPtr[interval-1])/konst;		densMat[0][interval-1] += (indexPtr[interval] - value)/konst;	}}static void MultGauss(h, shift)double h;int shift;/* Mult transform of data with Gaussian kernel with scale factor h.	In place if shift is zero, otherwise shifts to cols 3 and 4. 	If shifts, then uses constant for choosing optimal kernel and	only goes half way.											   */{	int L, nL;	double factor, arg, mult;		factor = indexPtr[nRows-1]-indexPtr[0];	factor *= factor;	factor = - 2.0 * PI * PI * h * h / factor;		arg = 0.0; mult = 1.0;	if (shift)	{	densMat[3][0] = densMat[0][0]; densMat[4][0] = densMat[1][0];		for (L=1; L<nRows/2; ++L)		{	arg   = factor * (double)(L * L);			mult  = exp(arg);			arg  /= 2.0;			mult -= 2.0 * exp(arg);			densMat[3][L] = mult * (densMat[0][L]*densMat[0][L] + densMat[1][L]*densMat[1][L]);		}	} 	else	{	for (L=1, nL=nRows-1; L<nRows/2; ++L,--nL)		{	arg  = factor * (double)(L * L);			mult = exp(arg);			densMat[0][L] *= mult; densMat[1][L] *= mult;		/* symmetry & complex */			densMat[0][nL] *= mult; densMat[1][nL] *= mult;		}		densMat[0][nRows/2] = 0.0; densMat[1][nRows/2] = 0.0;		/* zap at pi/2 */	}}static double OptimalScale (loH, hiH)double loH, hiH;/* Finds optimality scale using mult of transform by scaled kernels. */{	int i;	double hInc, optH, h, crit, minCrit;		h = loH;	hInc = (hiH - loH) / HCOUNT;	minCrit = 1.0E100;	while (h <= hiH)	{	MultGauss (h, SHIFT);		crit=0.0;		for (i=0; i<nRows/2; ++i)			crit += densMat[3][i];		crit += 1.0 / (h * (double)nRows) * sqrt(2.0 * PI);		printf ("For scale = %f criterion is %f.\n", h, crit);		if (crit < minCrit)		{	minCrit = crit;			optH = h;		}		h += hInc;	}	return (optH);}static void RestorePtrs (){	densMat[2] = densMat[1];	densMat[1] = densMat[0];	densMat[0] = indexPtr;}static double ColumnSum(mat, col)MATRIX *mat;int col;{	double sum=0.0;	int i;		for (i=0; i<mat->nRows; ++i)		sum += mat->pntr[col][i];	return (sum);}		void deCalcKernelDensity (data, h, density)VECTOR *data;double h;MATRIX *density;{	if (density->nCols < 3)		PostErrorMessage (77, "Need three column input for density estimation");	else if (LengthFails(density->nRows))		PostErrorMessage(88, "Length of input matrix is not a power of 2");	else	{			SetupGlobals (data, density);	/* also shuffles pointers of density matrix */		Discretize ();					/* now density's second col is series to tranform */		/* PrintMatrix (density, "density after discretizing"); */		/* printf ("Sum of col 0 after discrete is %f.\n", ColumnSum(density, 0)); */		ftTransform (1, density);		/* PrintMatrix (density, "density after transforming"); */		/* printf ("Sum of col 0 after transforming is %f.\n", ColumnSum(density, 0)); */		MultGauss (h, NOSHIFT);			/* in place product with gaussian kernel with scale h */		/* PrintMatrix (density, "density after gauss mult"); */		/* printf ("Sum of col 0 after gauss mult is %f.\n", ColumnSum(density, 0)); */		ftTransform (-1, density);		/* PrintMatrix (density, "density after inverse transform"); */		RestorePtrs();					/* restore col pointers to input format */	}}void deFindOptKernelDensity (data, loH, hiH, density)VECTOR *data;double loH, hiH;MATRIX *density; /* needs FOUR columns */{	double optH;		if (density->nCols < 4)		PostErrorMessage (7, "Need four column input for density estimation"); 	else if (LengthFails(density->nRows))		PostErrorMessage(8, "Length of input matrix must be a power of 2");	else	{			SetupGlobals (data, density);	/* also shuffles pointers of density matrix */		Discretize ();					/* now density's second col is series to tranform */		ftTransform (1, density);		optH = OptimalScale(loH, hiH);		MultGauss (optH, NOSHIFT);			/* product with gaussian kernel with opt scale h */		PrintMatrix (density, "density after gauss mult");		ftTransform (-1, density);		PrintMatrix (density, "density after inverse transform");		RestorePtrs();					/* restore col pointers to input format */	}}		