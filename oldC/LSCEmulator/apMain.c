/*	29 Sep 89 ... Problems with Build/Send matrices...handle error suspected.	14 Jul 89 ... Starting to take form suitable for MULT command.	12 Jul 89 ... Created to develop code for the transputer.	NOTES:		(1) Memory is tagged, indexing into array of matrices.		(2) All memory reads funneled into TaggedMatrix which does checking.				Do not access fMemory directly; use the provided internal fcns.		(3)	Packet behavior:				Instruction packets: conversion to scalar packet.				Matrix packets: conversion of matrix to scalar packet.				Tag packets: conversion of tag to matrix packet.*/#include <stdio.h>#include <stdlib.h>#include "Globals.h"#include "Utils.h"#include "Messages.h"#include "arDef.h"#include "InOut.h"#ifdef DEBUG_ALLOC#include "DebugAlloc.h"#endif/*  ____________________  Globals & Prototypes  ______________________  */#define QUEUESIZE		20#define NINSTRUCTIONS  100void SendMatrixToTag (Matrix *, int tag, ArrayProcessor *);void SendResetProgram (ArrayProcessor *);void SendMainProgram (ArrayProcessor *);void GetMatrixFromTag (int, Matrix *, ArrayProcessor *);void InitInstructionNames (void);void PrintInstruction (Instruction *);void PrintInstQueue (Instruction *inst);void PrintTaggedMatrix (int tag, ArrayProcessor *ap);void PrintScalarPacket (ScalarPacket *);void PrintMatrixPacket (MatrixPacket *);void PrintErrors(void);void PrintARModel (ARModel *model, char *str);/*  ________________________  main  _______________________  */	main (){	ArrayProcessor	arrayProcessor;	ScalarPacket sp;	Matrix 	mat3, mat13, mat14, mat15;	char *msg;	int rc;		InitArrayProcessor (&arrayProcessor);			/* Initialize.						*/	InitInstructionNames();							/* Fill in name fields for list.	*/	SendResetProgram(&arrayProcessor);				/* Reset the array processor.  		*/		AllocConstMatrix (3.0, 8, 2, &mat3);			PrintMatrix (&mat3, "mat3");	SendMatrixToTag (&mat3, 3, &arrayProcessor);	SendMainProgram (&arrayProcessor);				/* Send the program to run.  	*/	GetMatrixFromTag (3, &mat13, &arrayProcessor);	PrintMatrix (&mat13, "Retrieved from 3");	GetMatrixFromTag (4, &mat14, &arrayProcessor);	PrintMatrix (&mat14, "Retrieved from 4");	GetMatrixFromTag (5, &mat15, &arrayProcessor);	PrintMatrix (&mat15, "Retrieved from 5");}	/* end main */void SendResetProgram (arrayProcessor)ArrayProcessor *arrayProcessor;{	Instruction *theQueue;	int instCount=0;	InstPacket *resetProgram;	ScalarPacket sp;		printf (" ----------- Running reset program ---------- \n");		resetProgram = (InstPacket *)malloc ( (3*sizeof(int) + QUEUESIZE*sizeof(Instruction)) );	theQueue = resetProgram->instArray;	theQueue->inst = kReset;							theQueue->srcTag = 0; theQueue->destTag = 0;	theQueue->value = 0.0;	++theQueue; ++instCount;		theQueue->inst = kStop;	theQueue->srcTag = -1; theQueue->destTag = -1;	theQueue->value = 0.0;	++theQueue; ++instCount;		resetProgram->packetCode 	= kReset;	resetProgram->nInst 		= instCount;	PrintInstQueue (resetProgram->instArray);	ConvertInstPacket (resetProgram, &sp, arrayProcessor);	printf ("Elapsed time of program = %f\n", sp.scalar);	if (sp.returnCode EQ 0)		printf("Program completed successfully\n"); 	else	 	PrintErrors();	free ((char *)resetProgram);}void SendMainProgram (arrayProcessor)ArrayProcessor *arrayProcessor;{	Instruction *theQueue;	int instCount=0;	InstPacket *mainProgram;	ScalarPacket sp;		printf (" ----------- Running main program ---------- \n");		mainProgram = (InstPacket *)malloc ( (3*sizeof(int) + QUEUESIZE*sizeof(Instruction)) );	theQueue = mainProgram->instArray;		theQueue->inst = kAllocate;		theQueue->srcTag = 4; theQueue->destTag = 0;	theQueue->value = (8*32)+2;	++theQueue; ++instCount;			theQueue->inst = kFillConst;	theQueue->srcTag = 4; theQueue->destTag = 0;	theQueue->value = 4.0;	++theQueue; ++instCount;			theQueue->inst = kAdd;	theQueue->srcTag = 3; theQueue->destTag = 4;	theQueue->value = 0.0;	++theQueue; ++instCount;		theQueue->inst = kAllocate;		theQueue->srcTag = 5; theQueue->destTag = 0;	theQueue->value = (8*32)+2;	++theQueue; ++instCount;			theQueue->inst = kFFT;		theQueue->srcTag = 4; theQueue->destTag = 5;	theQueue->value = (8*32)+2;	++theQueue; ++instCount;		theQueue->inst = kStop;	theQueue->srcTag = -1; theQueue->destTag = -1;	theQueue->value = 0.0;	++theQueue; ++instCount;		mainProgram->packetCode = 0;	mainProgram->nInst 		= instCount;	PrintInstQueue (mainProgram->instArray);	ConvertInstPacket (mainProgram, &sp, arrayProcessor);	printf ("Elapsed time of program = %f\n", sp.scalar);	if (sp.returnCode EQ 0)		printf("Program completed successfully\n"); 	else	 	PrintErrors();	free ((char *)mainProgram);}void SendMatrixToTag (mat, tag, arrayProcessor)Matrix *mat;int tag;ArrayProcessor *arrayProcessor;{	MatrixPacket *mp;	ScalarPacket sp;		printf (" -----------  Sending matrix packet to tag %d. ----------- \n", tag);	BuildMatrixPacket (tag, mat, &mp);	PrintMatrixPacket (mp);	ConvertMatrixPacket (mp, &sp, arrayProcessor);	PrintScalarPacket (&sp);	free ((char *)mp);}void GetMatrixFromTag (tag, mat, arrayProcessor)int tag;Matrix *mat;ArrayProcessor *arrayProcessor;{	MatrixPacket *matPackPtr;	TagPacket tagPacket;	tagPacket.packetCode = 7;	tagPacket.matrixTag = tag;	ConvertTagPacket (&tagPacket, &matPackPtr, arrayProcessor);	/* PrintMatrixPacket (matPackPtr); */	BuildMatrixFromPacket (matPackPtr, mat);}/*  ___________________________  Debugging code  _______________________  */static char *instNames[NINSTRUCTIONS];void InitInstructionNames(){	instNames[kStore    ]= "Store ";	instNames[kGetMatrix]= "GetMx ";	instNames[kReset    ]= "Reset ";		instNames[kAllocate ]= "Alloc ";	instNames[kDuplicate]= " Dup  ";	instNames[kFree	    ]= " Free ";	instNames[kSwap		]= " Swap ";			instNames[kFillConst]= "FillC ";	instNames[kSetSeeds ]= "SetS  ";	instNames[kFillUni  ]= "FillU ";	instNames[kFillNorm	]= "FillN ";				instNames[kAddConst	]= "Add C ";	instNames[kMultConst]= "Mul C ";	instNames[kSquare	]= " Sqr  ";	instNames[kSqrt	    ]= " Sqrt ";	instNames[kInvert	]= " Invt ";	instNames[kReduce	]= " Red  ";		instNames[kAdd		]= " Add  ";	instNames[kDiff		]= " Subt ";		/* it does not like kSub or kMinus */	instNames[kMult		]= " Mult ";	instNames[kDiv  	]= " Div  ";		instNames[kARGen    ]= "AR Gen";	instNames[kAREst	]= "AR Est";	instNames[kFFT		]= " FFT  ";}	void PrintInstruction(theInstruction)Instruction	*theInstruction;{	int code;	printf (" %s ( ", instNames[theInstruction->inst]);	if (theInstruction->srcTag  >= 0)		printf ("%4d",theInstruction->srcTag);	else		printf ("    ");	if (theInstruction->destTag >= 0)		printf (",%4d",theInstruction->destTag);	else		printf ("     ");	printf (")  %f ",theInstruction->value);	if ( (theInstruction->inst EQ kAllocate) ||		 (theInstruction->inst EQ kStore)    ||		 (theInstruction->inst EQ kGetMatrix) )	{	code = theInstruction->value;		printf ("code is %d ", code);		printf ("    size  [ %d, %d]\n", code / 32, code % 32);	} else printf("\n");}void PrintTaggedMatrix (tag, ap)int tag;ArrayProcessor *ap;{	if (TagIsUsed (tag, ap->memory))		PrintMatrix (&ap->memory[tag], "AP matrix");	else		printf ("PTM: Tag %d does not exist.\n", tag);		Wait();}void PrintInstQueue (queue)Instruction *queue;{	int count=0;		while (queue->inst NE kStop)	{	PrintInstruction (queue);		++queue;		++count;	}	printf ("Stopped at instruction #%d\n",count);	Wait();}	void PrintScalarPacket (sp)ScalarPacket *sp;{	printf ("Scalar packet:\n");	printf ("    Packet Code = %d; Return Code = %d; Scalar = %f\n",				sp->packetCode, sp->returnCode, sp->scalar);	Wait();}void PrintMatrixPacket (mp)MatrixPacket *mp;{	int last;		last = (mp->nRows*mp->nCols)-1;	printf ("Matrix packet (%d bytes):\n", MatrixPacketSize(mp));	printf ("    Packet Code = %d; Return Code = %d, dimensions [%d, %d]\n",					mp->packetCode, mp->returnCode, mp->nRows, mp->nCols);	printf ("    data[   0] = %f", mp->data[0]);	printf ("    data[   1] = %f\n", mp->data[1]);	printf ("    data[%4d] = %f\n", last, mp->data[last]);	Wait();}void PrintErrors(){	char *str;	int rc;		while (rc = ErrorCode(&str))		printf ("Error #%3d:  %s.\n", rc, str);	Wait();}	void PrintARModel(model, str)ARModel *model;char *str;{	printf ("\n----- AR MODEL -----  %s\n", str);	if (model->type == scalar)		PrintVector(&model->coef.sCoef, " Scalar model");	else /* multivariate */		PrintCube(&model->coef.mCoef, "Vector model");	Wait();}		