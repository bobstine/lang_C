/*	21 Aug 89 ... Time series code.	18 Jul 89 ... Use non-printing error codes.	16 Jul 89 ... Addition of safety checks and debugging.	14 Jul 89 ... Created.		NOTES:  To add a new instruction				(1) Add its command to RunInstruction.				(2) Explain how to check its tags in InstructionTagsCheck.*/#include "Globals.h"#include "Utils.h"#include "apMachine.h"#ifdef DEBUG_ALLOC#include "DebugAlloc.h"#endif/*  __________________________  ap routines  _______________________  */void apInitArrayProcessor (ap)ArrayProcessor *ap;{	InitMemory (ap->memory);}pascal int apStoreMatrixAtTag (theMat, theTag, ap)Matrix *theMat;ArrayProcessor *ap;int theTag;{	int rc=0;		if (TagIsUsed (theTag, ap->memory))	{	rc = -1;		SetErrorCode (rc, "APMemory cannot store");	}	else if (TagIsValid (theTag))		StoreMatrix (theMat, theTag, ap->memory);	else		rc = -77;	return (rc);}	int apRetrieveMatrixFromTag (theTag, theMat, ap)int theTag;Matrix  *theMat;ArrayProcessor *ap;{	int rc=0;		if (TagIsUsed (theTag, ap->memory))		GetMatrix (theTag, theMat, ap->memory);	else	{	rc = -1;		SetErrorCode (rc, "APMemory tag not found");		theMat->nRows = 0;		theMat->nCols = 0;		theMat->pntr  = NULL;	}			return (rc);}Boolean apInstructionTagsCheck (theInst, ap) Instruction *theInst;ArrayProcessor *ap;{	Boolean rc;		switch (theInst->inst)	{		case kReset		:		case kSetSeeds	: rc = TRUE;						  break;						  				case kAllocate	: rc = NOT TagIsUsed (theInst->srcTag, ap->memory);						  break;						  		case kStore:		case kGetMatrix : rc = FALSE;			 			  break;				case kSwap		:		case kDuplicate	:		case kSquare	:		case kSqrt		:		case kInvert	:		case kReduce	:		case kAdd		:		case kDiff		:		case kMult		:		case kDiv		:		case kARGen		:		case kAREst		:		case kFFT		: rc = TagIsUsed (theInst->srcTag, ap->memory) 			 				   AND TagIsUsed (theInst->destTag,ap->memory);						  break;		case kFree		: 		case kFillConst	: 		case kFillUni	:		case kFillNorm	:		case kAddConst	:		case kMultConst : rc = TagIsUsed (theInst->srcTag, ap->memory);			 			  break;			 			  		default			: rc = FALSE;		}	return (rc);}int apRunInstruction (theInst, ap)Instruction *theInst;ArrayProcessor *ap;{	int axis, nRows, nCols;	int rc = 0;	Boolean transpose;		switch (theInst->inst)	{		case kStore		: rc = 7; break;		case kGetMatrix : rc = 8; break;				case kReset		: ClearMemory (ap->memory);		 				  ClearErrorCodes();						  ap->randomSeed = theInst->srcTag;						  break;						  		case kSwap		: SwapMemoryTags (theInst->srcTag, theInst->destTag, ap->memory);						  break;		case kAllocate  : AllocateMatrixAtTag (theInst->srcTag, theInst->destTag, theInst->lastTag, ap->memory);						  if (theInst->destTag EQ 0)						  	rc = FillWithConstant (theInst->srcTag, 0.0, ap->memory);						  break;		case kDuplicate : DuplicateMatrix (theInst->srcTag, theInst->destTag, ap->memory);						  break;		case kFree	    : FreeMatrix (theInst->srcTag, ap->memory);						  break;						  		case kFillConst : rc = FillWithConstant (theInst->srcTag, theInst->value, ap->memory);						  break;		case kSetSeeds	: ap->randomSeed = theInst->srcTag;						  break;		case kFillUni	: rc = FillWithUniform 	(theInst->srcTag, ap->randomSeed, ap->memory);						  break;		case kFillNorm  : rc = FillWithNormal (theInst->srcTag, ap->randomSeed, ap->memory);						  break;						case kAddConst	: rc = AddConstant(theInst->srcTag, theInst->value, ap->memory);						  break;		case kMultConst : rc = MultConstant(theInst->srcTag, theInst->value, ap->memory);						  break;		case kSquare	: rc = Square(theInst->srcTag, theInst->destTag, ap->memory);						  break;		case kSqrt	    : rc = SquareRoot(theInst->srcTag, theInst->destTag, ap->memory);						  break;		case kInvert 	: rc = Invert(theInst->srcTag, theInst->destTag, ap->memory);						  break;						  		case kReduce 	: if (theInst->value > 0.0)						     axis = 1;						  else						  	 axis = 0;						  rc = Reduce(theInst->srcTag, theInst->destTag, axis, ap->memory);						  break;				case kAdd		: rc = Add (theInst->srcTag, theInst->destTag, ap->memory);						  break;		case kDiff		: rc = Subtract (theInst->srcTag, theInst->destTag, ap->memory);						  break;		case kMult		: if (ap->lastInst.inst NE kAllocate)							rc = -10;						  else						  {	transpose = (theInst->value > 0.0);						 	rc = Multiply (theInst->srcTag, theInst->destTag, transpose,						 					ap->lastInst.srcTag, ap->memory);						  }						  break;		case kDiv  		: rc = Divide (theInst->srcTag, theInst->destTag, 2, ap->memory);						  break;		case kARGen		: if (ap->lastInst.inst NE kAllocate)							rc = -10;						  else						 	rc = ARFilter (theInst->srcTag, theInst->destTag,						 					 ap->lastInst.srcTag, ap->memory);						  break;		case kAREst		: rc = AREstimate (theInst->srcTag, theInst->destTag, ap->memory);						  break;		case kFFT		: rc = FFT (theInst->srcTag, theInst->destTag, ap->memory);						  break;						  		default			: rc = 10;	}	ap->lastInst = *theInst;	return (rc);}int apRunInstQueue (queue, ap)Instruction *queue;ArrayProcessor *ap;{	int count=0, rc;	while (queue->inst NE kStop)	{	if (NOT apInstructionTagsCheck (queue, ap))		{	rc = -100;			SetErrorCode (rc, "APMachine: tags do not check");			queue->inst = kStop;		}		else		{	rc = apRunInstruction (queue, ap);			if (rc NE 0)			{	SetErrorCode (rc, "APMachine: runtime error");				queue->inst = kStop;			}			else			{	++queue;				++count;			}		}	}	return (rc);}	