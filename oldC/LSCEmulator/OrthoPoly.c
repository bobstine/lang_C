/*		Orthogonal Polynomial estimation.				( see Morrison, Section 4.2)		10 Mar 88 ... Complete coding, complete most debugging. No walk through.	 8 Mar 88 ... Created.	 */#include <stdio.h>#include "ElemArrayOps.h"#include "InOut.h"/*	NOTES:	- The zero order poly is not stored, but computed directly			from the average of the input data.			*/void opFillMatrix (polyMat, polySS)VECTOR *polySS;MATRIX *polyMat;{	int col, row, nR, nC;	extended *destPtr, *jPtr, *jm1Ptr, *firstPtr;	extended  konst,J2;		nR = polyMat->nRows;	nC = polyMat->nCols;	if (nC != polySS->len) 		PostErrorMessage (0, "OP: Lengths do not agree in FillMatrix\n");		firstPtr= polyMat->pntr[0];		/* fill first col */	konst = (1.0 + (extended)nR)/2.0;	polySS->pntr[0] = 0.0;	for (row = 0; row < nR; ++row)	{	firstPtr[row] = ((extended) 1+row) - konst;		polySS->pntr[0] += firstPtr[row]*firstPtr[row];	}			if (nC > 1) 					/* fill second  col */	{	destPtr = polyMat->pntr[1];		konst = ((extended)(nR*nR) - 1.0)/12.0;		polySS->pntr[1] = 0.0;		for (row = 0; row < nR; ++row)	/* first col */		{	*destPtr = (firstPtr[row] * firstPtr[row]) - konst;			polySS->pntr[1] += *destPtr * *destPtr;			++destPtr;		}				for (col = 2; col < nC; ++col)	/* fill rest recursively */		{	destPtr = polyMat->pntr[col];			polySS->pntr[col] = 0.0;			jPtr	= polyMat->pntr[col-1];			jm1Ptr	= polyMat->pntr[col-2];			J2 = (extended)  col * col;			konst =  J2*((nR*nR) - J2)/(4.0*(4.0*J2 - 1.0));			/* fprintf (stderr, "J2 = %lf, konst = %lf\n", J2, konst); */			for (row=0; row<nR; ++row)			{	*destPtr = firstPtr[row]*jPtr[row] - konst*jm1Ptr[row];				polySS->pntr[col] += *destPtr * *destPtr;				++destPtr;			}		}	}}void opEstimate (data, polyMat, polySS, coefs)VECTOR *data, *coefs, *polySS;MATRIX *polyMat;{	int order, col;		coefs->pntr[0] = SumVector(data) / (extended)data->len;	for (order=1, col=0; order<coefs->len; ++order, ++col)		coefs->pntr[order] = DotProdVec(polyMat->pntr[col],data->pntr, data->len) / polySS->pntr[col];}void opCalcResids (data, coefs, polyMat, resids)VECTOR *data, *coefs, *resids;MATRIX *polyMat;{	int col, order, obs;	extended *rp;		rp = resids->pntr;	for (obs=0; obs<resids->len; ++obs)	{	*rp = data->pntr[obs] - coefs->pntr[0];		/* init with data - constant */		for (order=1, col=0; order<coefs->len; ++col, ++order)			*rp -= coefs->pntr[order] * polyMat->pntr[col][obs];		++rp;	}}