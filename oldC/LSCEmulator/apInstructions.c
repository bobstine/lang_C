/*	18 Jul 89 ... Improve error handling.	14 Jul 89 ... Created*/#include "apInstructions.h"#include <stdlib.h>#include "Globals.h"#include "Utils.h"#include "ElemArrayOps.h"#include "AdvArrayOps.h"#include "arGeneration.h"#include "arEstimation.h"#include "FourierTrans.h"#ifdef DEBUG_ALLOC#include "DebugAlloc.h"#endif#define NOTYET			-5#define DIMERROR		-1/*  ____________________ Local Prototypes  _____________________ */Boolean SameDimensions (Matrix *, Matrix *);/*  ___________________  Utilities  ____________________________ */Boolean SameDimensions (mat1, mat2)Matrix *mat1, *mat2;{	Boolean result;		result = (mat1->nRows EQ mat2->nRows) && 			  (mat1->nCols EQ mat2->nCols);	return (result);}/*  _______________  Specific instructions  ______________ */int FillWithConstant (tag, theConstant, memory)int tag;double theConstant;Matrix *memory;{	int i,j;	Matrix theMat;	double *cp;	theMat = memory[tag];	for (j=0; j<theMat.nCols; ++j)	{	cp = theMat.pntr[j];		for (i=0; i<theMat.nRows; ++i)			cp[i] = theConstant;	}	return (0);}int FillWithUniform (tag, seed, memory)int tag, seed;Matrix *memory;{	int i,j;	Matrix theMat;	double *cp;	theMat = memory[tag];	for (j=0; j<theMat.nCols; ++j)		{	cp = theMat.pntr[j];			for (i=0; i<theMat.nRows; ++i)				cp[i] = rand()/32767.0;		}		return (0);}int FillWithNormal (tag, seed, memory)int tag, seed;Matrix *memory;{	int i,j;	Matrix theMat;	double *cp;	theMat = memory[tag];	for (j=0; j<theMat.nCols; ++j)	{	cp = theMat.pntr[j];		for (i=0; i<theMat.nRows; ++i)			cp[i] = rand()/32767.0;	}	return (0);}/*  ____________________  Simple operations  _______________________  */	int AddConstant (tag, theConst, memory)int tag;double theConst;Matrix *memory;{	Matrix topMat;	int r, c;	double *colPtr;	topMat = memory[tag];	for (c=0; c<topMat.nCols; ++c)	{	colPtr = topMat.pntr[c];		for (r=0; r<topMat.nRows; ++r)			colPtr[r] += theConst;	}	return (0);}int MultConstant (tag, theConst, memory)int tag;double theConst;Matrix *memory;{	Matrix topMat;	int r, c;	double *colPtr;	topMat = memory[tag];	for (c=0; c<topMat.nCols; ++c)	{	colPtr = topMat.pntr[c];		for (r=0; r<topMat.nRows; ++r)			colPtr[r] *= theConst;	}	return (0);}int Add (srcTag, destTag, memory)int srcTag, destTag;Matrix *memory;{	Matrix mat1, mat2;	int r, c;	double *col1Ptr, *col2Ptr;	mat1 = memory[srcTag];	mat2 = memory[destTag];	if (!SameDimensions (&mat1, &mat2))		return (DIMERROR);	else	{	for (c=0; c<mat1.nCols; ++c)		{	col1Ptr = mat1.pntr[c];			col2Ptr = mat2.pntr[c];			for (r=0; r<mat1.nRows; ++r)				col2Ptr[r] += col1Ptr[r];		}		return (0);	}}int Subtract (srcTag, destTag, memory)int srcTag, destTag;Matrix *memory;{	Matrix src, dest;	int r, c;	double *srcPtr, *destPtr;	src = memory[srcTag];	dest = memory[destTag];	if (!SameDimensions (&src, &dest))		return (DIMERROR);	else	{	for (c=0; c<src.nCols; ++c)		{	srcPtr = src.pntr[c];			destPtr = dest.pntr[c];			for (r=0; r<src.nRows; ++r)				destPtr[r] -= srcPtr[r];		}		return (0);	}}int Multiply (srcTag, destTag, transpose, tag3, memory)int srcTag, destTag, tag3;Boolean transpose;Matrix *memory;{	Matrix mat1, mat2, prodMat;	mat1 = memory[srcTag];	mat2 = memory[destTag];	prodMat = memory[tag3];	MultMatrix (&mat1, &mat2, transpose, &prodMat); /* checks dimensions */	return (ErrorHasOccured());}int Divide (srcTag, destTag, tag3, memory)int srcTag, destTag, tag3;Matrix *memory;{	return (NOTYET);}int Square (tag, sqrTag, memory)int tag, sqrTag;Matrix *memory;{	Matrix topMat, square;		topMat = memory[tag];	square = memory[sqrTag];	MultMatrix (&topMat, &topMat, TRUE, &square);	return (ErrorHasOccured());}int SquareRoot (srcTag, destTag, memory)int srcTag, destTag;Matrix *memory;{	return (NOTYET);}int Invert (tag, invTag, memory)int tag, invTag;Matrix *memory;{	Matrix mat1, mat2;	mat1 = memory[tag];	mat2 = memory[invTag];	InvertMatrix (&mat1, &mat2); /* checks dimensions */	return (ErrorHasOccured());}int Reduce (tag, redTag, axis, memory)int tag, redTag, axis;Matrix *memory;{	Matrix newMat, topMat;	double *cp, total;	int topTag, newRows, r,c, rc;	topMat = memory[tag];	newMat = memory[redTag];	if (axis EQ 0) 	{	if (topMat.nCols EQ newMat.nRows)		{	for (c=0; c<newMat.nRows; ++c)			{	cp = topMat.pntr[c];				total = 0.0;				for (r=0; r<topMat.nRows; ++r)				 	total +=  cp[r];				newMat.pntr[0][c] = total;			}			rc = 0;		}		else			rc = DIMERROR;	}	else	{	if (topMat.nRows EQ newMat.nRows)		{	for (r=0; r<newMat.nRows; ++r)			{	total = 0.0;				for (c=0; c<topMat.nCols; ++c)						total += topMat.pntr[c][r];				newMat.pntr[0][r] = total;			}			rc = 0;		}		else			rc = DIMERROR;	}	return (rc);}/*  ________________________  Time Series Code  ___________________________  */int ARFilter (coefTag, errorTag, outputTag, memory) int coefTag, errorTag, outputTag;Matrix *memory;{	Matrix coef, error, y;	ARModel theModel;		coef  = memory[coefTag];	error = memory[errorTag];	y     = memory[outputTag];		arCreateScalarModel (&coef, &theModel);	arDefineGenModel (&theModel);	if (ErrorHasOccured())							/* stationary check here */		SetErrorCode (-1, "ARGen: nonstationary model");	else		arGenerateSeries (&error, &y);	arDisposeModel (&theModel);	return (ErrorHasOccured());}	int AREstimate (dataTag, estTag, memory)int dataTag, estTag;Matrix *memory;{	int dim = 1, arOrder;	Matrix estCoef, dataMat;	ARModel lsModel, ywModel;		dataMat = memory[dataTag];	estCoef = memory[estTag];		arOrder = estCoef.nRows - 1;	arAllocModel (arOrder, dim, &lsModel);	arAllocModel (arOrder, dim, &ywModel);	arUseMeanCorrection (FALSE);	arEstimateModel (&dataMat, &ywModel, &lsModel);	if (ErrorHasOccured())		SetErrorCode (-1, "AREst: cannot estimate");	else	{	CopyVec (ywModel.coef.sCoef.pntr, estCoef.pntr[0], arOrder+1);		if (estCoef.nCols > 1)			CopyVec (lsModel.coef.sCoef.pntr, estCoef.pntr[1], arOrder+1);	}	return (ErrorHasOccured());}int FFT (inputTag, outputTag, memory)int inputTag, outputTag;Matrix *memory;{	Matrix input, output;	int sign = 1;		input = memory[inputTag];	output = memory[outputTag];		CopyMatrix (&input, &output);	ftTransform (sign, &output);	return (ErrorHasOccured());}	