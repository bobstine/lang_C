/*			------  Fourier Transform  ----------		21 Aug 89 ... Modifed for parallel processor.	31 Mar 88 ...	Try out Robinson's version of FFT.	26 Mar 88 ...	Convolution now working; turn into separate module.	23 Mar 88 ...	New interfaces, two real series, convolution code.	22 Mar 88 ...	Get inversion straighted out; debug scramble. Timings.	21 Mar 88 ...	Cooley-Tukey verifed with APL; complete Sande-Tukey from Pascal.	20 Mar 88 ...	Addition of Cooley-Tukey code for FFT.	19 Mar 88 ...	Created.   		*/#include "Globals.h"#include "Utils.h"#include "FourierTrans.h"#include <Math.h>/*  _____________________  Local Procedures  ______________________  */void SetupGlobals (Matrix *input);void Scramble (void);void ctFFT (int sign);void stFFT (int sign);void newFFT (int sign);/*  ----------------------  constant definitions  -------------------  */#define		REAL	0					/* real and imag col indices */#define		IMAG	1#define 	MAXPOWER	15/*  ----------------------  global variables  -----------------------  */static 	double  *gReal, *gImag;		/* input data columns					*/static	int		gRows, gTwoExpo;		/* # rows of input mat, and log2(gRows) */static 	double  gAngles[2][MAXPOWER];static 	int	    gNeedToFillAngles = 1;/*  -----------------------------------------------------------------  */void newFFT (sign)int sign;/* Robinson's version of the Sande-Tukey with input in raw form. */{	int i,m[MAXPOWER], k, j, jH, L, nBlock, lBlock, iBlock, lbHalf, iStart;	double tempR, tempI, gRealN, gRealK, v, realW, imagW;	Matrix dummy;	AllocMatrix (0, 2, &dummy);	dummy.nRows = gRows; dummy.nCols = 2;	dummy.pntr[REAL] = gReal;  dummy.pntr[IMAG] = gImag;			gRealN = (double) gRows;	m[0] = gRows;	for (i=1; i<MAXPOWER; ++i)	{	m[i] = m[i-1] / 2;		/*  printf ("m[%d] = %d\n",i, m[i]); */	}	nBlock = 1;	for (L=0; L<gTwoExpo; ++L)	{	lBlock = gRows / nBlock;		lbHalf = lBlock/2;		k = 0;		for (iBlock=0; iBlock<nBlock; ++iBlock)		{	gRealK = (double)k;			v = sign * 2.0 * 3.14159 * gRealK/gRealN;			realW = cos(v); imagW = sin(v);			/* printf ("----> angle = %f with c = %f and s = %f (k=%d)\n", v,gRealW,imagW,k); */			iStart = lBlock * iBlock;			for (i=0; i<lbHalf; ++i)			{	j = iStart + i;				jH = j + lbHalf;				/* printf ("Exchanging jH=%d with j=%d\n", jH, j); */				tempR = gReal[jH]*realW - gImag[jH]*imagW;				tempI = gReal[jH]*imagW + gImag[jH]*realW;				gReal[jH] = gReal[j] - tempR;				gImag[jH] = gImag[j] - tempI;				gReal[j] += tempR;				gImag[j] += tempI;			}			/* PrintMatrix (&dummy, "Current data"); */			i = 2;			while (i <= gTwoExpo)			{	if (k < m[i]) break;				k -= m[i];				++i;			}			k += m[i];		}		nBlock *= 2;	}}static void SetupGlobals (input)		/* Globals -> gTwoExpo, gRows, gAngles, gReal, gImag */Matrix *input;{		int j;		if (input->nCols NE 2)		SetErrorCode (-5, "FFT: needs two col array");	else	{	gRows = input->nRows;		gReal = input->pntr[REAL];	gImag = input->pntr[IMAG];		j = 1; 		gTwoExpo = 0;		while (j < gRows)		/* log2(gRows) */		{	j += j;			gTwoExpo += 1;		}		if (j NE gRows)			SetErrorCode (-6, "FFT: needs power of 2 length");		else		{	if (gNeedToFillAngles)	/* fill W factor arrays */			{				gAngles[REAL][0] = 0.0; gAngles[IMAG][0] = 1.0;		/* [0] holds cos,sin pi/2 */				for (j=1; j<MAXPOWER; ++j)				{	gAngles[REAL][j] = sqrt( (1.0 + gAngles[REAL][j-1])/2.0 );					gAngles[IMAG][j] = gAngles[IMAG][j-1] / (2.0*gAngles[REAL][j]); /* now  pi/2(j+1) */				}				gNeedToFillAngles = 0;			}		}	}}			void Scramble ()/* In place rearrangement defined by index bit reversal. */{	int i, r, j,  k;	double zr, zi;		for (r=0; r<gRows; ++r)	{	k = 0;		j = r;		for (i=0; i<gTwoExpo; ++i)		{	k = (2*k)+j%2;		/* construct row # in bit-reversed order */			j /= 2;		}		if (k > r)		{	zr = gReal[r]; zi = gImag[r];			gReal[r] = gReal[k];			gImag[r] = gImag[k];			gReal[k] = zr;			gImag[k] = zi;		}	}}void ctFFT(sign)int sign;/* Cooley-Tukey FFT assuming that input is scrambled.   Value of sign (+/- 1) determines if inverse to be used */{	int offset, len, m, j, p, q, useAngle;	double angle, wi, wr, wpr, wpi, tempR, tempC;		for (p=0; p<gRows; p+=2)	/* handle +,- pairs first */	{	q = p + 1;		tempR = gReal[q]; tempC = gImag[q];		gReal[q] = gReal[p] - tempR;		gImag[q] = gImag[p] - tempC;		gReal[p] += tempR;	gImag[p] += tempC;	}	/* PrintMatrix (in, "after first step"); */	offset = 2;			/* index offset for elements being combined */	len = 4;			/* length of transform being computed */	useAngle = 0;		/* index into angle array */	while (len <= gRows)	{	wpr = gAngles[REAL][useAngle];		wpi = gAngles[IMAG][useAngle];		if (sign<0) wpi *= -1;		/* printf ("---- Angle increments  wpr = %f  wpi = %f\n", wpr, wpi); */		wr = 1.0; wi = 0.0;		/* first is always pi */		for (j = 0; j<offset; ++j)			/* outer loop over frequency */		{	for (p = j; p<gRows; p+=len)	/* loop over partitions of series */			{	q = p + offset;				tempR = wr * gReal[q] - wi * gImag[q];				tempC = wr * gImag[q] + wi * gReal[q];				gReal[q] = gReal[p] - tempR;				gImag[q] = gImag[p] - tempC;				gReal[p] += tempR;				gImag[p] += tempC;			}			tempR = wr;			wr = wr*wpr - wi*wpi;			/* W times angle increment in W'(complex mult) */			wi = wi*wpr + tempR * wpi;			/* printf ("     current gAngles are wr = %f and wi = %f\n", wr, wi); */		}		offset = len;		len *= 2;		useAngle += 1;	}	if (sign<0) 	{	tempR = (double) gRows;		for (p=0; p<gRows; ++p)		{	gReal[p] /= tempR;			gImag[p] /= tempR;		}	}}void stFFT (sign)int sign;/* Sande-Tukey FFT, leaving the output needing to be unscrambled. */{	int ct, offset, i0, nPairs, pass;	int k, kk, i, l, k1, j, useAngle, j1;	double wr, wi, ws, um, zr, zi, z;		offset = gRows / 2;	nPairs = 1;	i0 = gTwoExpo;	for (pass=1; pass<=gTwoExpo; ++pass)	{	for (k=0; k < offset; ++k)		{	/* printf ("Top for k loop with offset = %d\n", offset); */			wr = 1.0; wi = 0.0;			i = 1;			kk = k;			while ((kk != 0) && (i<i0))			{	if (kk%2 != 0)				{	useAngle = i0 - i - 1;					ws = wr*gAngles[REAL][useAngle] - wi*gAngles[IMAG][useAngle];					wi = wr*gAngles[IMAG][useAngle] + wi*gAngles[REAL][useAngle];					wr = ws;				}				kk /= 2;				i += 1;			}			/* printf ("Current wr=%f and wi=%f\n",wr,wi); */			if (sign < 0) wi *= -1;			/* negative imag for inverse trans */			l = k;			for (j=1; j<=nPairs; ++j)			{	k1 = l + offset;				zr = gReal[l] + gReal[k1];				zi = gImag[l] + gImag[k1];				z = wr*(gReal[l]-gReal[k1]) - wi*(gImag[l]-gImag[k1]);				gImag[k1] = wr*(gImag[l]-gImag[k1]) + wi*(gReal[l]-gReal[k1]);				gReal[k1] = z;				gReal[l] = zr;				gImag[l] = zi;				l = k1 + offset;			}		}		i0 -= 1;		nPairs += nPairs;		offset /= 2;	}	if (sign<0) 	{	z = (double) gRows;		for (j=0; j<gRows; ++j)		{	gReal[j] /= z;			gImag[j] /= z;		}	}}void ftTransform (sign, input)int sign;Matrix *input;{	SetupGlobals (input);	if (NOT ErrorHasOccured())	{	Scramble ();		ctFFT (sign);	}}void ftTransformPair (sign, input, out1, out2)Matrix *input, *out1, *out2;int sign;{	int j, nmj, half;	double *r1, *i1, *r2, *i2;		r1 = out1->pntr[REAL]; i1 = out1->pntr[IMAG];	r2 = out2->pntr[REAL]; i2 = out2->pntr[IMAG];	SetupGlobals(input);	Scramble ();	ctFFT (sign);	r1[0] = gReal[0]; i1[0] = 0.0;	r2[0] = gImag[0]; i2[0] = 0.0;	half = gRows/2;	r1[half] = gReal[half]; i1[half] = 0.0;	r2[half] = gImag[half]; i2[half] = 0.0;	nmj = gRows;	for (j = 1; j < half; ++j)	{	nmj -= 1;		r1[j] = 0.5 * (gReal[j] + gReal[nmj]); r1[nmj] =  r1[j];		i1[j] = 0.5 * (gImag[j] - gImag[nmj]); i1[nmj] = -i1[j];		i2[j] = 0.5 * (gReal[j] - gReal[nmj]); i2[nmj] = -i2[j];		r2[j] = 0.5 * (gImag[j] + gImag[nmj]); r2[nmj] =  r2[j];	}}void ftConvolve (input, ftData, ftKernel)Matrix *input, *ftData, *ftKernel;{	int j;		double *dataR, *dataI, *kernelR, *kernelI;		ftTransformPair (1, input, ftData, ftKernel);	/* sets globals */	dataR = ftData->pntr[REAL]; dataI = ftData->pntr[IMAG];	kernelR = ftKernel->pntr[REAL]; kernelI = ftKernel->pntr[IMAG];	for (j=0; j<gRows; ++j)	{	gReal[j] = dataR[j]*kernelR[j] - dataI[j]*kernelI[j];		gImag[j] = dataI[j]*kernelR[j] + dataR[j]*kernelI[j];	}	Scramble();	ctFFT (-1);}