#include "Globals.h"#include "Utils.h"#include "apMachine.h"#include "Messages.h"#include <string.h>#include <stdlib.h>#ifdef DEBUG_ALLOC#include "DebugAlloc.h"#endif#ifdef LSC#include <time.h>#endif/*  ___________________  Scalar conversions  __________________________  *//*				scalar --> scalar echo*/void ConvertScalarPacket (in, out)ScalarPacket *in, *out;{	out->scalar     = in->scalar;			/* an echo */	out->returnCode = in->returnCode;	out->packetCode = in->packetCode;}/*  ____________________  Vector conversions  _____________________  *//*		not well tested*/void ConvertVectorPacket (vp, sp)VectorPacket *vp;ScalarPacket *sp;{	Vector vec;		BuildVectorFromPacket (vp, &vec);	sp->packetCode = vec.len;	sp->scalar     = vec.pntr[0];	DisposeVector (&vec);}int VectorPacketSize (vp)VectorPacket *vp;{	return ( 2*sizeof(int) + (vp->len)*sizeof(double) );}void BuildVectorFromPacket (vp, vec)VectorPacket *vp;Vector *vec;{	AllocVector (vp->len, vec);	memcpy ((void *)vec->pntr, (void *)vp->data, vp->len * sizeof(double));}void BuildVectorPacket (vec, vp)Vector *vec;VectorPacket **vp;{	(*vp) = (VectorPacket *) malloc (2*sizeof(int) + vec->len*sizeof(double));	(*vp)->packetCode = 7;	(*vp)->len = vec->len;	memcpy ((char *)(*vp)->data, (char *)vec->pntr, vec->len*sizeof(double));}/*  	_____________________  Matrix conversions _____________________ 	matrix --> scalar packet, with scalar set to 0,0 element of matrix*/void ConvertMatrixPacket (mp, sp, arrayProcessor)MatrixPacket *mp;ScalarPacket *sp;ArrayProcessor *arrayProcessor;{	Matrix aMatrix;	int rc;		BuildMatrixFromPacket (mp, &aMatrix);	rc = apStoreMatrixAtTag (&aMatrix, mp->packetCode, arrayProcessor);	sp->packetCode = mp->packetCode;	sp->returnCode = rc;	sp->scalar	= (float)aMatrix.pntr[0][0];	if (rc) 			/* dont free unless cannot store */		DisposeMatrix (&aMatrix);}int MatrixPacketSize (mp)MatrixPacket *mp;{	return ( 4*sizeof(int) + (mp->nRows*mp->nCols)*sizeof(double) );}void BuildMatrixFromPacket (mp, mat)MatrixPacket *mp;Matrix *mat;{	int col, nBytes;	char *offset;		AllocMatrix (mp->nRows, mp->nCols, mat);	nBytes = mat->nRows * sizeof(double);	offset = (char *)&mp->data[0];	for (col=0; col<mat->nCols; ++col)	{	memcpy ((char *)mat->pntr[col], offset, nBytes);	/* dest, src */		offset += nBytes;	}}		void BuildMatrixPacket (code, mat, mpHand)int code;Matrix *mat;MatrixPacket **mpHand;{	int msgSize, matSize, col, nBytes;	char *offset;	ScalarPacket sp;		msgSize = 4*sizeof(int) + (mat->nRows*mat->nCols*sizeof(double));	(*mpHand) = (MatrixPacket *) malloc(msgSize);	(*mpHand)->packetCode = code;	(*mpHand)->returnCode = 0;	(*mpHand)->nRows = mat->nRows; (*mpHand)->nCols = mat->nCols;		nBytes = mat->nRows * sizeof(double);	offset = (char *)&(*mpHand)->data[0];	for (col=0; col<mat->nCols; ++col)	{	memcpy ((char *)offset, (char *)mat->pntr[col], nBytes);	/* dest, src */		offset += nBytes;	}}	/*	_______________________  Tag Packets  ______________________ 		tag --> matrix*/void ConvertTagPacket  (tpPtr,  mpHandle, arrayProcessor)TagPacket *tpPtr;MatrixPacket **mpHandle;ArrayProcessor *arrayProcessor;{		int rc;	Matrix mat;	rc = apRetrieveMatrixFromTag (tpPtr->matrixTag, &mat, arrayProcessor);	if (rc EQ 0)	{	BuildMatrixPacket(tpPtr->matrixTag, &mat, mpHandle);	}	else	{	(*mpHandle) = (MatrixPacket *) malloc(sizeof(MatrixPacket));		(*mpHandle)->packetCode = tpPtr->matrixTag;		(*mpHandle)->nRows = 0;		(*mpHandle)->nCols = 0;	}	(*mpHandle)->returnCode = rc;}	/*	_______________________  Instruction Processing  __________________	instructions --> scalar  (with timed value field)*/void ConvertInstPacket (ip, spPtr, arrayProcessor)InstPacket *ip;ScalarPacket *spPtr;ArrayProcessor	*arrayProcessor;{	double theValue=0.0;	clock_t startTime, stopTime;		startTime = clock();	spPtr->returnCode = apRunInstQueue (ip->instArray, arrayProcessor);	stopTime = clock();	spPtr->packetCode = ip->packetCode;	spPtr->scalar	  = (float) stopTime - startTime;}