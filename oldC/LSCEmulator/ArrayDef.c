/*		 		ArrayDef.c										*//*								 6 Oct 87						*//*	 					rev		31 Mar 88 AllocMatrix			*/#include <stdlib.h>#include "Globals.h"#include "ArrayDef.h"#ifdef DEBUG_ALLOC#include "DebugAlloc.h"#endifvoid AllocVector (len, vec)int len;Vector *vec;{	if (len > 0) {		vec->pntr = (double *) (malloc(len * sizeof(double)));		vec->len = (vec->pntr != NULL) ? len : 0;	} else {		vec->len = 0;		vec->pntr= NULL;	}}void AllocIntVector (len, intVec)int len;IntVector *intVec;{	if (len > 0) {		intVec->pntr = (int *) (malloc(len * sizeof(int)));		intVec->len = (intVec->pntr != NULL) ? len : 0;	} else {		intVec->len = 0;		intVec->pntr= NULL;	}}	void AllocMatrix (nRows, nCols, mat)int nRows, nCols;Matrix *mat;{	int	col;	mat->nCols = nCols;	mat->nRows = nRows;	mat->pntr = (double **) malloc(nCols * sizeof(double *));	if (mat->pntr NE NULL)	{	for (col = 0; col < nCols; col++)		{	if (nRows > 0) 				mat->pntr[col] = (double *) malloc(nRows * sizeof(double));		}	}}void AllocConstMatrix (theConst, nRows, nCols, mat)double theConst;int nRows, nCols;Matrix *mat;{	int i,j;	double *ptr;		AllocMatrix (nRows, nCols, mat);	for (j=0; j<mat->nCols; ++j)	{	ptr = mat->pntr[j];		for (i=0; i<mat->nRows; ++i)			*ptr++ = theConst;	}}void ResizeVector (len, vec)int len;Vector *vec;{	if (vec->len != len) 	{	free ((char *) vec->pntr);		vec->pntr = (double *) malloc (len * sizeof(double));		vec->len = len;	}}void ResizeMatrix (nRows, nCols, mat)int nRows, nCols;Matrix *mat;{	if ( (mat->nRows != nRows) || (mat->nCols != nCols) )	{	DisposeMatrix (mat);		AllocMatrix (nRows, nCols, mat);	}}void ResizeCube (nPlanes, nRows, nCols, cube)int nPlanes, nRows, nCols;Cube *cube;{	if ( (cube->nRows != nRows) || (cube->nCols != nCols) || (cube->nPlanes != nPlanes) )	{	DisposeCube (cube);		AllocCube (nPlanes, nRows, nCols, cube);	}}void DisposeVector (vec)Vector *vec;{	free ((char *) vec->pntr);	vec->len = 0;}void DisposeIntVector (intVec)IntVector *intVec;{	free ((char *) intVec->pntr);	intVec->len = 0;}void DisposeMatrix (mat)Matrix *mat;{	int col;		if (mat->nRows > 0) 	{	for (col = 0; col < mat->nCols; ++col)  			free ((char *) (mat->pntr)[col]);	}	free ((char *)mat->pntr);	mat->pntr  = NULL;	mat->nRows = 0;	mat->nCols = 0;}/*	buffer space for holding pointers into C arrays	*/#define MAXROW 20static int lastUsed = 1;static double *rowPtr1[MAXROW+1], *rowPtr0[MAXROW+1];double **ColPointers (mat, nRows, nCols)	/* useful if col order */double *mat;int nRows, nCols;{	int row, limit, jump;	double **rh;		limit = (nRows < MAXROW) ? nCols : MAXROW;	/* get min */		if (lastUsed == 1)		/* then use #0 */	{	rh = rowPtr0; lastUsed = 0;	} else	{	rh = rowPtr1; lastUsed = 1;	}	jump = 0;	for (row = 0; row<limit; ++row, jump += nCols)		rh[row] = (double *) &mat[jump];	return (rh);}void AllocCube (numPlanes, numRows, numCols, theCube)int numPlanes, numRows, numCols;Cube *theCube;{	int	p, c;		theCube->nPlanes = numPlanes;	theCube->nRows = numRows;	theCube->nCols = numCols;	theCube->pntr = (double ***) (malloc(numPlanes * sizeof(double **)));	for (p=0; p<numPlanes; ++p)	{	theCube->pntr[p] = (double **) (malloc(numCols * sizeof(double *)));		for (c=0; c<numCols; ++c)		{	theCube->pntr[p][c] = (double *)(malloc(numRows * sizeof(double)));		}	}}	 /*  AllocCube  */void DisposeCube (theCube)Cube *theCube;{	int p, c;		for (p=0; p<theCube->nPlanes; ++p)	{	for (c=0; c<theCube->nCols; ++c)			free ((char *) theCube->pntr[p][c]);		free((char *)theCube->pntr[p]);	}	free ((char *)(theCube->pntr));	theCube->pntr = NULL;	theCube->nPlanes = 0;	theCube->nRows = 0;	theCube->nCols = 0;}	/*  DisposeCube  */	