/*				AREstimation.c						16 Aug 89 ... Modified for transputers.	25 Oct 87 ... Created.	*/	#include "AREstimation.h"#include "Globals.h"#include "Utils.h"#include "ElemArrayOps.h"#include "AdvArrayOps.h"/*  ____________________  Local Procs  _____________________  */void CheckInput(ARModel *);void doMeanCorrection(Matrix *);void AccumSSandCP (Matrix *);void ReviseForLS (Matrix *);void MoveEstimates (ARModel *);/*  ___________________  Internal globals  __________________  */static Vector meanVec, scratch;static double *colPtr, *scrPtr;static Matrix ssMat, cpMat, estMat;static double **ssPtr, **cpPtr, **estPtr;static int dim, P;					static enum ARType modelType;static double mean;/*	_______  Internal globals set by external calls.  ________  */static int gUseMeanCorrection = FALSE;static int gSpaceIsAllocated  = FALSE;void arUseMeanCorrection (pick)int pick;  {	gUseMeanCorrection = pick;}void arUseFixedSpace (P, dim)int P,dim;{	int size;		if (gSpaceIsAllocated)		SetErrorCode (4, "AREst: space already allocated");	else	{	size = P * dim;		AllocMatrix(size, size, &ssMat);		ssPtr = ssMat.pntr;		AllocMatrix(size, dim, &cpMat);		cpPtr = cpMat.pntr;		AllocMatrix(size, dim, &estMat);		estPtr = estMat.pntr;		if (gUseMeanCorrection && (modelType EQ multivar))			AllocVector(dim, &meanVec);		AllocVector((P + 1) * dim, &scratch);		scrPtr = scratch.pntr;		gSpaceIsAllocated = TRUE;	}}void arFreeFixedSpace(){	if (gSpaceIsAllocated)	{	gSpaceIsAllocated = FALSE;		DisposeMatrix(&ssMat);		DisposeMatrix(&cpMat);		DisposeMatrix(&estMat);		if (gUseMeanCorrection && (modelType == multivar))			DisposeVector(&meanVec);		DisposeVector(&scratch);	}	else		SetErrorCode (5, "AREst: space not allocated; cannot free");}static void CheckInput(lsEsts)ARModel *lsEsts;{	if (modelType NE lsEsts->type)		SetErrorCode (-1, "AREst: model types do not agree");	if ((dim > 1) && (modelType EQ scalar))		SetErrorCode (-11, "AREst: conflict in input");}static void doMeanCorrection(data)Matrix *data;{	int t, d;			if (modelType EQ scalar)	{	colPtr = data->pntr[0];		mean = SumVec(colPtr, data->nRows)/(double)data->nRows;		for (t = 0; t<data->nRows; ++t)			colPtr[t] = colPtr[t] - mean;	} else /* multivariate */	{	for (d = 0; d<dim; ++d)		{	colPtr = data->pntr[d];			mean = SumVec(colPtr, data->nRows)/(double)data->nRows;			for (t = 0; t<data->nRows; ++t)				colPtr[t] = colPtr[t] - mean;			meanVec.pntr[d] = mean;		}	}}static void AccumSSandCP (data)Matrix *data;{	int k, t, lag, col, row, rowOffset, colOffset, offset, i, j, nObs;	nObs = data->nRows;	if (modelType EQ scalar)	{	colPtr = data->pntr[0];		for (lag = 0; lag < P; ++lag)		{	/* fill first row and column */			ssPtr[0][lag] = CrossLagProdVec(colPtr, colPtr, nObs, lag);			ssPtr[lag][0] = ssPtr[0][lag];		}		for (k = 1; k<P; ++k)		/* extend to remaining rows and cols */			for (i = k; i<P; ++i)			{	ssPtr[k][i] = ssPtr[0][i-k];				if (k != i)					ssPtr[i][k] = ssPtr[k][i];			}		cpPtr[0][P - 1] = CrossLagProdVec(colPtr, colPtr, nObs, P);		for (k = 0; k<= P - 2 ; ++k)	/* fill  remaining cross prods */			cpPtr[0][k] = ssPtr[0][k + 1];	} else /* multivariate */	{	offset = 0;		for (lag = 0, offset=0 ; lag < P; ++lag, offset += dim)		{	for (i = 0; i<dim; ++i)			{	colPtr = data->pntr[i];				for (j = i; j<dim; ++j)				{	ssPtr[j][offset + i] = CrossLagProdVec(colPtr, data->pntr[j], data->nRows, lag);					if (i != j)						ssPtr[i][offset + j] = CrossLagProdVec(data->pntr[j], colPtr, data->nRows, lag);				}		/* for j */			}			if (lag > 0)  		/* build first row with trans and fill cross products */			{	for (i = 0; i<dim; ++i)					for (j = 0 ; j< dim; ++j)					{	ssPtr[offset + j][i] = ssPtr[i][offset + j];						cpPtr[j][i + offset - dim] = ssPtr[j][offset + i];					}			}		}		/* for lag */		rowOffset = (P - 1) * dim;		for (i = 0; i<dim; ++i)			/* get last block of cross products*/			for (j = 0 ; j<dim; ++j)			{	cpPtr[j][rowOffset + i] = CrossLagProdVec(data->pntr[i], data->pntr[j], nObs, lag);				if  (i NE j)					cpPtr[i][rowOffset + j] = CrossLagProdVec(data->pntr[j], data->pntr[i], nObs, lag);			}		colOffset = 0;		for (col = 1; col < P; ++col) 		/* copy ss into rest of blocks  */		{	rowOffset = colOffset;			colOffset +=  dim;			for (row = col; row<P; ++row)			{	rowOffset += dim;				for (j = 0; j<dim; ++j)					for (i = 0; i<dim; ++i)						ssPtr[j + colOffset][i + rowOffset] = ssPtr[j][i + rowOffset - colOffset];				if (row NE col) 	/* place tranposed block */					for (j = 0; j<dim; ++j)						for (i = 0; i<dim; ++i)							ssPtr[i + rowOffset][j + colOffset] = ssPtr[j + colOffset][i + rowOffset];			}		}	}	/* else */}	/*  AccumSSandCP */static void ReviseForLS (data)Matrix *data;{	double *rowPtr, *colPtr;	int diag, j, t, nObs, lag, k, row, col, rowIn, colIn, limit, jM1;	double adj, meanSqr;	nObs = data->nRows;	if (modelType EQ scalar)	{	colPtr = data->pntr[0];		for (diag = 0; diag<P; ++diag)		/* last element of cp is correct */		{	adj = 0.0;			for (t = diag; t<P; ++t)		/* get leading terms  */				adj += colPtr[t - diag] * colPtr[t];				if (diag > 0)				/* adjust cp matrix  */					cpPtr[0][diag - 1] = cpPtr[0][diag - 1] - adj;				for (j = 1; j<=P - diag; ++j)		/* correct for last terms */				{	jM1 = j - 1;					adj += (colPtr[nObs - j - diag] * colPtr[nObs - j]) - (colPtr[P - j - diag] * colPtr[P - j]);					ssPtr[jM1][jM1 + diag] -=  adj;					if (diag != 0)			/* fill matrix symmetrically */						ssPtr[jM1 + diag][jM1] = ssPtr[jM1][jM1 + diag];				}		}		/* for diag */		if (gUseMeanCorrection)		{	adj = mean * (double)nObs;			meanSqr = mean * mean;			for (t = 0; t<P; ++t)				adj -= mean + colPtr[t];		/* data are deviations */			scrPtr[0] = adj;					/* total for dep var */			for (lag = 1; lag<=P; ++lag)		/* get totals for lag vars */				scrPtr[lag] = scrPtr[lag - 1] + colPtr[P - lag] - colPtr[nObs - lag];			adj = (double) nObs - P;			for (lag = 0; lag<=P; ++lag)		/* scrPtr holds ls means */				scrPtr[lag] = scrPtr[lag] / adj;			for (j = 1; j<=P; ++j)				/* adjust cp matrix */			{	cpPtr[0][j - 1] += adj * ((mean * (scrPtr[0] + scrPtr[j])) - (scrPtr[0] * scrPtr[j] + meanSqr));				scrPtr[j] -= mean;				/* form as deviations  */			}			for (j = 1; j<=P; ++j) 				for (k = j; k<=P; ++k)			/* adjust SS matrix and use symmetry */				{	ssPtr[j - 1][k - 1] -=  adj * (scrPtr[j] * scrPtr[k]);					if  (k != j)						ssPtr[k - 1][j - 1] = ssPtr[j - 1][k - 1];				}		}		/* if */	} else		/* multivariate */	{	for (row = 0; row < dim; ++row)			/* do the row, col element of every block */		{	rowPtr = data->pntr[row];			for (col = 0; col< dim; ++col)			{	colPtr = data->pntr[col];				for (diag = 0; diag<P; ++diag)	/*last block of cp is correct */				{	adj = 0.0;					for (t = diag; t<P; ++t)	/* get leading terms  */						adj += rowPtr[t - diag] * colPtr[t];					if  (diag > 0)				/* adjust cp matrix  */					{	rowIn = row + dim * (diag - 1);						cpPtr[col][rowIn] -=  adj;					}					for (j = 1; j <= (P - diag); ++j)	/* correct for last terms */					{	adj += (rowPtr[nObs - j - diag] * colPtr[nObs - j]) - (rowPtr[P-j-diag] * colPtr[P-j]);						rowIn = row + (j - 1 + diag) * dim;						colIn = col + (j - 1) * dim;						ssPtr[colIn][rowIn] -= adj;						if (diag != 0)			/* fill matrix symmetrically */							ssPtr[rowIn][colIn] = ssPtr[colIn][rowIn];					}				}	/* for diag */			}		}			/*for row */		if (gUseMeanCorrection) 		/* multivariate mean correction */		{	for (col = 0; col<dim; ++col)			{	colPtr = data->pntr[col];				adj = meanVec.pntr[col] * (double)nObs;				for (t = 0 ; t<P ; ++t)					adj -= (colPtr[t] + meanVec.pntr[col]);				scrPtr[col] = adj;		/* total for col */				for (lag = 1; lag <= P; ++lag)		/* get totals for lag vars  */				{	row = col + lag * dim;					scrPtr[row] = scrPtr[row - dim] + colPtr[P - lag] - colPtr[nObs - lag];				}			}		/*for col*/			adj = (double) (nObs - P);			for (lag = 0; lag <= P; ++lag)			/*form vector of ls means minus overall means */				for (row = 0 ; row < dim; ++row)					scrPtr[dim * lag + row] = (scrPtr[dim * lag + row]/adj) - meanVec.pntr[row];			limit = P * dim;			for (col = 0; col < dim; ++col)			{	for (row = 0; row < limit; ++row)		/* adjust cp matrix */					cpPtr[col][row] -= adj * (scrPtr[dim + row] * scrPtr[col]);			}						for (row = 0; row < limit; ++row)				for (col = row; col < limit; ++col)	/* adjust SS matrix and use symmetry */				{	ssPtr[col][row] -=  adj * (scrPtr[dim + row] * scrPtr[dim + col]);					if  (col != row)						ssPtr[row][col] = ssPtr[col][row];				}		}		/* if */	}}	/* doReviseForLS  */static void MoveEstimates (dest)ARModel *dest;{	int pln, row, col, rowOffset;	double *vecPtr;	double ***cubePtr;	if (modelType EQ scalar)	{	vecPtr = dest->coef.sCoef.pntr;		for  (row = 1; row <= P; ++row)			vecPtr[row] = - estPtr[0][row - 1];	/* spectral coef form */	}		/* scalar case */	else	{	cubePtr = dest->coef.mCoef.pntr;		rowOffset = 0;		for (pln = 1; pln<=P; ++pln)		{	for (row = 0; row<dim; ++row)				for (col = 0; col<dim; ++col)		/* transpose coef mats; spectral form */					cubePtr[pln][col][row] = - estPtr[row][rowOffset + col];			rowOffset += dim;		}		/* for pln */	}		/* multivar */}	/* MoveEstimates */void arEstimateModel (data, ywEsts, lsEsts)Matrix *data;ARModel *ywEsts, *lsEsts;{	int needToFree = 0;		modelType = ywEsts->type;	dim = data->nCols;	if (ywEsts->type EQ scalar)		P = ywEsts->coef.sCoef.len -1;	else		P = ywEsts->coef.mCoef.nPlanes -1;	CheckInput(lsEsts);	if (NOT ErrorHasOccured())	{	if (gSpaceIsAllocated EQ 0)			/*  allocs arrays and set pntr's	*/		{	arUseFixedSpace (P, dim);			needToFree = 1;		}		if (gUseMeanCorrection)				/*  mean estimation  and YW correction  */			doMeanCorrection(data);		AccumSSandCP(data);		SolveMultiSystem(&ssMat, &cpMat, &estMat);		MoveEstimates(ywEsts);				/* move adds negative sign	*/		ReviseForLS(data);		SolveMultiSystem(&ssMat, &cpMat, &estMat);		MoveEstimates(lsEsts);	}	if (needToFree)		arFreeFixedSpace();}	/* EstimateModel  */void arCalcResids (Matrix *, ARModel *, Matrix *);void arCalcResids (data, ests, resids)  /* NOT fully TESTED */Matrix *data, *resids;ARModel *ests;{	double *dataPtr, *resPtr, *coefPtr;	int t,j,p;		if (ests->type EQ multivar)		SetErrorCode (-1, "AAO: Factor destination too small");	else	{	p = ests->coef.sCoef.len - 1;		coefPtr = ests->coef.sCoef.pntr;		dataPtr = data->pntr[0];		resPtr = resids->pntr[0];		for (t=p; t<data->nRows; ++t)		{	resPtr[t] = dataPtr[t];			for (j=1; j<=p; ++j)				resPtr[t] += coefPtr[j] * dataPtr[t-j];		}	}}	/* arCalcResids */