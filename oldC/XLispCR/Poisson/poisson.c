/*	poisson.c	10 Jan 95 ... Port to PowerMac and metrowerks.	 21 Jul 94 ... Compute term in deriv of geometric log-like; lagged likelihood.	 16 Feb 94 ... Pair prob likelihood (why cant I do alloc?).	 12 Oct 93 ... Lots of debugging and speed increases.	  7 Jun 93 ... Created to speed generation of data for Poisson queue simulations.	  1 Oct 93 ... Transition probability for simulating likelihood.*/#include <math.h>#include <stdlib.h>#include "probability.h"#ifdef _UNIX_#include "probability.c"#endif#define Sqr(x) ((x)*(x))//	Prototypesvoid main (void);			// dummy stub for MW __start code to call ... may not be needed longervoid Generate ( long *queue, long *nQueuePtr, long *arrive, long *nArrivePtr, long *hold);						 void ProbVec (	double *q, double *lamPtr, double *elamPtr, double *pv,					 		long *lenPVPtr, double *qVec1, double *qVec2);void CalcACS (long *method, long *y, long *tLimit, double *acs, long *jLimit);void GenTruncRandom ( double *cdf, long *nCDFptr, long *low, long *high, 						double *uniform, long *result, long *nResPtr);						void SimulateSteps (long *returnCode, long *total, long *arrive, long *nPeriodPtr,					long *alloc, long *nextAlloc, double *survProb, long *nCellsPtr,					double *arriveCDF, double *uniform, double *prob);void GeometricLogLike (long *returnCode, long *y, long *pN, long *pLag, double *poissonPr, 					double *binomialPr, long *ProbLen, double *pXi, double *pLogLike);	void dGeoLLdLam (long *returnCode, long *y, long *pN, long *pLag, double *poissonPr, 					double *binomialPr, long *ProbLen, double *pXi, double *pLogLike);	void LambdaLogLike (long *returnCode, long *y, long *x, long *pN,		 double *plamU, double *plamC, double *scratch, long *pLenScr, double *pLogLike);//	Mainvoid main (void){	int i;	i = 1;}/*  _____________________  Generate  ______________________________  */void Generate ( long *queue, long *nQueuePtr, long *arrive, long *nArrivePtr, long *hold){	long inQueue;	int register j, time, i;		long nQueue, nArrive;		nArrive = *nArrivePtr;	nQueue  = *nQueuePtr;		/*---  initialize running count of number in queue		---*/	inQueue = queue[0];	for(i=1; i<nQueue; ++i)		inQueue += queue[i];			/*---  loop over time	---*/	time = nArrive;	while (time > 0)	{	inQueue -= *queue;			/*  remove the zeros from queue total	*/				for(j=0; j<nQueue-1; ++j)	/*  rotate queue down	*/			queue[j] = queue[j+1];			queue[nQueue-1]=0;								for(j=0; j<*arrive; ++j)	/* add in the holding times	*/		{	if (*hold < nQueue)		/* check for valid index	*/				++queue[ *hold ];			else				++queue[ nQueue-1 ];			++hold;		}					*arrive +=  inQueue;		/* adjust the queue totals	*/		inQueue = *arrive++;		-- time;	}}/*  _____________________  ProbVec  ______________________________  */static void convolve(double *q, double *old, double *new, int n);void ProbVec (	double *q, double *lamPtr, double *elamPtr, double *pv,				long *lenPVPtr, double *qVec1, double *qVec2){	int i, j,iLim, jLim;	double prob, divisor, *src, *dest, *hold;		double  lam, elam;	long    lenPV;		lam = *lamPtr;	elam = *elamPtr;	lenPV = *lenPVPtr;		/*---  initialize pv 			---*/	    pv[0]   = elam;				/* 0 */        prob  = lam * elam;			/* 1 */    pv[1] = q[0] * prob; 		    pv[2] = q[1] * prob;	    pv[3] = q[2] * prob;    for (i=4; i<lenPV; ++i)	pv[i] = 0.0;	/*---  initialize convolution	---*/		qVec1[0] = q[0];	qVec1[1] = q[1];	qVec1[2] = q[2];				/*---  convolutions 3,4,...		---*/	iLim = 2 + (lenPV-4)/3;	jLim = 3;	divisor = 1.0;		src  = qVec1;	dest = qVec2;		for(i=2; i<iLim; ++i)				/*  i denotes the ith arrival	*/	{	jLim += 2;						/*  number of terms in conv		*/		convolve(q, src, dest,jLim);	/*  do a convolution with q 	*/		divisor += 1.0;		prob *= lam / divisor;			/*  alter poisson prob			*/    	for (j = 0; j < jLim; ++j)		/*  add to prob vector			*/        	pv[i+j] += prob * dest[j];        hold = src;						/*  swap src and dest ptr's		*/        src = dest;        dest = hold;  	}}static void convolve(double *q, double *old, double *new, int n) /*  adds 2 more terms to convolution */{	int register i;	double q1, q2, q3;		q1 = *q++;	q2 = *q++;	q3 = *q  ;		*new++ = q1 * old[0];	*new++ = q1 * old[1] + q2 * old[0];	i = 2;	while (i < n-2)			/* old valid < n-2 	*/	{	*new++ = q1 * old[i] + q2 * old[i-1] + q3 * old[i-2];		++i;	}	*new++ = q2 * old[n-3] + q3 * old[n-4];	*new   = q3 * old[n-3];}/*  ___________________  Calculating the autocovariances  ____________________  */void CalcACS (long *meth, long *y, long *tLimit, double *acs, long *jLimit){	long t,j, diff, sum, total, end;	long tLim, jLim, method;	double mean, yBarOverN, n;			method = *meth;                 /* Convert to long values */	tLim = *tLimit;	jLim = *jLimit;			sum = 0;							/* first find the mean of the series */	for (t=0; t<tLim; ++t)		sum += y[t];	mean = ((double) sum) / ((double) tLim);		if (method == 0)	{	n = (double) tLim;		yBarOverN = mean / n;		total = sum;		sum = 0;		for (t = 0; t < tLim; ++t)		/* do variance first since no lag */			sum += y[t] * y[t];		*acs++ = ((double) sum) / n - mean * mean;		end = 0;		for (j=1; j < jLim; ++j)		{	sum = 0;			for (t = j; t< tLim; ++ t)				sum += y[t] * y[t-j];			end += y[j-1] + y[tLim-j];			*acs++ = ((double) sum) / n    /* adjust for end effects in mean corr */					- yBarOverN * ((double) (2 * total - end)  - (mean * (n-j)));		}	} else	{	*acs++ = mean;		for (j=1; j < jLim; ++j)		{	sum = 0;			for (t = j; t < tLim; ++t)			{	diff = y[t] - y[t-j];				sum += diff * diff;			}			*acs++ = mean - ((double) sum) / ((double) 2*tLim);		}	}}/*  _____________________  Generating Truncated Poisson  ______________________________  */void GenTruncRandom ( double *cdf, long *nCDFptr, long *low, long *high, 						double *uniform, long *result, long *nResPtr){	long nCDF, nRes;	/* Unix only */		double  rand;  		/* Cannot declare vector cdf[MAXCDF] in code resource */	int i;	long j;	nCDF = *nCDFptr;	nRes = *nResPtr;		for(i=0; i<nRes; ++i)	{	if ( *low == 0 )			rand = (*uniform++) * cdf[*high];		else			rand =  cdf[*low-1] + ((*uniform++) * (cdf[*high] - cdf[*low-1]));		/* --- result is position of rand in the cdf table --- */		j = *low++; ++high;		while (rand > cdf[j]) ++j;		*result++ = j;	}	}/*  _____________________  Generating the Step Sequence  ________________________  */void SimulateSteps (long *returnCode, long *total, long *arrive, long *nPeriodPtr,					long *alloc, long *nextAlloc, double *survProb, long *nCellsPtr,					double *arriveCDF, double *uniform, double *prob){	long nPeriod, nCells;		/* arguments */		long priorTotal, nSurvive, i, cell, diff, period, cellLimit,			leftInCell, haveSeen, haveChosen, maxCell, priorMaxCell, *pLong;		double biPower, intProb;	nPeriod = *nPeriodPtr;	nCells  = *nCellsPtr;		for (i=0; i<nCells; ++i)					/* one-time init of ALL	cells		*/		nextAlloc[i] = 0;		if (*total == 0)							/* if none initially in queue		*/	{	maxCell = 0;		priorMaxCell = 0;	} else	{	maxCell = nCells-1;						/* locate the largest occupied cell	*/		while( alloc[maxCell] == 0 ) --maxCell;		priorMaxCell = maxCell;	}		cellLimit = nCells - 1;			for (period=1; period <= nPeriod; ++period)   	{		priorTotal = total[period-1];			/* get total from prior allocation	*/				nextAlloc[0] = *arrive;					/* initialize the next allocation	*/		for (i=1; i<=priorMaxCell; ++i)			nextAlloc[i] = 0;				nSurvive = total[period] - *arrive;				cell = 0; 		if (nSurvive > 0)						/* select the survivors				*/		{	leftInCell = alloc[0];			haveSeen = 0; haveChosen = 0;			while (haveChosen < nSurvive)			{	while (leftInCell == 0)			/* find next non-empty cell			*/				{	leftInCell = alloc[++cell];					if (cell >= cellLimit)		/* check for unsatisfied demand 	*/					{	*returnCode = - period;	/* error occurs if item lasts longer*/						arriveCDF[0] = intProb;	/* than the input number of cells	*/						arriveCDF[1] = biPower;	/* can accomodate.					*/						return;					}				}				if ( ((priorTotal-haveSeen) * (*uniform++)) < (nSurvive-haveChosen) )				{	++nextAlloc[cell+1];		/* survive from current cell		*/					++haveChosen;				}				++haveSeen;				--leftInCell;			}		}		priorMaxCell = maxCell;					/*  max number in the current stage	*/		maxCell = cell + 1;												/*  binomial power					*/		biPower = 1.0;		for (i=0; i <= priorMaxCell; ++i)			if (alloc[i] > 0) biPower *= BinomialPower(nextAlloc[i+1], alloc[i], survProb[i]);												/*  truncated arrival prob interval	*/		diff = total[period] - total[period-1];		if(diff > 0)	intProb = arriveCDF[total[period]] - arriveCDF[diff-1];		else			intProb = arriveCDF[total[period]];				/*    used to compute the hypergeometric...not anymore						*/		/* hyperProb = hyperDens(nextAlloc,alloc,nSurvive,total[period-1],maxCell); */														/*  ratio cancels poisson arrival	*/		*prob *= intProb * biPower * ChooseDouble(nSurvive,total[period-1]);					pLong = nextAlloc;						/* swap cell array pointers			*/		nextAlloc = alloc;		alloc = pLong;				++arrive;		}}/*  _____________________  Geometric Likelihood  ________________________  */void GeometricLogLike (long *returnCode, long *y, long *pN, long *pLag, double *poissonPr, 					double *binomialPr, long *ProbLen, double *pAlpha, double *pLogLike){	long min, i, j, time, n, lag;					/* Local variables in both versions */	double transPr, oneMalpha, alpha, ratio, comb, den;	alpha = *pAlpha;	oneMalpha = 1.0 - alpha;	ratio = alpha/oneMalpha;		lag = time = *pLag;	while (time < *pN)	{	n = y[time-lag];		if (y[time] > n)					/* min num of arrivals */			min = y[time] - n;		else			min = 0; 				binomialPr[0] = 1.0;				/* build the initial binomial prob	*/		for (i = 0; i < n; ++i)			binomialPr[0] *= oneMalpha;		for (i = 1; i <= y[time]-min; ++i)	/* recursions for the rest */		{	den   = (double) i;			comb  = (double) (n+1-i);			comb  = comb / den;			binomialPr[i] = binomialPr[i-1] * ratio * comb;		}						transPr = 0;						/* inner product for each time	*/		for (i = min, j = y[time] - min; i <= y[time]; ++i, --j)			transPr += poissonPr[i] * binomialPr[j];					*pLogLike += log(transPr);		++time;	}}void dGeoLLdLam (long *returnCode, long *y, long *pN, long *pLag, double *poissonPr, 					double *binomialPr, long *ProbLen, double *pAlpha, double *pDeriv){	long min, i, j, time, n, lag;					double oneMalpha, alpha, ratio, comb, den, Pyt, Pytm1;		alpha = *pAlpha;	oneMalpha = 1.0 - alpha;	ratio = alpha/oneMalpha;		lag = time = *pLag;	*pDeriv = 0.0;	while (time < *pN)	{	if (y[time] > 0)						/* skip if zero.		*/		{	n = y[time-lag];			if (y[time] > n)					/* min = min num arrivals */				min = y[time] - n;			else				min = 0; 			binomialPr[0] = 1.0;				/* build the initial binomial prob	*/			for (i = 0; i < n; ++i)				binomialPr[0] *= oneMalpha;			for (i = 1; i <= y[time]-min; ++i)	/* recursions for the rest */			{	den   = (double) i;				comb  = (double) (n+1-i);				comb  = comb / den;				binomialPr[i] = binomialPr[i-1] * ratio * comb;			}			Pyt = 0;			for (i = min, j = y[time] - min; i <= y[time]; ++i, --j)				Pyt += poissonPr[i] * binomialPr[j];					if (min > 0) --min; 			Pytm1 = 0;				for (i = min, j = y[time] - 1 - min; i < y[time]; ++i, --j)				Pytm1 += poissonPr[i] * binomialPr[j];			*pDeriv += Pytm1 / Pyt;		}		++time;	}	*pDeriv -= (double) (*pN - 1);}void LambdaLogLike (long *returnCode, long *y, long *x, long *pN,		 double *plamU, double *plamC, double *scratch, long *pLenScr, double *pLogLike){	long i,j, xySum, maxSum, maxPower;		double *lamCPower, *lamUPower, *factorial,				sum, id, min;		maxPower = (*pLenScr / 3) - 1;			// Check for room	maxSum = 0;	for(i=0; i < *pN; ++ i)	{	sum = x[i]+y[i];		if (sum > maxSum)		{	maxSum = sum;			if (maxSum > maxPower)			/* no room in the inn -> RETURN */			{	*returnCode = -maxSum;				*y = i;				return;			}		}	}	maxPower = maxSum;		/* Set pointers for lookup tables */		lamCPower = scratch;	lamUPower = scratch +   (maxPower+1) ;	factorial = scratch + 2*(maxPower+1) ;		/* Initialize lookup tables */		lamCPower[0] = 1.0; 	lamUPower[0] = 1.0;	factorial[0] = 1.0;	for(i=1; i<=maxPower; ++i)	{	lamCPower[i] = *plamC * lamCPower[i-1];		lamUPower[i] = *plamU * lamUPower[i-1];		id = (double) i;		factorial[i] = id * factorial[i-1];	}		/* Accumulate log likelihood, with lambda terms at start */		id = (double) *pN;	*pLogLike = - id * (*plamC + 2.0 * *plamU);	for(i=0; i<*pN; ++i)	{	sum = 0.0;		if (x[i] < y[i]) min = x[i];		    else   		 min = y[i];		xySum = x[i] + y[i];		for(j = 0; j <= min; ++j)			sum +=  (lamCPower[j] * lamUPower[xySum - 2*j])					/ (factorial[j] * factorial[x[i]-j] * factorial[y[i]-j]);		*pLogLike += log(sum);	}			*returnCode = 0;}		