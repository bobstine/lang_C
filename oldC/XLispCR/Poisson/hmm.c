/*      Hidden Markov C implementation.		15 Jan 95 ... Port to metrowerks.    1 Dec 94 ... Fix initilization bug in SaveMaxPath (max not set).    7 Jun 94 ... Porting for Unix (through 6/13)	5 Jun 94 ... Work on geometric last cell methods.   24 May 94 ... Revise to use new prob code and attempt XLisp connection.    7 May 94 ... Fix the assignment of initial probabilities to use marginal prob.   29 Apr 94 ... Checking, timing, tuning up. Revise max path definition.   28 Apr 94 ... Implement node vector as linked list.   27 Apr 94 ... Created to speed the lisp implementation.   *//* ------------------------------------------------------------------- */#include <stdlib.h>#include <math.h>#include "localmem.h"#include "probability.h"#ifdef _UNIX_#include "probability.c"#include "localmem.c"#endif#ifdef _FILES_#include <stdio.h>#include <math.h>#include "debug.h"#define inputFile   "Chuck:XLisp:RAS Lisp:Poisson:hmm.input"#define outputFile  "Chuck:XLisp:RAS Lisp:Poisson:hmm.output"#endif#define min(A,B) ((A) < (B) ? (A) : (B))/* ------------------------------------------------------------------- */typedef struct Node {	double			prob;				/* Sum_j P(Sj), over all incoming		*/	double			maxPathProb;		/* Max_j P(Sj)							*/	struct Node		*predNode;			/* Argmax P(Sj), in prior node list		*/	struct Node 	*next;				/* next node in same node list 			*/	long 			cells[2];			/* not really 2, just the min number	*/} Node;typedef struct  {	Node *	ptr;			/* ptr to node prior to latest insertion in sorted list	*/	Node *  head;			/* allocation base addr node, first node of sorted list	*/	long 	len;			/* not including head or sentinel ptr					*/} NodeList;/*------------------------------------------*//*		  		 Prototypes  				*//*------------------------------------------*/#ifdef _FILES_	static	void	SetupGlobalsFromFile (char *file);	static	void 	WriteNodeList(NodeList *nlp, char *str);	static	void	WriteMaxPath(NodeList **pathArray, long n);	static	void	WriteNode (Node *np, FILE *fp);	static	void	WriteResults (double ll);#endifstatic	void	AllocateGlobals (void);static	NodeList **AllocatePath (long *yt, long n);static	double	SumOfProb(NodeList *nlp);static	double	AverageArrivals(NodeList *nlp);static	void	SaveMaxPath(NodeList **pathArray, long n, long *dest);static	NodeList* NewNodeList(void);static	void 	FreeNodeList(NodeList *nlp);static	void 	AddInitNode (long *cells, NodeList *nlp);	/* no check for redundant 	*/static	void	AddTransNode (long *cells, NodeList *nlp);	/* combined if present 		*/static	void 	AllocateInteger(long yt, NodeList *nlp);static	void	AllocateNode (Node *node, long yt, NodeList *nlp);static	long	CellOrder (long *cells1, long *cells2);		/* -1 is less, 0 equal, 1 >	*/static  void	AssignInitialProb(NodeList *nlp);static 	double	TransitionProb(long *prior, long *new);/*------------------------------------------*//*		  			Globals    				*//*------------------------------------------*/static long 	N_CELLS;static long 	LAST_CELL;static long 	NODE_SIZE;			/* add for rest of the cells in calls to alloc */static long		*MEMSIZE;static long		NODE_COUNT;			// Used to track number of cells allocatedstatic double	LAMBDA;static double	*EXITPR;			/* list of probs for surviving cells 	*/static double   *MEANS;				/* expected cell means					*/static double	*LIKE;				/* hmm likelihood value					*/static long		*zeroCells;			/* array of zero cells					*/static long		*cellLimit;static long 	*workCells;static double	*ARRIVAL_CDF;		/* table of arrival CDF					*/static long 	CDF_SIZE;static long  	NOBS;				/* data series length and values (long s)	*/static long 	*YT;static long		*DATA;				/* longs from XLisp */void main (void)	//	Dummy stub to satisfy __startup function.{	int i = 1;}//	Hidden Markov codevoid hmm (long *data, long *nObs, double *lambda, double *exitPr, long *nCells,			 double *like, long *memSize, double *arrive);void hmm (long *data, long *nObs, double *lambda, double *exitPr, long *nCells,	double *like, long *memSize, double *arrive){	NodeList **path, *nlp;	Node *np;	long i, calcArrive;	DATA = data;	NOBS = *nObs;	LAMBDA = *lambda;	EXITPR = exitPr;	N_CELLS = *nCells;	LIKE = like;	MEMSIZE = memSize;	NODE_COUNT = 0;	AllocateGlobals ();		if (*arrive > 0.0) calcArrive = 1; else calcArrive = 0;	path = LocalMalloc (NOBS * sizeof(NodeList *));	if (path == NULL)	{*LIKE = -777.77; goto Exit;}	nlp = NewNodeList();	path[0] = nlp;	AllocateInteger(YT[0], nlp);	AssignInitialProb(nlp);	if (calcArrive == 1) *arrive++ = AverageArrivals(nlp); 	for(i=1; i<NOBS; ++i)	{	if (calcArrive == 0)			DATA[i-1] = AvailableLocalMemory();	//	record mem use						path[i] = NewNodeList ();				// init list of nodes at [i]		if (path[i] == NULL)		{	*LIKE = -555.55;			goto Exit;		}		else		{	np = nlp->head->next;				// scan prior node list			while(np->next != NULL)			{	AllocateNode(np, YT[i], path[i]);				np = np->next;			}			nlp = path[i];			if (calcArrive == 1)				*arrive++ = AverageArrivals(nlp) ;		}	}  	if (calcArrive == 0)		{	DATA[0] = NODE_COUNT;					// number of nodes consumed.		DATA[NOBS-1] = AvailableLocalMemory();	// 		record mem use						}	else		SaveMaxPath(path, (long ) NOBS, DATA);	/* put max path into,  reverse order	*/	*MEMSIZE = AvailableLocalMemory();	(*LIKE) = SumOfProb(path[NOBS-1]);	for (i = 1; i<NOBS; ++i)					/* adjust for n-1 transition scaling	*/		(*LIKE) /= 10.0;Exit:	FreeLocalMemory();}/*------------------------------------------*//*		  	Globals and IO		  			*//*------------------------------------------*/static void AllocateGlobals(){	short i;		InitLocalMemory (*MEMSIZE);	CDF_SIZE = 25;	ARRIVAL_CDF = LocalMalloc(CDF_SIZE * sizeof(double));	if (ARRIVAL_CDF == NULL) return;	CalcPoissonCDF (LAMBDA, CDF_SIZE, ARRIVAL_CDF);	LAST_CELL = N_CELLS-1;	NODE_SIZE = sizeof(Node) + (N_CELLS-2)*sizeof(long );	zeroCells = (long *) LocalMalloc (N_CELLS * sizeof(long ));	for (i=0; i<N_CELLS; ++i)		zeroCells[i] = 0;	cellLimit = (long *) LocalMalloc (N_CELLS * sizeof(long ));	workCells = (long *) LocalMalloc (N_CELLS * sizeof(long ));	MEANS     = (double *) LocalMalloc (N_CELLS * sizeof(double));	YT = (long *) LocalMalloc(sizeof(long ) * NOBS);	for(i=0; i<NOBS; ++i)		YT[i] = DATA[i];}#ifdef _FILES_static void SetupGlobalsFromFile (file)char *file;		{	FILE *fp;	long i;		InitLocalMemory (100000);	fp = fopen(file, "r");	fscanf(fp, "lambda = %Lf\n", &LAMBDA);	fscanf(fp, "ncells = %d\n", &N_CELLS);	LAST_CELL = N_CELLS-1;	NODE_SIZE = sizeof(Node) + (N_CELLS-2)*sizeof(long );	CDF_SIZE = 25;	ARRIVAL_CDF = LocalMalloc(CDF_SIZE * sizeof(double));	CalcPoissonCDF (LAMBDA, CDF_SIZE, ARRIVAL_CDF);	EXITPR = (double *) LocalMalloc (N_CELLS * sizeof(double));	for (i=0; i<N_CELLS; ++i)		fscanf(fp, "exitpr = %Lf\n", &EXITPR[i]);	zeroCells = (long *) LocalMalloc (N_CELLS * sizeof(long ));	for (i=0; i<N_CELLS; ++i)		zeroCells[i] = 0;	cellLimit = (long *) LocalMalloc (N_CELLS * sizeof(long ));	workCells = (long *) LocalMalloc (N_CELLS * sizeof(long ));	MEANS     = (double *) LocalMalloc (N_CELLS * sizeof(double));	fscanf(fp, "n = %d\n", &NOBS);	YT = (long *) LocalMalloc(sizeof(long ) * NOBS);	for(i=0; i<NOBS; ++i)		fscanf(fp, "%d", &YT[i]);	fclose(fp);	DATA = LocalMalloc(NOBS * sizeof(long));}static void WriteResults(ll)double ll;{	FILE *fp;	long i;		fp = fopen (outputFile, "w");		fprintf (fp, "lambda = %Lf\n", LAMBDA);		/* echo input */		fprintf (fp, "N_CELLS = %d\n", N_CELLS);		for (i=0; i<N_CELLS; ++i)			fprintf(fp, "exitpr = %Lf\n", EXITPR[i]);		fprintf(fp, "n = %d\n", NOBS);		for (i=0; i<NOBS; ++i)			fprintf(fp, " %d", YT[i]);		fprintf(fp, "\nLogLike = %le\n", ll);	fclose(fp);}#endif/*------------------------------------------*//*		  		 Node Subroutines  			*//*------------------------------------------*/static Node	*sourceNode;		/*  used for backtracking when nodes are added 		*/static NodeList* NewNodeList(){	long i;	NodeList *nlp;	Node     *head, *tail;		nlp = (NodeList *) LocalMalloc (sizeof (NodeList) );	if (nlp == NULL)	return(nlp);	head = (Node *) LocalMalloc(NODE_SIZE);	tail = (Node *) LocalMalloc(NODE_SIZE);	if(head == NULL || tail == NULL)	 	nlp->head = NULL;	else	{	nlp->head = head;	    nlp->ptr  = head;	    head->next = tail;	    tail->next = NULL;	    for(i=0; i<N_CELLS; ++i)			/* mark last node cells	*/	    	tail->cells[i] = -1;	}	nlp->len = 0;	return(nlp);}static void FreeNodeList(NodeList *nlp){		Node *next, *prior;		prior = nlp->head;	next = nlp->head->next;	while(next->next != NULL)	{	free(prior);		prior = next;		next = next->next;	}	free(prior);	free(next);	free(nlp);}static	double	AverageArrivals(NodeList *nlp){	double avg, pSum;	Node *np;		avg = 0.0;	pSum = 0.0;	np = nlp->head->next;	while(np->next != NULL)	{	avg += np->prob * (double) np->cells[0];		pSum += np->prob;		np = np->next;	}	return (avg/pSum);}static	double	SumOfProb(NodeList *nlp){	double result;	Node *np;		result = 0.0;	np = nlp->head->next;	while(np->next != NULL)	{	result += np->prob;		np = np->next;	}	return (result);}static void SaveMaxPath(NodeList **pathArray, long n, long *dest)//  save arrivals associated with max prob path{	double max;	NodeList *nlp;	Node *np, *maxNode;		max = -1.0;								/* initialize max */	nlp = pathArray[n-1];					/* start at last node list, find max cell prob */	np = nlp->head->next;						while (np->next != NULL)	{	if (np->prob > max)		{	maxNode = np;			max = np->prob;		}		np = np->next;	}	/* "Max path prob = %12.10Lf\n", max */	*dest++ = (long) maxNode->cells[0];		/* save the number of arrivals (rev order)	*/	while (--n > 0)	{	maxNode = maxNode->predNode;		*dest++ = (long) maxNode->cells[0];	}}#ifdef _FILES_static void	WriteNode (np, fp)Node *np;FILE *fp;{	long j;		for (j=0; j<N_CELLS; ++j)		fprintf(fp," %4d", np->cells[j]);	fprintf(fp," p = %12.10Lf ", np->prob);	if (np->predNode != NULL)		fprintf(fp," max from %d arrivals.", np->predNode->cells[0]);}static void WriteNodeList(nlp, str)NodeList *nlp;char* str;{	long i=0;	double sum=0.0;	Node *np;	FILE *fp;		fp = fopen(outputFile, "a");	fprintf(fp,"Node vector [%d]: %s\n", nlp->len, str);	np = nlp->head->next;	while(np->next != NULL)	{	fprintf(fp,"\n%2d: ", i++);		WriteNode(np, fp);		sum += np->prob;		np = np->next;	}	fprintf(fp, "\nSum of node pr = %Lf \n", sum);	fprintf(fp, "\n-------------------\n");	fclose(fp);}static void WriteMaxPath(NodeList **pathArray, long n){	double max;	NodeList *nlp;	Node *np, *maxNode;	FILE *fp;		fp = fopen(outputFile, "a");	nlp = pathArray[n-1];	np = nlp->head->next;	while (np->next != NULL)	{	if (np->prob > max)		{	maxNode = np;			max = np->prob;		}		np = np->next;	}	fprintf(fp,"Max path prob = %12.10Lf\n", max);	fprintf(fp,"\nMax path cells (in reverse order from last to first):");	fprintf(fp,"\n %3d: ", n-1);	WriteNode(maxNode,fp);	while (--n > 0)	{	fprintf(fp,"\n %3d: ", n-1);		maxNode = maxNode->predNode;		WriteNode(maxNode,fp);	}	fprintf(fp, "\n");	fclose(fp);}#endifstatic void AddInitNode (long *newCells, NodeList *nlp){	long  i;	Node *last, *np;						/* new cells assumed to arrive in sorted order */		++NODE_COUNT;	np = (Node *) LocalMalloc(NODE_SIZE);	/* alloc new node		*/	np->predNode = NULL;					/* void its pred		*/	for (i=0; i<N_CELLS; ++i)				/* store cells 			*/		np->cells[i] = newCells[i];	last = nlp->ptr;						/* splice into list		*/	np->next = last->next;	last->next = np;	nlp->ptr = np;	++(nlp->len);							/* increment counter	*/}static void AddTransNode (long *newCells, NodeList *nlp){	long  i, pos;	double pathPr;	Node *new, *np, *prior;		pathPr = sourceNode->prob * TransitionProb(sourceNode->cells, newCells);	prior = nlp->ptr;	np = prior->next;	while(np != NULL)	{	pos = CellOrder(newCells, np->cells);	/* cells are kept in sorted order	*/		if (pos < 0)							/* neg means keep going				*/		{	prior = np;			np = np->next;		}		else if (pos == 0)						/* zero implies match & update		*/		{	np->prob += pathPr;			if(pathPr > np->maxPathProb)			{	np->predNode = sourceNode;				np->maxPathProb = pathPr;		/* 	5/1		*/			}			nlp->ptr = prior;			return;		}		else								/* add a new one before this one	*/		{	++NODE_COUNT;			new = (Node *) LocalMalloc(NODE_SIZE);						prior->next = new;			for (i=0; i<N_CELLS; ++i)				new->cells[i] = newCells[i];			new->prob = pathPr;			new->maxPathProb = pathPr;			new->next = np;			new->predNode = sourceNode;			nlp->ptr = prior;			++(nlp->len);			return;		}	}}static long CellOrder(long *cells1, long *cells2)			/* Optimize by unrolling... */{	long i;		for (i=0; i<N_CELLS; ++i)	{	if (cells1[i] < cells2[i])			return(-1);		else if (cells1[i] > cells2[i])			return(1);	}	return(0);}/*------------------------------------------*//*		   Allocation of Integers  			*//*------------------------------------------*/static void		(*insertFunc)(long *, NodeList *);		/* func that stores cell */static NodeList *theNodeList;		/* subroutines */static void 	AllocInt(long yt, long start);	 				/* recursive worker */static void	SetupNodeList (NodeList *, void (*f)());		/* sets up globals */static NodeList **AllocatePath (long *yt, long n){	NodeList **pathArray, *nlp;	Node *np;	long i;		pathArray = LocalMalloc (n * sizeof(NodeList *));		pathArray[0] = nlp = NewNodeList();	AllocateInteger(yt[0], nlp);	AssignInitialProb(nlp);	/*	WriteNodeList(nlp,"Initial allocation");	*/	for(i=1; i<n; ++i)	{	pathArray[i] = NewNodeList ();		if (pathArray[i] != NULL)		{	np = nlp->head->next;			while(np->next != NULL)			{	AllocateNode(np, yt[i], pathArray[i]);				np = np->next;			}			nlp = pathArray[i];		}	}	return(pathArray);}static void AllocateInteger(long yt, NodeList *nlp){	long i;		for(i=0; i<N_CELLS; ++i)			/* init cell limits	*/	 	cellLimit[i] = yt;	SetupNodeList (nlp, AddInitNode);	/* define globals	*/	AllocInt(yt, 0);					/* call recursive helper */}static void AllocateNode (Node *node, long yt, NodeList *nlp){		long i, mt = 0, sum=0;		sourceNode = node;			/* used with transition nodes	*/	nlp->ptr = nlp->head;		/* start looking at the head	*/	for(i=0; i<N_CELLS; ++i)		 	sum += node->cells[i];	cellLimit[0] = yt;			/* init  cell limits			*/	for(i=1; i<N_CELLS; ++i)	{	cellLimit[i] = node->cells[i-1];	}	cellLimit[LAST_CELL] += node->cells[LAST_CELL];	SetupNodeList (nlp, AddTransNode);	if (yt > sum) mt = yt - sum;	workCells[0] = mt;			/* force at least mt into cell zero */	AllocInt(yt-mt,0);}static void SetupNodeList(NodeList *nlp, void (*func)()){	long i;		theNodeList = nlp;	for(i=0; i<N_CELLS; ++i)		workCells[i] = 0;	insertFunc = func;}static void AllocInt(long yt, long start){		long i;		if(yt > 0)	{	for (i=start; i<N_CELLS; ++i)		{	if (workCells[i] < cellLimit[i])	/* room in ith cell */			{	++workCells[i];				AllocInt(yt - 1,i);				--workCells[i];			}		}	} else (*insertFunc)(workCells, theNodeList);}					/*------------------------------------------*//*		Probabilities of Allocations  		*//*------------------------------------------*/static void AssignInitialProb(NodeList *nlp){	Node *np;	long i;	double sum, holdMean, prob, margLam;			holdMean = 0.0;									/* compute mean of input hold dist */	prob = 1.0;	for(i=1; i<N_CELLS; ++i)	{	prob *= EXITPR[i-1];		holdMean += ((double) i) * prob * (1.0 - EXITPR[i]);	}	holdMean +=  prob * EXITPR[LAST_CELL] * 	               ( ((double) N_CELLS) + EXITPR[LAST_CELL] / (1.0-EXITPR[LAST_CELL]));	margLam = LAMBDA * (1.0 + holdMean);	prob = exp(-margLam);	for(i=1; i<=YT[0]; ++i)		prob *= margLam / ((double) i);				/* marginal prob for y_0	*/	MEANS[0] = LAMBDA;	for(i=1; i<N_CELLS; ++i)		MEANS[i] = MEANS[i-1] * EXITPR[i-1];	MEANS[LAST_CELL] /= (1.0 - EXITPR[LAST_CELL]);	/* geometric adj */	sum = LAMBDA;	for (i=1; i<N_CELLS; ++i)		sum += MEANS[i];	for (i=0; i<N_CELLS; ++i)		MEANS[i] /= sum;	np = nlp->head->next;	while ( np->next != NULL)	{	np->prob = prob * MultinomialDens(np->cells, MEANS, N_CELLS);		np->maxPathProb = np->prob;		np = np->next;	}}static 	double	TransitionProb(long *prior, long *new){	long i, nGeo, nBi,low, ct;	double tp, pBi, pGeo, sum;		if(new[0] == 0)		tp = ARRIVAL_CDF[0];	else		tp = ARRIVAL_CDF[new[0]] - ARRIVAL_CDF[new[0]-1];	for(i=1; i<N_CELLS-1; ++i)		tp *= BinomialDens(new[i], prior[i-1], EXITPR[i-1]);	nBi  = prior[LAST_CELL-1];	pBi  = EXITPR[LAST_CELL-1];	nGeo = prior[LAST_CELL];	pGeo = EXITPR[LAST_CELL];	ct = new[LAST_CELL];	if (ct > nGeo)			/* low and high are range on number from	*/		low =ct - nGeo;		/* next to last category that must be chosen */	else low = 0;	sum = 0.0;	for (i = low; i<=min(ct,nBi); ++i)		sum += BinomialDens(i, nBi, pBi) * BinomialDens(ct-i, nGeo, pGeo);	return(10.0 * tp * sum);}