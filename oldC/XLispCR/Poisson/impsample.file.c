/*    Driver to build importance sampler routines.    */#include <stdio.h>#include "probability.h"#include "random.h"#define _debugging_#ifdef _debugging_#include "debug.h"#include "math.h"#endif#define min(A,B) ((A) < (B) ? (A) : (B))/* ----------------------------------------------------------------- */void main(void);void PrintTransition (int *in, int *out, double prob, char *str);double  ImportanceProbMix		(int *yt, int n);double  ImportanceProbMixEach	(int *yt, int n);double	ImportanceProbMixHybrid (int *yt, int n);double  ImportanceProbOne		(int *yt, int n, void transFunc() );void	CalcBiCDFArray (int *inCells);double	TransitionProb(int *prior, int *new);double	ArrivalTransProb	(int in, int *inCells, int out, int *outCells);double	SurvivalTransProb	(int in, int *inCells, int out, int *outCells);double	HyperTransProb		(int in, int *inCells, int out, int *outCells);void	ArrivalTransition (int in, int *inCells, int out, int *outCells, double *sampleProb);void	SurvivalTransition(int, int *, int, int *, double *);void	HyperTransition   (int, int *, int, int *, double *);/* ----------------------------------------------------------------- */static double LAMBDA 		= 4.0 ;							/* 1.0 */static double MARG_PR[10]	= {0.8,0.64,0.512,0.4096,0.32768, 0.262144,0.209715,0,0,0};static double EXIT_PR[10]	= {.8,.8,.8,.8,.8,.8,.8,.8,.8,.8};static double HOLD_MEAN		= 4.0;#define		CDF_SIZE	25#define		N_CELLS		4#define		LAST_CELL	N_CELLS-1static double ARRIVAL_DENS[CDF_SIZE];static double ARRIVAL_CDF[CDF_SIZE];static double BI_CDF[N_CELLS][CDF_SIZE];static int	IN_CELLS[N_CELLS];static int OUT_CELLS[N_CELLS];/* ----------------------------------------------------------------- */#ifdef _debugging_void PrintTransition (in, out, prob, str)int *in, *out;double prob;char *str;{	int i;		printf("Transition %s: ", str);	for (i=0; i<N_CELLS; ++i)		printf("%d ", in[i]);	printf(" ---> ");	for (i=0; i<N_CELLS; ++i)		printf("%d ", out[i]);	printf(" w.p. %lf\n", prob);}#endif/* ------------------------------------------------------- *//* -------------------------------------------------------- *//*				Importance Sampling Routines				*//* -------------------------------------------------------- */double  ImportanceProbMixEach (yt, n)int *yt, n;{	double sampleProb, tp, trueProb, a, h, s;	int i,  *ptr, *old, *new, method;	int j, sumOld, sumNew;	FILE *fp;	//	fp = fopen("Chuck:XLisp:RAS Lisp:Poisson:temp.out", "w");	tp = PoissonDens(*yt, LAMBDA * (1.0 + HOLD_MEAN));	old = IN_CELLS;	new = OUT_CELLS;	MultinomialRand (*yt, EXIT_PR, old, N_CELLS);	for (i=0; i<n-1; ++i)							/* n-1 transitions		*/	{	CalcBiCDFArray(old);		method = floor (3.0 * Uniform());			/* select transition method	*/		switch (method)		{	case 0:	ArrivalTransition(yt[i], old, yt[i+1], new, &a);					h = HyperTransProb(yt[i], old, yt[i+1], new);					s = SurvivalTransProb(yt[i], old, yt[i+1], new);					break;			case 1:	SurvivalTransition(yt[i], old, yt[i+1], new, &s);					a = ArrivalTransProb(yt[i], old, yt[i+1], new);					h = HyperTransProb(yt[i], old, yt[i+1], new);					break;			case 2:	HyperTransition(yt[i], old, yt[i+1], new, &h);					a = ArrivalTransProb(yt[i], old, yt[i+1], new);					s = SurvivalTransProb(yt[i], old, yt[i+1], new);					break;		}#ifdef _debugging_		sumOld = sumNew = 0;		for (j=0; j<N_CELLS; ++j)		{	sumOld += old[j];			sumNew += new[j];		}		if (sumOld != yt[i] || sumNew != yt[i+1])		{	printf("Error %d <> %d or %d <> %d\n", yt[i], sumOld, yt[i+1], sumNew);			Wait();		}#endif		trueProb	= TransitionProb(old, new);		sampleProb	= (a + h + s) / 3.0;		tp *= trueProb / sampleProb;//		fprintf(fp, "%2d: %8.3f  %8.5f  %2d->%2d - %8.5f / (%6.3f = 1/3(%6.3f %6.3f %6.3f))\n",//		         i+1, log(tp), log(trueProb / sampleProb), yt[i], yt[i+1], trueProb, sampleProb, a, h, s);		ptr = old;								/* swap old with new	*/		old = new;		new = ptr;	}//	fclose(fp);	return( tp );}double  ImportanceProbMixHybrid (yt, n)int *yt, n;{	double sampleProb, tp, trueProb, a, h;	int i,  *ptr, *old, *new;	tp = PoissonDens(*yt, LAMBDA * (1.0 + HOLD_MEAN));	old = IN_CELLS;	new = OUT_CELLS;	MultinomialRand (*yt, EXIT_PR, old, N_CELLS);	/* initialization		*/	for (i=0; i<n-1; ++i)							/* n-1 transitions		*/	{	CalcBiCDFArray(old);		if (yt[i+1] < yt[i])						/* use survivor if dec	*/			SurvivalTransition(yt[i], old, yt[i+1], new, &sampleProb);		else										/* mix otherwise		*/		{	if (Uniform() > 0.5)			{	ArrivalTransition(yt[i], old, yt[i+1], new, &a);				h = HyperTransProb(yt[i], old, yt[i+1], new);			} else			{	HyperTransition(yt[i], old, yt[i+1], new, &h);				a = ArrivalTransProb(yt[i], old, yt[i+1], new);			}			sampleProb = (a + h) / 2.0;		}		trueProb = TransitionProb(old, new);		tp *= trueProb / sampleProb;		ptr = old;								/* swap old with new	*/		old = new;		new = ptr;	}	return( tp );}double  ImportanceProbMix (yt, n)int *yt, n;{	double seqProb, seqProb1, seqProb2, tp, sampleProb;	int i,  *ptr, *old, *new, method;	void (*transFunc)(int, int *, int, int *, double *);	double (*altTransProb1)(int, int *, int, int *),		   (*altTransProb2)(int, int *, int, int *);	method = floor (3.0 * Uniform());			/* select transition method	*/	printf("Using method %d\n", method);	switch (method)	{	case 0:	transFunc = ArrivalTransition;				altTransProb1 = SurvivalTransProb;				altTransProb2 = HyperTransProb;			break;		case 1:	transFunc = SurvivalTransition;				altTransProb1 = ArrivalTransProb;				altTransProb2 = HyperTransProb;			break;		case 2:	transFunc = HyperTransition;				altTransProb1 = SurvivalTransProb;				altTransProb2 = ArrivalTransProb;			break;	}	tp = PoissonDens(*yt, LAMBDA * (1.0 + HOLD_MEAN));	seqProb = seqProb1 = seqProb2 = 1.0;	old = IN_CELLS;	new = OUT_CELLS;	MultinomialRand (*yt, EXIT_PR, old, N_CELLS);	for (i=0; i<n-1; ++i)						/* n-1 transitions		*/	{	CalcBiCDFArray(old);		(*transFunc)(yt[i], old, yt[i+1], new, &sampleProb);		tp *= TransitionProb(old, new);		seqProb  *= sampleProb;		seqProb1 *= (*altTransProb1)(yt[i], old, yt[i+1], new);		seqProb2 *= (*altTransProb2)(yt[i], old, yt[i+1], new);		ptr = old;								/* swap old with new	*/		old = new;		new = ptr;	}	printf("tp = %g; Mixing p's %g  %g  %g\n", tp, seqProb, seqProb1, seqProb2);	return(3.0 * tp / (seqProb + seqProb1 + seqProb2));}double  ImportanceProbOne (yt, n, transFunc)int *yt, n;void transFunc(int, int *, int, int *, double *);{	double seqProb, tp, sampleProb;	int i, *ptr, *old, *new;		seqProb = PoissonDens(*yt, LAMBDA * (1.0 + HOLD_MEAN));	old = IN_CELLS;	new = OUT_CELLS;	MultinomialRand (*yt, EXIT_PR, old, N_CELLS);	for (i=0; i<n-1; ++i)						/* n-1 transitions		*/	{	CalcBiCDFArray(old);		transFunc(yt[i], old, yt[i+1], new, &sampleProb);		tp = TransitionProb(old, new);		seqProb *= tp / sampleProb;		ptr = old;								/* swap old with new	*/		old = new;		new = ptr;	}	return(seqProb);}void	CalcBiCDFArray (inCells)int *inCells;{	int i;		inCells[LAST_CELL-1] += inCells[LAST_CELL];	/* sum last two */	for (i=0; i<LAST_CELL; ++i)		if (inCells[i] > 0)			CalcBinomialCDF(inCells[i], EXIT_PR[i], BI_CDF[i]);		else			BI_CDF[i][0] = 1.0;	inCells[LAST_CELL-1] -= inCells[LAST_CELL];}/* -------------------------------------------------------- *//*				Actual Transition Function					*//* -------------------------------------------------------- */static 	double	TransitionProb(prior, new)int *prior, *new;{	int i, nGeo, nBi,low, ct, x;	double tp, pBi, pGeo, sum;		tp = ARRIVAL_DENS[new[0]];	for(i=0; i<LAST_CELL-1; ++i)	{	x = new[i+1];		if (x > 0)			tp *= BI_CDF[i][x] - BI_CDF[i][x-1];		else			tp *= BI_CDF[i][0];	}	nBi  = prior[LAST_CELL-1];	pBi  = EXIT_PR[LAST_CELL-1];	nGeo = prior[LAST_CELL];	pGeo = EXIT_PR[LAST_CELL];	ct = new[LAST_CELL];	if (ct > nGeo)			/* low and high are range on number from	*/		low =ct - nGeo;		/* next to last category that must be chosen */	else low = 0;	sum = 0.0;	for (i = low; i<=min(ct,nBi); ++i)		sum += BinomialDens(i, nBi, pBi) * BinomialDens(ct-i, nGeo, pBi);	return(tp * sum);}////////////////////////////////////////////////////////////////////////////  Importance sampling transition functions assume that the associated//  binomial probabilities have been pre-computed.  These are kept in the//  array BI_CDF.///////////////////////////////////////////////////////////////////////////* -------------------------------------------------------- *//*				Arrival	Transition Function					*//* -------------------------------------------------------- */void ArrivalTransition(yt, inCells, ytp1, outCells, sampleProb)int yt, *inCells, ytp1, *outCells;double *sampleProb;{	double prob;	int need, cell, avail;		need = 0;					/* find minimum number of arrivals		*/	if (ytp1 > yt) need = ytp1-yt;	TruncatedDiscreteSample		(ARRIVAL_CDF, CDF_SIZE, need, ytp1, outCells, sampleProb);	avail = yt - inCells[0];	/* number available in cells after cell */			     need = ytp1 - *outCells++;	/* number that must survive from  t		*/    inCells[LAST_CELL-1] += inCells[LAST_CELL];		/* fixup for last	*/    cell = 0;	while (0 < need)     {	TruncatedDiscreteSample			(BI_CDF[cell], 1+inCells[cell], need-avail, need, outCells, &prob);		*sampleProb *= prob;		need -= *outCells++;		avail -= inCells[++cell];	}	++cell;						/* fill in the rest of the cells with zero	*/	while (cell < N_CELLS)	{	*outCells++ = 0;		++cell;	}    inCells[LAST_CELL-1] -= inCells[LAST_CELL];		/* restore	*/}double	ArrivalTransProb(yt, inCells, ytp1, outCells)int yt, *inCells, ytp1, *outCells;{	double prob;	int need, cell, avail;		need = 0;	if (ytp1 > yt) need = ytp1-yt;	prob = TruncatedDiscreteProb(*outCells, ARRIVAL_CDF, CDF_SIZE, need, ytp1);	avail = yt - inCells[0];		     need = ytp1 - *outCells++;    inCells[LAST_CELL-1] += inCells[LAST_CELL];    cell = 0;	while (0 < need)     {	prob *= TruncatedDiscreteProb(*outCells, BI_CDF[cell], 1+inCells[cell], need-avail, need);		need -= *outCells++;		avail -= inCells[++cell];	}   inCells[LAST_CELL-1] -= inCells[LAST_CELL];		/* fixup for last	*/   return(prob); }/* -------------------------------------------------------- *//*				Survival Transition Function				*//* -------------------------------------------------------- */void SurvivalTransition(yt, inCells, ytp1, outCells, sampleProb)int yt, *inCells, ytp1, *outCells;double *sampleProb;{	double prob;	int cell, atMost;	*sampleProb = 1.0;	if (yt == 0)	{	*outCells++ = ytp1;		for (cell=1; cell< N_CELLS; ++cell)			*outCells++ = 0;	} else	{	outCells = &outCells[LAST_CELL];		/* count from end 		*/		cell = LAST_CELL-1;						/* get from this cell	*/		inCells[cell] += inCells[LAST_CELL];	/* patch the last cell	*/		while (inCells[cell] == 0)				/* find non-empty cell	*/		{	*outCells-- = 0;			-- cell;		}		atMost = ytp1;		while (cell >= 0 && atMost > 0)		{	TruncatedDiscreteSample				(BI_CDF[cell], 1+inCells[cell], 0, atMost, outCells, &prob);			*sampleProb *= prob;			atMost -= *outCells--;			-- cell;		}		if (atMost > 0)			*outCells = atMost;		else while (cell >= -1)					/* outCells are offset */		{	*outCells-- = 0;			-- cell;		}		inCells[N_CELLS-2] -= inCells[LAST_CELL];		/* restore	*/	}}double	SurvivalTransProb(yt, inCells, ytp1, outCells)int yt, *inCells, ytp1, *outCells;{	double prob;	int cell, atMost;	if (yt == 0)		return (1.0);	else	{	prob = 1.0;		outCells = &outCells[LAST_CELL];		/* count from end 		*/		cell = LAST_CELL-1;						/* get from this cell	*/		inCells[cell] += inCells[LAST_CELL];	/* patch the last cell	*/		while (inCells[cell] == 0)				/* find non-empty cell	*/		{	-- cell;			-- outCells;		}		atMost = ytp1;		while (cell >= 0 && atMost > 0)		{	prob *= TruncatedDiscreteProb (*outCells, BI_CDF[cell], 1+inCells[cell], 0, atMost);			atMost -= *outCells--;			-- cell;		}		inCells[LAST_CELL-1] -= inCells[LAST_CELL];		/* restore	*/	}}/* -------------------------------------------------------- *//*				HyperGeo Transition Function				*//* -------------------------------------------------------- */void HyperTransition(yt, inCells, ytp1, outCells, sampleProb)int yt, *inCells, ytp1, *outCells;double *sampleProb;{	int cell, need, nSurvive, haveChosen, haveSeen, leftInCell;	double prob;		if (ytp1 > yt)	need = ytp1-yt;	else 			need = 0;	TruncatedDiscreteSample		(ARRIVAL_CDF, CDF_SIZE, need, ytp1, outCells, sampleProb);	nSurvive = ytp1 - *outCells;	if (nSurvive == yt)						/* all must survive, so just move	*/	{	for(cell=1; cell < N_CELLS; ++cell)			outCells[cell] = inCells[cell-1];		outCells[LAST_CELL] += inCells[LAST_CELL];		return;	}	for (cell=1; cell<N_CELLS; ++cell)		/* init rest to zero			*/		outCells[cell] = 0;	if (nSurvive > 0)						/* select the survivors	using the	*/	{	cell = 0;		leftInCell = inCells[0];			/* sampling method of Knuth			*/		inCells[N_CELLS-2] += inCells[LAST_CELL];			/* fixup last cell	*/		haveSeen = 0; haveChosen = 0;		while (haveChosen < nSurvive)		{	while (leftInCell == 0)			/* find next non-empty cell			*/				leftInCell = inCells[++cell];			if ( ((yt-haveSeen) * Uniform()) < (nSurvive-haveChosen) )			{	++outCells[cell+1];			/* survive from current cell		*/				++haveChosen;			}			++haveSeen;			--leftInCell;		}		prob = HyperDens(outCells, inCells, nSurvive, yt, LAST_CELL);		*sampleProb *= prob;		inCells[N_CELLS-2] -= inCells[LAST_CELL];		/* restore	*/	}}double HyperTransProb(yt, inCells, ytp1, outCells)int yt, *inCells, ytp1, *outCells;{	int need, nSurvive;	double prob;		if (ytp1 > yt)	need = ytp1-yt;	else 			need = 0;	prob = TruncatedDiscreteProb(*outCells, ARRIVAL_CDF, CDF_SIZE, need, ytp1);	nSurvive = ytp1 - *outCells;	if (nSurvive > 0)		prob *= HyperDens(outCells, inCells, nSurvive, yt, LAST_CELL);	return(prob);}/* -------------------------------------------------------- *//*						Main								*//* -------------------------------------------------------- */#define LEN 25void main (){	int i, nReps = 800;	/* int yt[LEN] = {0,2,1,1,2,1,2,2,3,5,3,4,2,0,1,2,3,2,0,0,3,2,3,4,2}; */	int yt[LEN] = {18,21,21,21,17,18,16,12,10,13,15,18,15,17,15,19,13,14,15,18,16,14,14,14,16};	/* int yt[LEN] = {3, 7}; */	double avgMix, s2Mix;	double probMix, probHyb, probA, probH, probS;	FILE *fp;		fp = fopen("Chuck:XLisp:RAS Lisp:Poisson:impSample.out", "w");	fprintf(fp, "(def lambda %lf) \n (def exitpr '(%lf %lf %lf %lf))\n", LAMBDA,					EXIT_PR[0],EXIT_PR[1],EXIT_PR[2],EXIT_PR[3]);	fprintf(fp, "(def yt '(");	for (i=0; i<LEN; ++i)		fprintf(fp, "%d ", yt[i]);	fprintf(fp,"))\n");						InitRandom(0);	CalcPoissonDens(LAMBDA, CDF_SIZE, ARRIVAL_DENS);	CalcPoissonCDF(LAMBDA, CDF_SIZE, ARRIVAL_CDF);		fprintf(fp, "(def imp '(");	avgMix = 0.0; s2Mix = 0.0;	for(i=0; i<nReps; ++i)	{	probA = ImportanceProbOne (yt, LEN, ArrivalTransition);		probH = ImportanceProbOne (yt, LEN, HyperTransition);		probS = ImportanceProbOne (yt, LEN, SurvivalTransition);    	probMix = ImportanceProbMixEach (yt, LEN);    	probHyb = ImportanceProbMixHybrid (yt, LEN);    	fprintf (fp, "(%g  %g   %g %g %g)", probMix, probHyb, probA, probH, probS);    	if (0 == (i % 5))    	{	fprintf (fp, "\n");    		printf ("Hyb %g;   A=%g   H=%g   S=%g \n", probMix, probA, probH, probS);    	}    	avgMix += probMix;    	s2Mix  += probMix * probMix;    }    fprintf(fp, "  ))\n");    fclose(fp);        avgMix /= (double) nReps;    s2Mix = (s2Mix - nReps * avgMix * avgMix) / (nReps - 1);	printf("......... Avg mixing imp prob = %g (%g)\n",    		avgMix, sqrt(s2Mix/(double)nReps)); }	        /*  --------------------  old code  -----------------------        int yt, ytp1;	double hyper, arrive, survive, h2, a2, s2, p1, p2;    yt   = 3;	ytp1 = 5;	arrive = hyper = survive = 0.0;	a2 = h2 = s2 = 0.0;	for (i=0; i<nReps; ++i)	{	MultinomialRand (yt, EXIT_PR, in, N_CELLS);		CalcBiCDFArray(in);		HyperTransition(yt, in, ytp1, out, &p1); 		PrintTransition(in, out, p1, "hyper");		p2= HyperTransProb(yt,in,ytp1,out);		if (p1 != p2)		{	printf("Problem with hyper trans prob, %lf <> %lf\n", p1, p2);			Wait();		} 		p1 = TransitionProb(in, out) / p1;    	hyper += p1;   	h2 += p1 * p1;    	    	ArrivalTransition(yt, in, ytp1, out, &p1); 		PrintTransition(in, out, p1, "arriv"); 		p2 = ArrivalTransProb(yt,in,ytp1,out); 		if (p1 != p2)		{	printf("Problem with arrival trans prob, %lf <> %lf\n", p1, p2);			Wait();		} 		p1 = TransitionProb(in, out) / p1; 		arrive += p1; a2 += p1 * p1; 	        	SurvivalTransition(yt, in, ytp1, out, &p1); 		PrintTransition(in, out, p1, "surv "); 		p2 = SurvivalTransProb(yt,in,ytp1,out);		if (p1 != p2)		{	printf("Problem with survival trans prob, %lf <> %lf\n", p1, p2);			Wait();		} 		p1 = TransitionProb(in, out) / p1; 		survive += p1; s2 += p1 * p1;	}		-----------------------------------------------------------------	*/	