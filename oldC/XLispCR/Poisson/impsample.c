/*    Driver to build importance sampler routines.        NOTE:  project build with 4-byte ints.        1 Jun 94 ... Converted into code resource.    */#include "xlsx.h"#include "probability.h"#include "random.h"#include "math.h"#define min(A,B) ((A) < (B) ? (A) : (B))/*------------------------------------------*//*		  		 Prototypes  				*//*------------------------------------------*/void main (XLSXblock *parms);void PutAddrInA1(void);void SetupGlobals (XLSXblock *parms);double  ImportanceProbMix		(int *yt, int n);double  ImportanceProbMixEach	(int *yt, int n);double	ImportanceProbMixHybrid (int *yt, int n);double  ImportanceProbOne		(int *yt, int n, void transFunc() );void	CalcBiCDFArray (int *inCells);double	TransitionProb(int *prior, int *new);double	ArrivalTransProb	(int in, int *inCells, int out, int *outCells);double	SurvivalTransProb	(int in, int *inCells, int out, int *outCells);double	HyperTransProb		(int in, int *inCells, int out, int *outCells);void	ArrivalTransition (int in, int *inCells, int out, int *outCells, double *sampleProb);void	SurvivalTransition(int, int *, int, int *, double *);void	HyperTransition   (int, int *, int, int *, double *);/*------------------------------------------*//*		  			Globals    				*//*------------------------------------------*/static double LAMBDA;static double HOLDMEAN;static double *EXITPR;#define		CDF_SIZE	25				/* Caution: better not get cell counts > CDF_SIZE */#define		MAX_CELLS	 8static int	N_CELLS;static int LAST_CELL;static double ARRIVAL_DENS[CDF_SIZE];static double ARRIVAL_CDF[CDF_SIZE];static double BI_CDF[MAX_CELLS][CDF_SIZE];static double MARGPR[MAX_CELLS];		/* marginal cell occupancy prob */static int	IN_CELLS[MAX_CELLS];static int OUT_CELLS[MAX_CELLS];/*------------------------------------------*//*		  			Main    				*//*------------------------------------------*/void main (parms)XLSXblock *parms;{	int *yt, i, nObs, nSim, method;	long *data;	double *prob, probMix, probHyb, probA, probH, probS;			asm {	lea main, A0	}		/*  why not push A4, LEA into a4? */	PutAddrInA1();					/*	get stack-based location	*/	asm {	move.l a0,(a1)	}  		/*  save A0 into this location	*/	asm {	move.l a4,-(sp) };		/*	push a4 onto stack			*/		asm {	move.l (a1),a4	};		/*  move local addr to a4		*/	data	=   (long   *) XLSXargv(parms,0);	/*  input data				*/	nObs	= * (long   *) XLSXargv(parms,1);	method  = * (long   *) XLSXargv(parms,5);	/*  which to use			*/	prob	=	(double *) XLSXargv(parms,6);	/*  result to return		*/	nSim	= * (long   *) XLSXargv(parms,7);	/*  number to simulate		*/	yt = (int *) data;	for (i=0; i<nObs; ++i)			/* shift and overwrite as integer */		yt[i] = data[i];		SetupGlobals (parms);	i = 0;	switch(method)	{	case 0:	while (i++ < nSim) *prob++ = ImportanceProbOne (yt, nObs, ArrivalTransition);				break;		case 1:	while (i++ < nSim) *prob++ = ImportanceProbOne (yt, nObs, HyperTransition);				break;		case 2:	while (i++ < nSim) *prob++ = ImportanceProbOne (yt, nObs, SurvivalTransition);				break;		case 3:	while (i++ < nSim) *prob++ = ImportanceProbMixEach (yt, nObs);				break;		case 4:	while (i++ < nSim) *prob++ = ImportanceProbMixHybrid (yt, nObs);				break;		default:;     }	Exit:	asm { move.l (sp)+,a4 }			/*	pop A4 from stack			*/}void SetupGlobals (parms)XLSXblock *parms;{	double sum, prob;	int i;		LAMBDA	= *	(double *) XLSXargv(parms,2);	/*  arrival rate			*/	EXITPR	=   (double *) XLSXargv(parms,3);	/*  vector of exit probs	*/	N_CELLS = * (long   *) XLSXargv(parms,4);	/*  length of exitpr		*/		LAST_CELL = N_CELLS-1;		MARGPR[0] = LAMBDA;						/* compute marginal cell prob */	for(i=1; i<N_CELLS; ++i)		MARGPR[i] = MARGPR[i-1] * EXITPR[i-1];	MARGPR[LAST_CELL] /= (1.0 - EXITPR[LAST_CELL]);			/* geometric adj */	sum = LAMBDA;	for (i=1; i<N_CELLS; ++i)		sum += MARGPR[i];	for (i=0; i<N_CELLS; ++i)		MARGPR[i] /= sum;			HOLDMEAN = 0.0;							/* compute mean of input hold dist */	prob = 1.0;	for(i=1; i<N_CELLS-1; ++i)	{	prob *= EXITPR[i-1];		HOLDMEAN += ((double) i) * prob * (1.0 - EXITPR[i]);	}	HOLDMEAN += prob * EXITPR[LAST_CELL-1] * 	            ((double) N_CELLS) * EXITPR[LAST_CELL] / (1-EXITPR[LAST_CELL]);		InitRandom(0);	CalcPoissonDens(LAMBDA, CDF_SIZE, ARRIVAL_DENS);	CalcPoissonCDF(LAMBDA, CDF_SIZE, ARRIVAL_CDF);}				static void PutAddrInA1 (void){	asm {		bsr.s	@1			;  pushes return addr on stack		dc.l	0			;  store A4 here@1		move.l	(sp)+,a1    ;  pop stack (retrn addr) into a1	}}/* -------------------------------------------------------- *//*				Importance Sampling Routines				*//* -------------------------------------------------------- */double  ImportanceProbMixEach (yt, n)int *yt, n;{	double sampleProb, tp, trueProb, a, h, s;	int i,  *ptr, *old, *new, method;		tp = PoissonDens(*yt, LAMBDA * (1.0 + HOLDMEAN));	old = IN_CELLS;	new = OUT_CELLS;	MultinomialRand (*yt, MARGPR, old, N_CELLS);	for (i=0; i<n-1; ++i)							/* n-1 transitions		*/	{	CalcBiCDFArray(old);		method = floor (3.0 * Uniform());			/* select transition method	*/		switch (method)		{	case 0:	ArrivalTransition(yt[i], old, yt[i+1], new, &a);					h = HyperTransProb(yt[i], old, yt[i+1], new);					s = SurvivalTransProb(yt[i], old, yt[i+1], new);					break;			case 1:	SurvivalTransition(yt[i], old, yt[i+1], new, &s);					a = ArrivalTransProb(yt[i], old, yt[i+1], new);					h = HyperTransProb(yt[i], old, yt[i+1], new);					break;			case 2:	HyperTransition(yt[i], old, yt[i+1], new, &h);					a = ArrivalTransProb(yt[i], old, yt[i+1], new);					s = SurvivalTransProb(yt[i], old, yt[i+1], new);					break;		}		trueProb	= TransitionProb(old, new);		sampleProb	= (a + h + s) / 3.0;		tp *= trueProb / sampleProb;		ptr = old;								/* swap old with new	*/		old = new;		new = ptr;	}	return( tp );}double  ImportanceProbMixHybrid (yt, n)int *yt, n;{	double sampleProb, tp, trueProb, a, h;	int i,  *ptr, *old, *new;	tp = PoissonDens(*yt, LAMBDA * (1.0 + HOLDMEAN));	old = IN_CELLS;	new = OUT_CELLS;	MultinomialRand (*yt, EXITPR, old, N_CELLS);	/* initialization		*/	for (i=0; i<n-1; ++i)							/* n-1 transitions		*/	{	CalcBiCDFArray(old);		if (yt[i+1] < yt[i])						/* use survivor if dec	*/			SurvivalTransition(yt[i], old, yt[i+1], new, &sampleProb);		else										/* mix otherwise		*/		{	if (Uniform() > 0.5)			{	ArrivalTransition(yt[i], old, yt[i+1], new, &a);				h = HyperTransProb(yt[i], old, yt[i+1], new);			} else			{	HyperTransition(yt[i], old, yt[i+1], new, &h);				a = ArrivalTransProb(yt[i], old, yt[i+1], new);			}			sampleProb = (a + h) / 2.0;		}		trueProb = TransitionProb(old, new);		tp *= trueProb / sampleProb;		ptr = old;								/* swap old with new	*/		old = new;		new = ptr;	}	return( tp );}double  ImportanceProbMix (yt, n)int *yt, n;{	double seqProb, seqProb1, seqProb2, tp, sampleProb;	int i,  *ptr, *old, *new, method;	void (*transFunc)(int, int *, int, int *, double *);	double (*altTransProb1)(int, int *, int, int *),		   (*altTransProb2)(int, int *, int, int *);	method = floor (3.0 * Uniform());			/* select transition method	*/	switch (method)	{	case 0:	transFunc = ArrivalTransition;				altTransProb1 = SurvivalTransProb;				altTransProb2 = HyperTransProb;			break;		case 1:	transFunc = SurvivalTransition;				altTransProb1 = ArrivalTransProb;				altTransProb2 = HyperTransProb;			break;		case 2:	transFunc = HyperTransition;				altTransProb1 = SurvivalTransProb;				altTransProb2 = ArrivalTransProb;			break;	}	tp = PoissonDens(*yt, LAMBDA * (1.0 + HOLDMEAN));	seqProb = seqProb1 = seqProb2 = 1.0;	old = IN_CELLS;	new = OUT_CELLS;	MultinomialRand (*yt, EXITPR, old, N_CELLS);	for (i=0; i<n-1; ++i)						/* n-1 transitions		*/	{	CalcBiCDFArray(old);		(*transFunc)(yt[i], old, yt[i+1], new, &sampleProb);		tp *= TransitionProb(old, new);		seqProb  *= sampleProb;		seqProb1 *= (*altTransProb1)(yt[i], old, yt[i+1], new);		seqProb2 *= (*altTransProb2)(yt[i], old, yt[i+1], new);		ptr = old;								/* swap old with new	*/		old = new;		new = ptr;	}	return(3.0 * tp / (seqProb + seqProb1 + seqProb2));}double  ImportanceProbOne (yt, n, transFunc)int *yt, n;void transFunc(int, int *, int, int *, double *);{	double seqProb, tp, sampleProb;	int i, *ptr, *old, *new;		seqProb = PoissonDens(*yt, LAMBDA * (1.0 + HOLDMEAN));	old = IN_CELLS;	new = OUT_CELLS;	MultinomialRand (*yt, EXITPR, old, N_CELLS);	for (i=0; i<n-1; ++i)						/* n-1 transitions		*/	{	CalcBiCDFArray(old);		transFunc(yt[i], old, yt[i+1], new, &sampleProb);		tp = TransitionProb(old, new);		seqProb *= tp / sampleProb;		ptr = old;								/* swap old with new	*/		old = new;		new = ptr;	}	return(seqProb);}void	CalcBiCDFArray (inCells)int *inCells;{	int i;		inCells[LAST_CELL-1] += inCells[LAST_CELL];	/* sum last two */	for (i=0; i<LAST_CELL; ++i)		if (inCells[i] > 0)			CalcBinomialCDF(inCells[i], EXITPR[i], BI_CDF[i]);		else			BI_CDF[i][0] = 1.0;	inCells[LAST_CELL-1] -= inCells[LAST_CELL];}/* -------------------------------------------------------- *//*				Actual Transition Function					*//* -------------------------------------------------------- */static 	double	TransitionProb(prior, new)int *prior, *new;{	int i, nGeo, nBi,low, ct, x;	double tp, pBi, pGeo, sum;		tp = ARRIVAL_DENS[new[0]];	for(i=0; i<LAST_CELL-1; ++i)	{	x = new[i+1];		if (x > 0)			tp *= BI_CDF[i][x] - BI_CDF[i][x-1];		else			tp *= BI_CDF[i][0];	}	nBi  = prior[LAST_CELL-1];	pBi  = EXITPR[LAST_CELL-1];	nGeo = prior[LAST_CELL];	pGeo = EXITPR[LAST_CELL];	ct = new[LAST_CELL];	if (ct > nGeo)			/* low and high are range on number from	*/		low =ct - nGeo;		/* next to last category that must be chosen */	else low = 0;	sum = 0.0;	for (i = low; i<=min(ct,nBi); ++i)		sum += BinomialDens(i, nBi, pBi) * BinomialDens(ct-i, nGeo, pBi);	return(tp * sum);}////////////////////////////////////////////////////////////////////////////  Importance sampling transition functions assume that the associated//  binomial probabilities have been pre-computed.  These are kept in the//  array BI_CDF.///////////////////////////////////////////////////////////////////////////* -------------------------------------------------------- *//*				Arrival	Transition Function					*//* -------------------------------------------------------- */void ArrivalTransition(yt, inCells, ytp1, outCells, sampleProb)int yt, *inCells, ytp1, *outCells;double *sampleProb;{	double prob;	int need, cell, avail;		need = 0;					/* find minimum number of arrivals		*/	if (ytp1 > yt) need = ytp1-yt;	TruncatedDiscreteSample		(ARRIVAL_CDF, CDF_SIZE, need, ytp1, outCells, sampleProb);	avail = yt - inCells[0];	/* number available in cells after cell */			     need = ytp1 - *outCells++;	/* number that must survive from  t		*/    inCells[LAST_CELL-1] += inCells[LAST_CELL];		/* fixup for last	*/    cell = 0;	while (0 < need)     {	TruncatedDiscreteSample			(BI_CDF[cell], 1+inCells[cell], need-avail, need, outCells, &prob);		*sampleProb *= prob;		need -= *outCells++;		avail -= inCells[++cell];	}	++cell;						/* fill in the rest of the cells with zero	*/	while (cell < N_CELLS)	{	*outCells++ = 0;		++cell;	}    inCells[LAST_CELL-1] -= inCells[LAST_CELL];		/* restore	*/}double	ArrivalTransProb(yt, inCells, ytp1, outCells)int yt, *inCells, ytp1, *outCells;{	double prob;	int need, cell, avail;		need = 0;	if (ytp1 > yt) need = ytp1-yt;	prob = TruncatedDiscreteProb(*outCells, ARRIVAL_CDF, CDF_SIZE, need, ytp1);	avail = yt - inCells[0];		     need = ytp1 - *outCells++;    inCells[LAST_CELL-1] += inCells[LAST_CELL];    cell = 0;	while (0 < need)     {	prob *= TruncatedDiscreteProb(*outCells, BI_CDF[cell], 1+inCells[cell], need-avail, need);		need -= *outCells++;		avail -= inCells[++cell];	}   inCells[LAST_CELL-1] -= inCells[LAST_CELL];		/* fixup for last	*/   return(prob); }/* -------------------------------------------------------- *//*				Survival Transition Function				*//* -------------------------------------------------------- */void SurvivalTransition(yt, inCells, ytp1, outCells, sampleProb)int yt, *inCells, ytp1, *outCells;double *sampleProb;{	double prob;	int cell, atMost;	*sampleProb = 1.0;	if (yt == 0)	{	*outCells++ = ytp1;		for (cell=1; cell< N_CELLS; ++cell)			*outCells++ = 0;	} else	{	outCells = &outCells[LAST_CELL];		/* count from end 		*/		cell = LAST_CELL-1;						/* get from this cell	*/		inCells[cell] += inCells[LAST_CELL];	/* patch the last cell	*/		while (inCells[cell] == 0)				/* find non-empty cell	*/		{	*outCells-- = 0;			-- cell;		}		atMost = ytp1;		while (cell >= 0 && atMost > 0)		{	TruncatedDiscreteSample				(BI_CDF[cell], 1+inCells[cell], 0, atMost, outCells, &prob);			*sampleProb *= prob;			atMost -= *outCells--;			-- cell;		}		if (atMost > 0)			*outCells = atMost;		else while (cell >= -1)					/* outCells are offset */		{	*outCells-- = 0;			-- cell;		}		inCells[N_CELLS-2] -= inCells[LAST_CELL];		/* restore	*/	}}double	SurvivalTransProb(yt, inCells, ytp1, outCells)int yt, *inCells, ytp1, *outCells;{	double prob;	int cell, atMost;	if (yt == 0)		return (1.0);	else	{	prob = 1.0;		outCells = &outCells[LAST_CELL];		/* count from end 		*/		cell = LAST_CELL-1;						/* get from this cell	*/		inCells[cell] += inCells[LAST_CELL];	/* patch the last cell	*/		while (inCells[cell] == 0)				/* find non-empty cell	*/		{	-- cell;			-- outCells;		}		atMost = ytp1;		while (cell >= 0 && atMost > 0)		{	prob *= TruncatedDiscreteProb (*outCells, BI_CDF[cell], 1+inCells[cell], 0, atMost);			atMost -= *outCells--;			-- cell;		}		inCells[LAST_CELL-1] -= inCells[LAST_CELL];		/* restore	*/	}}/* -------------------------------------------------------- *//*				HyperGeo Transition Function				*//* -------------------------------------------------------- */void HyperTransition(yt, inCells, ytp1, outCells, sampleProb)int yt, *inCells, ytp1, *outCells;double *sampleProb;{	int cell, need, nSurvive, haveChosen, haveSeen, leftInCell;	double prob;		if (ytp1 > yt)	need = ytp1-yt;	else 			need = 0;	TruncatedDiscreteSample		(ARRIVAL_CDF, CDF_SIZE, need, ytp1, outCells, sampleProb);	nSurvive = ytp1 - *outCells;	if (nSurvive == yt)						/* all must survive, so just move	*/	{	for(cell=1; cell < N_CELLS; ++cell)			outCells[cell] = inCells[cell-1];		outCells[LAST_CELL] += inCells[LAST_CELL];		return;	}	for (cell=1; cell<N_CELLS; ++cell)		/* init rest to zero			*/		outCells[cell] = 0;	if (nSurvive > 0)						/* select the survivors	using the	*/	{	cell = 0;		leftInCell = inCells[0];			/* sampling method of Knuth			*/		inCells[N_CELLS-2] += inCells[LAST_CELL];			/* fixup last cell	*/		haveSeen = 0; haveChosen = 0;		while (haveChosen < nSurvive)		{	while (leftInCell == 0)			/* find next non-empty cell			*/				leftInCell = inCells[++cell];			if ( ((yt-haveSeen) * Uniform()) < (nSurvive-haveChosen) )			{	++outCells[cell+1];			/* survive from current cell		*/				++haveChosen;			}			++haveSeen;			--leftInCell;		}		prob = HyperDens(outCells, inCells, nSurvive, yt, LAST_CELL);		*sampleProb *= prob;		inCells[N_CELLS-2] -= inCells[LAST_CELL];		/* restore	*/	}}double HyperTransProb(yt, inCells, ytp1, outCells)int yt, *inCells, ytp1, *outCells;{	int need, nSurvive;	double prob;		if (ytp1 > yt)	need = ytp1-yt;	else 			need = 0;	prob = TruncatedDiscreteProb(*outCells, ARRIVAL_CDF, CDF_SIZE, need, ytp1);	nSurvive = ytp1 - *outCells;	if (nSurvive > 0)		prob *= HyperDens(outCells, inCells, nSurvive, yt, LAST_CELL);	return(prob);}