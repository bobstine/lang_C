/*	dtw.c	20 Apr 92 ... Serious debugging effort spots uninit pointer.	 4 Apr 92 ... Add other sorts of path finders, without so many constraints.	31 Mar 92 ... Modify to use sym/asymm weights and time map.	 5 Mar 92 ... More flexible path weights.	21 Feb 92 ... Allow path weights.	 5 Dec 91 ... Port to Unix/Mac combination.	 6 Aug 91 ... Add time mapping routine;install dispatcher and time map..	31 Jul 91 ... Modify for use as code resource in XLisp.	15 Jan 91 ... Modify BuildTable after fatal loss of files.	27 Dec 90 ... Convert to enhance S calls		 6 Dec 90 ... Finally happy with FillBounds.	 3 Dec 90 ... Created.*/#include "xlsx.h"#ifdef _MACXLISP_		/* Mac environ	*/#include "mem.h"#else					/* Unix world	*/#include <stdlib.h>#endif/*	___________________  Data Structure  ___________________________ */typedef struct DTWData	{				/*  _____  from XLisp  _____  */					long	nInUse;						/* input data length			*/		double 	*X, *Y;						/* pointers to input data 		*/		long    symDTW, symMap;				/* symmetric DTW weights, map	*/		long    maxPathLength;				/* length of given paths		*/		long  	*pathLength;				/* length of dtw route			*/		long    *pathX, *pathY;				/* integer paths of dtw 		*/		double  timeStart, timeIncr;		/* times for input data			*/		double  *dtwDist;					/* final time warp distance		*/		double  *mapOfTime;					/* mapped input times			*/											/*   to either Y time or common	*/											/*   time scale used in average.*/			/*___  internal use  ___*/				long 	*lowerBound, *upperBound;	/* index into X,Y 				*/		double 	**distArray;				/* min distances 				*/		long	**prodArray;				/* minizing productions 		*/			} DTWData;	#ifdef _MACXLISP_	   void main 		(XLSXblock *parms);  	/*  DEBUG:  dtwMain */static void DoDTW     	(XLSXblock *parms);static void DoTimeMap 	(XLSXblock *parms);static void DoAverage	(XLSXblock *parms);#else       /* Unix world */static void DoDTW (int *nInUse, double *X, double *Y,	long *symDTW, long *symMap,	int *maxPathLength, int *pathX, int *pathY, int *pathLength,	double *inputDist, double *dtwDist,	double *timeStart, double *timeIncr, double *timeMap);static void DoTimeMap (double *ts, double *ti, int *len, double *map,	int *newLen, double *newX);static void DoAverage (double *X, double *Y, double *timeStart, double *timeIncr, 						long *pathX, long *pathY, long *pathLength,						double *commonTime, double *average);#endif/* ________________________ Local definitions __________________________ */#define INFINITY	1E100#define BORDER		3#define Sqr(x)	((x)*(x))#define D(x,y)  distArray[x][BORDER+(y)]	/*  Component symDTW used to select the path finding algorithm.	*/	/*  The codes are												*/	#define HC_ASYM	0	/*	highly constrained,	asym		*/#define HC_SYM	1	/* 						symmetric	*/#define NC_ASYM	10	/*  no constraints,		asym		*/#define NC_SYM	11	/*  					symmetric	*/#define SC_ASYM 20	/*	some constraints,  	asym		*/#define SC_SYM	21	/*						symmetric	*/	/*	Local stages of the algorithm, each may make use of these symbols	*/	/*	to determine the type of allocation, for example, that is required.	*/	static void AllocateData  		(DTWData *data);static void DisposeData   		(DTWData *data);static void FillBounds    		(DTWData *data);static void InitDistancesAndProd(DTWData *data);static void FindPath      		(DTWData *data);static void MapXToYTime   		(DTWData *dtwData);static void CalcDTW       		(DTWData *data);/*  _________________  Function called from Mac XLisp  ________________________ */	/* 	This is the dispatcher routine: 		The first argument in the block from Lisp passes the 		parameter block to the following routines:				(0)  Given two real series, X and Y of common length,		     find the DTW to min separation of the two series.			 		(1)  Given a dtw time map, map times on the X scale to		     the corresponding y scale.  Map done in place over			 input times, which must be in ascending order.	*/	#ifdef _MACXLISP_	void main (parms)			/*   DEBUG: rename to dtwMain	*/XLSXblock *parms;{	long *code;		code = (long *) XLSXargv(parms,0);	switch (*code)	{	case 0: DoDTW(parms);				break;		case 1: DoTimeMap (parms);				break;		case 2: DoAverage (parms);				break;		default:(*code) = -9;	}}void DoDTW (parms)XLSXblock *parms;{	long t, offset;	double dist, *inputDist, *dtwDist;	DTWData dtwData;		/* Decode parm block */		dtwData.nInUse 			= *(long *)   XLSXargv(parms,1);	dtwData.X 				=  (double *) XLSXargv(parms,2);	dtwData.Y 				=  (double *) XLSXargv(parms,3);	dtwData.symDTW      	= *(long *)   XLSXargv(parms,4);	dtwData.symMap	     	= *(long *)   XLSXargv(parms,5);	dtwData.maxPathLength	= *(long *)   XLSXargv(parms,6);	dtwData.pathX  			=  (long *)   XLSXargv(parms,7);	dtwData.pathY  			=  (long *)   XLSXargv(parms,8);	dtwData.pathLength	    =  (long *)	  XLSXargv(parms,9);	inputDist				=  (double *) XLSXargv(parms,10);	dtwData.dtwDist			=  (double *) XLSXargv(parms,11);	dtwData.timeStart       = *(double *) XLSXargv(parms,12);	dtwData.timeIncr        = *(double *) XLSXargv(parms,13);	dtwData.mapOfTime		=  (double *) XLSXargv(parms,14);							/* just the length of X */	#else /* UNIX world */void DoDTW (nInUse, X, Y, symDTW, symMap,	maxPathLength, pathX, pathY, pathLength,	inputDist, dtwDist, timeStart, timeIncr, timeMap)int *nInUse, *symDTW, *symMap, *maxPathLength, *pathX, *pathY, *pathLength;double *X, *Y, *inputDist, *dtwDist, *timeStart, *timeIncr, *timeMap;{	long t, offset;	double dist;	DTWData dtwData;		/* Decode parameters into data structure */		dtwData.nInUse 			= * nInUse;	dtwData.X 				=  X;	dtwData.Y 				=  Y;	dtwData.symDTW			= *symDTW;	dtwData.symMap			= *symMap;	dtwData.maxPathLength	= *maxPathLength;	dtwData.pathX  			=  pathX;	dtwData.pathY  			=  pathY;	dtwData.pathLength	    =  pathLength;	dtwData.dtwDist			=  dtwDist;	dtwData.timeStart       = *timeStart;	dtwData.timeIncr        = *timeIncr;	dtwData.mapOfTime		=  timeMap;#endif		/*  Compute the initial squared distance  */	dist = 0.0;	for (t=0; t<dtwData.nInUse; ++t) 		dist += Sqr(dtwData.X[t] - dtwData.Y[t]); 	*inputDist = dist;		/*  Allocate space in the DTW structure and pass to subs */			AllocateData (&dtwData);	CalcDTW(&dtwData);			/* fills dtwDist and paths */	DisposeData(&dtwData); 	}#ifdef _MACXLISP_void DoTimeMap (parms)XLSXblock *parms;{	double timeStart, timeIncr, *map, *newX, lastTime;	long mapLength, newXLength;	long newXIndex, mapIndex;	double last, num, den, diff, tableLo, tableHi;		/* Decode parm block */		timeStart  = *(double *) XLSXargv(parms,1);	/* starting data time 		*/	timeIncr   = *(double *) XLSXargv(parms,2);	/* increment in dtw data 	*/	mapLength  = *(long   *) XLSXargv(parms,3); /* length of next vector    */	map        =  (double *) XLSXargv(parms,4);	/* mapped = spaced x->y time*/	newXLength = *(long   *) XLSXargv(parms,5); /* number of times to map   */	newX       =  (double *) XLSXargv(parms,6); /* new times to map to y    */#elsevoid DoTimeMap (ts, ti, len, map, newLen, newX)int *len, *newLen;double *ti, *ts, *map, *newX;{	double timeStart, timeIncr, lastTime;	int mapLength, newXLength;	int newXIndex, mapIndex;	double num, den, diff, tableLo, tableHi;		/* Decode parm block */		timeStart  = *ts;		/* starting data time 		*/	timeIncr   = *ti;		/* increment in dtw data 	*/	mapLength  = *len ; 	/* length of time map       */	newXLength = *newLen; 	/* number of times to map   */#endif	newXIndex = 0;	while (newXIndex<newXLength)	{	if (*newX >= timeStart)	/* time is past first in table */			break;			else					/* time is earlier than first in table */		{	*newX++ ;			/* so just leave these alone (in situ) */			++newXIndex;								}	}	lastTime = timeStart + timeIncr*(mapLength);    /* map corresponds to   =  */	tableLo = timeStart; 							/* = spaced data, so build */	tableHi = timeStart + timeIncr;	mapIndex=1;	while (newXIndex<newXLength)	{	if (mapIndex == mapLength || *newX > lastTime)			{	/* out of table or past end of map */			break;		}		if (*newX < tableHi)	/* got 'em */		{	den  = timeIncr;			num  = tableHi - *newX;			diff = map[mapIndex]-map[mapIndex-1];			*newX++ = map[mapIndex] - (num/den)*diff;			++newXIndex;		} else  /* look in the next interval */		{	++mapIndex;			tableLo = tableHi;			tableHi += timeIncr;		}	}	/*  dont need further since done in place */}#ifdef _MACXLISP_/*	The map component of dtwData must be twice the length of expanded path.			*//*  On conclusion, map is filled with the time and time average of the two inputs.	*//*  The procedure is entirely symmetric on the common average scale.				*/void DoAverage (parms)XLSXblock *parms;{	double *timeStart, *timeIncr, *X, *Y, *commonTime, *average;	long *pathX, *pathY, *pathLength;	long    pIndex;	double  halfIncr;		/* Decode parm block */		timeStart  	=  (double *) XLSXargv(parms,1);	/* starting data time 		*/	timeIncr   	=  (double *) XLSXargv(parms,2);	/* increment in dtw data 	*/	X  			=  (double *) XLSXargv(parms,3);	/* data vector			    */	Y        	=  (double *) XLSXargv(parms,4);	/* data vector				*/	pathX		=  (long   *) XLSXargv(parms,5); 	/* dtw path on X			*/	pathY      	=  (long   *) XLSXargv(parms,6);	/* dtw path on y    		*/	pathLength	=  (long   *) XLSXargv(parms,7);	commonTime	=  (double *) XLSXargv(parms,8);	/* returned common times	*/	average		=  (double *) XLSXargv(parms,9);	/* returned averages		*/#else	/* UNIX world */static void ComputeAverage(timeStart, timeIncr, X, Y, pathX, pathY, pathLength,							 commonTime, average)double *timeStart, *timeIncr, *X, *Y, *commonTime, *average;long *pathX, *pathY, *pathLength;{	long    pIndex;	double  halfIncr;#endif			halfIncr    =  0.5 * (*timeIncr);	*commonTime++ = *timeStart;				/* init the time averages */	*average++    = (*X + *Y) / 2.0;		pIndex = 1;								/* path in correct order from Lisp */		while (pIndex < *pathLength)	{	*commonTime = *(commonTime-1);		/* what it was plus half for each change */		if (pathX[pIndex] != pathX[pIndex-1])		{	*commonTime   += halfIncr;			X++;		}		if (pathY[pIndex] != pathY[pIndex-1])		{	*commonTime   += halfIncr;			Y++;		}		++commonTime;		*average++ = (*X + *Y) / 2.0;		++pIndex;	}}/* _________________________  Local functions  ________________________________ *//*	These are the productions used to mark how the algorithm reached a specific *//*	site in the distance array.													*/#define DIAGUPPROD		0			/* diag, then up	*/#define DIAGPROD 		1			/* diag				*/#define DIAGRIGHTPROD	2			/* diag, then right	*/#define RIGHTPROD		3			/* right	 		*/#define UPPROD			4			/* up				*/#define	RRPROD			5			/* right, right		*/#define UUPROD			6			/* up, up			*/#define UPDPROD			10			/* up & diagonal;  these two used at startup */#define UPDUPPROD		11			/* up, diag, up  	*/#define HALT			77			/* stop the process */static void AllocateData(dtwData)DTWData *dtwData;{	long    i, inLen;	long    **prodArray;				double  **distArray;		inLen = dtwData->nInUse;			/* allocate production array */	prodArray  = (long **) AllocateVec(inLen, sizeof(long *));	for (i=0; i<inLen; ++i)		prodArray[i] = (long *) AllocateVec(inLen, sizeof(long));	dtwData->prodArray = prodArray;		dtwData->lowerBound = nil;	dtwData->upperBound = nil;		switch (dtwData->symDTW)	{	case HC_SYM:		case HC_ASYM:				dtwData->lowerBound = (long *) AllocateVec(inLen, sizeof(long));				dtwData->upperBound = (long *) AllocateVec(inLen, sizeof(long));		case SC_SYM:		case SC_ASYM:				distArray  = (double **) AllocateVec (inLen, sizeof(double *));				for (i=0; i<inLen; ++i)				{	distArray[i] = (double *) AllocateVec ((inLen+2*BORDER), sizeof(double));				}				dtwData->distArray = distArray;				break;						case NC_SYM:		case NC_ASYM:				distArray    = (double **) AllocateVec(1, sizeof(double *));				distArray[0] = (double *)  AllocateVec(inLen, sizeof(double)); /* no BORDER */				dtwData->distArray = distArray;				break;	}			}static void DisposeData(dtwData)DTWData *dtwData;{	long i;						/* free ((void *) <-> DisposPtr ((Ptr) */		/* dispose of production array */	for (i=0; i<dtwData->nInUse; ++i)		FreeVec ((char *) dtwData->prodArray[i]);	FreeVec ((char *) dtwData->prodArray );	switch (dtwData->symDTW)	{	case HC_SYM :		case HC_ASYM:			FreeVec ((char *) dtwData->lowerBound );				FreeVec ((char *) dtwData->upperBound );		case SC_SYM :		case SC_ASYM:			for (i=0; i<dtwData->nInUse; ++i)				FreeVec ((char *) dtwData->distArray[i]);			FreeVec ((char *) dtwData->distArray );			break;					case NC_SYM :		case NC_ASYM:			FreeVec ((char *) dtwData->distArray[0]);			FreeVec ((char *) dtwData->distArray );			break;	}}static void CalcDTW (dtwData)DTWData *dtwData;{	long	y, time, prod,n;	double	d[7], curr, halfCurr, save;	double  **distArray, *X, *Y, *distCol;	long	**prodArray;		distArray = dtwData->distArray;	prodArray = dtwData->prodArray;	n = dtwData->nInUse;	X = dtwData->X;	Y = dtwData->Y;			if ((dtwData->symDTW == HC_SYM) || (dtwData->symDTW == HC_ASYM))	{	FillBounds(dtwData);				/* of the distance array 	*/		InitDistancesAndProd(dtwData);		/* not needed for NC cases 	*/	}		/* --- main loop to fill distance array --- */	switch (dtwData->symDTW)	{		case HC_SYM:			for (time=2; time<n; ++time)		 		for (y =LongIndex(dtwData->lowerBound,time);		 			 y<=LongIndex(dtwData->upperBound,time); ++y)				{ 	curr = Sqr(X[time]-Y[y]);					halfCurr = curr / 2.0;					d[DIAGPROD]  	 = D(time-1,y-1) + curr;							d[DIAGUPPROD]    = D(time-1,y-2) + halfCurr													  + Sqr(X[time]-Y[y-1]);					d[DIAGRIGHTPROD] = D(time-2,y-1) + halfCurr													  + Sqr(X[time-1]-Y[y]);						if (d[DIAGPROD] < d[DIAGUPPROD]) prod = DIAGPROD;					else		     			 	 prod = DIAGUPPROD;					if (d[DIAGRIGHTPROD]< d[prod])   prod = DIAGRIGHTPROD;						D(time, y) = d[prod];					LongMatAssign(prodArray, time, y, prod);				}			*dtwData->dtwDist = d[prod];		/* final is total distance */			break;				case HC_ASYM:			for (time=2; time<n; ++time)		/*  integrate versus X */	 			for (y=dtwData->lowerBound[time]; y<=dtwData->upperBound[time]; ++y)				{	curr = Sqr(X[time]-Y[y]);					d[DIAGPROD] 	=D(time-1,y-1)+curr;							d[DIAGUPPROD]   =D(time-1,y-2)+(Sqr(X[time]-Y[y-1]+curr))/2.0;					d[DIAGRIGHTPROD]=D(time-2,y-1)+Sqr(X[time-1]-Y[y])+curr;						if (d[DIAGPROD] < d[DIAGUPPROD]) prod = DIAGPROD;					else		     			 	 prod = DIAGUPPROD;					if (d[DIAGRIGHTPROD]< d[prod])   prod = DIAGRIGHTPROD;						D(time, y) = d[prod];					LongMatAssign(prodArray, time, y, prod);				}			*dtwData->dtwDist = d[prod];		/* final is total distance */			break;					case NC_SYM:		case NC_ASYM:			distCol = *distArray;			DoubleVecAssign(distCol, 0, Sqr(X[0]-Y[0]));			prodArray[0][0] = HALT;			/* initialize distance column with all up moves */			for (y = 1; y < n; ++y)			{	DoubleVecAssign(distCol, y ,distCol[y-1] + .5 * Sqr(X[0]-Y[y]));				LongMatAssign(prodArray, 0, y, UPPROD);			}			for (time = 1; time < n; ++time)			{	LongMatAssign(prodArray,time,0,RIGHTPROD);				save = distCol[0];	/* save = D(t-1, y-1), except for first */				DoubleVecAssign(distCol, 0, distCol[0] + .5 * Sqr(X[time]-Y[0]));				LongMatAssign(prodArray,time,0,RIGHTPROD);				for (y = 1; y < n; ++y)				{	curr = Sqr(X[time]-Y[y]);		/* Overwrite dist column:		*/					halfCurr = curr / 2.0;					d[DIAGPROD]  = curr     + save;	/* dist at three predecessors	*/					d[RIGHTPROD] = halfCurr + distCol[y];					d[UPPROD]    = halfCurr + distCol[y-1];						if (d[DIAGPROD] < d[UPPROD])	/* Which pred has smallest dist	*/							prod = DIAGPROD;					else	prod = UPPROD;					if (d[RIGHTPROD]< d[prod])							prod = RIGHTPROD;						save = distCol[y];				/* save the prior D(i,j)		*/					DoubleVecAssign(distCol,y,d[prod]);/* write the new distance		*/					LongMatAssign(prodArray,time,y,prod);				}			}			*dtwData->dtwDist = distCol[n-1];		/* final is total distance */			break;	}	/* switch */		FindPath(dtwData);	MapXToYTime (dtwData);}static void FillBounds(dtwData)DTWData *dtwData;{	long i, lower, half, add, nm1;		nm1 = dtwData->nInUse - 1;	half = 2 * (nm1 / 3);		/* limit of 1/2 growth rate */		/* handle slow growth */	for (i=0,lower=-1, add=1; i<= half; ++i)	{	lower += add;		dtwData->lowerBound[i]     = lower;		dtwData->upperBound[nm1-i] = nm1-lower;		add = ! add;	}	/* transition to fast growth -- depends on n-1 mod 3 */	half = half+1;	lower += 2 -  nm1 % 3;	LongVecAssign(dtwData->lowerBound,half,lower);	LongVecAssign(dtwData->upperBound,nm1-half,nm1-lower);	/* fast growth to polong at n-1,n-1 */	for (i=half+1; i< dtwData->nInUse; ++i)	{	lower += 2;		LongVecAssign(dtwData->lowerBound,i    ,lower     );		LongVecAssign(dtwData->upperBound,nm1-i, nm1-lower);	}	}static void InitDistancesAndProd(dtwData)DTWData *dtwData;{	double temp;	long x,y;	double *X, *Y;		X = dtwData->X;	Y = dtwData->Y;	for (x=0; x<dtwData->nInUse; ++x)	{	for (y=dtwData->lowerBound[x]-BORDER; y<dtwData->lowerBound[x]; ++y)			dtwData->D(x,y) = INFINITY;		for (y=dtwData->upperBound[x]+1; y<=dtwData->upperBound[x]+BORDER; ++y)			dtwData->D(x,y) = INFINITY;	}		temp = Sqr(X[0]-Y[0]);		dtwData->distArray[0][BORDER+0] = temp;	dtwData->distArray[0][BORDER+1] = temp + Sqr(X[0]-Y[1]);  /* never go here */		dtwData->distArray[1][BORDER+0] = temp + Sqr(X[1]-Y[0]);	dtwData->distArray[1][BORDER+1] = temp + Sqr(X[1]-Y[1]);	dtwData->distArray[1][BORDER+2] = temp + Sqr(X[0]-Y[1]) + Sqr(X[1]-Y[2]);	dtwData->prodArray[0][0] = -1;			/* no production			*/	dtwData->prodArray[1][0] =  RIGHTPROD;	/* go right 				*/	dtwData->prodArray[1][1] =  DIAGPROD;	/* diagonal production 		*/	dtwData->prodArray[1][2] =  UPDPROD;	/* up and diagonal 			*/}static void FindPath(dtwData)DTWData *dtwData;{	long time, x,y;	long *pathX, *pathY;	long **prodArray;		pathX = dtwData->pathX;	pathY = dtwData->pathY;	prodArray = dtwData->prodArray;		time = 0;	x = dtwData->nInUse-1; pathX[time] = x;		/* Zero origin */	y = dtwData->nInUse-1; pathY[time] = y;	while (x != 0) 	{	time +=1;		switch(prodArray[x][y])		{		case DIAGPROD:	x -= 1; y -= 1;						pathX[time] = pathX[time-1]-1;					  	pathY[time] = pathY[time-1]-1;					  	break;					  			case DIAGUPPROD:x -= 1; y -= 2;						pathX[time] = pathX[time-1];					  	pathY[time] = pathY[time-1]-1;					  	time += 1;					  	pathX[time] = pathX[time-1]-1;					  	pathY[time] = pathY[time-1]-1;					  	break;					  			case DIAGRIGHTPROD:						x -= 2; y -= 1;						pathX[time] = pathX[time-1]-1;					  	pathY[time] = pathY[time-1];					  	time += 1;					  	pathX[time] = pathX[time-1]-1;					  	pathY[time] = pathY[time-1]-1;					  	break;					  			case UPDPROD:	x -= 1; y -= 2;						pathX[time] = pathX[time-1]-1;					  	pathY[time] = pathY[time-1]-1;					  	time += 1;					  	pathX[time] = pathX[time-1];					  	pathY[time] = pathY[time-1]-1;					  	break;					  			case UPDUPPROD:	x -= 1; y -= 3;						pathX[time] = pathY[time-1];					  	pathY[time] = pathY[time-1]-1;					  	time += 1;					  	pathX[time] = pathX[time-1]-1;					  	pathY[time] = pathY[time-1]-1;					  	time += 1;					  	pathX[time] = pathX[time-1];					  	pathY[time] = pathY[time-1]-1;					  	break;					  			case RIGHTPROD:	x -= 1;						pathX[time] = pathX[time-1]-1;						pathY[time] = pathY[time-1];						break;					  			case UPPROD:	y -= 1;						pathX[time] = pathX[time-1];						pathY[time] = pathY[time-1]-1;						break;								case RRPROD:	x -= 2;						pathX[time] = pathX[time-1]-1;						pathY[time] = pathY[time-1];						time += 1;						pathX[time] = pathX[time-1]-1;						pathY[time] = pathY[time-1];						break;								case UUPROD:	y -= 2;						pathX[time] = pathX[time-1];						pathY[time] = pathY[time-1]-1;						time += 1;						pathX[time] = pathX[time-1];						pathY[time] = pathY[time-1]-1;						break;		}	}		/* while */	*(dtwData->pathLength) = time+1;}static void MapXToYTime(dtwData)DTWData *dtwData;{	double timeStart, timeIncr;	long    dataLen, pathLength, *pathX, *pathY, tIndex, pIndex;	double *mapX, timeAtX;	long 	symmetric;	double timeIncr50, timeIncrm1;		dataLen		= dtwData->nInUse;	symmetric	= dtwData->symMap;	timeStart   = dtwData->timeStart;	timeIncr    = dtwData->timeIncr;		pathLength 	= *dtwData->pathLength;	pathX   	= dtwData->pathX;	pathY   	= dtwData->pathY;	mapX		= dtwData->mapOfTime;	mapX[0] = timeStart;		/* force ends of time map to be extremes */		switch (dtwData->symDTW)	{			case HC_SYM:		case HC_ASYM:			if (dtwData->symMap == 1)			{	timeIncr50  =  1.0 * timeIncr;				timeIncrm1  = -0.5 * timeIncr;			} else			{	timeIncr50  =  0.5 * timeIncr;				timeIncrm1  =  0.0 * timeIncr;			}			pIndex = pathLength-2;						/* path in reverse order */			if (pathX[pIndex] == pathX[pIndex+1]) 		/* pair of x's start */				--pIndex;			tIndex = 1;									/* table row to be filled */			while (tIndex < dataLen)			{											/* output scale depends on ties	*/				if (pathX[pIndex] == pathX[pIndex-1])		/* tie on x */				{ mapX[tIndex++] = timeStart+timeIncr50+pathY[pIndex]*timeIncr;				  pIndex -= 2;				}				else if (pathY[pIndex] == pathY[pIndex-1])	/* tie on y */				{ mapX[tIndex++] = timeStart+timeIncrm1+pathY[pIndex]*timeIncr;					  pIndex -= 1;				}				else										/* distinct */				{ mapX[tIndex++] = timeStart + pathY[pIndex] * timeIncr;					  pIndex -= 1;				}			}			break;					case NC_SYM:		case NC_ASYM:			timeIncr50  =  0.5 * timeIncr;			mapX[dataLen-1] = timeStart + (dataLen-1) * timeIncr;			*mapX++ = timeStart;				/* map origin to origin & end to end */						pIndex = pathLength - 1;			/* find first non-zero pathX	*/			while (pathX[pIndex] == 0)			/* noting path in reverse order	*/				--pIndex;							tIndex = 1;							/* have done the ends			*/			while (tIndex < dataLen-1)			/* at least one match at time..	*/			{	timeAtX = timeStart + pathY[pIndex] * timeIncr;				--pIndex;						/* are there more matches?		*/				while (pathX[pIndex] == tIndex) /* count the X's at tIndex		*/				{	timeAtX += timeIncr50;					--pIndex;				}				*mapX++ = timeAtX;				/* insert in time map			*/				++tIndex;			}			break;	}		     }