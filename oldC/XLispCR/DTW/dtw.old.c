/*	dtw.c	 4 Apr 92 ... Add other sorts of path finders, without so many constraints.	31 Mar 92 ... Modify to use sym/asymm weights and time map.	 5 Mar 92 ... More flexible path weights.	21 Feb 92 ... Allow path weights.	 5 Dec 91 ... Port to Unix/Mac combination.	 6 Aug 91 ... Add time mapping routine;install dispatcher and time map..	31 Jul 91 ... Modify for use as code resource in XLisp.	15 Jan 91 ... Modify BuildTable after fatal loss of files.	27 Dec 90 ... Convert to enhance S calls		 6 Dec 90 ... Finally happy with FillBounds.	 3 Dec 90 ... Created.*/#include "xlsx.h"#ifdef _MACXLISP_#include "memory.h"#else		/* Unix world */#include <stdlib.h>#define  NewPtr     malloc#define  Ptr        void *#define  DisposPtr  free#endif/*	___________________  Data Structure  ___________________________ */typedef struct DTWData	{				/*  _____  from XLisp  _____  */					long	nInUse;						/*  input data length			*/		double 	*X, *Y;						/*  pointers to input data 		*/		long    symDTW, symMap;				/*  symmetric DTW weights, map	*/		long    maxPathLength;				/*  length of given paths		*/		long  	*pathLength;				/*  length of dtw route			*/		long    *pathX, *pathY;				/*  integer paths of dtw 		*/		double  timeStart, timeIncr;		/*  times for input data		*/		double  *mapOfTime;					/*  mapped input times			*/											/*   to either Y time or common	*/											/*   time scale used in average.*/			/*___  internal use  ___*/					long 	*lowerBound, *upperBound;	/* index into X,Y 				*/		double 	**distArray;				/* min distances 				*/		long	**prodArray;				/* minizing productions 		*/			} DTWData;	#ifdef _MACXLISP_	   void main 	  	(XLSXblock *parms);  			/* dtw */static void DoDTW     	(XLSXblock *parms);static void DoTimeMap 	(XLSXblock *parms);static void DoAverage	(XLSXblock *parms);#else       /* Unix world */static void DoDTW (int *nInUse, double *X, double *Y,	long *symDTW, long *symMap,	int *maxPathLength, int *pathX, int *pathY, int *pathLength,	double *inputDist, double *dtwDist,	double *timeStart, double *timeIncr, double *timeMap);static void DoTimeMap (double *ts, double *ti, int *len, double *map,	int *newLen, double *newX);static void DoAverage (double *X, double *Y, double *timeStart, double *timeIncr, 						long *pathX, long *pathY, long *pathLength,						double *commonTime, double *average);#endif/* ________________________ Local definitions __________________________ */#define INFINITY	1E20#define BORDER		3#define Sqr(x)	((x)*(x))	/*  Component symDTW used to select the path finding algorithm.	*/	/*  The codes are												*/	#define HC_ASYM	0	/*	highly constrained,	asym		*/#define HC_SYM	1	/* 						symmetric	*/#define NC_ASYM	10	/*  no constraints,		asym		*/#define NC_SYM	11	/*  					symmetric	*/#define SC_ASYM 20	/*	some constraints,  	asym		*/#define SC_SYM	21	/*						symmetric	*/#define	HASYMstatic void AllocateData  		(DTWData *data);static void DisposeData   		(DTWData *data);static void FillBounds    		(DTWData *data);static void InitDistancesAndProd(DTWData *data);static void FindPath      		(DTWData *data);static void MapXToYTime   		(DTWData *dtwData);static void CalcDTW       		(DTWData *data);/*  _________________  Function called from Mac XLisp  ________________________ */	/* 	This is the dispatcher routine: 		The first argument in the block from Lisp passes the 		parameter block to the following routines:				(0)  Given two real series, X and Y of common length,		     find the DTW to min separation of the two series.			 		(1)  Given a dtw time map, map times on the X scale to		     the corresponding y scale.  Map done in place over			 input times, which must be in ascending order.	*/	#ifdef _MACXLISP_	void main (parms)XLSXblock *parms;{	long *code;		code = (long *) XLSXargv(parms,0);	switch (*code)	{	case 0: DoDTW(parms);				break;		case 1: DoTimeMap (parms);				break;		case 2: DoAverage (parms);				break;		default:(*code) = -9;	}}void DoDTW (parms)XLSXblock *parms;{	long t;	double dist, *inputDist, *dtwDist;	DTWData dtwData;		/* Decode parm block */		dtwData.nInUse 			= *(long *)   XLSXargv(parms,1);	dtwData.X 				=  (double *) XLSXargv(parms,2);	dtwData.Y 				=  (double *) XLSXargv(parms,3);	dtwData.symDTW      	= *(long *)   XLSXargv(parms,4);	dtwData.symMap	     	= *(long *)   XLSXargv(parms,5);	dtwData.maxPathLength	= *(long *)   XLSXargv(parms,6);	dtwData.pathX  			=  (long *)   XLSXargv(parms,7);	dtwData.pathY  			=  (long *)   XLSXargv(parms,8);	dtwData.pathLength	    =  (long *)	  XLSXargv(parms,9);	inputDist				=  (double *) XLSXargv(parms,10);	dtwDist					=  (double *) XLSXargv(parms,11);	dtwData.timeStart       = *(double *) XLSXargv(parms,12);	dtwData.timeIncr        = *(double *) XLSXargv(parms,13);	dtwData.mapOfTime		=  (double *) XLSXargv(parms,14);							/* just the length of X */	#else /* UNIX world */void DoDTW (nInUse, X, Y, symDTW, symMap,	maxPathLength, pathX, pathY, pathLength,	inputDist, dtwDist, timeStart, timeIncr, timeMap)int *nInUse, *symDTW, *symMap, *maxPathLength, *pathX, *pathY, *pathLength;double *X, *Y, *inputDist, *dtwDist, *timeStart, *timeIncr, *timeMap;{	long t;	double dist;	DTWData dtwData;		/* Decode parameters into data structure */		dtwData.nInUse 			= * nInUse;	dtwData.X 				=  X;	dtwData.Y 				=  Y;	dtwData.symDTW			= *symDTW;	dtwData.symMap			= *symMap;	dtwData.maxPathLength	= *maxPathLength;	dtwData.pathX  			=  pathX;	dtwData.pathY  			=  pathY;	dtwData.pathLength	    =  pathLength;	dtwData.timeStart       = *timeStart;	dtwData.timeIncr        = *timeIncr;	dtwData.mapOfTime		=  timeMap;#endif		/*  Compute the initial squared distance  */	dist = 0.0;	for (t=0; t<dtwData.nInUse; ++t) 		dist += Sqr(dtwData.X[t] - dtwData.Y[t]); 	*inputDist = dist;		/*  Allocate space in the DTW structure and pass to subs */			AllocateData (&dtwData);	CalcDTW(&dtwData);	*dtwDist   = (double) dtwData.distArray[dtwData.nInUse-1][BORDER+dtwData.nInUse-1];	DisposeData(&dtwData); 	}#ifdef _MACXLISP_void DoTimeMap (parms)XLSXblock *parms;{	double timeStart, timeIncr, *map, *newX, lastTime;	long mapLength, newXLength;	long newXIndex, mapIndex;	double last, num, den, diff, tableLo, tableHi;		/* Decode parm block */		timeStart  = *(double *) XLSXargv(parms,1);	/* starting data time 		*/	timeIncr   = *(double *) XLSXargv(parms,2);	/* increment in dtw data 	*/	mapLength  = *(long   *) XLSXargv(parms,3); /* length of next vector    */	map        =  (double *) XLSXargv(parms,4);	/* mapped = spaced x->y time*/	newXLength = *(long   *) XLSXargv(parms,5); /* number of times to map   */	newX       =  (double *) XLSXargv(parms,6); /* new times to map to y    */#elsevoid DoTimeMap (ts, ti, len, map, newLen, newX)int *len, *newLen;double *ti, *ts, *map, *newX;{	double timeStart, timeIncr, lastTime;	int mapLength, newXLength;	int newXIndex, mapIndex;	double num, den, diff, tableLo, tableHi;		/* Decode parm block */		timeStart  = *ts;		/* starting data time 		*/	timeIncr   = *ti;		/* increment in dtw data 	*/	mapLength  = *len ; 	/* length of time map       */	newXLength = *newLen; 	/* number of times to map   */#endif	newXIndex = 0;	while (newXIndex<newXLength)	{	if (*newX >= timeStart)	/* time is past first in table */			break;			else					/* time is earlier than first in table */		{	*newX++ ;			/* so just leave these alone (in situ) */			++newXIndex;								}	}	lastTime = timeStart + timeIncr*(mapLength);    /* map corresponds to   =  */	tableLo = timeStart; 							/* = spaced data, so build */	tableHi = timeStart + timeIncr;	mapIndex=1;	while (newXIndex<newXLength)	{	if (mapIndex == mapLength || *newX > lastTime)			{	/* out of table or past end of map */			break;		}		if (*newX < tableHi)	/* got 'em */		{	den  = timeIncr;			num  = tableHi - *newX;			diff = map[mapIndex]-map[mapIndex-1];			*newX++ = map[mapIndex] - (num/den)*diff;			++newXIndex;		} else  /* look in the next interval */		{	++mapIndex;			tableLo = tableHi;			tableHi += timeIncr;		}	}	/*  dont need further since done in place */}#ifdef _MACXLISP_/*	The map component of dtwData must be twice the length of expanded path.			*//*  On conclusion, map is filled with the time and time average of the two inputs.	*//*  The procedure is entirely symmetric on the common average scale.				*/void DoAverage (parms)XLSXblock *parms;{	double *timeStart, *timeIncr, *X, *Y, *commonTime, *average;	long *pathX, *pathY, *pathLength;	long    pIndex;	double  halfIncr;		/* Decode parm block */		timeStart  	=  (double *) XLSXargv(parms,1);	/* starting data time 		*/	timeIncr   	=  (double *) XLSXargv(parms,2);	/* increment in dtw data 	*/	X  			=  (double *) XLSXargv(parms,3);	/* data vector			    */	Y        	=  (double *) XLSXargv(parms,4);	/* data vector				*/	pathX		=  (long   *) XLSXargv(parms,5); 	/* dtw path on X			*/	pathY      	=  (long   *) XLSXargv(parms,6);	/* dtw path on y    		*/	pathLength	=  (long   *) XLSXargv(parms,7);	commonTime	=  (double *) XLSXargv(parms,8);	/* returned common times	*/	average		=  (double *) XLSXargv(parms,9);	/* returned averages		*/#else	/* UNIX world */static void ComputeAverage(timeStart, timeIncr, X, Y, pathX, pathY, pathLength,							 commonTime, average)double *timeStart, *timeIncr, *X, *Y, *commonTime, *average;long *pathX, *pathY, *pathLength;{	long    pIndex;	double  halfIncr;#endif			halfIncr    =  0.5 * (*timeIncr);	*commonTime++ = *timeStart;				/* init the time averages */	*average++    = (*X + *Y) / 2.0;		pIndex = 1;								/* path in correct order from Lisp */		while (pIndex < *pathLength)	{	*commonTime = *(commonTime-1);		/* what it was plus half for each change */		if (pathX[pIndex] != pathX[pIndex-1])		{	*commonTime   += halfIncr;			X++;		}		if (pathY[pIndex] != pathY[pIndex-1])		{	*commonTime   += halfIncr;			Y++;		}		++commonTime;		*average++ = (*X + *Y) / 2.0;		++pIndex;	}}/* _________________________  Local functions  ________________________________ */#define UPPROD		0#define DIAGPROD 	1#define RIGHTPROD	2#define UPDPROD		10			/* up & diagonal 	*/#define UPDUPPROD	11			/* up, diag, up  	*/#define RPROD		12			/* right	 		*/static void AllocateData(dtwData)DTWData *dtwData;{	long    i, inLen;	long    **prodArray;	double  **distArray;		inLen = dtwData->nInUse;	dtwData->lowerBound = (long *) NewPtr(inLen * sizeof(long));	/* malloc <-> NewPtr */	dtwData->upperBound = (long *) NewPtr(inLen * sizeof(long));	distArray  = (double **) NewPtr(inLen * sizeof(double *));	prodArray  = (long **)   NewPtr(inLen * sizeof(long *));	for (i=0; i<inLen; ++i)	{	distArray[i] = (double *) NewPtr((inLen+2*BORDER) * sizeof(double));		prodArray[i] = (long *)   NewPtr(inLen * sizeof(long));	}	dtwData->distArray = distArray;	dtwData->prodArray = prodArray;}static void DisposeData(dtwData)DTWData *dtwData;{	long i;		DisposPtr ((Ptr) dtwData->lowerBound );	/* free ((void *) <-> DisposPtr ((Ptr) */	DisposPtr ((Ptr) dtwData->upperBound );	for (i=0; i<dtwData->nInUse; ++i)	{	DisposPtr ((Ptr) dtwData->distArray[i]);		DisposPtr ((Ptr) dtwData->prodArray[i]);	}	DisposPtr ((Ptr) dtwData->distArray );	DisposPtr ((Ptr) dtwData->prodArray );}static void CalcDTW (dtwData)DTWData *dtwData;{	long	y, time, prod;	double	d[3], curr, halfCurr;	double  **distArray, *X, *Y;	long	**prodArray;		distArray = dtwData->distArray;	prodArray = dtwData->prodArray;	X = dtwData->X;	Y = dtwData->Y;			FillBounds(dtwData);				/* of the distance array */	InitDistancesAndProd(dtwData);		/* --- main loop to fill distance array --- */	switch (dtwData->symDTW)	if (symmetric == 1)	{	for (time=2; time<dtwData->nInUse; ++time)	 		for (y=dtwData->lowerBound[time]; y<=dtwData->upperBound[time]; ++y)			{	/*  all start with diagonal move and end at (t,y); y+2=y+BORDER-1 */ 				curr = Sqr(X[time]-Y[y]);				halfCurr = curr / 2.0;				d[DIAGPROD]  = distArray[time-1][y+2] + curr;						d[UPPROD]    = distArray[time-1][y+1] + halfCurr													  + Sqr(X[time]-Y[y-1]);				d[RIGHTPROD] = distArray[time-2][y+2] + halfCurr													  + Sqr(X[time-1]-Y[y]);					if (d[DIAGPROD] < d[UPPROD]) prod = DIAGPROD;				else		     			 prod = UPPROD;				if (d[RIGHTPROD]< d[prod])   prod = RIGHTPROD;					distArray[time][BORDER + y] = d[prod];				prodArray[time][y] = prod;			}	} else  /* asymmetric, only weighting by change in time */	{	for (time=2; time<dtwData->nInUse; ++time)		/*  integrate versus X */	 		for (y=dtwData->lowerBound[time]; y<=dtwData->upperBound[time]; ++y)			{	/*  all start with diagonal move and end at (t,y); y+2=y+BORDER-1 */ 				curr = Sqr(X[time]-Y[y]);				d[DIAGPROD] =distArray[time-1][y+2] + curr;						d[UPPROD]   =distArray[time-1][y+1] + (Sqr(X[time]-Y[y-1]  + curr))/2.0;				d[RIGHTPROD]=distArray[time-2][y+2] + Sqr(X[time-1]-Y[y]) + curr ;					if (d[DIAGPROD] < d[UPPROD]) prod = DIAGPROD;				else		     			 prod = UPPROD;				if (d[RIGHTPROD]< d[prod])   prod = RIGHTPROD;					distArray[time][BORDER + y] = d[prod];				prodArray[time][y] = prod;			}	}	FindPath(dtwData);	MapXToYTime (dtwData);}static void FillBounds(dtwData)DTWData *dtwData;{	long i, lower, half, add, nm1;		nm1 = dtwData->nInUse - 1;	half = 2 * (nm1 / 3);		/* limit of 1/2 growth rate */		/* handle slow growth */	for (i=0,lower=-1, add=1; i<= half; ++i)	{	lower += add;		dtwData->lowerBound[i]     = lower;		dtwData->upperBound[nm1-i] = nm1-lower;		add = ! add;	}	/* transition to fast growth -- depends on n-1 mod 3 */	half = half+1;	lower += 2 -  nm1 % 3;	dtwData->lowerBound[half]     = lower;	dtwData->upperBound[nm1-half] = nm1-lower;	/* fast growth to polong at n-1,n-1 */	for (i=half+1; i< dtwData->nInUse; ++i)	{	lower += 2;		dtwData->lowerBound[i]     = lower;		dtwData->upperBound[nm1-i] = nm1-lower;	}	}static void InitDistancesAndProd(dtwData)DTWData *dtwData;{	double temp;	long x,y;	double *X, *Y;		X = dtwData->X;	Y = dtwData->Y;		for (x=0; x<dtwData->nInUse; ++x)	{	for (y=dtwData->lowerBound[x]-BORDER; y<dtwData->lowerBound[x]; ++y)			dtwData->distArray[x][BORDER+y] = INFINITY;		for (y=dtwData->upperBound[x]+1; y<=dtwData->upperBound[x]+BORDER; ++y)			dtwData->distArray[x][BORDER+y] = INFINITY;	}		temp = Sqr(X[0]-Y[0]);		dtwData->distArray[0][BORDER+0] = temp;	dtwData->distArray[0][BORDER+1] = temp + Sqr(X[0]-Y[1]);  /* never go here */		dtwData->distArray[1][BORDER+0] = temp + Sqr(X[1]-Y[0]);	dtwData->distArray[1][BORDER+1] = temp + Sqr(X[1]-Y[1]);	dtwData->distArray[1][BORDER+2] = temp + Sqr(X[0]-Y[1]) + Sqr(X[1]-Y[2]);	dtwData->prodArray[0][0] = -1;			/* no production			*/	dtwData->prodArray[1][0] =  RPROD;		/* go right 				*/	dtwData->prodArray[1][1] =  DIAGPROD;	/* diagonal production 		*/	dtwData->prodArray[1][2] =  UPDPROD;	/* up and diagonal 			*/}static void FindPath(dtwData)DTWData *dtwData;{	long time, x,y;	long *pathX, *pathY;	long **prodArray;		pathX = dtwData->pathX;	pathY = dtwData->pathY;	prodArray = dtwData->prodArray;		time = 0;	x = dtwData->nInUse-1; pathX[time] = x;	y = dtwData->nInUse-1; pathY[time] = y;	while (x != 0) 	{	time +=1;		switch(prodArray[x][y])		{		case DIAGPROD:	x -= 1; y -= 1;						pathX[time] = pathX[time-1]-1;					  	pathY[time] = pathY[time-1]-1;					  	break;					  			case UPPROD:	x -= 1; y -= 2;						pathX[time] = pathX[time-1];					  	pathY[time] = pathY[time-1]-1;					  	time += 1;					  	pathX[time] = pathX[time-1]-1;						/* usual start with diag! */					  	pathY[time] = pathY[time-1]-1;					  	break;					  			case RIGHTPROD:	x -= 2; y -= 1;						pathX[time] = pathX[time-1]-1;					  	pathY[time] = pathY[time-1];					  	time += 1;					  	pathX[time] = pathX[time-1]-1;					  	pathY[time] = pathY[time-1]-1;					  	break;					  			case UPDPROD:	x -= 1; y -= 2;						pathX[time] = pathX[time-1]-1;					  	pathY[time] = pathY[time-1]-1;					  	time += 1;					  	pathX[time] = pathX[time-1];					  	pathY[time] = pathY[time-1]-1;					  	break;					  			case UPDUPPROD:	x -= 1; y -= 3;						pathX[time] = pathY[time-1];					  	pathY[time] = pathY[time-1]-1;					  	time += 1;					  	pathX[time] = pathX[time-1]-1;					  	pathY[time] = pathY[time-1]-1;					  	time += 1;					  	pathX[time] = pathX[time-1];					  	pathY[time] = pathY[time-1]-1;					  	break;					  			case RPROD:		x -= 1;						pathX[time] = pathX[time-1]-1;						pathY[time] = pathY[time-1];						/* end prod; no increment */						break;		}	}		/* while */	*(dtwData->pathLength) = time+1;}static void MapXToYTime(dtwData)DTWData *dtwData;{	double timeStart, timeIncr;	long    dataLen, pathLength, *pathX, *pathY;	double *mapX;	long    tIndex, pIndex;	long 	symmetric;	double timeIncr50, timeIncrm1;		dataLen   = dtwData->nInUse;	symmetric = dtwData->symMap;		timeStart   =  dtwData->timeStart;	timeIncr    =  dtwData->timeIncr;	if (symmetric == 1)	{	timeIncr50  =  1.0 * timeIncr;		timeIncrm1  = -0.5 * timeIncr;	} else	{	timeIncr50  =  0.5 * timeIncr;		timeIncrm1  =  0.0 * timeIncr;	}		pathLength 	= *dtwData->pathLength;	pathX   	= dtwData->pathX;	pathY   	= dtwData->pathY;	mapX		= dtwData->mapOfTime;	mapX[0] = timeStart;		/* force ends of time map to be extremes */		pIndex = pathLength-2;						/* path in reverse order */	if (pathX[pIndex] == pathX[pIndex+1]) 		/* pair of x's start */		--pIndex;	tIndex = 1;									/* table row to be filled */	while (tIndex < dataLen)	{	/*tt0[tIndex]   =  tt0[tIndex-1] + timeIncr; input times evenly spaced */	 											/* output scale depends on ties	*/		if (pathX[pIndex] == pathX[pIndex-1])		/* tie on x */		{ mapX[tIndex++] = timeStart+timeIncr50+pathY[pIndex]*timeIncr;		  pIndex -= 2;		}		else if (pathY[pIndex] == pathY[pIndex-1])	/* tie on y */		{ mapX[tIndex++] = timeStart+timeIncrm1+pathY[pIndex]*timeIncr;			  pIndex -= 1;		}		else										/* distinct */		{ mapX[tIndex++] = timeStart + pathY[pIndex] * timeIncr;			  pIndex -= 1;		}	}}