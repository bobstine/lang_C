/*		random.asm.c												*//*		7 Oct 93 ... Converted from prior machine language files.	*/#include	"random.h"static long	offset;					/*	displacement for long double		*/									static long	mult;					/*	 constants for 2^31-1 generator	*/static long	base;									/* constants for 2^32 generator			*/static long	qMult;					/*	value -1 is even and is mult of 4	*/static long	seed;					/* internal random seed					*/static long	qSeed;					/* internal seed for index generator	*/void InitGenerator (randomSeed, quickSeed)long randomSeed, quickSeed;{		offset = 12;		mult   = 3324726;		base   = 2147483647;			/*	 2^31 -1	*/		qMult  = 1019585;				seed = randomSeed;		qSeed = quickSeed;}			void FillUniformVector (addr, n)double *addr;int n;{				long	saveA0, saveD0, saveD1, saveD2, saveD3;	double  saveFP0, saveFP1; 	asm{			MOVE.L	A0, saveA0		;			MOVE.L	D0, saveD0		; save D3			MOVE.L	D1, saveD1		;			MOVE.L	D2, saveD2		;			MOVE.L	D3, saveD3		;			FMOVE.X	FP0, saveFP0	; save floats			FMOVE.X FP1, saveFP1	;						MOVEA.L	addr, A0		; A0  = vector addr			EOR.L	D0,D0			; zero D0 register			MOVE.W	n, D0			; D0  = length			MOVE.L	mult, D1		; D1  = mult					MOVE.L	seed, D2		; D2  = seed			FMOVE.L	base, FP1		; FP1 = base for divisor			SUB.L	offset,A0		; initialize for later interleave  			SUBQ	#1, D0			; decrement n to hit -1 on time						MULU.L	D1,D3:D2		; full product with q in D2 (mod 2**32) (MULU = MULS since high bit is zero)			ASL.L	#1,D3			; shift high product to make room for 2**31			BFCLR	D2{0:1}			; check high bit of residue and set to zero			BEQ.S	@OK1			; no need to set low if 0 (carry high bit)			BFSET	D3{31:1}		; set low order bit of high quotient@OK1		ADD.L	D3, D2			; add quotient to residue mod 2**31, keep 'seed' in D2			BVC.S	@NoOVL1			; skip add if no overflow			ADDQ.L	#0x0001, D2		; increment sum for mod (2**31-1)@NoOVL1		BFCLR	D2{0:1}			; clear high bit@1			FMOVE.L	D2, FP0			; FP0 = new random integer			ADD.L	offset,A0		; increment offset			FDIV.X	FP1, FP0		; convert from integer to real on [0,1]			MULU.L	D1,D3:D2		; full product with q in D2 (mod 2**32) (MULU = MULS since high bit is zero)			ASL.L	#1,D3			; shift high product to make room for 2**31			BFCLR	D2{0:1}			; check high bit of residue and set to zero			BEQ.S	@OK2			; no need to set low if 0 (carry high bit)			BFSET	D3{31:1}		; set low order bit of high quotient@OK2		ADD.L	D3, D2			; add quotient to residue mod 2**31, keep 'seed' in D2			BVC.S	@NoOVL2			; skip add if no overflow			ADDQ.L	#0x0001, D2		; increment sum for mod (2**31-1)@NoOVL2		BFCLR	D2{0:1}			; clear high bit			FMOVE.X	FP0,(A0)		; store value in vector			DBRA 	D0, @1			MOVE.L	D2, seed		; save last seed for next time						MOVE.L	saveA0, A0		; restore A0			MOVE.L	saveD0, D0		; restore D0			MOVE.L	saveD1, D1		;			MOVE.L	saveD2, D2		;			MOVE.L	saveD3, D3		;			FMOVE.X saveFP0, FP0	; restore FP0			FMOVE.X saveFP1, FP1	;		}}