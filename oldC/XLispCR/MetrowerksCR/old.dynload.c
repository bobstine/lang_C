//	Code for loading and testing basic Mac code resource type applications.#ifndef __FILES__#	include <Files.h>]#endif#ifndef __ERRORS__#	include <Errors.h>#endif							#ifndef __STRINGS__#	include <Strings.h>			// c2pstr#endif#ifndef __FRAGLOAD__#	include <FragLoad.h>#endif#include "xlsx.h"#include <stdlib.h>#include <string.h>#include <stdio.h>//  Prototypes//	typedef void (*ExtFunctionPtr)(XLSXblock *parms);typedef void (*ExtFunctionPtr)(...);void AllocateXLSXBlock(XLSXblock *pBlock, int nArgs);void MyPrint(char *str);		// Used to test ability of CR to call me... failed.//  Local functionsvoid MyPrint(char *str){		printf(str);}void AllocateXLSXBlock(XLSXblock *pBlock, int nArgs){		pBlock->argc = nArgs;	pBlock->argv = (char **) malloc (nArgs * sizeof(char *));}//  Testing code starts herevoid main(void){	OSErr				err;	Str255				errName;	ConnectionID		connID;	ExtFunctionPtr		pFunc;	XLSXblock			parms;			FSSpec 				fileSpec;		Str255				symName;	Ptr					symAddr;	SymClass			symClass;	long				i, symCount;	int					differ;		//  Declare application specific variables		char	*callName = "RawSumVector";					Str63	filePath = "\pDave:ThinkC:XLispCR:Metrowerks CR:VectorOps";	double	x[10];	long 	n = 10;	double	sum=0.0, scale = 2.0;			//	Initialize application specific variables		for(i=0;i<n;++i)		x[i] = (double) i;		//  Stuff parameters if using the XLSXblock passing convention		AllocateXLSXBlock (&parms, 3);     // make sure correct number	parms.argv[0] = (char *)&x;	parms.argv[1] = (char *)&n;	parms.argv[2] = (char *)&sum;		//  Build a file spec record (for GetDiskFragment)	err = FSMakeFSSpec(0, 0, filePath, &fileSpec);	if (err)		printf ("Could not build FSSpec, err = %d\n", err);	else		printf ("File was found.\n");		//	Can load fragment via GetDiskFragment rather than via GetSharedLibrary even	//  though the code was constructed as a shared library.  GetDiskFragment	//  finds the code via a file path rather than a name reference as in GetSharedLibrary.	//  NIM System Software 3-6 gives the search path used by GetSharedLibrary. The following	//	call works if the file is, for example, in the same folder as the application.	//  err = GetSharedLibrary("\pVectorOps", kPowerPCArch, kLoadLib, &connID, (Ptr*)&pFunc,errName);	err = GetDiskFragment(&fileSpec, 0, 0, 0, kLoadLib, &connID, (Ptr*)&pFunc, errName);	if (err)	{	printf ("Error %d on loading fragment %P.\n", err, errName);		goto exit;	} else printf ("Fragment loaded successfully.\n");			//	Identify exported symbols and print	err = CountSymbols (connID, &symCount);	if (err)	{	printf ("Error %d on counting symbols.\n", err);		goto exit;	} else printf ("Found %d symbols in code fragment.\n", symCount);	printf("Exported symbol list...\n");	printf("     Name       Address      Class\n");	for (i=0; i<symCount; ++i)	{	err = GetIndSymbol(connID, i, symName, &symAddr, &symClass);		PtoCstr(symName);		differ = strcmp((char *)symName, callName);		printf("%d  %-15s    %d      %d",i, symName, symAddr, symClass);		if (differ) printf ("\n");		else		printf (" ***Callee***\n");	}		//	Find a specific routine	CtoPstr(callName);	err = FindSymbol (connID, (StringPtr) callName, &symAddr, &symClass);	if (err)	{	printf ("Error %d: cound not find requested symbol./n", err);		goto exit;	}	pFunc = (ExtFunctionPtr) symAddr;	(*pFunc)(&x, &n, &sum);	printf ("Value of result is %lf\n", sum);	//	Call and print results (twice)	/*			(void) (*pFunc)((XLSXblock *) &parms);			printf ("Value of result is %lf\n", sum);	*/	exit:	return;}