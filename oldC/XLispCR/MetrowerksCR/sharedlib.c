#define __DEBUGGING__#ifndef __FILES__#	include <Files.h>]#endif#ifndef __ERRORS__#	include <Errors.h>#endif							#ifndef __FRAGLOAD__#	include <FragLoad.h>#endif#ifndef _STRING#	include <string.h>#endif#ifdef __DEBUGGING__#  include <stdio.h>#endif#include "sharedlib.h"//	Type definitionstypedef void (*ExtFunctionPtr)(...);//	Internal data for array of connection ID's//  Make sure to change the initialization list if change LibrarySize#define noID kNoConnectionID#define LibrarySize 8static ConnectionID theLibrary[LibrarySize] = {noID,noID,noID,noID,noID,noID,noID,noID};//  Local prototypesvoid PrintLibrarySummary(void);//	Local functions#ifdef __DEBUGGING__void PrintLibrarySummary(void){	int 	lib;	long	sym, symCount;	Ptr		symAddr;	Str255	symName;	OSErr	err;	SymClass symClass;		for (lib = 0; lib < LibrarySize; ++lib)	{	if (theLibrary[lib] != kNoConnectionID)		{	err = CountSymbols (theLibrary[lib], &symCount);		// Need to check?			printf("\nLibrary @%d Exported symbol list...\n", theLibrary[lib]);			printf("        Name       Address      Class\n");			for (sym=0; sym<symCount; ++sym)			{	err = GetIndSymbol(theLibrary[lib], sym, symName, &symAddr, &symClass);				PtoCstr(symName);				printf("%d  %-15s    %d      %d\n", sym, symName, symAddr, symClass);			}		}	}}#endif				//	FunctionsConnectionID OpenLibrary(char *filePath){	long			lib;	FSSpec 			fileSpec;	Str255			errName;	OSErr			err;	Ptr				mainAddr;	ConnectionID 	connID;		connID = kNoConnectionID;		//  Build a file spec record for GetDiskFragment	CtoPstr(filePath);	err = FSMakeFSSpec(0, 0, (ConstStr255Param) filePath, &fileSpec);	PtoCstr((StringPtr)filePath);	if (err) return(err);		//	Open the fragment (will not add another copy if loaded, though gives new ID)	err = GetDiskFragment(&fileSpec, 0, 0, 0, kLoadLib, &connID, &mainAddr, errName);	if (err) return(err);		// Find available library record; error if no room remains	lib = 0;	while((theLibrary[lib] != kNoConnectionID) && (lib < LibrarySize))		++lib;	if (lib == LibrarySize)			return(-7);	else	{	theLibrary[lib] = connID;		return(connID);	}}Ptr LibrarySymbolAddr(char *callName, SymClass wantClass){	int 	lib, differ;	long	sym, symCount;	Ptr		symAddr;	Str255	symName;	SymClass symClass;	OSErr	err;		for (lib = 0; lib < LibrarySize; ++lib)	{	if (theLibrary[lib] > 0)		{	err = CountSymbols (theLibrary[lib], &symCount);		// Need to check err code?			for (sym=0; sym<symCount; ++sym)			{	err = GetIndSymbol(theLibrary[lib], sym, symName, &symAddr, &symClass);				PtoCstr(symName);				differ = strcmp((char *)symName, callName);				if (!differ & (symClass == wantClass))					return(symAddr);			}		}	}	return(NULL);}int CloseLibrary(ConnectionID connID){	int lib;		lib = 0;	while ((theLibrary[lib] != connID) & (lib < LibrarySize))		++lib;	if (lib == LibrarySize)	// not found		return(1);	else					// unloading frag, sets connID to kNoConnectionID	{	CloseConnection(&theLibrary[lib]);		return(0);	}}