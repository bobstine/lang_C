//	Code for loading and testing basic Mac code resource type applications.#ifndef __FILES__#	include <Files.h>]#endif#ifndef __ERRORS__#	include <Errors.h>#endif							#ifndef __STRINGS__#	include <Strings.h>			// c2pstr#endif#ifndef __FRAGLOAD__#	include <FragLoad.h>#endif#include <string.h>#include <stdlib.h>#include <stdio.h>//	Type definitionstypedef void (*ExtFunctionPtr)(...);//	Internal data for array of connection ID's#define noID kNoConnectionID#define LibrarySize 8ConnectionID theLibrary[LibrarySize] = {noID,noID,noID,noID,noID,noID,noID,noID};										//  Local prototypesvoid InitLibrary(void);void PrintLibrarySummary(void);int OpenLibrary(char *filePath, ConnectionID *connID);Ptr LibrarySymbol(char *callName, SymClass symClass);int CloseLibrary(ConnectionID connID);//	Local functionsvoid PrintLibrarySummary(void){	int 	lib;	long	sym, symCount;	Ptr		symAddr;	Str255	symName;	OSErr	err;	SymClass symClass;		for (lib = 0; lib < LibrarySize; ++lib)	{	if (theLibrary[lib] != kNoConnectionID)		{	err = CountSymbols (theLibrary[lib], &symCount);		// Need to check?			printf("\nLibrary @%d Exported symbol list...\n", theLibrary[lib]);			printf("        Name       Address      Class\n");			for (sym=0; sym<symCount; ++sym)			{	err = GetIndSymbol(theLibrary[lib], sym, symName, &symAddr, &symClass);				PtoCstr(symName);				printf("%d  %-15s    %d      %d\n", sym, symName, symAddr, symClass);			}		}	}}int OpenLibrary(char *filePath, ConnectionID *pConnID){	long			lib;	FSSpec 			fileSpec;	Str255			errName;	OSErr			err;	Ptr				mainAddr;		*pConnID = kNoConnectionID;		//  Build a file spec record for GetDiskFragment; error #1 if not found	CtoPstr(filePath);	err = FSMakeFSSpec(0, 0, (ConstStr255Param) filePath, &fileSpec);	PtoCstr((StringPtr)filePath);	if (err) return(1);		//	Open the fragment; error #2 if problem.	err = GetDiskFragment(&fileSpec, 0, 0, 0, kLoadLib, pConnID, &mainAddr, errName);	if (err) return(2);		// Find available library record; error #3 if no room remains	lib = 0;	while((theLibrary[lib] != kNoConnectionID) & (lib < LibrarySize))		++lib;	if (lib == LibrarySize)			return(3);	else	{	theLibrary[lib] = *pConnID;		return(0);	}}Ptr LibrarySymbol(char *callName, SymClass wantClass){	int 	lib, differ;	long	sym, symCount;	Ptr		symAddr;	Str255	symName;	SymClass symClass;	OSErr	err;		for (lib = 0; lib < LibrarySize; ++lib)	{	if (theLibrary[lib] > 0)		{	err = CountSymbols (theLibrary[lib], &symCount);		// Need to check err code?			for (sym=0; sym<symCount; ++sym)			{	err = GetIndSymbol(theLibrary[lib], sym, symName, &symAddr, &symClass);				PtoCstr(symName);				differ = strcmp((char *)symName, callName);				if (!differ & (symClass == wantClass))				{	printf("Found %s in library @%d\n", callName, theLibrary[lib]);					return(symAddr);				}			}		}	}	return(NULL);}int CloseLibrary(ConnectionID connID){	int lib;		lib = 0;	while ((theLibrary[lib] != connID) & (lib < LibrarySize))		++lib;	if (lib == LibrarySize)	// not found		return(1);	else					// unloading frag, sets connID to kNoConnectionID	{	CloseConnection(&theLibrary[lib]);		return(0);	}}//  Testing code starts herevoid main(void){	int		i, error;	long 	n = 10;	char	*callName = "AnotherRawSumVector";					char	*filePath1 = "Dave:ThinkC:XLispCR:Metrowerks CR:VectorOps";	char	*filePath2 = "Dave:ThinkC:XLispCR:Metrowerks CR:MoreVectorOps";	double	x[10];	double	sum=0.0, scale = 2.0;	ConnectionID lib1, lib2;	ExtFunctionPtr pFunc;			//	Initialize arguments prior to calling routine		for(i=0;i<n;++i)		x[i] = (double) i;			//	Open libraries	error = OpenLibrary(filePath1, &lib1);	error = OpenLibrary(filePath2, &lib2);	PrintLibrarySummary();		//	Call a specific routine	CloseLibrary(lib1);	pFunc =  (ExtFunctionPtr) LibrarySymbol(callName, 2);	if(pFunc != NULL)	{	(*pFunc)(&x, &n, &sum);		printf ("\nValue of result is %lf\n", sum);	} else printf("\nFunction %s not found\n", callName);		error = OpenLibrary(filePath1, &lib1);	if (error) printf ("Error on second load...%d\n", error);	printf("\nFinal Library...\n");	for(i=0; i<LibrarySize; ++i) printf("Lib[%d] = %d\n",i,theLibrary[i]);	printf("Done\n");	}