//   Header file for Lempel-Ziv codevoid LZ (long x[], long *pn, long *nQuant, long *codeWeight, double xHat[]);/*	LZ does a modified Lempel-Ziv compression of the input sequence.  The LZ parse tree	is held internally, and can be manipulated by the associated functions.  Upon return,	the x vector is overwritten as:		x[0] = number of unique code words		x[1] = time of second code word  (first always is at time = 0)		x[2] = time of second...		x[x[0]] = time of last code word.		The vector xHat returns the one-step ahead predictions of the process unless xHat is	nil.  The predictions are ONE STEP AHEAD, and thus shifted from the observed series	so that, for example, xHat[0] is the predictor for x[1], etc.		nQuant determines the size of the code array at each node, and codeWeight (>=1) 	determines how many must accumulate prior to spawning a new node.*/void LZPrintTree (void);void LZSummarizeTree (long *nCodeWords, double *avgCodeLen);void LZDisposeTree (void);/*	Functions for Markov coding of boolean integer input.		Penalty methods are coded as:		-1 - just the bits for the k state markov chain		0  - no penalty, but with bits for encoding the nodes of the tree		1  - FS penalty		2  - Rissanen penalty*/void FitMarkov(long x[], long *pn, long *pk, long *offset, long *penaltyMethod, 				long *pNodeCount, double *pBits);void MarkovBits (long x[], long *pn, long *pK, long *offset, long nodeCounts[4], double bits[4]);  // all 4void PrintMarkovArray(int size);