/*	random.c		13 May 94 ... Hacked to produce random samples.	*/#include "random.h"#include <time.h>static unsigned long localSeed;static double scratch[25];// xlrand.c - random number generators // Copyright (c) 1989, by David Michael Betz.                            // You may give out copies of this software; for conditions see the file //  COPYING included with this distribution.                              //       Combined Tausworthe generator. Tezuka and L'Ecuyer, (1991),// "Efficient and portable combined Tauseworthe random number// generators," ACM Transactions on Modeling and Computer Simulation 1,// 99-112.#define DFLTGEN 1#define MPFIX32 2147483647#define HPART(x) (((unsigned long) (x)) >> 16)#define LPART(x) (((unsigned long) (x)) & 0xFFFF)#define SETULONG(x,h,l) ((x) = ((h) << 16) + (l))/*------------------------------------------*//*        Multinomial Sampler		        *//*------------------------------------------*/void MultinomialRand(n, p, x, nCells)int n,*x, nCells;double *p;{	int i, bin;	double uni;		for (i=0; i<nCells; ++i)		x[i] = 0;	if (n == 0)			return;	else	{	scratch[0] = p[0];		for (i=1; i<n-1; ++i)			scratch[i] = scratch[i-1] + p[i];		/* accumulate p's			*/		scratch[n-1] = 1.0000001;					/* avoid rounding problems	*/        for (i=0; i<n; ++i)        {	uni = Uniform();        	bin = 0;        	while (uni > scratch[bin])        		++bin;        	++x[bin];		}	}}/*------------------------------------------*//*        Discrete Sampling Methods         *//*------------------------------------------*/	int DiscreteSample(table, n)double *table;int n;{	int i;	double uni;	uni = Uniform();	i = 0;	while (uni > table[i])		++i;	return(i);}void TruncatedDiscreteSample(table, n, lo, hi, x, prob)double *table, *prob;int n, lo, hi, *x;{	double min, uni;		if (lo < 0) lo = 0;					/* check input */	if (hi >= n) hi = n-1;				/* n is length of table	*/	if (lo == hi)	{	*x = lo; *prob = 1.0;	}	else	{	uni = Uniform();		if (lo == 0)		{	min = 0;			uni *= table[hi];		} else		{	min = table[lo-1];			uni = min + uni * (table[hi] - min);		}		*x = lo;		while (uni > table[*x])			++*x;		if (*x == 0)	*prob = table[0];		else			*prob = table[*x] - table[*x-1];		*prob = *prob / (table[hi] - min);	}}static long randomState[4];/*-----------------------------	InitRandom  -----------------------------*/  void InitRandom(seed)unsigned long seed;{    unsigned long I1, I2, Mask1=2147483647, Mask2=536870911;	if (seed == 0)		seed = (unsigned long) TickCount();  /* clock(); */	I1 = seed / (1 << 16);	I2 = seed % (1 << 16);	if (I1 <= 0 || I1 > Mask1) I1 = 1;	if (I2 <= 0 || I2 > Mask2) I1 = 1;	randomState[0] = Mask1;	randomState[1] = 0;	randomState[2] = I1;	randomState[3] = I2;}/*------------------------------	Uniform  ------------------------------*/double Uniform(){	static long Q1=13, Q2=2, S1=17, S2=17, P1mS1=19, P2mS2=12, P1mP2=2;	static unsigned long Mask1=2147483647, Mask2=536870911;	static double Norm=4.656612873E-10;	unsigned long I1, I2;	unsigned long b;	double x;	do	{	I1 = randomState[2];		I2 = randomState[3];		b=((I1 << Q1) ^ I1) & Mask1;		I1 = ((I1 << S1) ^ (b >> P1mS1)) & Mask1;		b = ((I2 << Q2) ^ I2) & Mask2;		I2 = ((I2 << S2) ^ (b >> P2mS2)) & Mask2;		b = I1 ^ (I2 << P1mP2);		randomState[1] = b;		randomState[2] = I1;		randomState[3] = I2;		x = b * Norm;	} while (x <= 0.0 || x >= 1.0);	return(x);}/*------------------------------	FillUniformVector  ------------------------------*/void FillUniformVector (v, n)double *v;int n;{	int i;		for (i = 0; i<n; ++i)		*v++ = Uniform();}		