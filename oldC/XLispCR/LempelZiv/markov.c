/* 			Binary markov generators and tabulators	26 Jun 96 ... Tabulate in place without holding onto data; generate from file.	25 Jun 96 ... Cut from LZ code.				Current Status:  		Looks fine for what it does.  It has not been linked to XLisp, but it does	what is advertised in performing the underlying Markov calculations.  		(1) It reads data from a file, converts it to a bit stream, and then computes the base 	leaves of a classification tree.  The Lisp code has to then reduces the leaves to	something more useful/compact.		(2) It can simulate such leaves from an arbitrary Markov process as well, returning	the leaves to Lisp for reduction without having to move the data itself back and	forth.*/#include <stdlib.h>#include <stdio.h>#include <ctype.h>#include "random.h"#include "markov.h"// Debug does more printing#define PRINT 0#define DEBUG 0//-------  Macros  --------------------------#define ABS(x)   (((x) < 0) ? (-x) : x)#define MIN(x,y) (((x) < (y)) ? (x) : (y))//-------  Globals  ------------------------long gIndex, gShiftBit, *gLeaves;//-------  internal prototypes  -------------void InitGlobals (long *leaves, long *pK);void CodeInteger(int theChar);void InitLeaves(long *leaves, int nLeaves);void InitIndexPowerShift (long *initial, long *k, unsigned long *index, unsigned long  *power, unsigned long  *shift);//  void InitGlobals (long *leaves, long *pK){		long i, nLeaves;	gIndex = 0;	gLeaves = leaves;	nLeaves = 1;	for (i = 0; i < *pK; ++i)		nLeaves *= 2;	InitLeaves(gLeaves, nLeaves);	gShiftBit = nLeaves / 2;   		// Bit in position k, or 2^(k-1)}void InitLeaves(long *leaves, int nLeaves){	int i;		for (i=0; i<2*nLeaves; ++i)		// Each leaf is two longs, #1's and n		leaves[i] = 0;}void InitIndexPowerShift (long *initial, long *k,			 unsigned long *index, unsigned long  *power, unsigned long  *shift){	int t;		*index = 0;	*power=1;						for(t=0; t<*k; ++t)					// with closest setting MSB	{	*index += initial[t] * *power;		*power *= 2;	}									// power = 2^k = size of the underlying array	*shift = *k - 1;}#if PRINTvoid PrintMarkovArray(int size){	int i;		printf("\n  --- Markov Array --- \n");	for(i=0; i<size; ++i)	{	printf("[%3d] %3d %3d -- h --> %8.3f \n", i, 			gMarkovArray[i][ONE],  gMarkovArray[i][COUNT], 			Entropy(gMarkovArray[i][ONE], gMarkovArray[i][COUNT]));	}	printf("----------------------\n");}#endif//==========================================================================//     Exported Markov functions //==========================================================================void GenerateMarkovArray (double p[], long initial[], long *pK, long *pN, long leaves[], long *pSeed){	long xt;	unsigned long  index, power, shift, nLeft;		InitIndexPowerShift (initial, pK, &index, &power, &shift);	nLeft = *pN - *pK;	InitRandom(*pSeed);							// Results in random seed from clock if zero	while(nLeft)												{	xt = BooleanRand(p[index]);		leaves[2*index]   += xt;				// Init the one counter by xt		leaves[2*index+1] += 1;					//		and the total counter by 1		index >>= 1;							// shift right 		index += (xt << shift);					// set MSB most recent value		-- nLeft;	}}void GenerateMarkovData (double p[], long *pk, long x[], long  *pn, long *pSeed){	long *pXt;	unsigned long index, power, shift, nLeft;		InitIndexPowerShift (x, pk, &index, &power, &shift);	pXt   = &x[*pk];						// initial pointer into data vector	nLeft = *pn - *pk;	InitRandom(*pSeed);						// Results in random seed from clock.	while(nLeft)												{	*pXt = BooleanRand(p[index]);		index >>= 1;						// shift right 		index += (*pXt << shift);			// set MSB most recent value		++ pXt;		-- nLeft;	}}void CalcMarkovArray(long x[], long *pn, long leaves[], long *pk, long *offset, long *pError){	long *pXt;	unsigned long  index, nLeft, power, shift;		*pError = 0;	if (*pk >= (*pn - *offset))	{	*pError = -1;	return;	}		if (*offset < *pk) *offset = *pk;			// ensure offset >= k	InitIndexPowerShift (&x[*offset - *pk], pk, &index, &power, &shift);	InitLeaves(leaves, power);	nLeft  = *pn - *offset;	pXt   = &x[*offset];	while(nLeft)												{	leaves[2*index  ] += *pXt;					leaves[2*index+1] += 1;		index >>= 1;							// shift right 		index += (*pXt << shift);				// set MSB most recent value		++ pXt;		-- nLeft;	}}void CodeInteger(int theChar){		int nBits = 5;	int mask = 1, bit;		while (nBits)	{	++gLeaves[2*gIndex+1];		bit = mask & theChar;  					// mask all but low bit		if (bit == 1)		{	++gLeaves[2*gIndex];			gIndex >>= 1;			gIndex += gShiftBit;		} else			gIndex >>= 1;		theChar >>= 1;							// shift char bits and dec counter		-- nBits;	}}	void CalcMarkovArrayFromFile(long leaves[], long *pK, long *pN, long *pError){	FILE *fp;	int charInt;	long nRead, nSkipped;			*pError = 0;							// open file	fp = fopen("markov.txt", "r");	if (fp == NULL)	{	*pError = -1;		return;	}		InitGlobals(leaves, pK);	nRead = 0; nSkipped = 0;	while (((charInt = getc(fp)) != EOF) && (++nRead <= *pN))	{	charInt = tolower(charInt);		if (isspace(charInt))			CodeInteger(0);		else if (ispunct(charInt))			CodeInteger(1);		else if (isalpha (charInt))			CodeInteger(2 + charInt - (int) 'a');		else			++nSkipped;	}	if (charInt == EOF)		*pError = -3;	*pN = nRead;	*pK = nSkipped;	fclose(fp);}