/*	timeseries.c		11 Apr 96 ... Add routine to do AR(p) estimation by both ls and yw.	 3 Apr 95 ... Corrected an error in AR(2+) generator and run from Lisp.	12 Jan 95 ... Converted to pure Unix format.	18 Nov 93 ... Created to check some of the prediction methods in referee report.*/#include <math.h>#include "solve.h"#include "nrutil.h"#include "timeseries.h"// #include <stdio.h>//#define Sqr(x) ((x)*(x))#define abs(d) ((d)>=0)?(d):(-(d))#define max(a,b) ((a)>(b)?a:b)//  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//  Global storage used by various routines to avoid lots of dynamic allocation.#define MAXORDER 20static int  gNeedSetup = 1;static double gCov[1+MAXORDER];static double theMatrix[MAXORDER][MAXORDER];static double *gMat[MAXORDER];void SetupPtrs(void); void SetupPtrs (void){	int j;		for(j=0; j<MAXORDER; ++j)		gMat[j] = theMatrix[j];}//  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -void ARCovariances (double phi[], long p, double cov[])  // cov better be p+1	{	int i,j;	double *coefs, **mat;						coefs = dvector(0,p);	mat   = dmatrix(0,p,0,p);	for(i=0; i<=p; ++i)				// fill matrix with zeros		for(j=0; j<=p; ++j)			mat[i][j] = 0.0;	coefs[0] = -1.0;				// extended coefs for index convenience	for(i=1; i<=p; ++i)		coefs[i] = phi[i-1];	for(i=0; i<=p; ++i)		for(j=0; j<=p; ++j)			mat[i][abs(i-j)] += coefs[j];	cov[0] = -1.0;	for(i=1;i<=p; ++i)		cov[i] = 0.0;	solve(mat, cov, p+1);	free_dvector(coefs,0,p);	free_dmatrix(mat,0,p,0,p);}void ARCovarRoot (double phi[], long p, double **sr){	int i,j;	double *cov;		cov = dvector(0,p);	ARCovariances (phi, p, cov);			// compute covarianes	for (i=0; i<p; ++i)						// put into matrix sr	{	sr[i][i] = cov[0];		for (j=0; j<i; ++j)		{	sr[i][j] = cov[i-j];			sr[j][i] = cov[i-j];		}	}	/*	printf ("\n --------  covariance matrix  --------\n");	for (i=0; i<p; ++i)	{	printf("[%d] ", i);		for (j=0; j<p; ++j)			printf(" %8.3f ", sr[i][j]);		printf("\n");	}	*/	choldc (sr, p, &j);						// in place cholesky decomp	free_dvector(cov,0,p);}//  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//	Generate an AR series   (assume that yt starts appropriately initialized to y[1]..y[p]//                           and that the rest are errors to be used and overwrittenvoid GenerateAR (double *yt, long *pT, double *coefs, long *pOrder){	long p;		int t,j;	double *pDest, *lag, **chol, sum;	p = *pOrder;	pDest = &yt[p];			if (p == 1)									// special loop if p = 1	{	yt[0] = yt[0] / sqrt(1 - coefs[0]*coefs[0]);		lag = yt;		for (t=1; t < *pT; ++t)			*pDest++ += (*coefs) * (*lag++);	} else	{	if (*pOrder > MAXORDER)		{	yt[0] = -7.7;			yt[1] = -7.7;			yt[2] = -7.7;			return;		}									// make sure pointers initialized		if (gNeedSetup) 		{	SetupPtrs();			gNeedSetup = 0;		}		chol = dmatrix(0,p-1,0,p-1);					ARCovarRoot (coefs, p, gMat);		// find chol root of covar matrix			/*			printf ("\n --------  Cholesky Root  --------\n");			for (i=0; i<p; ++i)			{	printf("[%d] ", i);				for (j=0; j<p; ++j)					printf(" %8.3f ", gMat[i][j]);				printf("\n");			}			*/		for (t = p-1; t >= 0; --t)				// initialize in place		{	sum = 0.0;			for (j = 0; j <= t; ++j)				sum += gMat[t][j] * yt[j];			yt[t] = sum;			// printf ("yt[%d] = %f\n", t, yt[t]);		}		--yt;									// so that yt[t-j] is really yt[t-j-1]		for	(t=p; t < *pT; ++t)											{	for(j=0; j < p; ++j)				*pDest += coefs[j] * yt[t-j];			++pDest;		}	}}//  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//	Estimate covariance sequence//    If method=1, then center the series.  Otherwise, compute as is.void CalcACS (double *y, long *pT, double *acs, long *jLimit, long *method){	double sum, mean, n;	long t,j;	n = (double) *pT;		if (*method != 0)					// find the mean	{	sum = 0.0;									for (t=0; t<*pT; ++t)			sum += y[t];		mean = ((double) sum) / n;		for (t=0; t<*pT; ++t)			// center the data series			y[t] -= mean;	}		sum = 0.0;							// calc variance separately	for (t=0; t < *pT; ++t)		sum += y[t] * y[t];	*acs++ = sum / n;		for (j=1; j < *jLimit; ++j)			// loop through the rest...	{	sum = 0.0;		for (t = j; t < *pT; ++t)			sum += y[t] * y[t-j];		*acs++ = sum / n;	}}//  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //	Estimate AR parameters... this version is only for AR(1) and optionally centers the//          data prior to estimation.  Returns residuals back in the input.void EstimateAR1 (double *y, long *pT, double *coefs, long *center, double *pRSS){		int t;		double mean, c0, c1, T;				T = (double) *pT;				if (*center == 1)		{	mean = 0.0;						// compute data mean			for (t = 0; t < *pT; ++t)				mean += y[t];			mean /= T;			for (t = 0; t < *pT; ++t)		// center the input data				y[t] -= mean;		}		c0 = 0.0;							// compute the num and denom		c1 = 0.0;		for (t=0; t < (*pT)-1; ++t)		{	c0 += y[t] * y[t];			c1 += y[t] * y[t+1];		}				*coefs = c1 / c0;				*pRSS = 0.0; 						// compute residuals in reverse and return SS		for (t=*pT-1; t > 0; --t)		{	y[t] -= *coefs * y[t-1];		// compute the fit			*pRSS += y[t] * y[t];		}		}//  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//	Estimate AR parameters... Optionally centers the data prior to estimation.//               If RSS > 0, returns residuals in data, with RSS as well.void EstimateLS (double *y, long *pT, double *coefs, long *pOrder, long *center, 					long *start,	double *pRSS){	long j,k,d,t,p,T, origin;		if (*pOrder > MAXORDER)	{	coefs[0] = -7.7;		return;	}									// initialize pointers (as needed)	if (gNeedSetup) 	{	SetupPtrs();		gNeedSetup = 0;	}	p = *pOrder;	origin = max(*start, p);			// response index  start <= t <= T-1	T = *pT;										// center ALL data if requested	if (*center == 1)	{	double avg = 0.0;		for (t=0; t<T; ++t)			avg += y[t];		avg /= (double) T;		for (t=0; t<T; ++t)			y[t] -= avg;	}											// compute T * sample covariances of response	for (j=0; j <= p; ++j)              //       each cov uses decaying number pairs,	{	gCov[j] = 0.0;                  //       so have to add more for ls estimates.		for (t=origin; t<T-j; ++t)		 	gCov[j] += y[t] * y[t+j];	}										// fix up the right hand side	{	long jm1;		for (j=1; j<=p; ++j)		{	jm1 = j - 1;			coefs[jm1] = gCov[j];			for (t=origin-j; t<origin; ++t)				coefs[jm1] += y[t] * y[t+j];		}	}										// fixup X'X from covariances, diagonally 	for (d=0; d<p; ++d)					// 		d denotes which diagonal	{	gMat[0][d] = gCov[d] - y[T-d-1] * y[T-1];		for (j=1; j<=d+1; ++j)			// 		adjust term in first row			gMat[0][d] += y[origin-j]*y[origin-j+d];		if (d > 0) gMat[d][0] = gMat[0][d];		for (j=1; j<p-d; ++j)			//      propagate down this diagonal		{	k = d + j + 1;			gMat[j][j+d] = gMat[j-1][j-1+d] + y[origin-k]*y[origin-k+d] - y[T-k] * y[T-k+d];			if (d > 0) gMat[j+d][j] = gMat[j][j+d];		}	}	/*	printf ("\n\n Equations to solve from estimating LS alone ...\n");	for (j=0; j<p; ++j)    {	printf ("\n %8.2f = ", coefs[j]);    	for (k=0; k<p; ++k)    		printf ("%8.2f ", gMat[j][k]);    }	printf("\n");    */		solve((double **)gMat,coefs,p);										// Compute residual SS if needed	if (*pRSS > 0.0)	{	double fit;		*pRSS = 0.0;		t = T-2;						// t is lagged value, with t+1 being predicted		while (t >= origin-1)			// overwrite backwards so can do in place		{	fit = 0.0;			for (j=0; j<p; ++j)				fit += coefs[j] * y[t-j];			y[t+1] -= fit;			*pRSS += y[t+1] * y[t+1];			--t;		}	}}//  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//  Estimate parameters via Yule-Walker and least squares with no centering.//      Valid only for order up to maxOrder.void EstimateBoth (double y[], long *pT, double ywCoefs[], double lsCoefs[], long *pOrder){	long j,k,d,t,p,T,jm1,km1;		if (*pOrder > MAXORDER)	{	ywCoefs[0] = -7.7;		lsCoefs[0] = -7.7;		return;	}								// make sure pointers initialized	if (gNeedSetup) 	{	SetupPtrs();		gNeedSetup = 0;	}	p = *pOrder;	T = *pT;									// compute sample covariances	for (j=0; j <= p; ++j)	{	gCov[j] = 0.0;		for (t=0; t<T-j; ++t)		 	gCov[j] += y[t] * y[t+j];		// cov[j] /= (double) T;	// cov is NOT normalized (otherwise need to in ls)	}									// solve yule-walker	for (j=0; j< p; ++j)	{ 	ywCoefs[j] = gCov[1+j];		for (k=0; k < p; ++k)			if (j>=k) gMat[j][k] = gCov[j-k];			else      gMat[j][k] = gCov[k-j];	}	solve((double **)gMat,ywCoefs,p);										// subtract off terms to get ls form	for (j=1; j<=p; ++j)  		{	jm1 = j-1;		lsCoefs[jm1] = gCov[j];			//		initialize		for (t = j; t < p; ++t)  		// 		adjust "right side" by S(j,p-1)			lsCoefs[jm1] -= y[t] * y[t-j];		for (k=j; k <= p; ++k) 			// 		adjust mat by D[j,k] = S(0,p-k-1)+S(n-k,n-k+j-1)		{	d = k-j;					//      k >= j, d >= 0			km1 = k-1;			gMat[jm1][km1] = gCov[d];		//		initialize			for(t=0; t<p-k; ++t)				gMat[jm1][km1] -= y[t+d] * y[t];			for(t=T-k; t<T-d; ++t)				gMat[jm1][km1] -= y[t+d] * y[t];			if (d != 0) gMat[km1][jm1] = gMat[jm1][km1];		}	}	/*	printf ("Equations to solve from estimating both...\n");	for (j=0; j<p; ++j)    {	printf ("\n %8.2f = ", lsCoefs[j]);    	for (k=0; k<p; ++k)    		printf ("%8.2f ", gMat[j][k]);    }	printf("\n");    */    	solve((double **)gMat,lsCoefs,p);}