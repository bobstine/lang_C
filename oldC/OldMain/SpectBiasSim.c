/*		Simulation of bias in spectral estimation in AR estimates.	27 Jun 88 ... Allow for special freqs at peaks.	23 Apr 88 ... Code for log bias added in place of mean estimation.				20 Apr 88 ... Further modifications for testing.	13 Apr 88 ... Introduce relative error computation and S2.	12 Apr 88 ... Created to check AR spectral estimation.	 */#include	<stdio.h>extended sqrt();extended cos();extended log();#include	"Globals.h"#include	"ArrayDef.h"#include	"InOut.h"#include	"arDef.h"#include	"arGeneration.h"#include	"arEstimation.h"/*  ----------------------  DEFINES  -------------------------  */#define		MAXORDER	   20		/*	for efficiency in spectral calc 			*/#define		MAXLENGTH	  400		/*  longest series length; also set theLengths 	*/#define		NLENGTHS		4		/*	nested series to compute 					*/#define		NXTRAFREQS		3		/*  number of special freqs to add				*/#define		NFREQS		    2 		/* 	number of frequencies to examine 			*/#define		TOTALFREQS		(NFREQS+NXTRAFREQS)#define 	SCALAR			1#define		SEED		153757853/*  ----------------------  GLOBALS  -------------------------  */static int 	theLengths[NLENGTHS] = { 50, 100, 200, MAXLENGTH };static int 		nTrials;static int 		arOrder;static double	estSpectrum[TOTALFREQS], logTrueSpectrum[TOTALFREQS],				freqs[TOTALFREQS], trueSpectrum[TOTALFREQS];static VECTOR 	dataDummy, arCoefs;static CUBE   	freqTotals, freqSSs;	/* plane=length, row=methods, col=freqs (last is S2) */static MATRIX	dataMat, residMat;static ARMODEL	genModel, lsModel, ywModel;/*  ----------------------------------------------------------  */static void AllocateSpace(){	AllocMatrix (MAXLENGTH, 1, &dataMat);	dataDummy.len = MAXLENGTH; dataDummy.pntr = dataMat.pntr[0];	AllocMatrix (MAXLENGTH, 1, &residMat);	AllocVector (arOrder+1, &arCoefs);	arAllocModel (arOrder, SCALAR, &genModel);	arAllocModel (arOrder, SCALAR, &lsModel);	arAllocModel (arOrder, SCALAR, &ywModel);	AllocCube (NLENGTHS, 4, TOTALFREQS+1, &freqTotals);	/* 4 = (yw, ls, mean, nomean) */	AllocCube (NLENGTHS, 4, TOTALFREQS+1, &freqSSs);		}static void FreeSpace(){	int len;		dataMat.nRows = MAXLENGTH;		/* to be on the safe side */	DisposeMatrix (&dataMat);	DisposeMatrix (&residMat);	DisposeVector (&arCoefs);	DisposeCube (&freqTotals);	DisposeCube (&freqSSs);		arDisposeModel (&genModel);	arDisposeModel (&lsModel);	arDisposeModel (&ywModel);}static void ParseCmdLine (argc, argv)/* First argument treated as nTrials, rest are coefs.   *//* Allocates space and sets globals arCoefs, arOrder.	*/int argc;				char *argv[];{	int  arg;		if (argc <= 2)	{	fprintf (stderr, "Need to supply nReps and coefs of generating process.\n");		exit(1);	}		/* for (arg=0; arg<argc; ++arg)		fprintf (stderr, "argv[%d] --->%s<---\n", arg, argv[arg]); */	sscanf (argv[1], "%d", &nTrials);	arOrder = argc-2;			/* remove name and nTrials */	AllocateSpace();			/* make room for reading coefs */	arCoefs.pntr[0] = 1.0;	for (arg=2; arg<argc; ++arg) 		sscanf (argv[arg], "%nf", &arCoefs.pntr[arg-1]);	/* PrintVector (&arCoefs, "Input echo"); */}static void Initialize(arCoefs)VECTOR *arCoefs;{	int r,c,p;		for (p=0; p<freqTotals.nPlanes; ++p)	/* init cumulative area to 0 */		for (r=0; r<freqTotals.nRows; ++r)			for (c=0; c<freqTotals.nCols; ++c)			{	freqTotals.pntr[p][c][r] = 0.0;				freqSSs.pntr[p][c][r] = 0.0;			}	arInitGeneration();	for (p=0; p<arCoefs->len; ++p)		genModel.coef.sCoef.pntr[p] = arCoefs->pntr[p];	genModel.type = scalar;	arPrintModel (&genModel, "Generating model");	arDefineGenModel (&genModel);}static void CalcSpectrum (coefs, sigma2, spect)VECTOR *coefs;double sigma2;	/* error variance estimate */double *spect;{	int j, k, offset;	double tot, *alpha, fInc, conv[MAXORDER];	register double factor;		alpha = coefs->pntr;	conv[0] = 1.0;	offset = 1;	while (offset <= arOrder)	{	conv[offset] = 0.0;		for (j=0; j<=arOrder - offset; ++j)			conv[offset] += alpha[j]*alpha[j+offset];		conv[0] += alpha[offset]*alpha[offset];		++offset;	}	fInc = PI / (double) (NFREQS-1);	freqs[0] = 0.0;	for (j=1; j<NFREQS; ++j)		freqs[j] = freqs[j-1] + fInc;	freqs[NFREQS    ] = 0.785347143;			/*  special frequencies */	freqs[NFREQS + 1] = 1.405586343;	freqs[NFREQS + 2] = 2.723629339;			for (j=0; j<TOTALFREQS; ++j)	{	spect[j] = conv[0];		for (k=1; k<=arOrder; ++k)			spect[j] += 2.0 * conv[k] * cos(freqs[j] * (double)k);	}	factor = sigma2/(2.0*PI);	for (j=0; j<TOTALFREQS; ++j)	{	spect[j] = factor / spect[j];		/* fprintf (stderr, "[%2d ( %f ) ] f= %f\n", j, freqs[j], spect[j]); */	}}	static void AccumSimResults (len, row, coefs, s2)int len, row;			/* len is plane of cube */ARMODEL *coefs;double s2;{	int j;	register double est, true;		CalcSpectrum (&coefs->coef.sCoef, s2, estSpectrum);		for (j=0; j<TOTALFREQS; ++j)	{	est =  estSpectrum[j] - trueSpectrum[j] ;			/* actual bias */		freqTotals.pntr[len][j][row] += est;		freqSSs.pntr[len][j][row] += est * est;		/*	fprintf (stderr, " bias[%d] %9.4f \n", j, est);	*/			est =  log(estSpectrum[j]) - logTrueSpectrum[j] ;	/* bias of logs */		freqTotals.pntr[len][j][row+2] += est;				/* put logs in 3&4 */		freqSSs.pntr[len][j][row+2] += est * est;	}	s2 -= 1.0;	freqTotals.pntr[len][TOTALFREQS][row] += s2;			/* last col are s2 res */	freqSSs.pntr[len][TOTALFREQS][row] += s2 * s2;	}void PrintSimResults (){	int j, method, len;	extended N, T, rN1, mean, sd;		N = (extended)nTrials;	rN1 = sqrt (N-1.0);	/* PrintCube (&freqTotals, "Freq totals"); */	/* PrintCube (&freqSSs, "Freq SSs"); */	fprintf (stdout," ------ SUMMARY of simulated T x BIAS of A(w) alone  ------\n");	fprintf (stdout," SEED is %d with ", SEED);	fprintf (stdout," %d trials with a max length of %d.\n", nTrials, MAXLENGTH);	fprintf (stdout," For each length, cols are YW, LS pairs for no mean, then bias of logs.\n");	fprintf (stdout,"  Output format:  T x AVG BIAS (SE MEAN)\n");	fprintf (stdout," True spectrum \n");	for (j=0; j<TOTALFREQS; ++j)		fprintf (stdout, "[%2d] %10.3f \n", j, trueSpectrum[j]);	fprintf (stdout, "\n\n");	for (len=0; len<NLENGTHS; ++len)	{	T = (double) theLengths[len];		fprintf (stdout, "[freq]  T x AVG bias for LENGTH = %d.\n\n", theLengths[len]);		fprintf (stdout, "[ s2 ] ");		for (method=0; method<4; ++method)		{	mean = freqTotals.pntr[len][TOTALFREQS][method] /N;			sd = T * sqrt((freqSSs.pntr[len][TOTALFREQS][method] /N) - mean*mean);			fprintf (stdout, " %9.4f(%8.4f)",T*mean, sd/rN1);		}		fprintf (stdout, "\n\n");		for (j=0; j<TOTALFREQS; ++j)		{	fprintf (stdout, "[%4.3f] ",  freqs[j] );			for (method=0; method<4; ++method)			{	mean = freqTotals.pntr[len][j][method] /N;				sd = T * sqrt((freqSSs.pntr[len][j][method] /N) - mean*mean);				fprintf (stdout, " %9.4f(%8.4f)",T*mean, sd/rN1);			}			fprintf (stdout, "\n");		}		fprintf (stdout, "__________________________________________________\n\n");	}}double CalcS2 (x, len)double *x;int len;{	int i;	extended s2 = 0.0;		for (i=arOrder; i<len; ++i)		s2 += x[i]*x[i];	s2 /= (double)(len - 2*arOrder);	return (s2);}main(argc, argv)int argc;				/* count includes tool name */char *argv[];{	int trial, len,f;	double ywS2, lsS2;		VECTOR dummy;		InitRandomSamples (SEED);	ParseCmdLine (argc, argv);					/* and allocates space */	Initialize(&arCoefs);		trial = 0;	CalcSpectrum (&arCoefs, 1.0, trueSpectrum);	/* true sigma2 is one */	for (f=0; f<TOTALFREQS; ++f)		logTrueSpectrum[f] = log(trueSpectrum[f]);	dummy.len = 50; dummy.pntr = dataMat.pntr[0];	while (trial < nTrials)	{	if (trial%500 == 0) fprintf(stderr, "Trial #%d\n", trial);		arGenerateSeries(&dataMat);				/* expects array input */		for (len=0; len<NLENGTHS; ++len)		{	dataMat.nRows =  theLengths[len];	/* DANGER  using subset of lengths */			dataDummy.len =  theLengths[len];						arUseMeanCorrection (0);			/*	fprintf (stderr, "Starting estimation\n");	*/			arEstimateModel(&dataMat, &ywModel, &lsModel);			/*	arPrintModel (&ywModel, "est yw model");	*/			/*	arPrintModel (&lsModel, "est ls model");	*/				arCalcResids (&dataMat, &ywModel, &residMat);			ywS2 = CalcS2(residMat.pntr[0], theLengths[len]);			/*	fprintf (stderr, "Resid S2 for YW = %f;", ywS2);	*/			AccumSimResults (len, 0, &ywModel, ywS2);			arCalcResids (&dataMat, &lsModel, &residMat);			lsS2 = CalcS2(residMat.pntr[0], theLengths[len]);			/*	fprintf (stderr, " and LS = %f.\n", lsS2);	*/			AccumSimResults (len, 1, &lsModel, lsS2);		}		trial += 1;	}	PrintSimResults();	FreeSpace();}			/*		Mean correction code						arUseMeanCorrection (1);			arEstimateModel(&dataMat, &ywModel, &lsModel);						arCalcResids (&dataMat, &ywModel, &residMat);			AccumSimResults (len, 2, &ywModel, CalcS2(residMat.pntr[0], theLengths[len]));			arCalcResids (&dataMat, &lsModel, &residMat);			AccumSimResults (len, 3, &lsModel, CalcS2(residMat.pntr[0], theLengths[len]));			*/									/*		Add this code to test generator.						VECTOR test;			AllocVector (10, &test);			FillNormalVector (&test);			PrintVector (&test);			DisposeVector (&test);						*/