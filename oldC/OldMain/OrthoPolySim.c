/*		Simulation of bias in AR estimates in polynomial			regression models.				13 Mar 88 ... Add code for incremental simulation.	10 Mar 88 ... Continue coding and debugging.	 8 Mar 88 ... Created.	 */#include	<stdio.h>extended sqrt();#include	"Globals.h"#include	"ArrayDef.h"#include	"InOut.h"#include	"OrthoPoly.h"#include	"arDef.h"#include	"arGeneration.h"#include	"arEstimation.h"#define 	MAXPOLYORDER 	3		/*	max order of poly to consider */#define		NOFTRIALS		2000 	/*	how many series of max length */#define		MAXLENGTH		400		/*  longest series length; also set theLengths */#define		NOFLENGTHS		4		/*	nested series to compute */#define		ARORDER			1		/* 	order of AR in error process */#define 	SCALAR			1#define		SEED		1173546327static int 	theLengths[NOFLENGTHS] = { 50, 100, 200, MAXLENGTH };CUBE   	arTotals, arSSs;MATRIX	dataMat, residMat;VECTOR 	polyCoefs;VECTOR 	resDummy, dataDummy;ARMODEL	genModel, lsModel, ywModel;MATRIX	polyMatArray[NOFLENGTHS];		/* array of point matrices for each length */VECTOR	polySSArray[NOFLENGTHS];void AllocateSpace(){	int len;		for (len=0; len<NOFLENGTHS; ++len)	{	AllocMatrix (theLengths[len], MAXPOLYORDER, &polyMatArray[len]);		AllocVector (MAXPOLYORDER, &polySSArray[len]);	}	AllocVector (MAXPOLYORDER+1, &polyCoefs);	/* 1 for constant */	AllocMatrix (MAXLENGTH, 1, &dataMat);	AllocMatrix (MAXLENGTH, 1, &residMat);	arAllocModel (ARORDER, SCALAR, &genModel);	arAllocModel (ARORDER, SCALAR, &lsModel);	arAllocModel (ARORDER, SCALAR, &ywModel);	AllocCube (1,4*NOFLENGTHS,ARORDER+1, &arTotals);	/* 4 rows for each length;1 for constant */	AllocCube (1,4*NOFLENGTHS,ARORDER+1, &arSSs);			resDummy.len = MAXLENGTH;	resDummy.pntr = residMat.pntr[0];	dataDummy.len = MAXLENGTH;	dataDummy.pntr = dataMat.pntr[0];	}void Initialize(arCoef)extended arCoef;{	int r,c,p;		for (p=0; p<arTotals.nPlanes; ++p)	/* init cumulative area to 0 */		for (r=0; r<arTotals.nRows; ++r)			for (c=0; c<arTotals.nCols; ++c)			{	arTotals.pntr[p][c][r] = 0.0;				arSSs.pntr[p][c][r] = 0.0;			}	arInitGeneration();	genModel.coef.sCoef.pntr[1] = arCoef;	genModel.type = scalar;	arPrintModel (&genModel, "Generating model");	arDefineGenModel (&genModel);		for (p=0; p<NOFLENGTHS; ++p)		opFillMatrix(&polyMatArray[p], &polySSArray[p]);}void FreeSpace(){	int len;		for (len=0; len<NOFLENGTHS; ++len)	{	DisposeVector (&polySSArray[len]);		DisposeMatrix (&polyMatArray[len]);	}	DisposeVector (&polyCoefs);	DisposeMatrix (&dataMat);	DisposeMatrix (&residMat);	DisposeCube (&arTotals);	DisposeCube (&arSSs);		arDisposeModel (&genModel);	arDisposeModel (&lsModel);	arDisposeModel (&ywModel);}void AccumSimResults (offset, ywEsts, lsEsts)int offset;					/* use offset of 0 for raw, 2 for regr */ARMODEL *ywEsts, *lsEsts;{	int j;	register extended est;	extended *ls, *yw;		ls = lsEsts->coef.sCoef.pntr;	yw = ywEsts->coef.sCoef.pntr;	for (j=1; j<=ARORDER; ++j)		/* yw in row 0, ls in 1 */	{	est = yw[j];		arTotals.pntr[0][j][offset] += est;		arSSs.pntr[0][j][offset] += est * est;		est = ls[j];		arTotals.pntr[0][j][1+offset] += est;		arSSs.pntr[0][j][1+offset] += est * est;	}	}void PrintSimResults (){	int j, shift, len;	extended N, mean, sd;		N = (extended)NOFTRIALS;	fprintf (stdout," ---- SUMMARY of simulation results ----\n");	fprintf (stdout," SEED= %d \n", SEED);	fprintf (stdout," Using %d trials with a max length of %d.\n\n", NOFTRIALS, MAXLENGTH);	fprintf (stdout,"[coef] meth   AVG           STD DEV\n\n");	for (j=1; j<=ARORDER; ++j)		for (len=0; len<NOFLENGTHS; ++len)		{	fprintf (stdout, "Results for LENGTH = %d.\n\n", theLengths[len]);			for (shift=0; shift<3; shift +=2)			{	mean = arTotals.pntr[0][j][4*len+shift] / N;				sd = sqrt(arSSs.pntr[0][j][4*len+shift]/N - mean*mean);				fprintf (stdout, "[%2d] YW %12.4lf  %12.4lf\n",j,mean,sd);				mean = arTotals.pntr[0][j][(4*len)+1+shift] / N;				sd = sqrt(arSSs.pntr[0][j][(4*len)+1+shift]/N - mean*mean);				fprintf (stdout, "[%2d] LS %12.4lf  %12.4lf\n\n",j,mean,sd);			}			fprintf (stdout, "----------------------------------\n");		}}main(){	int trial, order, len;			AllocateSpace();	Initialize(-0.5);	trial = 0;	InitRandomSamples (SEED, SEED);	while (trial < NOFTRIALS)	{	arGenerateSeries(&dataMat);				/* expects array input */		for (len=0; len<NOFLENGTHS; ++len)		{	dataMat.nRows =  theLengths[len];	/* DANGER  using subset of lengths */			dataDummy.len =  theLengths[len];			resDummy.len  =  theLengths[len];			residMat.nRows = theLengths[len];			arEstimateModel(&dataMat, &ywModel, &lsModel);			AccumSimResults (4*len, &ywModel, &lsModel);			opEstimate(&dataDummy, &polyMatArray[len], &polySSArray[len], &polyCoefs);			opCalcResids (&dataDummy, &polyCoefs, &polyMatArray[len], &resDummy);			arEstimateModel(&residMat, &ywModel, &lsModel);			AccumSimResults (2+4*len, &ywModel, &lsModel);		}		trial += 1;	}	PrintSimResults();	FreeSpace();}		/* PrintCube (&arTotals, "Totals cube"); */		/* PrintMatrix (&dataMat, "data"); */		/* PrintVector (&polyCoefs, "polynomial coefs"); */		/* arPrintModel (&lsModel, "ls model"); */