/*	alignment.c		 6 Dec 90 ... Finally happy with FillBounds.	 5 Dec 90 ... Build time tables, MapTimes.	 4 Dec 90 ... Patch FillBounds in middle and check; install borders; check inits.	 3 Dec 90 ... Created.*/#include "alignment.h"#ifdef _debugging_#include "debug.h"#include <stdio.h>#endif/*	productions for traversal */#define UPPROD		0#define DIAGPROD 	1#define RIGHTPROD	2#define UPDPROD		10	/* up & diagonal */#define UPDUPPROD	11	/* up, diag, up  */#define RPROD		12  /* right		 */#define INFINITY	1E20#define BORDER		3static int		nInUse=0;										/* length of data	*/static float	*X, *Y;											/* pointers to data */											static int		lowerBound[MAXLENGTH], upperBound[MAXLENGTH];	/* index into X,Y 	*/static float	distArray[MAXLENGTH][MAXLENGTH+2*BORDER];		/* min distances 	*/static int 		prodArray[MAXLENGTH][MAXLENGTH];				/* minizing productions */static int		pathLength=0;									/* DTW path 		*/static int		path[MAXLENGTH*2][2];static float	pathStartTime, pathTimeIncr;static float	timeTable[MAXLENGTH][2];						/* time correspondence *//* ___ Local function headers ___ */#define Sqr(x)	(x)*(x)void FillBounds(void);void InitDistancesAndProd(void);void CalcDistanceAt(int x,int y);void FindPath(void);void BuildTimeTable(void);/* ___ Local functions ___ */void FillBounds(){	int i, lower, half, add, nm1;		nm1 = nInUse - 1;	half = 2 * (nm1 / 3);		/* limit of 1/2 growth rate */		/* handle slow growth */	for (i=0,lower=-1, add=1; i<= half; ++i)	{	lower += add;		lowerBound[i]     = lower;		upperBound[nm1-i] = nm1-lower;		add = ! add;	}	/* transition to fast growth -- depends on n-1 mod 3 */	half = half+1;	lower += 2 -  nm1 % 3;	lowerBound[half]     = lower;	upperBound[nm1-half] = nm1-lower;	/* fast growth to point at n-1,n-1 */	for (i=half+1; i< nInUse; ++i)	{	lower += 2;		lowerBound[i]     = lower;		upperBound[nm1-i] = nm1-lower;	}	}void InitDistancesAndProd(){	float temp;	int x,y;		for (x=0; x<nInUse; ++x)	{	for (y=lowerBound[x]-BORDER; y<lowerBound[x]; ++y)			distArray[x][BORDER+y] = INFINITY;		for (y=upperBound[x]+1; y<=upperBound[x]+BORDER; ++y)			distArray[x][BORDER+y] = INFINITY;	}		temp = Sqr(X[0]-Y[0]);	distArray[0][BORDER+0] = temp;		distArray[1][BORDER+0] = temp + Sqr(X[1]-Y[0]);	distArray[1][BORDER+1] = temp + Sqr(X[1]-Y[1]);	if (distArray[1][BORDER+1] < distArray[1][BORDER+0])		temp = distArray[1][BORDER+1];	else		temp = distArray[1][BORDER+0];	distArray[1][BORDER+2] = temp + Sqr(X[1] - Y[2]);		prodArray[0][0] = -1;			/* no production led to this point */		prodArray[1][0] =  RPROD;		/* go right */	prodArray[1][1] =  DIAGPROD;	/* diagonal production */	prodArray[1][2] =  UPDPROD;		/* up and diagonal */}void FindPath(){	int time, x,y;		time = 0;	x = nInUse-1; path[time][0] = x;	y = nInUse-1; path[time][1] = y;	while (x != 0) 	{	time +=1;		switch(prodArray[x][y])		{		case DIAGPROD:	x -= 1; y -= 1;						path[time][0] = path[time-1][0]-1;					  	path[time][1] = path[time-1][1]-1;					  	break;					  			case UPPROD:	x -= 1; y -= 2;						path[time][0] = path[time-1][0];					  	path[time][1] = path[time-1][1]-1;					  	time += 1;					  	path[time][0] = path[time-1][0]-1;	/* usual start with diag! */					  	path[time][1] = path[time-1][1]-1;					  	break;					  			case RIGHTPROD:	x -= 2; y -= 1;						path[time][0] = path[time-1][0]-1;					  	path[time][1] = path[time-1][1];					  	time += 1;					  	path[time][0] = path[time-1][0]-1;					  	path[time][1] = path[time-1][1]-1;					  	break;					  			case UPDPROD:	x -= 1; y -= 2;						path[time][0] = path[time-1][0]-1;					  	path[time][1] = path[time-1][1]-1;					  	time += 1;					  	path[time][0] = path[time-1][0];					  	path[time][1] = path[time-1][1]-1;					  	break;					  			case UPDUPPROD:	x -= 1; y -= 3;						path[time][0] = path[time-1][0];					  	path[time][1] = path[time-1][1]-1;					  	time += 1;					  	path[time][0] = path[time-1][0]-1;					  	path[time][1] = path[time-1][1]-1;					  	time += 1;					  	path[time][0] = path[time-1][0];					  	path[time][1] = path[time-1][1]-1;					  	break;					  			case RPROD:		x -= 1;						path[time][0] = path[time-1][0]-1;						path[time][1] = path[time-1][1];	/* end prod; no increment */						break;		}	}		/* while */	pathLength = time+1;}void BuildTimeTable()		/* map X (pre) times to Y (post) time scale */{	int time, i, pIndex;	float incr45, incr65, incr15;	/* increment 4/5, 6/5, 1.5 of usual */		incr45 = 0.8 * pathTimeIncr;	incr65 = 1.2 * pathTimeIncr;	incr15 = 1.5 * pathTimeIncr;		timeTable[0][0] = timeTable[0][1] = pathStartTime;	for (i=1; i<nInUse; ++i)		timeTable[i][0] = timeTable[i-1][0] + pathTimeIncr;	timeTable[nInUse-1][1] = timeTable[nInUse-1][0];		/* force agreement at ends */		i = 1;	pIndex = pathLength-2;	if (path[pathLength-1][1] == path[pathLength-2][1])	/* startup check */	{	timeTable[1][1] = 0.2 * pathTimeIncr;		++i;		--pIndex;	};								/* path in reverse order */	while (i < nInUse-1)		{	if (path[pIndex][1] == path[pIndex-1][1])		/* matches next Y */		{	timeTable[i  ][1] = timeTable[i-1][1] + incr45;			timeTable[i+1][1] = timeTable[i-1][1] + incr65;			i += 2;			pIndex -= 2;		}		else if (path[pIndex][0] == path[pIndex-1][0])	/* match on X */		{	timeTable[i][1] = timeTable[i-1][1] + incr15;			i += 1;			pIndex -= 2;		}		else			/* no ties */		{	timeTable[i++][1] = pathStartTime + pathTimeIncr*path[pIndex--][1];		}	}			}void DoDTW (inputN, timeStart, timeIncr, inputX, inputY)long *inputN;float *timeStart,  *timeIncr, *inputX, *inputY;{	int		x,y, time, prod;	float	diff, dist, d[3];	double  total;		/* --- initialize globals --- */	if (*inputN > MAXLENGTH)	{	nInUse = 0;		pathLength = 0;		return;	}	nInUse = *inputN;	X = inputX; Y = inputY;	pathStartTime = *timeStart;	pathTimeIncr = *timeIncr;			/* --- determine the permitted upper/lower bounds using 2 to 1 exp/compression --- */	FillBounds();	/*	PrintIntVec (lowerBound, nInUse, "Lower bounds");	PrintIntVec (upperBound, nInUse, "Upper bounds");	*/		/* --- initialize the distance array and productions --- */	InitDistancesAndProd();		/* --- main loop to fill distance array --- */	for (time=2; time<nInUse; ++time)	 	for (y=lowerBound[time]; y<=upperBound[time]; ++y)		{	/*  all start with diagonal move  */			d[DIAGPROD]  = distArray[time-1][y+2];									d[UPPROD]    = distArray[time-1][y+1] + Sqr(X[time]-Y[y-1]);			d[RIGHTPROD] = distArray[time-2][y+2] + Sqr(X[time-1]-Y[y]);				if (d[DIAGPROD] < d[UPPROD]) prod = DIAGPROD;			else		     			 prod = UPPROD;			if (d[RIGHTPROD] <d[prod])   prod = RIGHTPROD;				distArray[time][BORDER + y] = d[prod] + Sqr(X[time]-Y[y]);			prodArray[time][y] = prod;		}		/* --- print the distance array ---	printf ("Distance array with productions\n");	for (y=nInUse-1; y>=0; --y)	{	for (time=0; time<nInUse; ++time)	 	{	if(distArray[time][BORDER+y] < INFINITY)	 			printf(" %5.2f [%2d] ", distArray[time][BORDER+y], prodArray[time][y]);	 		else	 			printf(" ***** [%2d] ",-7);	 	}	 	printf ("\n");	}	Wait();	*/		/* --- recover path leading to final distance --- */	FindPath();	printf ("DTW path\n");	for (x=0; x<pathLength; ++x)		printf ("[%3d] %3d %3d \n", x, path[x][0], path[x][1]);					/* --- create time mapping table --- */	BuildTimeTable();	/*	printf ("Time Mapping Table\n");	for (x=0; x<nInUse; ++x)		printf("[%2d] %f --> %f \n", x, timeTable[x][0], timeTable[x][1]);	*/}void DTWSummary (nSteps, dist)long *nSteps;float *dist;{	*dist = distArray[nInUse-1][BORDER+nInUse-1];	*nSteps = pathLength;}				void MapTimes (N, realTime, alignTime)long *N;float *realTime, *alignTime;{	int dataIndex, tableIndex;	float inTime, num, den, diff;	int done;		done = 0;	dataIndex = 0;	tableIndex=0;	while (dataIndex<*N)	{	if (*realTime >= timeTable[0][0])	/* time is past first in table */			break;			else								/* time is earlier than first in table */		{	*alignTime++ = *realTime++;		/* so just copy these over */			++dataIndex;									}	}	done = 1;	while (dataIndex<*N)	{	++tableIndex;		/* ran out of table or time is past end of table */		if (tableIndex == nInUse || *realTime > timeTable[nInUse-1][0])				{	done = 0;			break;		}		if (*realTime < timeTable[tableIndex][0])		/* got 'em */		{	den  = timeTable[tableIndex][0]-timeTable[tableIndex-1][0];			diff = timeTable[tableIndex][1]-timeTable[tableIndex-1][1];			num  = *realTime++ - timeTable[tableIndex][0];			*alignTime++ = timeTable[tableIndex][1] + (num/den)*diff;			++dataIndex;		}	}	if (!done)	{	for (;dataIndex<*N;++dataIndex)			*alignTime++ = *realTime++;	}}				