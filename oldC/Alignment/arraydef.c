/*		 		arrayDef.c											*//*								 6 Oct 87							*//*	 					rev		20 Dec 90 Debugging & int vectors	*/#include "arrayDef.h"#include <stdlib.h>void AllocIntVector (len, intVec)int len;INTVECTOR *intVec;{	if (len > 0) {		intVec->pntr = (int *) (malloc(len * sizeof(int)));		intVec->len = (intVec->pntr != NULL) ? len : 0;	} else {		intVec->len = 0;		intVec->pntr= NULL;	}}void AllocIntMatrix (nRows, nCols, intMat)int nRows, nCols;INTMATRIX *intMat;{	int	col;	intMat->nCols = nCols;	intMat->nRows = nRows;	intMat->pntr = (int **) malloc(nCols * sizeof(int *));	if (intMat->pntr != NULL)		for (col = 0; col < nCols; col++)		{	if (nRows > 0) 			{	intMat->pntr[col] = (int *) malloc(nRows * sizeof(int));				if (intMat->pntr[col] == NULL)					intMat->nRows = 0;			} else intMat->pntr[col] = NULL;		}}void AllocVector (len, vec)int len;VECTOR *vec;{	if (len > 0) {		vec->pntr = (double *) (malloc(len * sizeof(double)));		vec->len = (vec->pntr != NULL) ? len : 0;	} else {		vec->len = 0;		vec->pntr= NULL;	}}void AllocMatrix (nRows, nCols, mat)int nRows, nCols;MATRIX *mat;{	int	col;	mat->nCols = nCols;	mat->nRows = nRows;	mat->pntr = (double **) malloc(nCols * sizeof(double *));	if (mat->pntr != NULL)		for (col = 0; col < nCols; col++)		{	if (nRows > 0) 			{	mat->pntr[col] = (double *) malloc(nRows * sizeof(double));				if (mat->pntr[col] == NULL)					mat->nRows = 0;			} else mat->pntr[col] = NULL;		}}void ResizeVector (len, vec)int len;VECTOR *vec;{	if (vec->len != len) 	{	free ((char *) vec->pntr);		vec->pntr = (double *) malloc (len * sizeof(double));		vec->len = len;	}}void ResizeMatrix (nRows, nCols, mat)int nRows, nCols;MATRIX *mat;{	if ( (mat->nRows != nRows) || (mat->nCols != nCols) )	{	DisposeMatrix (mat);		AllocMatrix (nRows, nCols, mat);	}}void ResizeCube (nPlanes, nRows, nCols, cube)int nPlanes, nRows, nCols;CUBE *cube;{	if ( (cube->nRows != nRows) || (cube->nCols != nCols) || (cube->nPlanes != nPlanes) )	{	DisposeCube (cube);		AllocCube (nPlanes, nRows, nCols, cube);	}}void DisposeVector (vec)VECTOR *vec;{	free ((char *) vec->pntr);	vec->len = 0;}void DisposeIntVector (intVec)INTVECTOR *intVec;{	free ((char *) intVec->pntr);	intVec->len = 0;}void DisposeIntMatrix (intMat)INTMATRIX *intMat;{	int col;		if (intMat->nRows > 0) 	{	for (col = 0; col < intMat->nCols; ++col)  			free ((char *) (intMat->pntr)[col]);	}	free ((char *)intMat->pntr);	intMat->nRows = 0;	intMat->nCols = 0;}void DisposeMatrix (mat)MATRIX *mat;{	int col;		if (mat->nRows > 0) 	{	for (col = 0; col < mat->nCols; ++col)  			free ((char *) (mat->pntr)[col]);	}	free ((char *)mat->pntr);	mat->nRows = 0;	mat->nCols = 0;}/*	buffer space for holding pointers into C arrays	*/#define MAXROW 20static int lastUsed = 1;static double *rowPtr1[MAXROW+1], *rowPtr0[MAXROW+1];double **ColPointers (mat, nRows, nCols)	/* useful if col order */double *mat;int nRows, nCols;{	int row, limit, jump;	double **rh;		limit = (nRows < MAXROW) ? nCols : MAXROW;	/* get min */		if (lastUsed == 1)		/* then use #0 */	{	rh = rowPtr0; lastUsed = 0;	} else	{	rh = rowPtr1; lastUsed = 1;	}	jump = 0;	for (row = 0; row<limit; ++row, jump += nCols)		rh[row] = (double *) &mat[jump];	return (rh);}void AllocCube (numPlanes, numRows, numCols, theCube)int numPlanes, numRows, numCols;CUBE *theCube;{	int	p, c;		theCube->nPlanes = numPlanes;	theCube->nRows = numRows;	theCube->nCols = numCols;	theCube->pntr = (double ***) (malloc(numPlanes * sizeof(double **)));	if (theCube->pntr != NULL)		for (p=0; p<numPlanes; ++p)		{	theCube->pntr[p] = (double **) (malloc(numCols * sizeof(double *)));			if (theCube->pntr[p] != NULL)				for (c=0; c<numCols; ++c)					theCube->pntr[p][c] = (double *)(malloc(numRows * sizeof(double)));		}}	 /*  AllocCube  */void DisposeCube (theCube)CUBE *theCube;{	int p, c;		for (p=0; p<theCube->nPlanes; ++p)	{	for (c=0; c<theCube->nCols; ++c)			free ((char *) theCube->pntr[p][c]);		free((char *)theCube->pntr[p]);	}	free ((char *)(theCube->pntr));	theCube->pntr = NULL;	theCube->nPlanes = 0;	theCube->nRows = 0;	theCube->nCols = 0;}	/*  DisposeCube  */	