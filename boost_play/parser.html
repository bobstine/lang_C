<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <title>Boost C++ Libraries</title>
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />  <link rel="icon" href="/favicon.ico" type="image/ico" />
  <link rel="stylesheet" type="text/css" href="/style/section-doc.css" />
  <!--[if IE]> <style type="text/css"> body { behavior: url(/style/csshover.htc); } </style> <![endif]-->

</head><!-- boost_1_35_0/libs/spirit/example/fundamental/list_parser.cpp -->

<body>
  <div id="heading">
      <div id="heading-placard"></div>

  <h1 id="heading-title"><a href="/"><img src="/gfx/space.png" alt=
  "Boost C++ Libraries" id="heading-logo" /><span id="boost">Boost</span>
  <span id="cpplibraries">C++ Libraries</span></a></h1>

  <p id="heading-quote"><span class="quote">&ldquo;...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.&rdquo;</span> <span class="attribution">&mdash; <a href=
  "http://www.gotw.ca/" class="external">Herb Sutter</a> and <a href=
  "http://en.wikipedia.org/wiki/Andrei_Alexandrescu" class="external">Andrei
  Alexandrescu</a>, <a href=
  "http://safari.awprofessional.com/?XmlId=0321113586" class="external">C++
  Coding Standards</a></span></p>

  <div id="heading-sections">
    <ul>
      <li id="welcome-section-tab"><a href="/">Welcome</a></li>

      <li id="boost-section-tab"><a href="/users/">Introduction</a></li>

      <li id="community-section-tab"><a href="/community/">Community</a></li>

      <li id="development-section-tab"><a href=
      "/development/">Development</a></li>

      <li id="support-section-tab"><a href="/support/">Support</a></li>

      <li id="doc-section-tab"><a href="/doc/">Documentation</a></li>

      <li id="map-section-tab"><a href="/map.html">Index</a></li>
    </ul>
  </div>
  </div>

  <div id="body">
    <div id="body-inner">
      <div id="content">
        <div class="section" id="docs">
          <div class="section-0">
            <div class="section-body">
              <h3>libs/spirit/example/fundamental/list_parser.cpp</h3>
<pre>
/*=============================================================================
    Copyright (c) 2001-2003 Hartmut Kaiser
    http://spirit.sourceforge.net/

    Use, modification and distribution is subject to the Boost Software
    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
=============================================================================*/
///////////////////////////////////////////////////////////////////////////////
// This sample shows the usage of the list_p utility parser
//  1. parsing a simple ',' delimited list w/o item formatting
//  2. parsing a CSV list (comma separated values - strings, integers or reals)
//  3. parsing a token list (token separated values - strings, integers or
//     reals)
// with an action parser directly attached to the item part of the list_p
// generated parser

#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;

#include &lt;<a href="../../../../boost/spirit/core.hpp">boost/spirit/core.hpp</a>&gt;
#include &lt;<a href="../../../../boost/spirit/utility/confix.hpp">boost/spirit/utility/confix.hpp</a>&gt;
#include &lt;<a href="../../../../boost/spirit/utility/lists.hpp">boost/spirit/utility/lists.hpp</a>&gt;
#include &lt;<a href="../../../../boost/spirit/utility/escape_char.hpp">boost/spirit/utility/escape_char.hpp</a>&gt;

///////////////////////////////////////////////////////////////////////////////
using namespace std;
using namespace boost::spirit;

///////////////////////////////////////////////////////////////////////////////
// actor, attached to the list_p parser
class list_actor
{
public:
    list_actor (std::vector&lt;std::string&gt; &amp;vec_) : vec(vec_) {}

    // The following operator() is called by the action parser generated by
    // attaching this actor to a list_p generated list parser.

    template &lt;typename ActionIterT&gt;
    void operator() (ActionIterT const &amp;first, ActionIterT const &amp;last) const
    {
        vec.push_back(std::string(first, last-first));
    }

private:
    std::vector&lt;std::string&gt; &amp;vec;
};

///////////////////////////////////////////////////////////////////////////////
// main entry point
int main ()
{
    // 1. parsing a simple ',' delimited list w/o item formatting
    char const*                 plist_wo_item = &quot;element1,element2,element3&quot;;
    rule&lt;&gt;                      list_wo_item;
    std::vector&lt;std::string&gt;    vec_list;

    list_wo_item =
            list_p[push_back_a(vec_list)]
        ;

    parse_info&lt;&gt; result = parse (plist_wo_item, list_wo_item);

    cout &lt;&lt; &quot;-----------------------------------------------------------------&quot;
        &lt;&lt; endl;

    if (result.hit)
    {
        cout
            &lt;&lt; &quot;Parsing simple list&quot; &lt;&lt; endl
            &lt;&lt; &quot;\t&quot; &lt;&lt; plist_wo_item &lt;&lt; endl
            &lt;&lt; &quot;Parsed successfully!&quot; &lt;&lt; endl &lt;&lt; endl;

        cout
            &lt;&lt; &quot;Actor was called &quot; &lt;&lt; (int)vec_list.size()
            &lt;&lt; &quot; times: &quot; &lt;&lt; endl;

        cout
            &lt;&lt; &quot;Results got from the list parser:&quot; &lt;&lt; endl;
        for (std::vector&lt;std::string&gt;::iterator it = vec_list.begin();
             it != vec_list.end(); ++it)
        {
            cout &lt;&lt; *it &lt;&lt; endl;
        }
    }
    else
    {
        cout &lt;&lt; &quot;Failed to parse simple list!&quot; &lt;&lt; endl;
    }

    cout &lt;&lt; endl;

    // 2. parsing a CSV list (comma separated values - strings, integers or
    // reals)
    char const *plist_csv = &quot;\&quot;string\&quot;,\&quot;string with an embedded \\\&quot;\&quot;,&quot;
        &quot;12345,0.12345e4,,2&quot;;
    rule&lt;&gt; list_csv, list_csv_item;
    std::vector&lt;std::string&gt; vec_item;

    vec_list.clear();

    list_csv_item =
        !(
                confix_p('\&quot;', *c_escape_ch_p, '\&quot;')
            |   longest_d[real_p | int_p]
        );

    list_csv =
            list_p(
                list_csv_item[push_back_a(vec_item)],
                ','
            )[push_back_a(vec_list)]
        ;

    result = parse (plist_csv, list_csv);

    cout &lt;&lt; &quot;-----------------------------------------------------------------&quot;
        &lt;&lt; endl;
    if (result.hit)
    {
        cout
            &lt;&lt; &quot;Parsing CSV list (comma separated values) &quot; &lt;&lt; endl
            &lt;&lt; &quot;\t&quot; &lt;&lt; plist_csv &lt;&lt; endl
            &lt;&lt; &quot;Parsed successfully!&quot; &lt;&lt; endl &lt;&lt; endl;

        if (result.full)
        {
            cout &lt;&lt; &quot;Matched &quot; &lt;&lt; (int)vec_list.size() &lt;&lt;
                &quot; list elements (full list): &quot; &lt;&lt; endl;
        }
        else
        {
            cout &lt;&lt; &quot;Matched &quot; &lt;&lt; (int)vec_list.size() &lt;&lt;
                &quot; list elements: &quot; &lt;&lt; endl;
        }

        cout &lt;&lt; &quot;The list parser matched:&quot; &lt;&lt; endl;
        for (std::vector&lt;std::string&gt;::iterator itl = vec_list.begin();
                itl != vec_list.end(); ++itl)
        {
            cout &lt;&lt; *itl &lt;&lt; endl;
        }

        cout &lt;&lt; endl &lt;&lt; &quot;Item(s) got directly from the item parser:&quot; &lt;&lt; endl;
        for (std::vector&lt;std::string&gt;::iterator it = vec_item.begin();
                it != vec_item.end(); ++it)
        {
            cout &lt;&lt; *it &lt;&lt; endl;
        }

    }
    else
    {
        cout &lt;&lt; &quot;Failed to parse CSV list!&quot; &lt;&lt; endl;
    }

    cout &lt;&lt; endl;

    // 3. parsing a token list (token separated values - strings, integers or
    // reals) with an action parser directly attached to the item part of the
    // list_p generated parser
    char const *plist_csv_direct = &quot;\&quot;string\&quot;&lt;par&gt;\&quot;string with an embedded &quot;
        &quot;\\\&quot;\&quot;&lt;par&gt;12345&lt;par&gt;0.12345e4&quot;;
    rule&lt;&gt; list_csv_direct, list_csv_direct_item;

    vec_list.clear();
    vec_item.clear();

    // Note: the list parser is here generated through the list_p.direct()
    // generator function. This inhibits re-attachment of the item_actor_direct
    // during parser construction (see: comment in utility/lists.hpp)
    list_csv_direct_item =
            confix_p('\&quot;', *c_escape_ch_p, '\&quot;')
        |   longest_d[real_p | int_p]
        ;

    list_csv_direct =
            list_p.direct(
                (*list_csv_direct_item)[list_actor(vec_item)],
                &quot;&lt;par&gt;&quot;
            )[list_actor(vec_list)]
        ;

    result = parse (plist_csv_direct, list_csv_direct);

    cout &lt;&lt; &quot;-----------------------------------------------------------------&quot;
        &lt;&lt; endl;
    if (result.hit)
    {
        cout
            &lt;&lt; &quot;Parsing CSV list (comma separated values)&quot; &lt;&lt; endl
            &lt;&lt; &quot;The list parser was generated with 'list_p.direct()'&quot; &lt;&lt; endl
            &lt;&lt; &quot;\t&quot; &lt;&lt; plist_csv_direct &lt;&lt; endl
            &lt;&lt; &quot;Parsed successfully!&quot; &lt;&lt; endl &lt;&lt; endl;

        if (result.full)
        {
            cout &lt;&lt; &quot;Matched &quot; &lt;&lt; vec_list.size() &lt;&lt;
                &quot; list elements (full list): &quot; &lt;&lt; endl;
        }
        else
        {
            cout &lt;&lt; &quot;Matched &quot; &lt;&lt; vec_list.size() &lt;&lt;
                &quot; list elements: &quot; &lt;&lt; endl;
        }

        cout &lt;&lt; &quot;The list parser matched:&quot; &lt;&lt; endl;
        for (std::vector&lt;std::string&gt;::iterator itl = vec_list.begin();
                itl != vec_list.end(); ++itl)
        {
            cout &lt;&lt; *itl &lt;&lt; endl;
        }

        cout &lt;&lt; endl &lt;&lt; &quot;Items got directly from the item parser:&quot; &lt;&lt; endl;
        for (std::vector&lt;std::string&gt;::iterator it = vec_item.begin();
                it != vec_item.end(); ++it)
        {
            cout &lt;&lt; *it &lt;&lt; endl;
        }

    }
    else
    {
        cout &lt;&lt; &quot;Failed to parse CSV list!&quot; &lt;&lt; endl;
    }

    cout &lt;&lt; endl;

    return 0;
}
</pre>
            </div>
          </div>
        </div>
      </div>

      <div class="clear"></div>
    </div>
  </div>

  <div id="footer">
    <div id="footer-left">
      <div id="revised">
        <p>Revised $Date: 2008-11-03 08:44:40 -0500 (Mon, 03 Nov 2008) $</p>
      </div>

      <div id="copyright">
        <p>Copyright Beman Dawes, David Abrahams, 1998-2005.</p>

        <p>Copyright Rene Rivera 2004-2008.</p>
      </div>  <div id="license">
    <p>Distributed under the <a href="/LICENSE_1_0.txt" class=
    "internal">Boost Software License, Version 1.0</a>.</p>
  </div>
    </div>

    <div id="footer-right">
        <div id="banners">
    <p id="banner-xhtml"><a href="http://validator.w3.org/check?uri=referer"
    class="external">XHTML 1.0</a></p>

    <p id="banner-css"><a href=
    "http://jigsaw.w3.org/css-validator/check/referer" class=
    "external">CSS</a></p>

    <p id="banner-osi"><a href=
    "http://www.opensource.org/docs/definition.php" class="external">OSI
    Certified</a></p>
  </div>
    </div>

    <div class="clear"></div>
  </div>
</body>
</html>
