/*		Bootstrap Confidence Intervals		*//*	24 Jan 89 ... Created to simulate intervals for Fox chapter.*/#include "Globals.h"#include "ArrayDef.h"#include "ElemArrayOps.h"#include "InOut.h"#include "RandomSamples.h"#include "ProbDist.h"#include <stdio.h>#include <math.h>/*		************  what about the residual 0.0 at location 0???? */#define Z05		1.645void bsSample (VECTOR *source, VECTOR *dest);		/* Sample with replacement from source into destination.	*/		void arGeneration (double arCoef, VECTOR *arSeries);		/* Generate an AR(1) series. 								*/		/*		INPUT --> arSeries are the errors					*/		/*		OUTPUT -> arSeries is the arProcess 				*/		void arCondGeneration (double arCoef, double lastY, VECTOR *arSeries);		/* Generate reverse time series that ends at lastY 			*/		/*		INPUT --> arSeries are the errors to use			*/		/*		OUTPUT -> arSeries is the arProcess 				*/		void arEstimation (VECTOR *arSeries, double *estCoef);		/* LS estimator with no constant in the model				*/		void arFiltering  (VECTOR *arSeries, double arCoef, VECTOR *arResids);		/* Computes resids from input coef and series; [0] is set to 0.0 */		double arSD	(VECTOR *arResids);		/* Estimated standard deviation from residuals.				*/		double arForecast (VECTOR *arSeries, double arCoef);		/* One step forecast 										*/		void arPredictionInterval (VECTOR *arSeries, double arCoef, double errorSD,							double *lower, double *upper);		/* 90% interval for Y[T+1] of AR(1) model with given coef.	*/double arBSCoverageEstimate (VECTOR *arSeries, double estCoef,							 VECTOR *arResids, double residSD, int B);		/* Bootstrap coverage estimate from B replicates of AR(1)	*/void bsSample (source, dest)VECTOR *source;VECTOR *dest;{	INTVECTOR indexVec;	double *destPtr;	int	*intPtr, t, item, min=100, max=0;		AllocIntVector (dest->len, &indexVec);	FillIntVector (&indexVec, dest->len);	intPtr = indexVec.pntr;	destPtr = dest->pntr;		for (t=0; t<dest->len; ++t)		*destPtr++ = source->pntr[*intPtr++];		DisposeIntVector (&indexVec);}void arGeneration(arCoef, arSeries)double  arCoef;VECTOR *arSeries;{	int t;	double *lastPtr, *currPtr; 	currPtr  = lastPtr = arSeries->pntr;	*currPtr /= 1 - arCoef*arCoef;		/* normalize first */	for (t = 1; t < arSeries->len; ++t)	{	++currPtr;		*currPtr += arCoef * (*lastPtr);		++lastPtr;	}}void arCondGeneration (arCoef, lastY, arSeries) double arCoef;double lastY;VECTOR *arSeries;		{	int t;	double *lastPtr, *currPtr; 		currPtr  = lastPtr = &arSeries->pntr[arSeries->len-1];	/* start at end */	*currPtr = lastY;										/* fix last 	*/	for (t = 1; t < arSeries->len; ++t)	{	--currPtr;		*currPtr += arCoef * (*lastPtr);		--lastPtr;	}}void arEstimation(arSeries, estCoef)VECTOR *arSeries;double *estCoef;{	int t;	double numSS = 0.0, denSS = 0.0;	double *lastPtr, *currPtr;	 	currPtr  = lastPtr = arSeries->pntr;	for (t=1; t<arSeries->len; ++t)	{	++currPtr;		numSS += (*currPtr) * (*lastPtr);		++lastPtr;		denSS += (*currPtr) * (*lastPtr);	}	*estCoef = numSS / denSS;}void arFiltering  (arSeries, arCoef, arResids) VECTOR *arSeries;double arCoef;VECTOR *arResids;{	int t;	double *lastPtr, *currPtr, *resPtr;	if (arSeries->len != arResids->len)	{	printf("Series lengths do not match in Filtering\n");		Wait();	}	currPtr  = lastPtr = arSeries->pntr;	resPtr = arResids->pntr;	*resPtr = 0.0;			/* res[0] = 0.0 */	for (t=1; t<arSeries->len; ++t)	{	++currPtr; ++resPtr;		*resPtr = (*currPtr) - arCoef * (*lastPtr);		++lastPtr;	}}double arSD	(arResids) VECTOR *arResids;{	double ss;		ss = DotProdVec (arResids->pntr, arResids->pntr, arResids->len);	return (sqrt(ss/(arResids->len-2)));}double arForecast(arSeries, arCoef) VECTOR *arSeries;double arCoef;{	return( arCoef * arSeries->pntr[arSeries->len-1] );}void arPredictionInterval (arSeries, arCoef, errorSD, lower, upper) VECTOR *arSeries;double  arCoef, errorSD;double *lower, *upper;{	double pred;		pred = arForecast (arSeries, arCoef);	*lower = pred - Z05 * errorSD;	*upper = pred + Z05 * errorSD;}double arBSCoverageEstimate (arSeries, estCoef, arResids, residSD, B)VECTOR *arSeries;double estCoef, residSD;VECTOR *arResids;int B;{		VECTOR bsReplicate, bsResids;	double yT, bsCoef, bsSD, lowerPt, upperPt, *dblPtr, condExpect;	double coverageTotal = 0.0;	int t, b, *intPtr;		AllocVector (arSeries->len, &bsReplicate);	AllocVector (arSeries->len, &bsResids);	yT = arSeries->pntr[arSeries->len - 1];		b = 0;	while (b++<B)	{		FillNormalVector (&bsReplicate);				/* parametric bootstrap     */		for (t=0; t<bsReplicate.len; ++t)				/*    scale to obs sd		*/			bsReplicate.pntr[t] *= residSD;		/* bsSample (arResids, &bsReplicate);				resample ar residuals	*/		arCondGeneration (estCoef, yT, &bsReplicate);	/* convert rep into AR(1)   */		condExpect = estCoef * yT;				arEstimation (&bsReplicate, &bsCoef);			/* est BS coef and resids	*/		arFiltering  (&bsReplicate, bsCoef, &bsResids);		bsSD = arSD (&bsResids);						arPredictionInterval (&bsReplicate, bsCoef, bsSD, &lowerPt, &upperPt);		coverageTotal += GaussCDF((upperPt - condExpect)/residSD)						 - GaussCDF((lowerPt - condExpect)/residSD);	}	DisposeVector (&bsReplicate);	DisposeVector (&bsResids);		return (coverageTotal/B);}main (){		VECTOR	theData, theResids;	FILE	*theFile;	double	theCoef, estCoef, residSD, lastY, condExpect;	double	coverage, bsCoverage, lowerPt, upperPt;	long	theSeed;		int		theLength;	int		rep, nReps, bsReps;	Boolean unConditional;			printf ("Enter last Y, ar coef, and series length:\n");	printf ("  If lastY < 0 , then series have random endpoint.\n");	scanf ("%lf %lf %d", &lastY, &theCoef, &theLength);	unConditional = (lastY < 0);	printf ("Now enter the number of replications and BS replications:\n");	scanf ("%d %d", &nReps, &bsReps);	printf ("Parameter echo %f %d %d\n", theCoef, theLength, nReps);	theFile = fopen ("Dave:Data Desk:Bootstrap Data", "w+");	fprintf (theFile, "EstCoef ResidSD LastY Coverage BSCoverage\n");	fprintf (theFile, "%f %f %f %f %f\n", theCoef, 1.0, lastY, 0.9, 0.9);			theSeed = 32473635;	InitRandomSamples (theSeed);			AllocVector (theLength, &theData);	AllocVector (theLength, &theResids);		for (rep = 1; rep <= nReps; ++rep)	{				FillNormalVector (&theData);		if (unConditional)		{	arGeneration (theCoef, &theData);			condExpect = theCoef * theData.pntr[theData.len-1];		} else		{	arCondGeneration (theCoef, lastY, &theData);			condExpect = theCoef * lastY;		};				arEstimation (&theData, &estCoef);		arFiltering  (&theData, estCoef, &theResids);		residSD = arSD (&theResids);						arPredictionInterval (&theData, estCoef, residSD, &lowerPt, &upperPt);				coverage = GaussCDF(upperPt - condExpect) - GaussCDF(lowerPt - condExpect);		bsCoverage = arBSCoverageEstimate (&theData, estCoef, &theResids, residSD, bsReps);		/* printf ("Coverage is %f\n", coverage); */		/* printf ("BS coverage estimate is %f\n\n", coverage); */				if ((rep % 20) == 0) printf ("Count is %d\n", rep);		fprintf (theFile, "%f %f %f %f %f\n", estCoef, residSD,					 theData.pntr[theData.len-1], coverage, bsCoverage);	}		}