/*		 		ArrayDef.c										*//*								 6 Oct 87						*//*	 					rev		31 Mar 88 AllocMatrix			*/#include <stdio.h>#include <storage.h>#include "Globals.h"#include "ArrayDef.h"#include "InOut.h"/*	_____ Debugging memory chain to check allocations _____	*/static int newList = 1;  /* 1 = TRUE */static int totalBytes = 0;struct MEMREC {	struct MEMREC *next;	char *ptr;	int nBytes;	} MEMREC;struct MEMREC *headPtr, last;/*  ______________  Local Functions  ______________  */char *MyAlloc(int nBytes);int MyFree (char *ptr);	void PrintMemChain(){	struct MEMREC *mp;	int i=0;		mp = headPtr;	fprintf (stderr,"\nDump of current memory list totaling %d bytes.\n", totalBytes);	while (mp)	{	fprintf (stderr,"Record #%3d with %4d bytes @location %ld\n", ++i, mp->nBytes, mp->ptr);		mp = mp->next;	}	Wait();}void CheckMemPointer (ptr, str)char *ptr, *str;{	struct MEMREC *mp;	int i=0;		fprintf (stderr,str);	mp = headPtr;	while (mp)	{	++i;		if (mp->ptr ==  ptr)		{	 fprintf (stderr," --- pointer match found in record %d with %d bytes./\n", i, mp->nBytes);			return;		}		mp = mp->next;	}	fprintf (stderr," --- match to pointer NOT found...\n");	Wait();}char *MyAlloc(nBytes)int nBytes;{	struct MEMREC *new;	char *ptr;		if (newList)	/* Initialize the memory list */	{	newList = 0;		headPtr = &last;		last.next = NULL;		last.nBytes = -1;		last.ptr = NULL;	}	new = (struct MEMREC *) malloc(sizeof(struct MEMREC));	ptr = malloc (nBytes);	new->next = headPtr;	new->nBytes = nBytes;	new->ptr = ptr;	headPtr = new;	totalBytes += nBytes;	return (ptr);}int MyFree (ptr)char *ptr;{	struct MEMREC *mp, *nextRec;		if (ptr == headPtr->ptr)		/* check for first */	{	totalBytes -= headPtr->nBytes;		free (headPtr->ptr);		nextRec = headPtr->next;		free ( (char *) headPtr);		headPtr = nextRec;		return (1);	}	mp = headPtr;	while (mp->next)	{	if (ptr == mp->next->ptr)		/* find match */		{	totalBytes -= mp->next->nBytes;			free (mp->next->ptr);			nextRec = mp->next->next;			free ( (char *)mp->next );			mp->next = nextRec;			return (1);		}		mp = mp->next;	}	fprintf (stderr,"Record NOT found; suggest terminating if should be!\n");	Wait();	return (-1);}			int SpaceIsAvail(count)int count;{	return(1);}void AllocVector (len, vec)int len;VECTOR *vec;{	if (len > 0) {		vec->pntr = (double *) (MyAlloc(len * sizeof(double)));		vec->len = (vec->pntr != NULL) ? len : 0;	} else {		vec->len = 0;		vec->pntr= NULL;	}	if (vec->pntr == NULL)		PostErrorMessage (7, "No space allocated for vector.");}void AllocIntVector (len, intVec)int len;INTVECTOR *intVec;{	if (len > 0) {		intVec->pntr = (int *) (MyAlloc(len * sizeof(int)));		intVec->len = (intVec->pntr != NULL) ? len : 0;	} else {		intVec->len = 0;		intVec->pntr= NULL;	}	if (intVec->pntr == NULL)		PostErrorMessage (7, "No space allocated for vector.");}	void AllocMatrix (nRows, nCols, mat)int nRows, nCols;MATRIX *mat;{	int	col;	mat->nCols = nCols;	mat->nRows = nRows;	mat->pntr = (double **) MyAlloc(nCols * sizeof(double *));	if (mat->pntr == NULL)		PostErrorMessage (7, "No space allocated for main matrix pointer.");	else		for (col = 0; col < nCols; col++)		{	if (nRows > 0) 			{	mat->pntr[col] = (double *) MyAlloc(nRows * sizeof(double));				if (mat->pntr[col] == NULL)				{	PostErrorMessage (7, "No space allocated for matrix col pointer.");					mat->nRows = 0;				}			} else {				mat->pntr[col] = NULL;			}		}}void ResizeVector (len, vec)int len;VECTOR *vec;{	if (vec->len != len) 	{	MyFree ((char *) vec->pntr);		vec->pntr = (double *) MyAlloc (len * sizeof(double));		vec->len = len;	}	if (vec->pntr == NULL)		PostErrorMessage (7, "No space allocated for vector pointer.");}void ResizeMatrix (nRows, nCols, mat)int nRows, nCols;MATRIX *mat;{	if ( (mat->nRows != nRows) || (mat->nCols != nCols) )	{	DisposeMatrix (mat);		AllocMatrix (nRows, nCols, mat);	}}void ResizeCube (nPlanes, nRows, nCols, cube)int nPlanes, nRows, nCols;CUBE *cube;{	if ( (cube->nRows != nRows) || (cube->nCols != nCols) || (cube->nPlanes != nPlanes) )	{	DisposeCube (cube);		AllocCube (nPlanes, nRows, nCols, cube);	}}void DisposeVector (vec)VECTOR *vec;{	MyFree ((char *) vec->pntr);	vec->len = 0;}void DisposeIntVector (intVec)INTVECTOR *intVec;{	MyFree ((char *) intVec->pntr);	intVec->len = 0;}void DisposeMatrix (mat)MATRIX *mat;{	int col;		if (mat->nRows > 0) 	{	for (col = 0; col < mat->nCols; ++col)  			MyFree ((char *) (mat->pntr)[col]);	}	MyFree ((char *)mat->pntr);	mat->nRows = 0;	mat->nCols = 0;}/*	buffer space for holding pointers into C arrays	*/#define MAXROW 20static int lastUsed = 1;static double *rowPtr1[MAXROW+1], *rowPtr0[MAXROW+1];double **ColPointers (mat, nRows, nCols)	/* useful if col order */double *mat;int nRows, nCols;{	int row, limit, jump;	double **rh;		limit = (nRows < MAXROW) ? nCols : MAXROW;	/* get min */		if (lastUsed == 1)		/* then use #0 */	{	rh = rowPtr0; lastUsed = 0;	} else	{	rh = rowPtr1; lastUsed = 1;	}	jump = 0;	for (row = 0; row<limit; ++row, jump += nCols)		rh[row] = (double *) &mat[jump];	return (rh);}void AllocCube (numPlanes, numRows, numCols, theCube)int numPlanes, numRows, numCols;CUBE *theCube;{	int	p, c;		theCube->nPlanes = numPlanes;	theCube->nRows = numRows;	theCube->nCols = numCols;	theCube->pntr = (double ***) (MyAlloc(numPlanes * sizeof(double **)));	if (theCube->pntr == NULL)		PostErrorMessage (7, "No space allocated for main cube pointer.");	else		for (p=0; p<numPlanes; ++p)		{	theCube->pntr[p] = (double **) (MyAlloc(numCols * sizeof(double *)));			if (theCube->pntr[p] == NULL)				PostErrorMessage (7, "No space allocated for cube plane pointer.");			else				for (c=0; c<numCols; ++c)				{	theCube->pntr[p][c] = (double *)(MyAlloc(numRows * sizeof(double)));					if (theCube->pntr[p][c] == NULL)						PostErrorMessage (7, "No space allocated for cube col pointer.");				}		}}	 /*  AllocCube  */void DisposeCube (theCube)CUBE *theCube;{	int p, c;		for (p=0; p<theCube->nPlanes; ++p)	{	for (c=0; c<theCube->nCols; ++c)			MyFree ((char *) theCube->pntr[p][c]);		MyFree((char *)theCube->pntr[p]);	}	MyFree ((char *)(theCube->pntr));	theCube->pntr = NULL;	theCube->nPlanes = 0;	theCube->nRows = 0;	theCube->nCols = 0;}	/*  DisposeCube  */	