/*				ElemArrayOps.c					*//*									 7 Oct 87	*//*							rev		19 Oct 87	*/#include "Globals.h"#include "ElemArrayOps.h"#include "InOut.h"#include <math.h>  #ifdef	USEASMextern void DiffVec1 (double *vp, int len);#endif#define min(A,B) ((A)<(B)?(A):(B))double DotProdVector (a,b)VECTOR *a,*b;{	/* printf ("Initial [1] elements are %f and %f\n", a->pntr[1], b->pntr[1]); */ 	return ( DotProdVec (a->pntr, b->pntr, min(a->len, b->len)) ); }#ifndef	USEASMdouble DotProdVec (a,b, len)double *a, *b;int len;{	int i;	double total = 0.0, temp;		for (i=0; i<len; ++i)	{		total += a[i] * b[i];		/* printf ("Internal values are %f %f with product %f\n", a[i], b[i], a[i]*b[i]); */		/* temp = a[i] * b[i];		total += temp;  need if using doubles */	}	return (total);}#endifdouble CrossLagProdVector (a, b, lag)VECTOR *a, *b;int lag;{	return (CrossLagProdVec (a->pntr, b->pntr, a->len, lag));}double CrossLagProdVec (a, b, len,lag)double *a, *b;int len, lag;{	/* order VIP to multivar AR models, need Sum a[t-lag]*b[t] */	return (DotProdVec (a, b+lag, len-lag));	}double SumVector (a)VECTOR *a;{	return (SumVec(a->pntr, a->len));}#ifndef	USEASMdouble SumVec (a, len)double *a;int len;{	int i;	double total = 0.0;		for (i=0; i<len; i++)		total += *a++;	return (total);}#endifdouble StdDevVector (a, center)VECTOR *a;double center;{	return(StdDevVec(a->pntr, a->len, center));}double StdDevVec (a, len, center)double *a, center;int len;{	double temp, total = 0.0;	int i;	for (i=0; i<len; ++i)	{	temp = *a++ - center;		total += temp * temp;	}	return (sqrt(total));}void CalcLagProdVector (y, lp)VECTOR *y, *lp;{	CalcLagProdVec (y->pntr, y->len, lp->pntr, lp->len -1);}void CalcLagProdVec (y, len, lp, maxLag)double *y, *lp;int len, maxLag;{		int i, lag;	double total = 0.0;	double *shift;		shift = y;	for (lag=0; lag<=maxLag; ++lag)		*lp++ = DotProdVec (y, shift++, len-lag) / (double)len;}double QuadFormVector (v, mat)VECTOR *v;MATRIX *mat;{	if ((v->len != mat->nRows) || (mat->nRows != mat->nCols))	{	PostErrorMessage (1, "Illegal lengths in QuadForm");		return (0.0);	} else		return (QuadFormVec (v->pntr, mat->pntr, v->len));}double QuadFormVec (v, mat, dim)double *v, *mat[];int dim;{	int row, col;	double total = 0.0;	for (row = 0; row < dim; ++row)		total += v[row] * v[row] * mat[row][row];	for (row = 0; row < dim-1; ++row)		for (col = row+1; col < dim; ++col)			total += 2.0 * v[row] * v[col] * mat[col][row];	return (total);}double MaxAbsVector (a)VECTOR *a;{	return(MaxAbsVec(a->pntr, a->len));}double MaxAbsVec (a, len)double *a;int len;{	int i;	double av, max = 0.0;		for (i = 0; i<len; ++i, ++a)	{	av = (*a < 0.0) ? -*a : *a;		if (av > max)			max = av;	}	return (max);}void CopyVector (a,b)VECTOR *a, *b;{	if (a->len != b->len)		PostErrorMessage (0, "Unequal vector lens in CopyVector; copy fewer");	CopyVec (a->pntr, b->pntr, min(a->len, b->len));}void CopyVec (a,b,len)double *a, *b;int len;{	int i;		for (i=0; i<len; ++i)		b[i] = a[i];	/*  BlockMove(a, b,len * sizeof(double)); */	}void CopyMatrix (a,b)MATRIX *a, *b;{	if (a->nCols != b->nCols)		PostErrorMessage (0, "Unequal # cols in mat copy; using min.");	if (a->nRows != b->nRows)		PostErrorMessage (0, "Unequal # rows in mat copy; using min.");	CopyMat (a->pntr, b->pntr, min(a->nRows, b->nRows), min(a->nCols, b->nCols));}void CopyMat (a, b, nRows, nCols)double *a[], *b[];int nRows, nCols;{	int i,j;	double *aPtr, *bPtr;		for (j=0; j<nCols; ++j)	{	aPtr = a[j];		bPtr = b[j];		for (i=0; i<nRows; ++i)			bPtr[i] = aPtr[i];	}					/******	int   count, col;	count = nRows * sizeof(double);	for (col=0; col < nCols; ++col)		BlockMove(a[col], b[col], count);	******/}void CopyCube (src, dest)CUBE *src, *dest;{	int p;		for (p=0; p < src->nPlanes; ++p)		CopyMat (src->pntr[p], dest->pntr[p], dest->nRows, dest->nCols);}			void DiffVector (diff, y)int diff;VECTOR *y;{	if (diff >= y->len)		PostErrorMessage (2, "Cannot difference vector: too short");	else		DiffVec (diff, y->pntr, y->len);}void DiffVec (diff, y, len)int diff;double *y;int len;{	int d, i;	for (d=1; d<=diff; ++d)#ifdef	USEASM		DiffVec1 (y, len+1-d);#else		for (i=0; i<len - d; ++i)			y[i] = y[i + 1] - y[i];#endif	for (i=len-diff; i<len; ++i)		y[i] = 0.0;			/* zero rest of vector */}