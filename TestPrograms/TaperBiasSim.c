/*		Simulation of bias in with tapering in AR estimates.				28 Mar 88 ... Created to check on tapering effects.	 */#include	<stdio.h>extended sqrt();extended cos();#include	"Globals.h"#include	"ArrayDef.h"#include	"InOut.h"#include	"arDef.h"#include	"arGeneration.h"#include	"arEstimation.h"#define		MAXLENGTH		400		/*  longest series length; also set theLengths */#define		NOFLENGTHS		4		/*	nested series to compute */#define 	SCALAR			1#define		SEED		1173546327#define		TAPERPCT		0.10	/*	amount to taper from EACH end */static int 	theLengths[NOFLENGTHS] = { 50, 100, 200, MAXLENGTH };CUBE   	arTotals, arSSs;MATRIX	dataMat, taperMat;VECTOR 	dataDummy, taperDummy, arCoefs;ARMODEL	genModel, lsModel, ywModel;void TaperData (input, output)VECTOR *input, *output;{	int t, maxIndex, len;	extended *iP, *oP, m;		len = input->len;	maxIndex = TAPERPCT * len;	m = (extended) maxIndex;	iP = input->pntr; oP = output->pntr;	/* fprintf (stderr, "Tapering %d obs on each end.\n", maxIndex); */	for (t=0; t<maxIndex; ++t)		oP[t] = iP[t] * 0.5 * (1.0 - cos((PI*t+0.5)/m));	for (t=maxIndex; t<len-maxIndex; ++t)		oP[t] = iP[t];	for (t=len-maxIndex; t<len; ++t)		oP[t] = iP[t] * 0.5 * (1.0 - cos((PI*(len-t)-0.5)/m));	/* PrintVector (output, "Tapered data"); */}				void AllocateSpace(arOrder)int arOrder;{	AllocMatrix (MAXLENGTH, 1, &dataMat);	dataDummy.len = MAXLENGTH; dataDummy.pntr = dataMat.pntr[0];	AllocMatrix (MAXLENGTH, 1, &taperMat);	taperDummy.len = MAXLENGTH; taperDummy.pntr = taperMat.pntr[0];	AllocVector (arOrder+1, &arCoefs);	arAllocModel (arOrder, SCALAR, &genModel);	arAllocModel (arOrder, SCALAR, &lsModel);	arAllocModel (arOrder, SCALAR, &ywModel);	AllocCube (1,4*NOFLENGTHS,arOrder+1, &arTotals);	/* 4 rows for each length;1 for constant */	AllocCube (1,4*NOFLENGTHS,arOrder+1, &arSSs);		}void Initialize(arCoefs)VECTOR *arCoefs;{	int r,c,p;		for (p=0; p<arTotals.nPlanes; ++p)	/* init cumulative area to 0 */		for (r=0; r<arTotals.nRows; ++r)			for (c=0; c<arTotals.nCols; ++c)			{	arTotals.pntr[p][c][r] = 0.0;				arSSs.pntr[p][c][r] = 0.0;			}	arInitGeneration();	for (p=0; p<arCoefs->len; ++p)		genModel.coef.sCoef.pntr[p] = arCoefs->pntr[p];	genModel.type = scalar;	arPrintModel (&genModel, "Generating model");	arDefineGenModel (&genModel);}void FreeSpace(){	int len;		dataMat.nRows = MAXLENGTH;		/* to be on the safe side */	taperMat.nRows= MAXLENGTH;	DisposeMatrix (&dataMat);	DisposeMatrix (&taperMat);	DisposeVector (&arCoefs);	DisposeCube (&arTotals);	DisposeCube (&arSSs);		arDisposeModel (&genModel);	arDisposeModel (&lsModel);	arDisposeModel (&ywModel);}void AccumSimResults (offset, ywEsts, lsEsts)int offset;					/* use offset of 0 for raw, 2 for tapered */ARMODEL *ywEsts, *lsEsts;{	int j, arOrder;	register extended est;	extended *ls, *yw;		arOrder = lsEsts->coef.sCoef.len-1;	ls = lsEsts->coef.sCoef.pntr;	yw = ywEsts->coef.sCoef.pntr;	for (j=1; j<=arOrder; ++j)		/* yw in row 0, ls in 1 */	{	est = yw[j];		arTotals.pntr[0][j][offset] += est;		arSSs.pntr[0][j][offset] += est * est;		est = ls[j];		arTotals.pntr[0][j][1+offset] += est;		arSSs.pntr[0][j][1+offset] += est * est;	}	}void PrintSimResults (nTrials, arOrder)int nTrials, arOrder;{	int j, shift, len;	extended N, mean, sd;		N = (extended)nTrials;	fprintf (stdout," ---- SUMMARY of simulation results ----\n");	fprintf (stdout," SEED= %d \n", SEED);	fprintf (stdout," Using %d trials with a max length of %d.\n\n", nTrials, MAXLENGTH);	fprintf (stdout,"  First no tapering, then with tapering of %5.2f%\n", TAPERPCT);	fprintf (stdout,"[coef] meth   AVG           STD DEV\n\n");	for (j=1; j<=arOrder; ++j)		for (len=0; len<NOFLENGTHS; ++len)		{	fprintf (stdout, "Results for LENGTH = %d.\n\n", theLengths[len]);			for (shift=0; shift<3; shift +=2)			{	mean = arTotals.pntr[0][j][4*len+shift] / N;				sd = sqrt(arSSs.pntr[0][j][4*len+shift]/N - mean*mean);				fprintf (stdout, "[%2d] YW %12.4lf  %12.4lf\n",j,mean,sd);				mean = arTotals.pntr[0][j][(4*len)+1+shift] / N;				sd = sqrt(arSSs.pntr[0][j][(4*len)+1+shift]/N - mean*mean);				fprintf (stdout, "[%2d] LS %12.4lf  %12.4lf\n\n",j,mean,sd);			}			fprintf (stdout, "----------------------------------\n");		}}main(argc, argv)int argc;			/* count includes tool name */char *argv[];{	int trial, order, len;		int nTrials=1, arg, arOrder=0;		/* First argument treated as nReps, rest are coefs.   */	if (argc <= 2)	{	fprintf (stderr, "Need to supply nReps and coefs of generating process.\n");		exit(1);	}		for (arg=0; arg<argc; ++arg)		fprintf (stderr, "argv[%d] --->%s<---\n", arg, argv[arg]);	sscanf (argv[1], "%d", &nTrials);	arOrder = argc-2;			/* remove name and nTrials */	AllocateSpace(arOrder);		/* make room for reading coefs */	arCoefs.pntr[0] = 1.0;	for (arg=2; arg<argc; ++arg) 		sscanf (argv[arg], "%nf", &arCoefs.pntr[arg-1]);	PrintVector (&arCoefs, "Input echo");	Initialize(&arCoefs);	trial = 0;	InitRandomSamples (SEED, SEED);	while (trial < nTrials)	{	arGenerateSeries(&dataMat);				/* expects array input */		for (len=0; len<NOFLENGTHS; ++len)		{	dataMat.nRows =  theLengths[len];	/* DANGER  using subset of lengths */			dataDummy.len =  theLengths[len];			taperMat.nRows=  theLengths[len];			taperDummy.len=  theLengths[len];			TaperData (&dataDummy, &taperDummy);			arEstimateModel(&dataMat, &ywModel, &lsModel);			AccumSimResults (4*len, &ywModel, &lsModel);			arEstimateModel(&taperMat, &ywModel, &lsModel);			AccumSimResults (2+4*len, &ywModel, &lsModel);		}		trial += 1;	}	PrintSimResults(nTrials, arOrder);	FreeSpace();}		/* PrintCube (&arTotals, "Totals cube"); */		/* PrintMatrix (&dataMat, "data"); */		/* arPrintModel (&lsModel, "ls model"); */