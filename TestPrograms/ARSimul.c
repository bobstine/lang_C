/*				ARSimul.c						*//*								26 Oct 87		*//*							rev	 5 Jun 88		*//*												*//*		Driver for simulating AR processes.		*//*		NOT set up for handling scalar processes*/#include <strings.h>#include <stdio.h>#include "Globals.h"#include "RandomSamples.h"#include "InOut.h"#include "ARDef.h"#include "ARGeneration.h"#include "AREstimation.h"#include "ArrayDef.h"#ifdef PROTOextern int scanf(char*, ...);extern int fprintf (stderr,...);extern double sqrt(double);void ReadConst(void);void AllocateSpace(void);void ReadTheModel(void);void UpdateResults(ARMODEL *, ARMODEL *, ARMODEL *);void ShowResults(void);int main (void);#elseextern double sqrt();void ReadConst();void AllocateSpace();void ReadTheModel();void UpdateResults();void ShowResults();int main ();#endif#define ESTMEAN 0#define SEED 1514235262#define SQR(X) ((X)*(X))static int arOrder, dim, nObs, nReps;static ARMODEL theModel;static double ***modelArray;static ARMODEL ywEsts, lsEsts, ywEstsWithMean, lsEstsWithMean;static ARMODEL ywBias, lsBias, ywBiasWithMean, lsBiasWithMean;static ARMODEL ywSS, lsSS, ywSSWithMean, lsSSWithMean;static MATRIX  theData;static void ParseConstants (argc, argv)/* First three arguments treated as nTrials,p,d:  rest are coefs.   *//* Allocates space and sets globals arCoefs, arOrder.	*/int argc;				char *argv[];{	int  arg;		if (argc <= 3)	{	fprintf (stderr, "Need to supply nReps, T, p, d, and coefs of generating process.\n");		exit(1);	}		/* for (arg=0; arg<argc; ++arg)		fprintf (stderr, "argv[%d] --->%s<---\n", arg, argv[arg]); */	sscanf (argv[1], "%d", &nReps);	sscanf (argv[2], "%d", &nObs);	sscanf (argv[3], "%d", &arOrder);	sscanf (argv[4], "%d", &dim);	if (dim <= 1)	{	fprintf (stderr, "Dimension of model MUST BE greater than 1.\n");		exit(1);	}		fprintf (stderr,"Const echo %d, %d, %d, %d\n", nReps,  nObs, arOrder, dim);}static void AllocateSpace(){	AllocMatrix(nObs, dim, &theData);	arAllocModel (arOrder, dim, &theModel);	modelArray = theModel.coef.mCoef.pntr;		arAllocModel (arOrder, dim, &ywEsts);	arAllocModel (arOrder, dim, &lsEsts);	arAllocModel (arOrder, dim, &ywEstsWithMean);	arAllocModel (arOrder, dim, &lsEstsWithMean);			arAllocModel (arOrder, dim, &ywBias);	arAllocModel (arOrder, dim, &lsBias);	arAllocModel (arOrder, dim, &ywBiasWithMean);	arAllocModel (arOrder, dim, &lsBiasWithMean);			arAllocModel (arOrder, dim, &ywSS);	arAllocModel (arOrder, dim, &lsSS);	arAllocModel (arOrder, dim, &ywSSWithMean);	arAllocModel (arOrder, dim, &lsSSWithMean);	}		static void ParseCoefs(argc, argv)int argc;				char *argv[];{	int p,r,c, arg;	arg = 4;				/* first 5 are name, n,T, p, d */	for (p=1; p<=arOrder; ++p)		for (r=0; r<dim; ++r)			for (c=0; c<dim; ++c)			{	++arg;				sscanf (argv[arg], "%nf", &(theModel.coef.mCoef.pntr[p][c][r]));			}	arPrintModel (&theModel, "Input model echo");	Wait();}static void UpdateResults (estimates, bias, mse)ARMODEL *estimates, *bias, *mse;{	int p,r,c;	double ***estArray, ***biasArray, ***mseArray;	double *estVec, *biasVec, *mseVec;	double diff;		estArray = estimates->coef.mCoef.pntr;	biasArray = bias->coef.mCoef.pntr;	mseArray = mse->coef.mCoef.pntr;	for (p=1; p<=arOrder; ++p)		for (c=0; c<dim; ++c)		{	estVec = estArray[p][c];			biasVec = biasArray[p][c];			mseVec = mseArray[p][c];			for (r=0; r<dim; ++r)			{	diff = estVec[r] - modelArray[p][c][r];				biasVec[r] += diff;				mseVec[r] += diff * diff;			}		}}static void ShowResults (){	int p,r,c;	double realN, div, bias;		realN = (double) (nReps);	div = (double) (nReps * (nReps-1));	for (p=1; p<=arOrder; ++p)		for (c=0; c<dim; ++c)			for (r=0; r<dim; ++r)			{	bias = ywBias.coef.mCoef.pntr[p][c][r] /= realN;				ywSS.coef.mCoef.pntr[p][c][r] = 					sqrt( (ywSS.coef.mCoef.pntr[p][c][r] + realN*(SQR(bias))  ) /div );					bias = lsBias.coef.mCoef.pntr[p][c][r] /= realN;				lsSS.coef.mCoef.pntr[p][c][r] = 					sqrt( (lsSS.coef.mCoef.pntr[p][c][r] + realN*(SQR(bias))  ) /div );							}	fprintf (stdout,"----------------------------------------------\n");	fprintf (stdout,"Random seed is %u\n", SEED);	fprintf (stdout,"Results based on %d series of length %d.\n", nReps, nObs);	fprintf (stdout,"Value of ESTMEAN = %d\n", ESTMEAN);	arPrintModel(&theModel, "Generating model coefficients");	arPrintModel(&ywBias, "Yule-Walker simulated avg bias");	arPrintModel(&ywSS,   "Yule-Walker std err of simulated mean bias");	arPrintModel(&lsBias, "Least-squares simulated avg bias");	arPrintModel(&lsSS,   "Least-squares std dev of simulated mean bias");}							 main(argc, argv)int argc;				/* count includes tool name */char *argv[];{	int rep, t, d;			Wait();	ParseConstants(argc, argv);	/* Reads in NReps, NObs, arOrder, dim>1 */	AllocateSpace();			/* Also inits first planes */	ParseCoefs(argc, argv);		InitRandomSamples (SEED);	arInitGeneration();	arDefineGenModel(&theModel);	arUseFixedSpace (arOrder, dim);	arUseMeanCorrection(ESTMEAN);		for (rep=0; rep<nReps; ++rep)	{		if ( (rep%250) == 0)			fprintf (stderr, "Series replication %d.\n", rep);		arGenerateSeries(&theData);				/********************  test data		for (t=0; t<theData.nRows; ++t)			for (d=0; d<theData.nCols; ++d)				theData.pntr[d][t] = (double) (-5 + t % 10 + d * t);		PrintMatrix (&theData, "The data");		********************/				arEstimateModel(&theData, &ywEsts, &lsEsts);				/******************		arPrintModel (&lsEsts, "Interim ls results");		******************/				UpdateResults (&ywEsts, &ywBias, &ywSS);		UpdateResults (&lsEsts, &lsBias, &lsSS);	}	ShowResults();}