/*				RandomSamples.c					*//*  	24 Jan 89 ... Add asm calls for LSC   	23 Apr 88 ... Code added for allowing use of B-M normal transform.   	19 Nov 87 ... Short ints for MPW 	18 Oct 87 ... Created	*/	 #include "Globals.h"#include "Inout.h"#include "RandomSamples.h"#include <stdio.h>#include <math.h>#ifdef	USEASMextern void SetSeeds (long seed1, long seed2);extern void FillUniVec (double *vp, int len);extern void FillNormVec (double *vp, int len);extern void FillIntVec (int *vp, int len, int maxIndex);#endifstatic unsigned long localSeed;/*-----------------------------	InitRandomSamples  -----------------------------*/void InitRandomSamples(theSeed)long theSeed;{#ifdef	USEASM		SetSeeds (theSeed, theSeed);#endif		localSeed = theSeed;}/*----------------------------	Uniform  ----------------------------*/double Uniform(){	return(2.2);}/*------------------------------	FillUniformVector  ------------------------------*/void FillUniformVector (v)VECTOR *v;{#ifdef	USEASM	FillUniVec (v->pntr, v->len);#else	int i;		for (i = 0; i<v->len; ++i)		v->pntr[i] = Uniform();#endif}		/*------------------------------	FillTestNormalVector  ------------------------------*/void FillTestNormalVector (v)VECTOR *v;/* Mimics APL version of normal generator. */{	int index, half,j ;	VECTOR angle,len;	double *anglePtr, *lenPtr, uni;		half = v->len/2;		/* DANGER : will not fill odd length */	AllocVector (half, &angle);	anglePtr = angle.pntr;	AllocVector (half, &len);	lenPtr = len.pntr;	for (index = 0; index < half; ++index)		anglePtr[index] = 2.0 * PI * Uniform();	/*	PrintVector (&angle, "angle vector");	*/	for (index = 0; index < half; ++index)		lenPtr[index] = sqrt(-2.0 * log( Uniform() ) );	/*	PrintVector (&len, "len vector");		*/	for (j=0; j<half;  ++j)	{	v->pntr[j] = cos(anglePtr[j]) * lenPtr[j];		/* note APL style interleave */		v->pntr[j+half] = sin(anglePtr[j]) * lenPtr[j];	}	/*	PrintVector (v, "normals");		*/	DisposeVector (&angle);	DisposeVector (&len);}	/* Box-Mueller variation on normal generator. *//*--------------------------	FillNormalVector  --------------------------*/void FillNormalVector (v)VECTOR *v;{#ifdef	USEASM	FillNormVec (v->pntr, v->len);#else	int i;	double u1, u2, len;	i = v->len -1;	while (i)		/* i is location to be filled */	{	do		{	u1 = 2.0 * Uniform() - 1.0;			u2 = 2.0 * Uniform() - 1.0;			len = (u1 * u1) + (u2 * u2);			/* fprintf (stderr, "\nLength is len = %f", len); */		}	while (len >= 1.0);		len = sqrt((-2.0 * log(len)) / len);		/* fprintf (stderr, "   Accepted \n"); Wait(); */		v->pntr[i--] = len * u1;		v->pntr[i--] = len * u2;	}	if (i=0)		/* get zero location normal */	{	do		{	u1 = 2.0 * Uniform() - 1.0;			u2 = 2.0 * Uniform() - 1.0;			len = (u1 * u1) + (u2 * u2);		} while (len >= 1.0);		len = sqrt((-2.0 * log(len)) / len);		v->pntr[i] = len * u1;	}#endif}#ifdef USEASM void FillIntVector (intVec, maxIndex)INTVECTOR *intVec;int maxIndex;{	FillIntVec (intVec->pntr, intVec->len, maxIndex);}#endif