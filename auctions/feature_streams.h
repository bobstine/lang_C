// -*- mode: c++; fill-column: 80; -*-
#ifndef _FEATURE_STREAMS_H_
#define _FEATURE_STREAMS_H_

/*
 *  feature_stream.h
 *  auctions
 *
 *  Created by Robert Stine on 1/18/08.
 *  Copyright 2008. All rights reserved.
 *
 
 Feature streams implement an abstract protocol and deliver upon request the
 'next' feature.  Each stream combines an iterator that traverses some
 underlying collection of features (be they in a list or generated by a model)
 and a tranformation that operates on the result of the iterator.  The iterator
 can return whatever, so long as it cooperates with the transformation to
 produce a feature vector.

 Feature streams (along with bidders) are held in experts that participate in the
 auction. Experts call
 
        has_feature()
	
 before placing any bids. If the stream has/makes a feature, then a winning
 expert will call
 
        pop()

 which must return a feature vector.  pop() must (a) run very fast and (b)
 return a vector of features.  Heavy lifting required in order to be able to
 pop() must be done in the transformation class.  Certain classes of bidders in
 the calling expert may ask for the number of remaining features in order to
 determine how much to bid.  In order to support such bidding, the stream will
 need to implement

        number_remaining()
 
 Stream properties...
    Streams should be *lightweight*.  They will be copied heavily in the auction.
    Basically act as a stack/queue, a type of iterator really.  The stream itself
    does *not* hold data, just the rules to build new variables.

 Types of streams ...
    Finite           chooses variables from a fixed set of columns as a queue
    Fit              builds features depending on state of model (such as just added var)
    Interaction      interactions among features from a source of fixed size
    Feature-product  interactions between a feature and a fixed set (counts down, as vars in model)
    Cross-product    interactions between fixed set of features and a set of increasing size
    Lag              lags of a given feature
    Polynomial       bundle of several powers at once
    Subspace         several variables as a bundle


  
*/

#include "features.h"
#include "feature_predicates.h"
#include "feature_iterators.h"
#include "feature_transformations.h"

#include "light_threads.h"

// polynomial
#include "function_utils.h"
#include "debug.h"

// for finite streams
#include <queue>
#include <iostream>
#include <sstream>
#include <boost/shared_ptr.hpp>

/*
  bool has_feature ()
  {
    if(m_thread.done() && Stream::has_feature_ready())
      return true;
    else if (Stream::can_build_more_features())
      m_thread( boost::bind( &Stream::build_next_feature, this ) );
    else
      debugging::debug("RGST",3) << "threaded, regulated stream '" << Stream::name() <<"' cannot build more features.\n";
    return false;
  }
};

*/

 

template<class Iterator, class Transform>
class FeatureStream
{

private:
  std::string             mName;
  Iterator                mIterator;
  Transform               mTransform;    // copy each time start a new thread
  LightThread<Transform>  mThread;       // use -> to extract information from underlying transform

public:
  ~FeatureStream() { }

  FeatureStream (std::string name, Iterator it, Transform trans)
    : mName(name), mIterator(it), mTransform(trans), mThread() { make_features(); }
  
  std::string    name()                      const { return mName; }
  std::string    feature_name()              const { std::cout << "FS: retrieve name\n"; if (has_feature()) return mThread->output_features()[0].name(); else return "empty/busy"; }
  void           print_to(std::ostream& os)  const { os <<  mName << " @ " << feature_name(); }

  int            number_remaining()          const { return mIterator.number_remaining(); }

  bool           is_busy()                   const { return !mThread.done(); }
  bool           has_feature()                     { if (is_busy()) return false; if (mThread->empty()) { make_features(); return false; } else return true; }
  FeatureVector  pop()                             { assert (has_feature()); FeatureVector fv (mThread->output_features()); make_features(); return fv; }

private:
  void make_features()
    { std::cout << "FS: make_features\n";
      if (mIterator.valid())
      { // load up the transform operator
	mTransform.input(*mIterator);
	// advance the iterator
	++mIterator;
	// start thread on transformation
	mThread(mTransform);
      }
    }
};

template<class Iterator, class Transform, class Avoid>
std::ostream&
operator<<(std::ostream& os, FeatureStream<Iterator,Transform> const& s) { s.print_to(os); return os; }






// -----------------------------------------------------------------------------------------------------------------------------
//
//    make__stream     make__stream     make__stream     make__stream     make__stream     make__stream
//
// -----------------------------------------------------------------------------------------------------------------------------

template<class Collection, class Pred>
FeatureStream< CyclicIterator<Collection, Pred>, Identity>
make_finite_stream (std::string const& name, Collection const& source, Pred pred)
{
  return FeatureStream< CyclicIterator<Collection, Pred>, Identity>
    ("CyclicStream::"+name, CyclicIterator<Collection,Pred>(source, pred), Identity());
}



template<class Collection, class Pred, class Operator>
FeatureStream< DynamicIterator<Collection, Pred>, Operator>
make_dynamic_stream (std::string const& name, Collection const& source, Pred pred, Operator op)
{
  return FeatureStream< DynamicIterator<Collection, Pred>, Operator >
    ("DynamicStream::"+name, DynamicIterator<Collection,Pred>(source, pred), op);
}

/*
  
template< class AvoidCollection >
FeatureStream< LagIterator, Identity, AvoidCollection>
make_lag_stream (std::string const& name, Feature const& f, int maxLag, int blockSize, int numberCycles, AvoidCollection const& avoid)
{
  return FeatureStream< LagIterator, Identity, AvoidCollection>
    ("LagStream::"+name, LagIterator(f, maxLag, numberCycles, blockSize), Identity(), avoid);
}


template <class Collection, class AvoidCollection>
FeatureStream< DynamicIterator<Collection, SkipIfDerived>, BuildPolynomialFeature, AvoidCollection>
make_polynomial_stream (std::string const& name, Collection const& src, int degree, AvoidCollection const& avoid)
{
  std::cout << "TEST: make_polynomial_stream of degree " << degree << std::endl;
  return FeatureStream< DynamicIterator<Collection, SkipIfDerived>, BuildPolynomialFeature, AvoidCollection>
    ("Polynomial::"+name, DynamicIterator<Collection,SkipIfDerived>(src, SkipIfDerived()), BuildPolynomialFeature(degree), avoid);
}


template <class Collection,  class AvoidCollection>
FeatureStream< DynamicIterator<Collection, SkipIfDerived>, BuildNeighborhoodFeature, AvoidCollection>
make_neighborhood_stream (std::string const& name, Collection const& src, IntegerColumn const& col, AvoidCollection const& avoid)
{
  std::cout << "TEST: make_neighborhood_stream with indices " << col << std::endl;
  return FeatureStream< DynamicIterator<Collection, SkipIfDerived>, BuildNeighborhoodFeature, AvoidCollection>
    ("Neighborhood::"+name, DynamicIterator<Collection,SkipIfDerived>(src, SkipIfDerived()), BuildNeighborhoodFeature(col), avoid);
}


template <class Collection,  class AvoidCollection>
FeatureStream< QueueIterator<Collection, SkipIfRelated>, BuildProductFeature,AvoidCollection>
make_feature_product_stream (std::string const& name, Collection const& c, Feature const& f, AvoidCollection const& avoid)
{
  std::cout << "FPRS: make_feature_product_stream from feature " << f->name() << std::endl;
  return FeatureStream< QueueIterator<Collection,SkipIfRelated>, BuildProductFeature, AvoidCollection>
    ("Feature-product::"+name, QueueIterator<Collection, SkipIfRelated>(c, SkipIfRelated(f)), BuildProductFeature(f), avoid);
}


template <class Model,  class AvoidCollection>
FeatureStream< ModelIterator<Model>, BuildCalibrationFeature<Model>,AvoidCollection >
make_calibration_stream (std::string const& name, Model const& model, int degree, int skip, AvoidCollection const& avoid)
{
  std::cout << "FPRS: make_calibration_stream of degree " << degree << " with initial skip of " << skip << " cases.\n";
  return FeatureStream< ModelIterator<Model>, BuildCalibrationFeature<Model>, AvoidCollection >
    ("Calibration::"+name, ModelIterator<Model>(model), BuildCalibrationFeature<Model>(degree,skip), avoid);
}


template <class Collection, class Trans,  class AvoidCollection>
FeatureStream< BundleIterator<Collection, SkipIfInBasis>, Trans,AvoidCollection >
make_subspace_stream (std::string const& name, Collection const& src, Trans const& trans, int bundleSize, AvoidCollection const& avoid)
{
  std::cout << "FPRS: make_subspace_stream with bundle size " << bundleSize << std::endl;
  return FeatureStream< BundleIterator<Collection,SkipIfInBasis>, Trans, AvoidCollection >
    ("Subspace::"+name, BundleIterator<Collection,SkipIfInBasis>(src, bundleSize, SkipIfInBasis()), trans, avoid);
}

template <class Collection,  class AvoidCollection>
FeatureStream< InteractionIterator<Collection, SkipIfRelatedPair>, Identity, AvoidCollection >
make_interaction_stream (std::string const& name, Collection const& src, bool useSquares, AvoidCollection const& avoid)
{
  std::cout << "FPRS: make_interaction_stream (static) " << std::endl;
  return FeatureStream< InteractionIterator<Collection,SkipIfRelatedPair>, Identity, AvoidCollection>
    ("Interaction::"+name, InteractionIterator<Collection,SkipIfRelatedPair>(src, useSquares, SkipIfRelatedPair()), Identity(), avoid);
}


template <class Predicate, class AvoidCollection>
FeatureStream< CrossProductIterator<SkipIfRelatedPair>, Identity, AvoidCollection >
make_cross_product_stream (std::string const& name, FeatureVector const& slow, FeatureVector const& fast, bool useSquares, AvoidCollection const& avoid)
{
  std::cout << "FPRS: make_interaction_stream (static) " << std::endl;
  return FeatureStream< CrossProductIterator<SkipIfRelatedPair>, Identity, AvoidCollection>
    ("Interaction::"+name, CrossProductIterator<SkipIfRelatedPair>(slow, fast, SkipIfRelatedPair()), Identity(), avoid);
}
*/

///////////////////////////////////////////////////////////////////////

#include "feature_streams.Template.h"

#endif
